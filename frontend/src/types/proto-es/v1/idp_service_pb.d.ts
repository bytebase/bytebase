// @generated by protoc-gen-es v2.5.2
// @generated from file v1/idp_service.proto (package bytebase.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";
import type { EmptySchema, FieldMask } from "@bufbuild/protobuf/wkt";

/**
 * Describes the file v1/idp_service.proto.
 */
export declare const file_v1_idp_service: GenFile;

/**
 * @generated from message bytebase.v1.GetIdentityProviderRequest
 */
export declare type GetIdentityProviderRequest = Message<"bytebase.v1.GetIdentityProviderRequest"> & {
  /**
   * The name of the identity provider to retrieve.
   * Format: idps/{idp}
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message bytebase.v1.GetIdentityProviderRequest.
 * Use `create(GetIdentityProviderRequestSchema)` to create a new message.
 */
export declare const GetIdentityProviderRequestSchema: GenMessage<GetIdentityProviderRequest>;

/**
 * @generated from message bytebase.v1.ListIdentityProvidersRequest
 */
export declare type ListIdentityProvidersRequest = Message<"bytebase.v1.ListIdentityProvidersRequest"> & {
};

/**
 * Describes the message bytebase.v1.ListIdentityProvidersRequest.
 * Use `create(ListIdentityProvidersRequestSchema)` to create a new message.
 */
export declare const ListIdentityProvidersRequestSchema: GenMessage<ListIdentityProvidersRequest>;

/**
 * @generated from message bytebase.v1.ListIdentityProvidersResponse
 */
export declare type ListIdentityProvidersResponse = Message<"bytebase.v1.ListIdentityProvidersResponse"> & {
  /**
   * The identity providers from the specified request.
   *
   * @generated from field: repeated bytebase.v1.IdentityProvider identity_providers = 1;
   */
  identityProviders: IdentityProvider[];
};

/**
 * Describes the message bytebase.v1.ListIdentityProvidersResponse.
 * Use `create(ListIdentityProvidersResponseSchema)` to create a new message.
 */
export declare const ListIdentityProvidersResponseSchema: GenMessage<ListIdentityProvidersResponse>;

/**
 * @generated from message bytebase.v1.CreateIdentityProviderRequest
 */
export declare type CreateIdentityProviderRequest = Message<"bytebase.v1.CreateIdentityProviderRequest"> & {
  /**
   * The identity provider to create.
   *
   * @generated from field: bytebase.v1.IdentityProvider identity_provider = 1;
   */
  identityProvider?: IdentityProvider;

  /**
   * The ID to use for the identity provider, which will become the final component of
   * the identity provider's resource name.
   *
   * This value should be 4-63 characters, and valid characters
   * are /[a-z][0-9]-/.
   *
   * @generated from field: string identity_provider_id = 2;
   */
  identityProviderId: string;

  /**
   * If set to true, the request will be validated without actually creating the identity provider.
   *
   * @generated from field: bool validate_only = 3;
   */
  validateOnly: boolean;
};

/**
 * Describes the message bytebase.v1.CreateIdentityProviderRequest.
 * Use `create(CreateIdentityProviderRequestSchema)` to create a new message.
 */
export declare const CreateIdentityProviderRequestSchema: GenMessage<CreateIdentityProviderRequest>;

/**
 * @generated from message bytebase.v1.UpdateIdentityProviderRequest
 */
export declare type UpdateIdentityProviderRequest = Message<"bytebase.v1.UpdateIdentityProviderRequest"> & {
  /**
   * The identity provider to update.
   *
   * The identity provider's `name` field is used to identify the identity provider to update.
   * Format: idps/{identity_provider}
   *
   * @generated from field: bytebase.v1.IdentityProvider identity_provider = 1;
   */
  identityProvider?: IdentityProvider;

  /**
   * The list of fields to update.
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 2;
   */
  updateMask?: FieldMask;

  /**
   * If set to true, and the identity provider is not found, a new identity provider will be created.
   * In this situation, `update_mask` is ignored.
   *
   * @generated from field: bool allow_missing = 3;
   */
  allowMissing: boolean;
};

/**
 * Describes the message bytebase.v1.UpdateIdentityProviderRequest.
 * Use `create(UpdateIdentityProviderRequestSchema)` to create a new message.
 */
export declare const UpdateIdentityProviderRequestSchema: GenMessage<UpdateIdentityProviderRequest>;

/**
 * @generated from message bytebase.v1.DeleteIdentityProviderRequest
 */
export declare type DeleteIdentityProviderRequest = Message<"bytebase.v1.DeleteIdentityProviderRequest"> & {
  /**
   * The name of the identity provider to delete.
   * Format: idps/{identity_provider}
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message bytebase.v1.DeleteIdentityProviderRequest.
 * Use `create(DeleteIdentityProviderRequestSchema)` to create a new message.
 */
export declare const DeleteIdentityProviderRequestSchema: GenMessage<DeleteIdentityProviderRequest>;

/**
 * @generated from message bytebase.v1.TestIdentityProviderRequest
 */
export declare type TestIdentityProviderRequest = Message<"bytebase.v1.TestIdentityProviderRequest"> & {
  /**
   * The identity provider to test connection including uncreated.
   *
   * @generated from field: bytebase.v1.IdentityProvider identity_provider = 1;
   */
  identityProvider?: IdentityProvider;

  /**
   * @generated from oneof bytebase.v1.TestIdentityProviderRequest.context
   */
  context: {
    /**
     * @generated from field: bytebase.v1.OAuth2IdentityProviderTestRequestContext oauth2_context = 2;
     */
    value: OAuth2IdentityProviderTestRequestContext;
    case: "oauth2Context";
  } | {
    /**
     * OIDC authentication context for test connection.
     *
     * @generated from field: bytebase.v1.OIDCIdentityProviderTestRequestContext oidc_context = 3;
     */
    value: OIDCIdentityProviderTestRequestContext;
    case: "oidcContext";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message bytebase.v1.TestIdentityProviderRequest.
 * Use `create(TestIdentityProviderRequestSchema)` to create a new message.
 */
export declare const TestIdentityProviderRequestSchema: GenMessage<TestIdentityProviderRequest>;

/**
 * @generated from message bytebase.v1.OAuth2IdentityProviderTestRequestContext
 */
export declare type OAuth2IdentityProviderTestRequestContext = Message<"bytebase.v1.OAuth2IdentityProviderTestRequestContext"> & {
  /**
   * Authorize code from website.
   *
   * @generated from field: string code = 1;
   */
  code: string;
};

/**
 * Describes the message bytebase.v1.OAuth2IdentityProviderTestRequestContext.
 * Use `create(OAuth2IdentityProviderTestRequestContextSchema)` to create a new message.
 */
export declare const OAuth2IdentityProviderTestRequestContextSchema: GenMessage<OAuth2IdentityProviderTestRequestContext>;

/**
 * @generated from message bytebase.v1.OIDCIdentityProviderTestRequestContext
 */
export declare type OIDCIdentityProviderTestRequestContext = Message<"bytebase.v1.OIDCIdentityProviderTestRequestContext"> & {
  /**
   * Authorize code from OIDC provider.
   *
   * @generated from field: string code = 1;
   */
  code: string;
};

/**
 * Describes the message bytebase.v1.OIDCIdentityProviderTestRequestContext.
 * Use `create(OIDCIdentityProviderTestRequestContextSchema)` to create a new message.
 */
export declare const OIDCIdentityProviderTestRequestContextSchema: GenMessage<OIDCIdentityProviderTestRequestContext>;

/**
 * @generated from message bytebase.v1.TestIdentityProviderResponse
 */
export declare type TestIdentityProviderResponse = Message<"bytebase.v1.TestIdentityProviderResponse"> & {
  /**
   * The map of claims returned by the identity provider.
   *
   * @generated from field: map<string, string> claims = 1;
   */
  claims: { [key: string]: string };

  /**
   * The matched user info from the claims.
   *
   * @generated from field: map<string, string> user_info = 2;
   */
  userInfo: { [key: string]: string };
};

/**
 * Describes the message bytebase.v1.TestIdentityProviderResponse.
 * Use `create(TestIdentityProviderResponseSchema)` to create a new message.
 */
export declare const TestIdentityProviderResponseSchema: GenMessage<TestIdentityProviderResponse>;

/**
 * @generated from message bytebase.v1.IdentityProvider
 */
export declare type IdentityProvider = Message<"bytebase.v1.IdentityProvider"> & {
  /**
   * The name of the identity provider.
   * Format: idps/{idp}
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The display title of the identity provider.
   *
   * @generated from field: string title = 2;
   */
  title: string;

  /**
   * The domain for email matching when using this identity provider.
   *
   * @generated from field: string domain = 3;
   */
  domain: string;

  /**
   * The type of identity provider protocol.
   *
   * @generated from field: bytebase.v1.IdentityProviderType type = 4;
   */
  type: IdentityProviderType;

  /**
   * The configuration details for the identity provider.
   *
   * @generated from field: bytebase.v1.IdentityProviderConfig config = 5;
   */
  config?: IdentityProviderConfig;
};

/**
 * Describes the message bytebase.v1.IdentityProvider.
 * Use `create(IdentityProviderSchema)` to create a new message.
 */
export declare const IdentityProviderSchema: GenMessage<IdentityProvider>;

/**
 * @generated from message bytebase.v1.IdentityProviderConfig
 */
export declare type IdentityProviderConfig = Message<"bytebase.v1.IdentityProviderConfig"> & {
  /**
   * @generated from oneof bytebase.v1.IdentityProviderConfig.config
   */
  config: {
    /**
     * OAuth2 protocol configuration.
     *
     * @generated from field: bytebase.v1.OAuth2IdentityProviderConfig oauth2_config = 1;
     */
    value: OAuth2IdentityProviderConfig;
    case: "oauth2Config";
  } | {
    /**
     * OIDC protocol configuration.
     *
     * @generated from field: bytebase.v1.OIDCIdentityProviderConfig oidc_config = 2;
     */
    value: OIDCIdentityProviderConfig;
    case: "oidcConfig";
  } | {
    /**
     * LDAP protocol configuration.
     *
     * @generated from field: bytebase.v1.LDAPIdentityProviderConfig ldap_config = 3;
     */
    value: LDAPIdentityProviderConfig;
    case: "ldapConfig";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message bytebase.v1.IdentityProviderConfig.
 * Use `create(IdentityProviderConfigSchema)` to create a new message.
 */
export declare const IdentityProviderConfigSchema: GenMessage<IdentityProviderConfig>;

/**
 * OAuth2IdentityProviderConfig is the structure for OAuth2 identity provider config.
 *
 * @generated from message bytebase.v1.OAuth2IdentityProviderConfig
 */
export declare type OAuth2IdentityProviderConfig = Message<"bytebase.v1.OAuth2IdentityProviderConfig"> & {
  /**
   * The authorization endpoint URL for OAuth2 flow.
   *
   * @generated from field: string auth_url = 1;
   */
  authUrl: string;

  /**
   * The token endpoint URL for exchanging authorization code.
   *
   * @generated from field: string token_url = 2;
   */
  tokenUrl: string;

  /**
   * The user information endpoint URL.
   *
   * @generated from field: string user_info_url = 3;
   */
  userInfoUrl: string;

  /**
   * The OAuth2 client identifier.
   *
   * @generated from field: string client_id = 4;
   */
  clientId: string;

  /**
   * The OAuth2 client secret for authentication.
   *
   * @generated from field: string client_secret = 5;
   */
  clientSecret: string;

  /**
   * The list of OAuth2 scopes to request.
   *
   * @generated from field: repeated string scopes = 6;
   */
  scopes: string[];

  /**
   * Mapping configuration for user attributes from OAuth2 response.
   *
   * @generated from field: bytebase.v1.FieldMapping field_mapping = 7;
   */
  fieldMapping?: FieldMapping;

  /**
   * Whether to skip TLS certificate verification.
   *
   * @generated from field: bool skip_tls_verify = 8;
   */
  skipTlsVerify: boolean;

  /**
   * The authentication style for client credentials.
   *
   * @generated from field: bytebase.v1.OAuth2AuthStyle auth_style = 9;
   */
  authStyle: OAuth2AuthStyle;
};

/**
 * Describes the message bytebase.v1.OAuth2IdentityProviderConfig.
 * Use `create(OAuth2IdentityProviderConfigSchema)` to create a new message.
 */
export declare const OAuth2IdentityProviderConfigSchema: GenMessage<OAuth2IdentityProviderConfig>;

/**
 * OIDCIdentityProviderConfig is the structure for OIDC identity provider config.
 *
 * @generated from message bytebase.v1.OIDCIdentityProviderConfig
 */
export declare type OIDCIdentityProviderConfig = Message<"bytebase.v1.OIDCIdentityProviderConfig"> & {
  /**
   * The OIDC issuer URL for the identity provider.
   *
   * @generated from field: string issuer = 1;
   */
  issuer: string;

  /**
   * The OIDC client identifier.
   *
   * @generated from field: string client_id = 2;
   */
  clientId: string;

  /**
   * The OIDC client secret for authentication.
   *
   * @generated from field: string client_secret = 3;
   */
  clientSecret: string;

  /**
   * The scopes that the OIDC provider supports.
   * Should be fetched from the well-known configuration file of the OIDC provider.
   *
   * @generated from field: repeated string scopes = 4;
   */
  scopes: string[];

  /**
   * Mapping configuration for user attributes from OIDC claims.
   *
   * @generated from field: bytebase.v1.FieldMapping field_mapping = 5;
   */
  fieldMapping?: FieldMapping;

  /**
   * Whether to skip TLS certificate verification.
   *
   * @generated from field: bool skip_tls_verify = 6;
   */
  skipTlsVerify: boolean;

  /**
   * The authentication style for client credentials.
   *
   * @generated from field: bytebase.v1.OAuth2AuthStyle auth_style = 7;
   */
  authStyle: OAuth2AuthStyle;

  /**
   * The authorization endpoint of the OIDC provider.
   * Should be fetched from the well-known configuration file of the OIDC provider.
   *
   * @generated from field: string auth_endpoint = 8;
   */
  authEndpoint: string;
};

/**
 * Describes the message bytebase.v1.OIDCIdentityProviderConfig.
 * Use `create(OIDCIdentityProviderConfigSchema)` to create a new message.
 */
export declare const OIDCIdentityProviderConfigSchema: GenMessage<OIDCIdentityProviderConfig>;

/**
 * LDAPIdentityProviderConfig is the structure for LDAP identity provider config.
 *
 * @generated from message bytebase.v1.LDAPIdentityProviderConfig
 */
export declare type LDAPIdentityProviderConfig = Message<"bytebase.v1.LDAPIdentityProviderConfig"> & {
  /**
   * Host is the hostname or IP address of the LDAP server, e.g.,
   * "ldap.example.com".
   *
   * @generated from field: string host = 1;
   */
  host: string;

  /**
   * Port is the port number of the LDAP server, e.g., 389. When not set, the
   * default port of the corresponding security protocol will be used, i.e. 389
   * for StartTLS and 636 for LDAPS.
   *
   * @generated from field: int32 port = 2;
   */
  port: number;

  /**
   * SkipTLSVerify controls whether to skip TLS certificate verification.
   *
   * @generated from field: bool skip_tls_verify = 3;
   */
  skipTlsVerify: boolean;

  /**
   * BindDN is the DN of the user to bind as a service account to perform
   * search requests.
   *
   * @generated from field: string bind_dn = 4;
   */
  bindDn: string;

  /**
   * BindPassword is the password of the user to bind as a service account.
   *
   * @generated from field: string bind_password = 5;
   */
  bindPassword: string;

  /**
   * BaseDN is the base DN to search for users, e.g., "ou=users,dc=example,dc=com".
   *
   * @generated from field: string base_dn = 6;
   */
  baseDn: string;

  /**
   * UserFilter is the filter to search for users, e.g., "(uid=%s)".
   *
   * @generated from field: string user_filter = 7;
   */
  userFilter: string;

  /**
   * SecurityProtocol is the security protocol to be used for establishing
   * connections with the LDAP server.
   *
   * @generated from field: bytebase.v1.LDAPIdentityProviderConfig.SecurityProtocol security_protocol = 8;
   */
  securityProtocol: LDAPIdentityProviderConfig_SecurityProtocol;

  /**
   * FieldMapping is the mapping of the user attributes returned by the LDAP
   * server.
   *
   * @generated from field: bytebase.v1.FieldMapping field_mapping = 9;
   */
  fieldMapping?: FieldMapping;
};

/**
 * Describes the message bytebase.v1.LDAPIdentityProviderConfig.
 * Use `create(LDAPIdentityProviderConfigSchema)` to create a new message.
 */
export declare const LDAPIdentityProviderConfigSchema: GenMessage<LDAPIdentityProviderConfig>;

/**
 * @generated from enum bytebase.v1.LDAPIdentityProviderConfig.SecurityProtocol
 */
export enum LDAPIdentityProviderConfig_SecurityProtocol {
  /**
   * @generated from enum value: SECURITY_PROTOCOL_UNSPECIFIED = 0;
   */
  SECURITY_PROTOCOL_UNSPECIFIED = 0,

  /**
   * StartTLS is the security protocol that starts with an unencrypted connection and then upgrades to TLS.
   *
   * @generated from enum value: START_TLS = 1;
   */
  START_TLS = 1,

  /**
   * LDAPS is the security protocol that uses TLS from the beginning.
   *
   * @generated from enum value: LDAPS = 2;
   */
  LDAPS = 2,
}

/**
 * Describes the enum bytebase.v1.LDAPIdentityProviderConfig.SecurityProtocol.
 */
export declare const LDAPIdentityProviderConfig_SecurityProtocolSchema: GenEnum<LDAPIdentityProviderConfig_SecurityProtocol>;

/**
 * FieldMapping saves the field names from user info API of identity provider.
 * As we save all raw json string of user info response data into `principal.idp_user_info`,
 * we can extract the relevant data based with `FieldMapping`.
 *
 * @generated from message bytebase.v1.FieldMapping
 */
export declare type FieldMapping = Message<"bytebase.v1.FieldMapping"> & {
  /**
   * Identifier is the field name of the unique identifier in 3rd-party idp user info. Required.
   *
   * @generated from field: string identifier = 1;
   */
  identifier: string;

  /**
   * DisplayName is the field name of display name in 3rd-party idp user info. Optional.
   *
   * @generated from field: string display_name = 2;
   */
  displayName: string;

  /**
   * Phone is the field name of primary phone in 3rd-party idp user info. Optional.
   *
   * @generated from field: string phone = 3;
   */
  phone: string;

  /**
   * Groups is the field name of groups in 3rd-party idp user info. Optional.
   * Mainly used for OIDC: https://developer.okta.com/docs/guides/customize-tokens-groups-claim/main/
   *
   * @generated from field: string groups = 4;
   */
  groups: string;
};

/**
 * Describes the message bytebase.v1.FieldMapping.
 * Use `create(FieldMappingSchema)` to create a new message.
 */
export declare const FieldMappingSchema: GenMessage<FieldMapping>;

/**
 * @generated from enum bytebase.v1.IdentityProviderType
 */
export enum IdentityProviderType {
  /**
   * Unspecified identity provider type.
   *
   * @generated from enum value: IDENTITY_PROVIDER_TYPE_UNSPECIFIED = 0;
   */
  IDENTITY_PROVIDER_TYPE_UNSPECIFIED = 0,

  /**
   * OAuth 2.0 authentication protocol.
   *
   * @generated from enum value: OAUTH2 = 1;
   */
  OAUTH2 = 1,

  /**
   * OpenID Connect authentication protocol.
   *
   * @generated from enum value: OIDC = 2;
   */
  OIDC = 2,

  /**
   * LDAP directory service authentication.
   *
   * @generated from enum value: LDAP = 3;
   */
  LDAP = 3,
}

/**
 * Describes the enum bytebase.v1.IdentityProviderType.
 */
export declare const IdentityProviderTypeSchema: GenEnum<IdentityProviderType>;

/**
 * @generated from enum bytebase.v1.OAuth2AuthStyle
 */
export enum OAuth2AuthStyle {
  /**
   * @generated from enum value: OAUTH2_AUTH_STYLE_UNSPECIFIED = 0;
   */
  OAUTH2_AUTH_STYLE_UNSPECIFIED = 0,

  /**
   * IN_PARAMS sends the "client_id" and "client_secret" in the POST body
   * as application/x-www-form-urlencoded parameters.
   *
   * @generated from enum value: IN_PARAMS = 1;
   */
  IN_PARAMS = 1,

  /**
   * IN_HEADER sends the client_id and client_password using HTTP Basic Authorization.
   * This is an optional style described in the OAuth2 RFC 6749 section 2.3.1.
   *
   * @generated from enum value: IN_HEADER = 2;
   */
  IN_HEADER = 2,
}

/**
 * Describes the enum bytebase.v1.OAuth2AuthStyle.
 */
export declare const OAuth2AuthStyleSchema: GenEnum<OAuth2AuthStyle>;

/**
 * IdentityProviderService manages external identity providers for SSO authentication.
 *
 * @generated from service bytebase.v1.IdentityProviderService
 */
export declare const IdentityProviderService: GenService<{
  /**
   * Gets an identity provider by name.
   * Permissions required: bb.identityProviders.get
   *
   * @generated from rpc bytebase.v1.IdentityProviderService.GetIdentityProvider
   */
  getIdentityProvider: {
    methodKind: "unary";
    input: typeof GetIdentityProviderRequestSchema;
    output: typeof IdentityProviderSchema;
  },
  /**
   * Lists all configured identity providers (public endpoint for login page).
   * Permissions required: None
   *
   * @generated from rpc bytebase.v1.IdentityProviderService.ListIdentityProviders
   */
  listIdentityProviders: {
    methodKind: "unary";
    input: typeof ListIdentityProvidersRequestSchema;
    output: typeof ListIdentityProvidersResponseSchema;
  },
  /**
   * Creates a new identity provider.
   * Permissions required: bb.identityProviders.create
   *
   * @generated from rpc bytebase.v1.IdentityProviderService.CreateIdentityProvider
   */
  createIdentityProvider: {
    methodKind: "unary";
    input: typeof CreateIdentityProviderRequestSchema;
    output: typeof IdentityProviderSchema;
  },
  /**
   * Updates an identity provider.
   * Permissions required: bb.identityProviders.update
   * When allow_missing=true, also requires: bb.identityProviders.create
   *
   * @generated from rpc bytebase.v1.IdentityProviderService.UpdateIdentityProvider
   */
  updateIdentityProvider: {
    methodKind: "unary";
    input: typeof UpdateIdentityProviderRequestSchema;
    output: typeof IdentityProviderSchema;
  },
  /**
   * Deletes an identity provider.
   * Permissions required: bb.identityProviders.delete
   *
   * @generated from rpc bytebase.v1.IdentityProviderService.DeleteIdentityProvider
   */
  deleteIdentityProvider: {
    methodKind: "unary";
    input: typeof DeleteIdentityProviderRequestSchema;
    output: typeof EmptySchema;
  },
  /**
   * Tests the connection and configuration of an identity provider.
   * Permissions required: bb.identityProviders.update
   *
   * @generated from rpc bytebase.v1.IdentityProviderService.TestIdentityProvider
   */
  testIdentityProvider: {
    methodKind: "unary";
    input: typeof TestIdentityProviderRequestSchema;
    output: typeof TestIdentityProviderResponseSchema;
  },
}>;

