// @generated by protoc-gen-es v2.5.2
// @generated from file v1/user_service.proto (package bytebase.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";
import type { EmptySchema, FieldMask, Timestamp } from "@bufbuild/protobuf/wkt";
import type { State } from "./common_pb";

/**
 * Describes the file v1/user_service.proto.
 */
export declare const file_v1_user_service: GenFile;

/**
 * @generated from message bytebase.v1.GetUserRequest
 */
export declare type GetUserRequest = Message<"bytebase.v1.GetUserRequest"> & {
  /**
   * The name of the user to retrieve.
   * Format: users/{user uid or user email}
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message bytebase.v1.GetUserRequest.
 * Use `create(GetUserRequestSchema)` to create a new message.
 */
export declare const GetUserRequestSchema: GenMessage<GetUserRequest>;

/**
 * @generated from message bytebase.v1.BatchGetUsersRequest
 */
export declare type BatchGetUsersRequest = Message<"bytebase.v1.BatchGetUsersRequest"> & {
  /**
   * The user names to retrieve.
   * Format: users/{user uid or user email}
   *
   * @generated from field: repeated string names = 1;
   */
  names: string[];
};

/**
 * Describes the message bytebase.v1.BatchGetUsersRequest.
 * Use `create(BatchGetUsersRequestSchema)` to create a new message.
 */
export declare const BatchGetUsersRequestSchema: GenMessage<BatchGetUsersRequest>;

/**
 * @generated from message bytebase.v1.BatchGetUsersResponse
 */
export declare type BatchGetUsersResponse = Message<"bytebase.v1.BatchGetUsersResponse"> & {
  /**
   * The users from the specified request.
   *
   * @generated from field: repeated bytebase.v1.User users = 1;
   */
  users: User[];
};

/**
 * Describes the message bytebase.v1.BatchGetUsersResponse.
 * Use `create(BatchGetUsersResponseSchema)` to create a new message.
 */
export declare const BatchGetUsersResponseSchema: GenMessage<BatchGetUsersResponse>;

/**
 * @generated from message bytebase.v1.ListUsersRequest
 */
export declare type ListUsersRequest = Message<"bytebase.v1.ListUsersRequest"> & {
  /**
   * The maximum number of users to return. The service may return fewer than
   * this value.
   * If unspecified, at most 10 users will be returned.
   * The maximum value is 1000; values above 1000 will be coerced to 1000.
   *
   * @generated from field: int32 page_size = 1;
   */
  pageSize: number;

  /**
   * A page token, received from a previous `ListUsers` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListUsers` must match
   * the call that provided the page token.
   *
   * @generated from field: string page_token = 2;
   */
  pageToken: string;

  /**
   * Show deleted users if specified.
   *
   * @generated from field: bool show_deleted = 3;
   */
  showDeleted: boolean;

  /**
   * Filter is used to filter users returned in the list.
   * The syntax and semantics of CEL are documented at https://github.com/google/cel-spec
   *
   * Supported filter:
   * - name: the user name, support "==" and ".matches()" operator.
   * - email: the user email, support "==" and ".matches()" operator.
   * - user_type: the type, check UserType enum for values, support "==", "in [xx]", "!(in [xx])" operator.
   * - state: check State enum for values, support "==" operator.
   * - project: the project full name in "projects/{id}" format, support "==" operator.
   *
   * For example:
   * name == "ed"
   * name.matches("ed")
   * email == "ed@bytebase.com"
   * email.matches("ed")
   * user_type == "SERVICE_ACCOUNT"
   * user_type in ["SERVICE_ACCOUNT", "USER"]
   * !(user_type in ["SERVICE_ACCOUNT", "USER"])
   * state == "DELETED"
   * project == "projects/sample-project"
   * You can combine filter conditions like:
   * name.matches("ed") && project == "projects/sample-project"
   * (name == "ed" || email == "ed@bytebase.com") && project == "projects/sample-project"
   *
   * @generated from field: string filter = 4;
   */
  filter: string;
};

/**
 * Describes the message bytebase.v1.ListUsersRequest.
 * Use `create(ListUsersRequestSchema)` to create a new message.
 */
export declare const ListUsersRequestSchema: GenMessage<ListUsersRequest>;

/**
 * @generated from message bytebase.v1.ListUsersResponse
 */
export declare type ListUsersResponse = Message<"bytebase.v1.ListUsersResponse"> & {
  /**
   * The users from the specified request.
   *
   * @generated from field: repeated bytebase.v1.User users = 1;
   */
  users: User[];

  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message bytebase.v1.ListUsersResponse.
 * Use `create(ListUsersResponseSchema)` to create a new message.
 */
export declare const ListUsersResponseSchema: GenMessage<ListUsersResponse>;

/**
 * @generated from message bytebase.v1.CreateUserRequest
 */
export declare type CreateUserRequest = Message<"bytebase.v1.CreateUserRequest"> & {
  /**
   * The user to create.
   *
   * @generated from field: bytebase.v1.User user = 1;
   */
  user?: User;
};

/**
 * Describes the message bytebase.v1.CreateUserRequest.
 * Use `create(CreateUserRequestSchema)` to create a new message.
 */
export declare const CreateUserRequestSchema: GenMessage<CreateUserRequest>;

/**
 * @generated from message bytebase.v1.UpdateUserRequest
 */
export declare type UpdateUserRequest = Message<"bytebase.v1.UpdateUserRequest"> & {
  /**
   * The user to update.
   *
   * The user's `name` field is used to identify the user to update.
   * Format: users/{user}
   *
   * @generated from field: bytebase.v1.User user = 1;
   */
  user?: User;

  /**
   * The list of fields to update.
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 2;
   */
  updateMask?: FieldMask;

  /**
   * The otp_code is used to verify the user's identity by MFA.
   *
   * @generated from field: optional string otp_code = 3;
   */
  otpCode?: string;

  /**
   * The regenerate_temp_mfa_secret flag means to regenerate temporary MFA secret for user.
   * This is used for MFA setup. The temporary MFA secret and recovery codes will be returned in the response.
   *
   * @generated from field: bool regenerate_temp_mfa_secret = 4;
   */
  regenerateTempMfaSecret: boolean;

  /**
   * The regenerate_recovery_codes flag means to regenerate recovery codes for user.
   *
   * @generated from field: bool regenerate_recovery_codes = 5;
   */
  regenerateRecoveryCodes: boolean;
};

/**
 * Describes the message bytebase.v1.UpdateUserRequest.
 * Use `create(UpdateUserRequestSchema)` to create a new message.
 */
export declare const UpdateUserRequestSchema: GenMessage<UpdateUserRequest>;

/**
 * @generated from message bytebase.v1.DeleteUserRequest
 */
export declare type DeleteUserRequest = Message<"bytebase.v1.DeleteUserRequest"> & {
  /**
   * The name of the user to delete.
   * Format: users/{user}
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message bytebase.v1.DeleteUserRequest.
 * Use `create(DeleteUserRequestSchema)` to create a new message.
 */
export declare const DeleteUserRequestSchema: GenMessage<DeleteUserRequest>;

/**
 * @generated from message bytebase.v1.UndeleteUserRequest
 */
export declare type UndeleteUserRequest = Message<"bytebase.v1.UndeleteUserRequest"> & {
  /**
   * The name of the deleted user.
   * Format: users/{user}
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message bytebase.v1.UndeleteUserRequest.
 * Use `create(UndeleteUserRequestSchema)` to create a new message.
 */
export declare const UndeleteUserRequestSchema: GenMessage<UndeleteUserRequest>;

/**
 * @generated from message bytebase.v1.User
 */
export declare type User = Message<"bytebase.v1.User"> & {
  /**
   * The name of the user.
   * Format: users/{user}. {user} is a system-generated unique ID.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: bytebase.v1.State state = 2;
   */
  state: State;

  /**
   * @generated from field: string email = 3;
   */
  email: string;

  /**
   * @generated from field: string title = 4;
   */
  title: string;

  /**
   * @generated from field: bytebase.v1.UserType user_type = 5;
   */
  userType: UserType;

  /**
   * @generated from field: string password = 7;
   */
  password: string;

  /**
   * @generated from field: string service_key = 8;
   */
  serviceKey: string;

  /**
   * The mfa_enabled flag means if the user has enabled MFA.
   *
   * @generated from field: bool mfa_enabled = 9;
   */
  mfaEnabled: boolean;

  /**
   * The mfa_secret is the temporary secret using in two phase verification.
   *
   * @generated from field: string mfa_secret = 10;
   */
  mfaSecret: string;

  /**
   * The recovery_codes is the temporary recovery codes using in two phase verification.
   *
   * @generated from field: repeated string recovery_codes = 11;
   */
  recoveryCodes: string[];

  /**
   * Should be a valid E.164 compliant phone number.
   * Could be empty.
   *
   * @generated from field: string phone = 12;
   */
  phone: string;

  /**
   * @generated from field: bytebase.v1.User.Profile profile = 13;
   */
  profile?: User_Profile;
};

/**
 * Describes the message bytebase.v1.User.
 * Use `create(UserSchema)` to create a new message.
 */
export declare const UserSchema: GenMessage<User>;

/**
 * @generated from message bytebase.v1.User.Profile
 */
export declare type User_Profile = Message<"bytebase.v1.User.Profile"> & {
  /**
   * @generated from field: google.protobuf.Timestamp last_login_time = 1;
   */
  lastLoginTime?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp last_change_password_time = 2;
   */
  lastChangePasswordTime?: Timestamp;

  /**
   * source means where the user comes from. For now we support Entra ID SCIM sync, so the source could be Entra ID.
   *
   * @generated from field: string source = 3;
   */
  source: string;
};

/**
 * Describes the message bytebase.v1.User.Profile.
 * Use `create(User_ProfileSchema)` to create a new message.
 */
export declare const User_ProfileSchema: GenMessage<User_Profile>;

/**
 * @generated from enum bytebase.v1.UserType
 */
export enum UserType {
  /**
   * @generated from enum value: USER_TYPE_UNSPECIFIED = 0;
   */
  USER_TYPE_UNSPECIFIED = 0,

  /**
   * @generated from enum value: USER = 1;
   */
  USER = 1,

  /**
   * @generated from enum value: SYSTEM_BOT = 2;
   */
  SYSTEM_BOT = 2,

  /**
   * @generated from enum value: SERVICE_ACCOUNT = 3;
   */
  SERVICE_ACCOUNT = 3,
}

/**
 * Describes the enum bytebase.v1.UserType.
 */
export declare const UserTypeSchema: GenEnum<UserType>;

/**
 * @generated from service bytebase.v1.UserService
 */
export declare const UserService: GenService<{
  /**
   * Get the user.
   * Any authenticated user can get the user.
   *
   * @generated from rpc bytebase.v1.UserService.GetUser
   */
  getUser: {
    methodKind: "unary";
    input: typeof GetUserRequestSchema;
    output: typeof UserSchema;
  },
  /**
   * Get the users in batch.
   * Any authenticated user can batch get users.
   *
   * @generated from rpc bytebase.v1.UserService.BatchGetUsers
   */
  batchGetUsers: {
    methodKind: "unary";
    input: typeof BatchGetUsersRequestSchema;
    output: typeof BatchGetUsersResponseSchema;
  },
  /**
   * Get the current authenticated user.
   *
   * @generated from rpc bytebase.v1.UserService.GetCurrentUser
   */
  getCurrentUser: {
    methodKind: "unary";
    input: typeof EmptySchema;
    output: typeof UserSchema;
  },
  /**
   * List all users.
   * Any authenticated user can list users.
   *
   * @generated from rpc bytebase.v1.UserService.ListUsers
   */
  listUsers: {
    methodKind: "unary";
    input: typeof ListUsersRequestSchema;
    output: typeof ListUsersResponseSchema;
  },
  /**
   * Create a user.
   * When Disallow Signup is enabled, only the caller with bb.users.create on the workspace can create a user.
   * Otherwise, any unauthenticated user can create a user.
   *
   * @generated from rpc bytebase.v1.UserService.CreateUser
   */
  createUser: {
    methodKind: "unary";
    input: typeof CreateUserRequestSchema;
    output: typeof UserSchema;
  },
  /**
   * Only the user itself and the user with bb.users.update permission on the workspace can update the user.
   *
   * @generated from rpc bytebase.v1.UserService.UpdateUser
   */
  updateUser: {
    methodKind: "unary";
    input: typeof UpdateUserRequestSchema;
    output: typeof UserSchema;
  },
  /**
   * Only the user with bb.users.delete permission on the workspace can delete the user.
   * The last remaining workspace admin cannot be deleted.
   *
   * @generated from rpc bytebase.v1.UserService.DeleteUser
   */
  deleteUser: {
    methodKind: "unary";
    input: typeof DeleteUserRequestSchema;
    output: typeof EmptySchema;
  },
  /**
   * Only the user with bb.users.undelete permission on the workspace can undelete the user.
   *
   * @generated from rpc bytebase.v1.UserService.UndeleteUser
   */
  undeleteUser: {
    methodKind: "unary";
    input: typeof UndeleteUserRequestSchema;
    output: typeof UserSchema;
  },
}>;

