// @generated by protoc-gen-es v2.5.2
// @generated from file v1/user_service.proto (package bytebase.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";
import type { EmptySchema, FieldMask, Timestamp } from "@bufbuild/protobuf/wkt";
import type { State } from "./common_pb";

/**
 * Describes the file v1/user_service.proto.
 */
export declare const file_v1_user_service: GenFile;

/**
 * @generated from message bytebase.v1.GetUserRequest
 */
export declare type GetUserRequest = Message<"bytebase.v1.GetUserRequest"> & {
  /**
   * The name of the user to retrieve.
   * Format: users/{email}
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message bytebase.v1.GetUserRequest.
 * Use `create(GetUserRequestSchema)` to create a new message.
 */
export declare const GetUserRequestSchema: GenMessage<GetUserRequest>;

/**
 * @generated from message bytebase.v1.BatchGetUsersRequest
 */
export declare type BatchGetUsersRequest = Message<"bytebase.v1.BatchGetUsersRequest"> & {
  /**
   * The user names to retrieve.
   * Format: users/{email}
   *
   * @generated from field: repeated string names = 1;
   */
  names: string[];
};

/**
 * Describes the message bytebase.v1.BatchGetUsersRequest.
 * Use `create(BatchGetUsersRequestSchema)` to create a new message.
 */
export declare const BatchGetUsersRequestSchema: GenMessage<BatchGetUsersRequest>;

/**
 * @generated from message bytebase.v1.BatchGetUsersResponse
 */
export declare type BatchGetUsersResponse = Message<"bytebase.v1.BatchGetUsersResponse"> & {
  /**
   * The users from the specified request.
   *
   * @generated from field: repeated bytebase.v1.User users = 1;
   */
  users: User[];
};

/**
 * Describes the message bytebase.v1.BatchGetUsersResponse.
 * Use `create(BatchGetUsersResponseSchema)` to create a new message.
 */
export declare const BatchGetUsersResponseSchema: GenMessage<BatchGetUsersResponse>;

/**
 * @generated from message bytebase.v1.ListUsersRequest
 */
export declare type ListUsersRequest = Message<"bytebase.v1.ListUsersRequest"> & {
  /**
   * The maximum number of users to return. The service may return fewer than
   * this value.
   * If unspecified, at most 10 users will be returned.
   * The maximum value is 1000; values above 1000 will be coerced to 1000.
   *
   * @generated from field: int32 page_size = 1;
   */
  pageSize: number;

  /**
   * A page token, received from a previous `ListUsers` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListUsers` must match
   * the call that provided the page token.
   *
   * @generated from field: string page_token = 2;
   */
  pageToken: string;

  /**
   * Show deleted users if specified.
   *
   * @generated from field: bool show_deleted = 3;
   */
  showDeleted: boolean;

  /**
   * Filter is used to filter users returned in the list.
   * The syntax and semantics of CEL are documented at https://github.com/google/cel-spec
   *
   * Supported filter:
   * - name: the user name, support "==" and ".matches()" operator.
   * - email: the user email, support "==" and ".matches()" operator.
   * - user_type: the type, check UserType enum for values, support "==", "in [xx]", "!(in [xx])" operator.
   * - state: check State enum for values, support "==" operator.
   * - project: the project full name in "projects/{id}" format, support "==" operator.
   *
   * For example:
   * name == "ed"
   * name.matches("ed")
   * email == "ed@bytebase.com"
   * email.matches("ed")
   * user_type == "SERVICE_ACCOUNT"
   * user_type in ["SERVICE_ACCOUNT", "USER"]
   * !(user_type in ["SERVICE_ACCOUNT", "USER"])
   * state == "DELETED"
   * project == "projects/sample-project"
   * You can combine filter conditions like:
   * name.matches("ed") && project == "projects/sample-project"
   * (name == "ed" || email == "ed@bytebase.com") && project == "projects/sample-project"
   *
   * @generated from field: string filter = 4;
   */
  filter: string;
};

/**
 * Describes the message bytebase.v1.ListUsersRequest.
 * Use `create(ListUsersRequestSchema)` to create a new message.
 */
export declare const ListUsersRequestSchema: GenMessage<ListUsersRequest>;

/**
 * @generated from message bytebase.v1.ListUsersResponse
 */
export declare type ListUsersResponse = Message<"bytebase.v1.ListUsersResponse"> & {
  /**
   * The users from the specified request.
   *
   * @generated from field: repeated bytebase.v1.User users = 1;
   */
  users: User[];

  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message bytebase.v1.ListUsersResponse.
 * Use `create(ListUsersResponseSchema)` to create a new message.
 */
export declare const ListUsersResponseSchema: GenMessage<ListUsersResponse>;

/**
 * @generated from message bytebase.v1.CreateUserRequest
 */
export declare type CreateUserRequest = Message<"bytebase.v1.CreateUserRequest"> & {
  /**
   * The user to create.
   *
   * @generated from field: bytebase.v1.User user = 1;
   */
  user?: User;
};

/**
 * Describes the message bytebase.v1.CreateUserRequest.
 * Use `create(CreateUserRequestSchema)` to create a new message.
 */
export declare const CreateUserRequestSchema: GenMessage<CreateUserRequest>;

/**
 * @generated from message bytebase.v1.UpdateUserRequest
 */
export declare type UpdateUserRequest = Message<"bytebase.v1.UpdateUserRequest"> & {
  /**
   * The user to update.
   *
   * The user's `name` field is used to identify the user to update.
   * Format: users/{email}
   *
   * @generated from field: bytebase.v1.User user = 1;
   */
  user?: User;

  /**
   * The list of fields to update.
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 2;
   */
  updateMask?: FieldMask;

  /**
   * The otp_code is used to verify the user's identity by MFA.
   *
   * @generated from field: optional string otp_code = 3;
   */
  otpCode?: string;

  /**
   * The regenerate_temp_mfa_secret flag means to regenerate temporary MFA secret for user.
   * This is used for MFA setup. The temporary MFA secret and recovery codes will be returned in the response.
   *
   * @generated from field: bool regenerate_temp_mfa_secret = 4;
   */
  regenerateTempMfaSecret: boolean;

  /**
   * The regenerate_recovery_codes flag means to regenerate recovery codes for user.
   *
   * @generated from field: bool regenerate_recovery_codes = 5;
   */
  regenerateRecoveryCodes: boolean;

  /**
   * If set to true, and the user is not found, a new user will be created.
   * In this situation, `update_mask` is ignored.
   *
   * @generated from field: bool allow_missing = 6;
   */
  allowMissing: boolean;
};

/**
 * Describes the message bytebase.v1.UpdateUserRequest.
 * Use `create(UpdateUserRequestSchema)` to create a new message.
 */
export declare const UpdateUserRequestSchema: GenMessage<UpdateUserRequest>;

/**
 * @generated from message bytebase.v1.DeleteUserRequest
 */
export declare type DeleteUserRequest = Message<"bytebase.v1.DeleteUserRequest"> & {
  /**
   * The name of the user to delete.
   * Format: users/{email}
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message bytebase.v1.DeleteUserRequest.
 * Use `create(DeleteUserRequestSchema)` to create a new message.
 */
export declare const DeleteUserRequestSchema: GenMessage<DeleteUserRequest>;

/**
 * @generated from message bytebase.v1.UndeleteUserRequest
 */
export declare type UndeleteUserRequest = Message<"bytebase.v1.UndeleteUserRequest"> & {
  /**
   * The name of the deleted user.
   * Format: users/{email}
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message bytebase.v1.UndeleteUserRequest.
 * Use `create(UndeleteUserRequestSchema)` to create a new message.
 */
export declare const UndeleteUserRequestSchema: GenMessage<UndeleteUserRequest>;

/**
 * @generated from message bytebase.v1.UpdateEmailRequest
 */
export declare type UpdateEmailRequest = Message<"bytebase.v1.UpdateEmailRequest"> & {
  /**
   * The name of the user whose email to update.
   * Format: users/{email}
   * Note: This is the current (old) email address. The new email is specified in the 'email' field.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The new email address.
   *
   * @generated from field: string email = 2;
   */
  email: string;
};

/**
 * Describes the message bytebase.v1.UpdateEmailRequest.
 * Use `create(UpdateEmailRequestSchema)` to create a new message.
 */
export declare const UpdateEmailRequestSchema: GenMessage<UpdateEmailRequest>;

/**
 * @generated from message bytebase.v1.User
 */
export declare type User = Message<"bytebase.v1.User"> & {
  /**
   * The name of the user.
   * Format: users/{email}
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The lifecycle state of the user account.
   *
   * @generated from field: bytebase.v1.State state = 2;
   */
  state: State;

  /**
   * The email address of the user, used for login and notifications.
   *
   * @generated from field: string email = 3;
   */
  email: string;

  /**
   * The display title or full name of the user.
   *
   * @generated from field: string title = 4;
   */
  title: string;

  /**
   * The type of user account.
   *
   * @generated from field: bytebase.v1.UserType user_type = 5;
   */
  userType: UserType;

  /**
   * The password for authentication. Only used during user creation or password updates.
   *
   * @generated from field: string password = 6;
   */
  password: string;

  /**
   * The service key for service account authentication. Only used for service accounts.
   *
   * @generated from field: string service_key = 7;
   */
  serviceKey: string;

  /**
   * The mfa_enabled flag means if the user has enabled MFA.
   *
   * @generated from field: bool mfa_enabled = 8;
   */
  mfaEnabled: boolean;

  /**
   * Temporary OTP secret used during MFA setup and regeneration.
   *
   * @generated from field: string temp_otp_secret = 9;
   */
  tempOtpSecret: string;

  /**
   * Temporary recovery codes used during MFA setup and regeneration.
   *
   * @generated from field: repeated string temp_recovery_codes = 10;
   */
  tempRecoveryCodes: string[];

  /**
   * Timestamp when temp_otp_secret was created. Used by frontend to show countdown timer.
   *
   * @generated from field: google.protobuf.Timestamp temp_otp_secret_created_time = 11;
   */
  tempOtpSecretCreatedTime?: Timestamp;

  /**
   * Should be a valid E.164 compliant phone number.
   * Could be empty.
   *
   * @generated from field: string phone = 12;
   */
  phone: string;

  /**
   * User profile metadata.
   *
   * @generated from field: bytebase.v1.User.Profile profile = 13;
   */
  profile?: User_Profile;

  /**
   * The groups for the user.
   * Format: groups/{email}
   *
   * @generated from field: repeated string groups = 14;
   */
  groups: string[];

  /**
   * Workload Identity configuration (only for WORKLOAD_IDENTITY type)
   *
   * @generated from field: bytebase.v1.WorkloadIdentityConfig workload_identity_config = 15;
   */
  workloadIdentityConfig?: WorkloadIdentityConfig;
};

/**
 * Describes the message bytebase.v1.User.
 * Use `create(UserSchema)` to create a new message.
 */
export declare const UserSchema: GenMessage<User>;

/**
 * @generated from message bytebase.v1.User.Profile
 */
export declare type User_Profile = Message<"bytebase.v1.User.Profile"> & {
  /**
   * The last time the user successfully logged in.
   *
   * @generated from field: google.protobuf.Timestamp last_login_time = 1;
   */
  lastLoginTime?: Timestamp;

  /**
   * The last time the user changed their password.
   *
   * @generated from field: google.protobuf.Timestamp last_change_password_time = 2;
   */
  lastChangePasswordTime?: Timestamp;

  /**
   * source means where the user comes from. For now we support Entra ID SCIM sync, so the source could be Entra ID.
   *
   * @generated from field: string source = 3;
   */
  source: string;
};

/**
 * Describes the message bytebase.v1.User.Profile.
 * Use `create(User_ProfileSchema)` to create a new message.
 */
export declare const User_ProfileSchema: GenMessage<User_Profile>;

/**
 * WorkloadIdentityConfig for API layer
 *
 * @generated from message bytebase.v1.WorkloadIdentityConfig
 */
export declare type WorkloadIdentityConfig = Message<"bytebase.v1.WorkloadIdentityConfig"> & {
  /**
   * Platform type (currently only GITHUB is supported)
   *
   * @generated from field: bytebase.v1.WorkloadIdentityConfig.ProviderType provider_type = 1;
   */
  providerType: WorkloadIdentityConfig_ProviderType;

  /**
   * OIDC Issuer URL (auto-filled based on provider_type, can be overridden)
   *
   * @generated from field: string issuer_url = 2;
   */
  issuerUrl: string;

  /**
   * Allowed audiences for token validation
   *
   * @generated from field: repeated string allowed_audiences = 3;
   */
  allowedAudiences: string[];

  /**
   * Subject pattern to match (e.g., "repo:owner/repo:ref:refs/heads/main")
   *
   * @generated from field: string subject_pattern = 4;
   */
  subjectPattern: string;
};

/**
 * Describes the message bytebase.v1.WorkloadIdentityConfig.
 * Use `create(WorkloadIdentityConfigSchema)` to create a new message.
 */
export declare const WorkloadIdentityConfigSchema: GenMessage<WorkloadIdentityConfig>;

/**
 * ProviderType identifies the CI/CD platform.
 *
 * @generated from enum bytebase.v1.WorkloadIdentityConfig.ProviderType
 */
export enum WorkloadIdentityConfig_ProviderType {
  /**
   * @generated from enum value: PROVIDER_TYPE_UNSPECIFIED = 0;
   */
  PROVIDER_TYPE_UNSPECIFIED = 0,

  /**
   * @generated from enum value: GITHUB = 1;
   */
  GITHUB = 1,

  /**
   * @generated from enum value: GITLAB = 2;
   */
  GITLAB = 2,
}

/**
 * Describes the enum bytebase.v1.WorkloadIdentityConfig.ProviderType.
 */
export declare const WorkloadIdentityConfig_ProviderTypeSchema: GenEnum<WorkloadIdentityConfig_ProviderType>;

/**
 * @generated from enum bytebase.v1.UserType
 */
export enum UserType {
  /**
   * Unspecified user type.
   *
   * @generated from enum value: USER_TYPE_UNSPECIFIED = 0;
   */
  USER_TYPE_UNSPECIFIED = 0,

  /**
   * Regular human user account.
   *
   * @generated from enum value: USER = 1;
   */
  USER = 1,

  /**
   * System-managed bot account for automated operations.
   *
   * @generated from enum value: SYSTEM_BOT = 2;
   */
  SYSTEM_BOT = 2,

  /**
   * Service account for API integrations.
   *
   * @generated from enum value: SERVICE_ACCOUNT = 3;
   */
  SERVICE_ACCOUNT = 3,

  /**
   * External CI/CD workload identity.
   *
   * @generated from enum value: WORKLOAD_IDENTITY = 4;
   */
  WORKLOAD_IDENTITY = 4,
}

/**
 * Describes the enum bytebase.v1.UserType.
 */
export declare const UserTypeSchema: GenEnum<UserType>;

/**
 * UserService manages user accounts and authentication.
 *
 * @generated from service bytebase.v1.UserService
 */
export declare const UserService: GenService<{
  /**
   * Get the user.
   * Any authenticated user can get the user.
   * Permissions required: bb.users.get
   *
   * @generated from rpc bytebase.v1.UserService.GetUser
   */
  getUser: {
    methodKind: "unary";
    input: typeof GetUserRequestSchema;
    output: typeof UserSchema;
  },
  /**
   * Get the users in batch.
   * Any authenticated user can batch get users.
   * Permissions required: bb.users.get
   *
   * @generated from rpc bytebase.v1.UserService.BatchGetUsers
   */
  batchGetUsers: {
    methodKind: "unary";
    input: typeof BatchGetUsersRequestSchema;
    output: typeof BatchGetUsersResponseSchema;
  },
  /**
   * Get the current authenticated user.
   * Permissions required: None
   *
   * @generated from rpc bytebase.v1.UserService.GetCurrentUser
   */
  getCurrentUser: {
    methodKind: "unary";
    input: typeof EmptySchema;
    output: typeof UserSchema;
  },
  /**
   * List all users.
   * Any authenticated user can list users.
   * Permissions required: bb.users.list
   *
   * @generated from rpc bytebase.v1.UserService.ListUsers
   */
  listUsers: {
    methodKind: "unary";
    input: typeof ListUsersRequestSchema;
    output: typeof ListUsersResponseSchema;
  },
  /**
   * Creates a user. When Disallow Signup is enabled, requires bb.users.create permission; otherwise any user can sign up.
   * Permissions required: bb.users.create (only when Disallow Signup is enabled)
   *
   * @generated from rpc bytebase.v1.UserService.CreateUser
   */
  createUser: {
    methodKind: "unary";
    input: typeof CreateUserRequestSchema;
    output: typeof UserSchema;
  },
  /**
   * Updates a user. Users can update their own profile, or users with bb.users.update permission can update any user.
   * Note: Email updates are not supported through this API. Use UpdateEmail instead.
   * Permissions required: bb.users.update (or self)
   *
   * @generated from rpc bytebase.v1.UserService.UpdateUser
   */
  updateUser: {
    methodKind: "unary";
    input: typeof UpdateUserRequestSchema;
    output: typeof UserSchema;
  },
  /**
   * Deletes a user. Requires bb.users.delete permission with additional validation: the last remaining workspace admin cannot be deleted.
   * Permissions required: bb.users.delete
   *
   * @generated from rpc bytebase.v1.UserService.DeleteUser
   */
  deleteUser: {
    methodKind: "unary";
    input: typeof DeleteUserRequestSchema;
    output: typeof EmptySchema;
  },
  /**
   * Restores a deleted user.
   * Permissions required: bb.users.undelete
   *
   * @generated from rpc bytebase.v1.UserService.UndeleteUser
   */
  undeleteUser: {
    methodKind: "unary";
    input: typeof UndeleteUserRequestSchema;
    output: typeof UserSchema;
  },
  /**
   * Updates a user's email address.
   * Permissions required: bb.users.updateEmail
   *
   * @generated from rpc bytebase.v1.UserService.UpdateEmail
   */
  updateEmail: {
    methodKind: "unary";
    input: typeof UpdateEmailRequestSchema;
    output: typeof UserSchema;
  },
}>;

