// @generated by protoc-gen-es v2.5.2
// @generated from file v1/database_service.proto (package bytebase.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";
import type { FieldMask, Timestamp } from "@bufbuild/protobuf/wkt";
import type { State } from "./common_pb";
import type { InstanceResource } from "./instance_service_pb";

/**
 * Describes the file v1/database_service.proto.
 */
export declare const file_v1_database_service: GenFile;

/**
 * @generated from message bytebase.v1.GetDatabaseRequest
 */
export declare type GetDatabaseRequest = Message<"bytebase.v1.GetDatabaseRequest"> & {
  /**
   * The name of the database to retrieve.
   * Format: instances/{instance}/databases/{database}
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message bytebase.v1.GetDatabaseRequest.
 * Use `create(GetDatabaseRequestSchema)` to create a new message.
 */
export declare const GetDatabaseRequestSchema: GenMessage<GetDatabaseRequest>;

/**
 * @generated from message bytebase.v1.BatchGetDatabasesRequest
 */
export declare type BatchGetDatabasesRequest = Message<"bytebase.v1.BatchGetDatabasesRequest"> & {
  /**
   * The parent resource shared by all databases being retrieved.
   * - projects/{project}: batch get databases in a project;
   * - instances/{instances}: batch get databases in a instance;
   * Use "-" as wildcard to batch get databases across parent.
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * The list of database names to retrieve.
   *
   * @generated from field: repeated string names = 2;
   */
  names: string[];
};

/**
 * Describes the message bytebase.v1.BatchGetDatabasesRequest.
 * Use `create(BatchGetDatabasesRequestSchema)` to create a new message.
 */
export declare const BatchGetDatabasesRequestSchema: GenMessage<BatchGetDatabasesRequest>;

/**
 * @generated from message bytebase.v1.BatchGetDatabasesResponse
 */
export declare type BatchGetDatabasesResponse = Message<"bytebase.v1.BatchGetDatabasesResponse"> & {
  /**
   * The databases from the specified request.
   *
   * @generated from field: repeated bytebase.v1.Database databases = 1;
   */
  databases: Database[];
};

/**
 * Describes the message bytebase.v1.BatchGetDatabasesResponse.
 * Use `create(BatchGetDatabasesResponseSchema)` to create a new message.
 */
export declare const BatchGetDatabasesResponseSchema: GenMessage<BatchGetDatabasesResponse>;

/**
 * @generated from message bytebase.v1.ListDatabasesRequest
 */
export declare type ListDatabasesRequest = Message<"bytebase.v1.ListDatabasesRequest"> & {
  /**
   * - projects/{project}: list databases in a project, require "bb.projects.get" permission.
   * - workspaces/-: list databases in the workspace, require "bb.databases.list" permission.
   * - instances/{instances}: list databases in a instance, require "bb.instances.get" permission
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * The maximum number of databases to return. The service may return fewer
   * than this value.
   * If unspecified, at most 10 databases will be returned.
   * The maximum value is 1000; values above 1000 will be coerced to 1000.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize: number;

  /**
   * A page token, received from a previous `ListDatabases` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListDatabases` must
   * match the call that provided the page token.
   *
   * @generated from field: string page_token = 3;
   */
  pageToken: string;

  /**
   * Filter is used to filter databases returned in the list.
   * The syntax and semantics of CEL are documented at https://github.com/google/cel-spec
   *
   * Supported filter:
   * - environment: the environment full name in "environments/{id}" format, support "==" operator.
   * - name: the database name, support ".matches()" operator.
   * - project: the project full name in "projects/{id}" format, support "==" operator.
   * - instance: the instance full name in "instances/{id}" format, support "==" operator.
   * - engine: the database engine, check Engine enum for values. Support "==", "in [xx]", "!(in [xx])" operator.
   * - exclude_unassigned: should be "true" or "false", will not show unassigned databases if it's true, support "==" operator.
   * - drifted: should be "true" or "false", show drifted databases if it's true, support "==" operator.
   * - table: filter by the database table, support "==" and ".matches()" operator.
   * - labels.{key}: the database label, support "==" and "in" operators.
   *
   * For example:
   * environment == "environments/{environment resource id}"
   * environment == "" (find databases which environment is not set)
   * project == "projects/{project resource id}"
   * instance == "instances/{instance resource id}"
   * name.matches("database name")
   * engine == "MYSQL"
   * engine in ["MYSQL", "POSTGRES"]
   * !(engine in ["MYSQL", "POSTGRES"])
   * exclude_unassigned == true
   * drifted == true
   * table == "sample"
   * table.matches("sam")
   * labels.environment == "production"
   * labels.region == "asia"
   * labels.region in ["asia", "europe"]
   *
   * You can combine filter conditions like:
   * environment == "environments/prod" && name.matches("employee")
   *
   * @generated from field: string filter = 4;
   */
  filter: string;

  /**
   * Show deleted database if specified.
   *
   * @generated from field: bool show_deleted = 5;
   */
  showDeleted: boolean;

  /**
   * The order by of databases.
   * Support name, project, instance. The default sorting order is ascending.
   * For example:
   * - order_by = "name" - order by name ascending
   * - order_by = "name desc"
   * - order_by = "name desc, project asc"
   *
   * @generated from field: string order_by = 6;
   */
  orderBy: string;
};

/**
 * Describes the message bytebase.v1.ListDatabasesRequest.
 * Use `create(ListDatabasesRequestSchema)` to create a new message.
 */
export declare const ListDatabasesRequestSchema: GenMessage<ListDatabasesRequest>;

/**
 * @generated from message bytebase.v1.ListDatabasesResponse
 */
export declare type ListDatabasesResponse = Message<"bytebase.v1.ListDatabasesResponse"> & {
  /**
   * The databases from the specified request.
   *
   * @generated from field: repeated bytebase.v1.Database databases = 1;
   */
  databases: Database[];

  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message bytebase.v1.ListDatabasesResponse.
 * Use `create(ListDatabasesResponseSchema)` to create a new message.
 */
export declare const ListDatabasesResponseSchema: GenMessage<ListDatabasesResponse>;

/**
 * @generated from message bytebase.v1.UpdateDatabaseRequest
 */
export declare type UpdateDatabaseRequest = Message<"bytebase.v1.UpdateDatabaseRequest"> & {
  /**
   * The database to update.
   *
   * The database's `name` field is used to identify the database to update.
   * Format: instances/{instance}/databases/{database}
   *
   * @generated from field: bytebase.v1.Database database = 1;
   */
  database?: Database;

  /**
   * The list of fields to update.
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 2;
   */
  updateMask?: FieldMask;

  /**
   * If set to true, and the database is not found, a new database will be created.
   * In this situation, `update_mask` is ignored.
   *
   * @generated from field: bool allow_missing = 3;
   */
  allowMissing: boolean;
};

/**
 * Describes the message bytebase.v1.UpdateDatabaseRequest.
 * Use `create(UpdateDatabaseRequestSchema)` to create a new message.
 */
export declare const UpdateDatabaseRequestSchema: GenMessage<UpdateDatabaseRequest>;

/**
 * @generated from message bytebase.v1.BatchUpdateDatabasesRequest
 */
export declare type BatchUpdateDatabasesRequest = Message<"bytebase.v1.BatchUpdateDatabasesRequest"> & {
  /**
   * The parent resource shared by all databases being updated.
   * Format: instances/{instance}
   * If the operation spans parents, a dash (-) may be accepted as a wildcard.
   * We only support updating the project of databases for now.
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * The request message specifying the resources to update.
   * A maximum of 1000 databases can be modified in a batch.
   *
   * @generated from field: repeated bytebase.v1.UpdateDatabaseRequest requests = 2;
   */
  requests: UpdateDatabaseRequest[];
};

/**
 * Describes the message bytebase.v1.BatchUpdateDatabasesRequest.
 * Use `create(BatchUpdateDatabasesRequestSchema)` to create a new message.
 */
export declare const BatchUpdateDatabasesRequestSchema: GenMessage<BatchUpdateDatabasesRequest>;

/**
 * @generated from message bytebase.v1.BatchUpdateDatabasesResponse
 */
export declare type BatchUpdateDatabasesResponse = Message<"bytebase.v1.BatchUpdateDatabasesResponse"> & {
  /**
   * Databases updated.
   *
   * @generated from field: repeated bytebase.v1.Database databases = 1;
   */
  databases: Database[];
};

/**
 * Describes the message bytebase.v1.BatchUpdateDatabasesResponse.
 * Use `create(BatchUpdateDatabasesResponseSchema)` to create a new message.
 */
export declare const BatchUpdateDatabasesResponseSchema: GenMessage<BatchUpdateDatabasesResponse>;

/**
 * @generated from message bytebase.v1.BatchSyncDatabasesRequest
 */
export declare type BatchSyncDatabasesRequest = Message<"bytebase.v1.BatchSyncDatabasesRequest"> & {
  /**
   * The parent resource shared by all databases being updated.
   * Format: instances/{instance}
   * If the operation spans parents, a dash (-) may be accepted as a wildcard.
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * The list of database names to sync.
   *
   * @generated from field: repeated string names = 2;
   */
  names: string[];
};

/**
 * Describes the message bytebase.v1.BatchSyncDatabasesRequest.
 * Use `create(BatchSyncDatabasesRequestSchema)` to create a new message.
 */
export declare const BatchSyncDatabasesRequestSchema: GenMessage<BatchSyncDatabasesRequest>;

/**
 * @generated from message bytebase.v1.BatchSyncDatabasesResponse
 */
export declare type BatchSyncDatabasesResponse = Message<"bytebase.v1.BatchSyncDatabasesResponse"> & {
};

/**
 * Describes the message bytebase.v1.BatchSyncDatabasesResponse.
 * Use `create(BatchSyncDatabasesResponseSchema)` to create a new message.
 */
export declare const BatchSyncDatabasesResponseSchema: GenMessage<BatchSyncDatabasesResponse>;

/**
 * @generated from message bytebase.v1.SyncDatabaseRequest
 */
export declare type SyncDatabaseRequest = Message<"bytebase.v1.SyncDatabaseRequest"> & {
  /**
   * The name of the database to sync.
   * Format: instances/{instance}/databases/{database}
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message bytebase.v1.SyncDatabaseRequest.
 * Use `create(SyncDatabaseRequestSchema)` to create a new message.
 */
export declare const SyncDatabaseRequestSchema: GenMessage<SyncDatabaseRequest>;

/**
 * @generated from message bytebase.v1.SyncDatabaseResponse
 */
export declare type SyncDatabaseResponse = Message<"bytebase.v1.SyncDatabaseResponse"> & {
};

/**
 * Describes the message bytebase.v1.SyncDatabaseResponse.
 * Use `create(SyncDatabaseResponseSchema)` to create a new message.
 */
export declare const SyncDatabaseResponseSchema: GenMessage<SyncDatabaseResponse>;

/**
 * @generated from message bytebase.v1.GetDatabaseMetadataRequest
 */
export declare type GetDatabaseMetadataRequest = Message<"bytebase.v1.GetDatabaseMetadataRequest"> & {
  /**
   * The name of the database to retrieve metadata.
   * Format: instances/{instance}/databases/{database}/metadata
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Filter is used to filter databases returned in the list.
   * The syntax and semantics of CEL are documented at https://github.com/google/cel-spec
   *
   * Supported filter:
   * - schema: the schema name, support "==" operator.
   * - table: the table name, support "==" and ".matches()" operator.
   *
   * For example:
   * schema == "schema-a"
   * table == "table-a"
   * table.matches("table-a")
   * schema == "schema-a" && table.matches("sample")
   * The filter used to search table with wildcard "sample" in the schema "schemas/schema-a".
   * The column masking level will only be returned when a table filter is used.
   *
   * @generated from field: string filter = 2;
   */
  filter: string;

  /**
   * Limit the response size of returned table metadata per schema.
   * For example, if the database has 3 schemas, and each schema has 100 tables,
   * if limit is 20, then only 20 tables will be returned for each schema, total 60 tables.
   * Default 0, means no limit.
   *
   * @generated from field: int32 limit = 3;
   */
  limit: number;
};

/**
 * Describes the message bytebase.v1.GetDatabaseMetadataRequest.
 * Use `create(GetDatabaseMetadataRequestSchema)` to create a new message.
 */
export declare const GetDatabaseMetadataRequestSchema: GenMessage<GetDatabaseMetadataRequest>;

/**
 * @generated from message bytebase.v1.GetDatabaseSchemaRequest
 */
export declare type GetDatabaseSchemaRequest = Message<"bytebase.v1.GetDatabaseSchemaRequest"> & {
  /**
   * The name of the database to retrieve schema.
   * Format: instances/{instance}/databases/{database}/schema
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message bytebase.v1.GetDatabaseSchemaRequest.
 * Use `create(GetDatabaseSchemaRequestSchema)` to create a new message.
 */
export declare const GetDatabaseSchemaRequestSchema: GenMessage<GetDatabaseSchemaRequest>;

/**
 * @generated from message bytebase.v1.GetDatabaseSDLSchemaRequest
 */
export declare type GetDatabaseSDLSchemaRequest = Message<"bytebase.v1.GetDatabaseSDLSchemaRequest"> & {
  /**
   * The name of the database to retrieve SDL schema.
   * Format: instances/{instance}/databases/{database}/sdlSchema
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The format of the SDL schema output.
   *
   * @generated from field: bytebase.v1.GetDatabaseSDLSchemaRequest.SDLFormat format = 2;
   */
  format: GetDatabaseSDLSchemaRequest_SDLFormat;
};

/**
 * Describes the message bytebase.v1.GetDatabaseSDLSchemaRequest.
 * Use `create(GetDatabaseSDLSchemaRequestSchema)` to create a new message.
 */
export declare const GetDatabaseSDLSchemaRequestSchema: GenMessage<GetDatabaseSDLSchemaRequest>;

/**
 * SDLFormat specifies the output format for SDL schema.
 *
 * @generated from enum bytebase.v1.GetDatabaseSDLSchemaRequest.SDLFormat
 */
export enum GetDatabaseSDLSchemaRequest_SDLFormat {
  /**
   * Unspecified format. Defaults to SINGLE_FILE.
   *
   * @generated from enum value: SDL_FORMAT_UNSPECIFIED = 0;
   */
  SDL_FORMAT_UNSPECIFIED = 0,

  /**
   * Single file format: returns the complete SDL schema as a single file.
   *
   * @generated from enum value: SINGLE_FILE = 1;
   */
  SINGLE_FILE = 1,

  /**
   * Multi-file format: returns the SDL schema as a ZIP archive containing
   * multiple files organized by schema objects (tables, views, functions, etc.).
   *
   * @generated from enum value: MULTI_FILE = 2;
   */
  MULTI_FILE = 2,
}

/**
 * Describes the enum bytebase.v1.GetDatabaseSDLSchemaRequest.SDLFormat.
 */
export declare const GetDatabaseSDLSchemaRequest_SDLFormatSchema: GenEnum<GetDatabaseSDLSchemaRequest_SDLFormat>;

/**
 * @generated from message bytebase.v1.DiffSchemaRequest
 */
export declare type DiffSchemaRequest = Message<"bytebase.v1.DiffSchemaRequest"> & {
  /**
   * The name of the database or changelog.
   * Format:
   * database: instances/{instance}/databases/{database}
   * changelog: instances/{instance}/databases/{database}/changelogs/{changelog}
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from oneof bytebase.v1.DiffSchemaRequest.target
   */
  target: {
    /**
     * The target schema.
     *
     * @generated from field: string schema = 2;
     */
    value: string;
    case: "schema";
  } | {
    /**
     * The resource name of the changelog
     * Format:
     * instances/{instance}/databases/{database}/changelogs/{changelog}
     *
     * @generated from field: string changelog = 3;
     */
    value: string;
    case: "changelog";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message bytebase.v1.DiffSchemaRequest.
 * Use `create(DiffSchemaRequestSchema)` to create a new message.
 */
export declare const DiffSchemaRequestSchema: GenMessage<DiffSchemaRequest>;

/**
 * @generated from message bytebase.v1.DiffSchemaResponse
 */
export declare type DiffSchemaResponse = Message<"bytebase.v1.DiffSchemaResponse"> & {
  /**
   * @generated from field: string diff = 1;
   */
  diff: string;
};

/**
 * Describes the message bytebase.v1.DiffSchemaResponse.
 * Use `create(DiffSchemaResponseSchema)` to create a new message.
 */
export declare const DiffSchemaResponseSchema: GenMessage<DiffSchemaResponse>;

/**
 * @generated from message bytebase.v1.Database
 */
export declare type Database = Message<"bytebase.v1.Database"> & {
  /**
   * The name of the database.
   * Format: instances/{instance}/databases/{database}
   * {database} is the database name in the instance.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The existence of a database.
   *
   * @generated from field: bytebase.v1.State state = 2;
   */
  state: State;

  /**
   * The latest synchronization time.
   *
   * @generated from field: google.protobuf.Timestamp successful_sync_time = 3;
   */
  successfulSyncTime?: Timestamp;

  /**
   * The project for a database.
   * Format: projects/{project}
   *
   * @generated from field: string project = 4;
   */
  project: string;

  /**
   * The version of database schema.
   *
   * @generated from field: string schema_version = 5;
   */
  schemaVersion: string;

  /**
   * The environment resource.
   * Format: environments/prod where prod is the environment resource ID.
   *
   * @generated from field: optional string environment = 6;
   */
  environment?: string;

  /**
   * The effective environment based on environment tag above and environment
   * tag on the instance. Inheritance follows
   * https://cloud.google.com/resource-manager/docs/tags/tags-overview.
   *
   * @generated from field: optional string effective_environment = 7;
   */
  effectiveEnvironment?: string;

  /**
   * Labels will be used for deployment and policy control.
   *
   * @generated from field: map<string, string> labels = 8;
   */
  labels: { [key: string]: string };

  /**
   * The instance resource.
   *
   * @generated from field: bytebase.v1.InstanceResource instance_resource = 9;
   */
  instanceResource?: InstanceResource;

  /**
   * The database is available for DML prior backup.
   *
   * @generated from field: bool backup_available = 10;
   */
  backupAvailable: boolean;

  /**
   * The schema is drifted from the source of truth.
   *
   * @generated from field: bool drifted = 11;
   */
  drifted: boolean;
};

/**
 * Describes the message bytebase.v1.Database.
 * Use `create(DatabaseSchema$)` to create a new message.
 */
export declare const DatabaseSchema$: GenMessage<Database>;

/**
 * DatabaseMetadata is the metadata for databases.
 *
 * @generated from message bytebase.v1.DatabaseMetadata
 */
export declare type DatabaseMetadata = Message<"bytebase.v1.DatabaseMetadata"> & {
  /**
   * The database metadata name.
   *
   * Format: instances/{instance}/databases/{database}/metadata
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The schemas is the list of schemas in a database.
   *
   * @generated from field: repeated bytebase.v1.SchemaMetadata schemas = 2;
   */
  schemas: SchemaMetadata[];

  /**
   * The character_set is the character set of a database.
   *
   * @generated from field: string character_set = 3;
   */
  characterSet: string;

  /**
   * The collation is the collation of a database.
   *
   * @generated from field: string collation = 4;
   */
  collation: string;

  /**
   * The extensions is the list of extensions in a database.
   *
   * @generated from field: repeated bytebase.v1.ExtensionMetadata extensions = 5;
   */
  extensions: ExtensionMetadata[];

  /**
   * The owner of the database.
   *
   * @generated from field: string owner = 6;
   */
  owner: string;

  /**
   * The search_path is the search path of a PostgreSQL database.
   *
   * @generated from field: string search_path = 7;
   */
  searchPath: string;
};

/**
 * Describes the message bytebase.v1.DatabaseMetadata.
 * Use `create(DatabaseMetadataSchema)` to create a new message.
 */
export declare const DatabaseMetadataSchema: GenMessage<DatabaseMetadata>;

/**
 * SchemaMetadata is the metadata for schemas.
 * This is the concept of schema in Postgres, but it's a no-op for MySQL.
 *
 * @generated from message bytebase.v1.SchemaMetadata
 */
export declare type SchemaMetadata = Message<"bytebase.v1.SchemaMetadata"> & {
  /**
   * The name is the schema name.
   * It is an empty string for databases without such concept such as MySQL.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The tables is the list of tables in a schema.
   *
   * @generated from field: repeated bytebase.v1.TableMetadata tables = 2;
   */
  tables: TableMetadata[];

  /**
   * The external_tables is the list of external tables in a schema.
   *
   * @generated from field: repeated bytebase.v1.ExternalTableMetadata external_tables = 3;
   */
  externalTables: ExternalTableMetadata[];

  /**
   * The views is the list of views in a schema.
   *
   * @generated from field: repeated bytebase.v1.ViewMetadata views = 4;
   */
  views: ViewMetadata[];

  /**
   * The functions is the list of functions in a schema.
   *
   * @generated from field: repeated bytebase.v1.FunctionMetadata functions = 5;
   */
  functions: FunctionMetadata[];

  /**
   * The procedures is the list of procedures in a schema.
   *
   * @generated from field: repeated bytebase.v1.ProcedureMetadata procedures = 6;
   */
  procedures: ProcedureMetadata[];

  /**
   * The streams is the list of streams in a schema, currently, only used for
   * Snowflake.
   *
   * @generated from field: repeated bytebase.v1.StreamMetadata streams = 7;
   */
  streams: StreamMetadata[];

  /**
   * The routines is the list of routines in a schema, currently, only used for
   * Snowflake.
   *
   * @generated from field: repeated bytebase.v1.TaskMetadata tasks = 8;
   */
  tasks: TaskMetadata[];

  /**
   * The materialized_views is the list of materialized views in a schema.
   *
   * @generated from field: repeated bytebase.v1.MaterializedViewMetadata materialized_views = 9;
   */
  materializedViews: MaterializedViewMetadata[];

  /**
   * The packages is the list of packages in a schema.
   *
   * @generated from field: repeated bytebase.v1.PackageMetadata packages = 10;
   */
  packages: PackageMetadata[];

  /**
   * The owner of the schema.
   *
   * @generated from field: string owner = 11;
   */
  owner: string;

  /**
   * The sequences is the list of sequences in a schema, sorted by name.
   *
   * @generated from field: repeated bytebase.v1.SequenceMetadata sequences = 12;
   */
  sequences: SequenceMetadata[];

  /**
   * The events is the list of scheduled events in a schema.
   *
   * @generated from field: repeated bytebase.v1.EventMetadata events = 13;
   */
  events: EventMetadata[];

  /**
   * The enum_types is the list of user-defined enum types in a schema.
   *
   * @generated from field: repeated bytebase.v1.EnumTypeMetadata enum_types = 14;
   */
  enumTypes: EnumTypeMetadata[];

  /**
   * Whether to skip this schema during schema dump operations.
   *
   * @generated from field: bool skip_dump = 15;
   */
  skipDump: boolean;

  /**
   * The comment is the comment of a schema.
   *
   * @generated from field: string comment = 16;
   */
  comment: string;
};

/**
 * Describes the message bytebase.v1.SchemaMetadata.
 * Use `create(SchemaMetadataSchema)` to create a new message.
 */
export declare const SchemaMetadataSchema: GenMessage<SchemaMetadata>;

/**
 * @generated from message bytebase.v1.EnumTypeMetadata
 */
export declare type EnumTypeMetadata = Message<"bytebase.v1.EnumTypeMetadata"> & {
  /**
   * The name of a type.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The enum values of a type.
   *
   * @generated from field: repeated string values = 2;
   */
  values: string[];

  /**
   * The comment describing the enum type.
   *
   * @generated from field: string comment = 3;
   */
  comment: string;

  /**
   * Whether to skip this enum type during schema dump operations.
   *
   * @generated from field: bool skip_dump = 4;
   */
  skipDump: boolean;
};

/**
 * Describes the message bytebase.v1.EnumTypeMetadata.
 * Use `create(EnumTypeMetadataSchema)` to create a new message.
 */
export declare const EnumTypeMetadataSchema: GenMessage<EnumTypeMetadata>;

/**
 * @generated from message bytebase.v1.EventMetadata
 */
export declare type EventMetadata = Message<"bytebase.v1.EventMetadata"> & {
  /**
   * The name of the event.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The schedule of the event.
   *
   * @generated from field: string definition = 2;
   */
  definition: string;

  /**
   * The time zone of the event.
   *
   * @generated from field: string time_zone = 3;
   */
  timeZone: string;

  /**
   * The SQL mode setting for the event.
   *
   * @generated from field: string sql_mode = 4;
   */
  sqlMode: string;

  /**
   * The character set used by the client creating the event.
   *
   * @generated from field: string character_set_client = 5;
   */
  characterSetClient: string;

  /**
   * The collation used for the connection when creating the event.
   *
   * @generated from field: string collation_connection = 6;
   */
  collationConnection: string;

  /**
   * The comment is the comment of an event.
   *
   * @generated from field: string comment = 7;
   */
  comment: string;
};

/**
 * Describes the message bytebase.v1.EventMetadata.
 * Use `create(EventMetadataSchema)` to create a new message.
 */
export declare const EventMetadataSchema: GenMessage<EventMetadata>;

/**
 * @generated from message bytebase.v1.SequenceMetadata
 */
export declare type SequenceMetadata = Message<"bytebase.v1.SequenceMetadata"> & {
  /**
   * The name of a sequence.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The data type of a sequence.
   *
   * @generated from field: string data_type = 2;
   */
  dataType: string;

  /**
   * The start value of a sequence.
   *
   * @generated from field: string start = 3;
   */
  start: string;

  /**
   * The minimum value of a sequence.
   *
   * @generated from field: string min_value = 4;
   */
  minValue: string;

  /**
   * The maximum value of a sequence.
   *
   * @generated from field: string max_value = 5;
   */
  maxValue: string;

  /**
   * Increment value of a sequence.
   *
   * @generated from field: string increment = 6;
   */
  increment: string;

  /**
   * Cycle is whether the sequence cycles.
   *
   * @generated from field: bool cycle = 7;
   */
  cycle: boolean;

  /**
   * Cache size of a sequence.
   *
   * @generated from field: string cache_size = 8;
   */
  cacheSize: string;

  /**
   * Last value of a sequence.
   *
   * @generated from field: string last_value = 9;
   */
  lastValue: string;

  /**
   * The owner table of the sequence.
   *
   * @generated from field: string owner_table = 10;
   */
  ownerTable: string;

  /**
   * The owner column of the sequence.
   *
   * @generated from field: string owner_column = 11;
   */
  ownerColumn: string;

  /**
   * The comment describing the sequence.
   *
   * @generated from field: string comment = 12;
   */
  comment: string;

  /**
   * Whether to skip this sequence during schema dump operations.
   *
   * @generated from field: bool skip_dump = 13;
   */
  skipDump: boolean;
};

/**
 * Describes the message bytebase.v1.SequenceMetadata.
 * Use `create(SequenceMetadataSchema)` to create a new message.
 */
export declare const SequenceMetadataSchema: GenMessage<SequenceMetadata>;

/**
 * @generated from message bytebase.v1.TriggerMetadata
 */
export declare type TriggerMetadata = Message<"bytebase.v1.TriggerMetadata"> & {
  /**
   * The name is the name of the trigger.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The event is the event of the trigger, such as INSERT, UPDATE, DELETE,
   * TRUNCATE.
   *
   * @generated from field: string event = 2;
   */
  event: string;

  /**
   * The timing is the timing of the trigger, such as BEFORE, AFTER.
   *
   * @generated from field: string timing = 3;
   */
  timing: string;

  /**
   * The body is the body of the trigger.
   *
   * @generated from field: string body = 4;
   */
  body: string;

  /**
   * The SQL mode setting for the trigger.
   *
   * @generated from field: string sql_mode = 5;
   */
  sqlMode: string;

  /**
   * The character set used by the client creating the trigger.
   *
   * @generated from field: string character_set_client = 6;
   */
  characterSetClient: string;

  /**
   * The collation used for the connection when creating the trigger.
   *
   * @generated from field: string collation_connection = 7;
   */
  collationConnection: string;

  /**
   * The comment describing the trigger.
   *
   * @generated from field: string comment = 8;
   */
  comment: string;

  /**
   * Whether to skip this trigger during schema dump operations.
   *
   * @generated from field: bool skip_dump = 9;
   */
  skipDump: boolean;
};

/**
 * Describes the message bytebase.v1.TriggerMetadata.
 * Use `create(TriggerMetadataSchema)` to create a new message.
 */
export declare const TriggerMetadataSchema: GenMessage<TriggerMetadata>;

/**
 * @generated from message bytebase.v1.ExternalTableMetadata
 */
export declare type ExternalTableMetadata = Message<"bytebase.v1.ExternalTableMetadata"> & {
  /**
   * The name is the name of a external table.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The external_server_name is the name of the external server.
   *
   * @generated from field: string external_server_name = 2;
   */
  externalServerName: string;

  /**
   * The external_database_name is the name of the external database.
   *
   * @generated from field: string external_database_name = 3;
   */
  externalDatabaseName: string;

  /**
   * The columns is the ordered list of columns in a foreign table.
   *
   * @generated from field: repeated bytebase.v1.ColumnMetadata columns = 4;
   */
  columns: ColumnMetadata[];
};

/**
 * Describes the message bytebase.v1.ExternalTableMetadata.
 * Use `create(ExternalTableMetadataSchema)` to create a new message.
 */
export declare const ExternalTableMetadataSchema: GenMessage<ExternalTableMetadata>;

/**
 * TableMetadata is the metadata for tables.
 *
 * @generated from message bytebase.v1.TableMetadata
 */
export declare type TableMetadata = Message<"bytebase.v1.TableMetadata"> & {
  /**
   * The name is the name of a table.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The columns is the ordered list of columns in a table.
   *
   * @generated from field: repeated bytebase.v1.ColumnMetadata columns = 2;
   */
  columns: ColumnMetadata[];

  /**
   * The indexes is the list of indexes in a table.
   *
   * @generated from field: repeated bytebase.v1.IndexMetadata indexes = 3;
   */
  indexes: IndexMetadata[];

  /**
   * The engine is the engine of a table.
   *
   * @generated from field: string engine = 4;
   */
  engine: string;

  /**
   * The collation is the collation of a table.
   *
   * @generated from field: string collation = 5;
   */
  collation: string;

  /**
   * The character set of table.
   *
   * @generated from field: string charset = 6;
   */
  charset: string;

  /**
   * The row_count is the estimated number of rows of a table.
   *
   * @generated from field: int64 row_count = 7;
   */
  rowCount: bigint;

  /**
   * The data_size is the estimated data size of a table.
   *
   * @generated from field: int64 data_size = 8;
   */
  dataSize: bigint;

  /**
   * The index_size is the estimated index size of a table.
   *
   * @generated from field: int64 index_size = 9;
   */
  indexSize: bigint;

  /**
   * The data_free is the estimated free data size of a table.
   *
   * @generated from field: int64 data_free = 10;
   */
  dataFree: bigint;

  /**
   * The create_options is the create option of a table.
   *
   * @generated from field: string create_options = 11;
   */
  createOptions: string;

  /**
   * The comment is the comment of a table.
   *
   * @generated from field: string comment = 12;
   */
  comment: string;

  /**
   * The foreign_keys is the list of foreign keys in a table.
   *
   * @generated from field: repeated bytebase.v1.ForeignKeyMetadata foreign_keys = 13;
   */
  foreignKeys: ForeignKeyMetadata[];

  /**
   * The partitions is the list of partitions in a table.
   *
   * @generated from field: repeated bytebase.v1.TablePartitionMetadata partitions = 14;
   */
  partitions: TablePartitionMetadata[];

  /**
   * The check_constraints is the list of check constraints in a table.
   *
   * @generated from field: repeated bytebase.v1.CheckConstraintMetadata check_constraints = 15;
   */
  checkConstraints: CheckConstraintMetadata[];

  /**
   * The owner of the table.
   *
   * @generated from field: string owner = 16;
   */
  owner: string;

  /**
   * The sorting_keys is a tuple of column names or arbitrary expressions. ClickHouse specific field.
   * Reference: https://clickhouse.com/docs/en/engines/table-engines/mergetree-family/mergetree#order_by
   *
   * @generated from field: repeated string sorting_keys = 17;
   */
  sortingKeys: string[];

  /**
   * The triggers is the list of triggers associated with the table.
   *
   * @generated from field: repeated bytebase.v1.TriggerMetadata triggers = 18;
   */
  triggers: TriggerMetadata[];

  /**
   * Whether to skip this table during schema dump operations.
   *
   * @generated from field: bool skip_dump = 19;
   */
  skipDump: boolean;

  /**
   * https://docs.pingcap.com/tidb/stable/information-schema-tables/
   *
   * @generated from field: string sharding_info = 20;
   */
  shardingInfo: string;

  /**
   * https://docs.pingcap.com/tidb/stable/clustered-indexes/#clustered-indexes
   * CLUSTERED or NONCLUSTERED.
   *
   * @generated from field: string primary_key_type = 21;
   */
  primaryKeyType: string;
};

/**
 * Describes the message bytebase.v1.TableMetadata.
 * Use `create(TableMetadataSchema)` to create a new message.
 */
export declare const TableMetadataSchema: GenMessage<TableMetadata>;

/**
 * CheckConstraintMetadata is the metadata for check constraints.
 *
 * @generated from message bytebase.v1.CheckConstraintMetadata
 */
export declare type CheckConstraintMetadata = Message<"bytebase.v1.CheckConstraintMetadata"> & {
  /**
   * The name is the name of a check constraint.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The expression is the expression of a check constraint.
   *
   * @generated from field: string expression = 2;
   */
  expression: string;
};

/**
 * Describes the message bytebase.v1.CheckConstraintMetadata.
 * Use `create(CheckConstraintMetadataSchema)` to create a new message.
 */
export declare const CheckConstraintMetadataSchema: GenMessage<CheckConstraintMetadata>;

/**
 * TablePartitionMetadata is the metadata for table partitions.
 *
 * @generated from message bytebase.v1.TablePartitionMetadata
 */
export declare type TablePartitionMetadata = Message<"bytebase.v1.TablePartitionMetadata"> & {
  /**
   * The name is the name of a table partition.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The type of a table partition.
   *
   * @generated from field: bytebase.v1.TablePartitionMetadata.Type type = 2;
   */
  type: TablePartitionMetadata_Type;

  /**
   * The expression is the expression of a table partition.
   * For PostgreSQL, the expression is the text of {FOR VALUES
   * partition_bound_spec}, see
   * https://www.postgresql.org/docs/current/sql-createtable.html. For MySQL,
   * the expression is the `expr` or `column_list` of the following syntax.
   * PARTITION BY
   *    { [LINEAR] HASH(expr)
   *    | [LINEAR] KEY [ALGORITHM={1 | 2}] (column_list)
   *    | RANGE{(expr) | COLUMNS(column_list)}
   *    | LIST{(expr) | COLUMNS(column_list)} }.
   *
   * @generated from field: string expression = 3;
   */
  expression: string;

  /**
   * The value is the value of a table partition.
   * For MySQL, the value is for RANGE and LIST partition types,
   * - For a RANGE partition, it contains the value set in the partition's
   * VALUES LESS THAN clause, which can be either an integer or MAXVALUE.
   * - For a LIST partition, this column contains the values defined in the
   * partition's VALUES IN clause, which is a list of comma-separated integer
   * values.
   * - For others, it's an empty string.
   *
   * @generated from field: string value = 4;
   */
  value: string;

  /**
   * The use_default is whether the users use the default partition, it stores
   * the different value for different database engines. For MySQL, it's [INT]
   * type, 0 means not use default partition, otherwise, it's equals to number
   * in syntax [SUB]PARTITION {number}.
   *
   * @generated from field: string use_default = 5;
   */
  useDefault: string;

  /**
   * The subpartitions is the list of subpartitions in a table partition.
   *
   * @generated from field: repeated bytebase.v1.TablePartitionMetadata subpartitions = 6;
   */
  subpartitions: TablePartitionMetadata[];

  /**
   * @generated from field: repeated bytebase.v1.IndexMetadata indexes = 7;
   */
  indexes: IndexMetadata[];

  /**
   * @generated from field: repeated bytebase.v1.CheckConstraintMetadata check_constraints = 8;
   */
  checkConstraints: CheckConstraintMetadata[];
};

/**
 * Describes the message bytebase.v1.TablePartitionMetadata.
 * Use `create(TablePartitionMetadataSchema)` to create a new message.
 */
export declare const TablePartitionMetadataSchema: GenMessage<TablePartitionMetadata>;

/**
 * Type is the type of a table partition, some database engines may not
 * support all types. Only avilable for the following database engines now:
 * MySQL: RANGE, RANGE COLUMNS, LIST, LIST COLUMNS, HASH, LINEAR HASH, KEY,
 * LINEAR_KEY
 * (https://dev.mysql.com/doc/refman/8.0/en/partitioning-types.html) TiDB:
 * RANGE, RANGE COLUMNS, LIST, LIST COLUMNS, HASH, KEY PostgreSQL: RANGE,
 * LIST, HASH (https://www.postgresql.org/docs/current/ddl-partitioning.html)
 *
 * @generated from enum bytebase.v1.TablePartitionMetadata.Type
 */
export enum TablePartitionMetadata_Type {
  /**
   * @generated from enum value: TYPE_UNSPECIFIED = 0;
   */
  TYPE_UNSPECIFIED = 0,

  /**
   * @generated from enum value: RANGE = 1;
   */
  RANGE = 1,

  /**
   * @generated from enum value: RANGE_COLUMNS = 2;
   */
  RANGE_COLUMNS = 2,

  /**
   * @generated from enum value: LIST = 3;
   */
  LIST = 3,

  /**
   * @generated from enum value: LIST_COLUMNS = 4;
   */
  LIST_COLUMNS = 4,

  /**
   * @generated from enum value: HASH = 5;
   */
  HASH = 5,

  /**
   * @generated from enum value: LINEAR_HASH = 6;
   */
  LINEAR_HASH = 6,

  /**
   * @generated from enum value: KEY = 7;
   */
  KEY = 7,

  /**
   * @generated from enum value: LINEAR_KEY = 8;
   */
  LINEAR_KEY = 8,
}

/**
 * Describes the enum bytebase.v1.TablePartitionMetadata.Type.
 */
export declare const TablePartitionMetadata_TypeSchema: GenEnum<TablePartitionMetadata_Type>;

/**
 * ColumnMetadata is the metadata for columns.
 *
 * @generated from message bytebase.v1.ColumnMetadata
 */
export declare type ColumnMetadata = Message<"bytebase.v1.ColumnMetadata"> & {
  /**
   * The name is the name of a column.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The position is the position in columns.
   *
   * @generated from field: int32 position = 2;
   */
  position: number;

  /**
   * @generated from field: bool has_default = 3;
   */
  hasDefault: boolean;

  /**
   * The default value of column.
   *
   * @generated from field: string default = 4;
   */
  default: string;

  /**
   * Oracle specific metadata.
   * The default_on_null is the default on null of a column.
   *
   * @generated from field: bool default_on_null = 5;
   */
  defaultOnNull: boolean;

  /**
   * The on_update is the on update action of a column.
   * For MySQL like databases, it's only supported for TIMESTAMP columns with
   * CURRENT_TIMESTAMP as on update value.
   *
   * @generated from field: string on_update = 6;
   */
  onUpdate: string;

  /**
   * The nullable is the nullable of a column.
   *
   * @generated from field: bool nullable = 7;
   */
  nullable: boolean;

  /**
   * The type is the type of a column.
   *
   * @generated from field: string type = 8;
   */
  type: string;

  /**
   * The character_set is the character_set of a column.
   *
   * @generated from field: string character_set = 9;
   */
  characterSet: string;

  /**
   * The collation is the collation of a column.
   *
   * @generated from field: string collation = 10;
   */
  collation: string;

  /**
   * The comment is the comment of a column.
   *
   * @generated from field: string comment = 11;
   */
  comment: string;

  /**
   * The generation is the generation of a column.
   *
   * @generated from field: bytebase.v1.GenerationMetadata generation = 12;
   */
  generation?: GenerationMetadata;

  /**
   * @generated from field: bool is_identity = 13;
   */
  isIdentity: boolean;

  /**
   * The identity_generation is for identity columns, PG only.
   *
   * @generated from field: bytebase.v1.ColumnMetadata.IdentityGeneration identity_generation = 14;
   */
  identityGeneration: ColumnMetadata_IdentityGeneration;

  /**
   * The identity_seed is for identity columns, MSSQL only.
   *
   * @generated from field: int64 identity_seed = 15;
   */
  identitySeed: bigint;

  /**
   * The identity_increment is for identity columns, MSSQL only.
   *
   * @generated from field: int64 identity_increment = 16;
   */
  identityIncrement: bigint;

  /**
   * The default_constraint_name is the name of the default constraint, MSSQL only.
   * In MSSQL, default values are implemented as named constraints. When modifying or
   * dropping a column's default value, you must reference the constraint by name.
   * This field stores the actual constraint name from the database.
   *
   * Example: A column definition like:
   *   CREATE TABLE employees (
   *     status NVARCHAR(20) DEFAULT 'active'
   *   )
   *
   * Will create a constraint with an auto-generated name like 'DF__employees__statu__3B75D760'
   * or a user-defined name if specified:
   *   ALTER TABLE employees ADD CONSTRAINT DF_employees_status DEFAULT 'active' FOR status
   *
   * To modify the default, you must first drop the existing constraint by name:
   *   ALTER TABLE employees DROP CONSTRAINT DF__employees__statu__3B75D760
   *   ALTER TABLE employees ADD CONSTRAINT DF_employees_status DEFAULT 'inactive' FOR status
   *
   * This field is populated when syncing from the database. When empty (e.g., when parsing
   * from SQL files), the system cannot automatically drop the constraint.
   *
   * @generated from field: string default_constraint_name = 17;
   */
  defaultConstraintName: string;
};

/**
 * Describes the message bytebase.v1.ColumnMetadata.
 * Use `create(ColumnMetadataSchema)` to create a new message.
 */
export declare const ColumnMetadataSchema: GenMessage<ColumnMetadata>;

/**
 * @generated from enum bytebase.v1.ColumnMetadata.IdentityGeneration
 */
export enum ColumnMetadata_IdentityGeneration {
  /**
   * @generated from enum value: IDENTITY_GENERATION_UNSPECIFIED = 0;
   */
  IDENTITY_GENERATION_UNSPECIFIED = 0,

  /**
   * @generated from enum value: ALWAYS = 1;
   */
  ALWAYS = 1,

  /**
   * @generated from enum value: BY_DEFAULT = 2;
   */
  BY_DEFAULT = 2,
}

/**
 * Describes the enum bytebase.v1.ColumnMetadata.IdentityGeneration.
 */
export declare const ColumnMetadata_IdentityGenerationSchema: GenEnum<ColumnMetadata_IdentityGeneration>;

/**
 * @generated from message bytebase.v1.GenerationMetadata
 */
export declare type GenerationMetadata = Message<"bytebase.v1.GenerationMetadata"> & {
  /**
   * @generated from field: bytebase.v1.GenerationMetadata.Type type = 1;
   */
  type: GenerationMetadata_Type;

  /**
   * @generated from field: string expression = 2;
   */
  expression: string;
};

/**
 * Describes the message bytebase.v1.GenerationMetadata.
 * Use `create(GenerationMetadataSchema)` to create a new message.
 */
export declare const GenerationMetadataSchema: GenMessage<GenerationMetadata>;

/**
 * @generated from enum bytebase.v1.GenerationMetadata.Type
 */
export enum GenerationMetadata_Type {
  /**
   * @generated from enum value: TYPE_UNSPECIFIED = 0;
   */
  TYPE_UNSPECIFIED = 0,

  /**
   * @generated from enum value: VIRTUAL = 1;
   */
  VIRTUAL = 1,

  /**
   * @generated from enum value: STORED = 2;
   */
  STORED = 2,
}

/**
 * Describes the enum bytebase.v1.GenerationMetadata.Type.
 */
export declare const GenerationMetadata_TypeSchema: GenEnum<GenerationMetadata_Type>;

/**
 * ViewMetadata is the metadata for views.
 *
 * @generated from message bytebase.v1.ViewMetadata
 */
export declare type ViewMetadata = Message<"bytebase.v1.ViewMetadata"> & {
  /**
   * The name is the name of a view.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The definition is the definition of a view.
   *
   * @generated from field: string definition = 2;
   */
  definition: string;

  /**
   * The comment is the comment of a view.
   *
   * @generated from field: string comment = 3;
   */
  comment: string;

  /**
   * The dependency_columns is the list of dependency columns of a view.
   *
   * @generated from field: repeated bytebase.v1.DependencyColumn dependency_columns = 4;
   */
  dependencyColumns: DependencyColumn[];

  /**
   * The columns is the ordered list of columns in a table.
   *
   * @generated from field: repeated bytebase.v1.ColumnMetadata columns = 5;
   */
  columns: ColumnMetadata[];

  /**
   * The triggers is the list of triggers in a view.
   *
   * @generated from field: repeated bytebase.v1.TriggerMetadata triggers = 6;
   */
  triggers: TriggerMetadata[];

  /**
   * @generated from field: bool skip_dump = 7;
   */
  skipDump: boolean;
};

/**
 * Describes the message bytebase.v1.ViewMetadata.
 * Use `create(ViewMetadataSchema)` to create a new message.
 */
export declare const ViewMetadataSchema: GenMessage<ViewMetadata>;

/**
 * DependencyColumn is the metadata for dependency columns.
 *
 * @generated from message bytebase.v1.DependencyColumn
 */
export declare type DependencyColumn = Message<"bytebase.v1.DependencyColumn"> & {
  /**
   * The schema is the schema of a reference column.
   *
   * @generated from field: string schema = 1;
   */
  schema: string;

  /**
   * The table is the table of a reference column.
   *
   * @generated from field: string table = 2;
   */
  table: string;

  /**
   * The column is the name of a reference column.
   *
   * @generated from field: string column = 3;
   */
  column: string;
};

/**
 * Describes the message bytebase.v1.DependencyColumn.
 * Use `create(DependencyColumnSchema)` to create a new message.
 */
export declare const DependencyColumnSchema: GenMessage<DependencyColumn>;

/**
 * MaterializedViewMetadata is the metadata for materialized views.
 *
 * @generated from message bytebase.v1.MaterializedViewMetadata
 */
export declare type MaterializedViewMetadata = Message<"bytebase.v1.MaterializedViewMetadata"> & {
  /**
   * The name is the name of a materialized view.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The definition is the definition of a materialized view.
   *
   * @generated from field: string definition = 2;
   */
  definition: string;

  /**
   * The comment is the comment of a materialized view.
   *
   * @generated from field: string comment = 3;
   */
  comment: string;

  /**
   * The dependency_columns is the list of dependency columns of a materialized
   * view.
   *
   * @generated from field: repeated bytebase.v1.DependencyColumn dependency_columns = 4;
   */
  dependencyColumns: DependencyColumn[];

  /**
   * The columns is the ordered list of columns in a table.
   *
   * @generated from field: repeated bytebase.v1.TriggerMetadata triggers = 5;
   */
  triggers: TriggerMetadata[];

  /**
   * The indexes is the list of indexes in a table.
   *
   * @generated from field: repeated bytebase.v1.IndexMetadata indexes = 6;
   */
  indexes: IndexMetadata[];

  /**
   * @generated from field: bool skip_dump = 7;
   */
  skipDump: boolean;
};

/**
 * Describes the message bytebase.v1.MaterializedViewMetadata.
 * Use `create(MaterializedViewMetadataSchema)` to create a new message.
 */
export declare const MaterializedViewMetadataSchema: GenMessage<MaterializedViewMetadata>;

/**
 * @generated from message bytebase.v1.DependencyTable
 */
export declare type DependencyTable = Message<"bytebase.v1.DependencyTable"> & {
  /**
   * The schema is the schema of a reference table.
   *
   * @generated from field: string schema = 1;
   */
  schema: string;

  /**
   * The table is the name of a reference table.
   *
   * @generated from field: string table = 2;
   */
  table: string;
};

/**
 * Describes the message bytebase.v1.DependencyTable.
 * Use `create(DependencyTableSchema)` to create a new message.
 */
export declare const DependencyTableSchema: GenMessage<DependencyTable>;

/**
 * FunctionMetadata is the metadata for functions.
 *
 * @generated from message bytebase.v1.FunctionMetadata
 */
export declare type FunctionMetadata = Message<"bytebase.v1.FunctionMetadata"> & {
  /**
   * The name is the name of a function.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The definition is the definition of a function.
   *
   * @generated from field: string definition = 2;
   */
  definition: string;

  /**
   * The signature is the name with the number and type of input arguments the
   * function takes.
   *
   * @generated from field: string signature = 3;
   */
  signature: string;

  /**
   * MySQL specific metadata.
   *
   * @generated from field: string character_set_client = 4;
   */
  characterSetClient: string;

  /**
   * @generated from field: string collation_connection = 5;
   */
  collationConnection: string;

  /**
   * @generated from field: string database_collation = 6;
   */
  databaseCollation: string;

  /**
   * @generated from field: string sql_mode = 7;
   */
  sqlMode: string;

  /**
   * @generated from field: string comment = 8;
   */
  comment: string;

  /**
   * The dependency_tables is the list of dependency tables of a function.
   * For PostgreSQL, it's the list of tables that the function depends on the return type definition.
   *
   * @generated from field: repeated bytebase.v1.DependencyTable dependency_tables = 9;
   */
  dependencyTables: DependencyTable[];

  /**
   * @generated from field: bool skip_dump = 10;
   */
  skipDump: boolean;
};

/**
 * Describes the message bytebase.v1.FunctionMetadata.
 * Use `create(FunctionMetadataSchema)` to create a new message.
 */
export declare const FunctionMetadataSchema: GenMessage<FunctionMetadata>;

/**
 * ProcedureMetadata is the metadata for procedures.
 *
 * @generated from message bytebase.v1.ProcedureMetadata
 */
export declare type ProcedureMetadata = Message<"bytebase.v1.ProcedureMetadata"> & {
  /**
   * The name is the name of a procedure.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The definition is the definition of a procedure.
   *
   * @generated from field: string definition = 2;
   */
  definition: string;

  /**
   * The signature is the name with the number and type of input arguments the
   * procedure takes.
   *
   * @generated from field: string signature = 3;
   */
  signature: string;

  /**
   * MySQL specific metadata.
   *
   * @generated from field: string character_set_client = 4;
   */
  characterSetClient: string;

  /**
   * @generated from field: string collation_connection = 5;
   */
  collationConnection: string;

  /**
   * @generated from field: string database_collation = 6;
   */
  databaseCollation: string;

  /**
   * @generated from field: string sql_mode = 7;
   */
  sqlMode: string;

  /**
   * The comment is the comment of a procedure.
   *
   * @generated from field: string comment = 9;
   */
  comment: string;

  /**
   * @generated from field: bool skip_dump = 8;
   */
  skipDump: boolean;
};

/**
 * Describes the message bytebase.v1.ProcedureMetadata.
 * Use `create(ProcedureMetadataSchema)` to create a new message.
 */
export declare const ProcedureMetadataSchema: GenMessage<ProcedureMetadata>;

/**
 * PackageMetadata is the metadata for packages.
 *
 * @generated from message bytebase.v1.PackageMetadata
 */
export declare type PackageMetadata = Message<"bytebase.v1.PackageMetadata"> & {
  /**
   * The name is the name of a package.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The definition is the definition of a package.
   *
   * @generated from field: string definition = 2;
   */
  definition: string;
};

/**
 * Describes the message bytebase.v1.PackageMetadata.
 * Use `create(PackageMetadataSchema)` to create a new message.
 */
export declare const PackageMetadataSchema: GenMessage<PackageMetadata>;

/**
 * @generated from message bytebase.v1.TaskMetadata
 */
export declare type TaskMetadata = Message<"bytebase.v1.TaskMetadata"> & {
  /**
   * The name is the name of a task.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The id is the snowflake-generated id of a task.
   * Example: 01ad32a0-1bb6-5e93-0000-000000000001
   *
   * @generated from field: string id = 2;
   */
  id: string;

  /**
   * The owner of the task.
   *
   * @generated from field: string owner = 3;
   */
  owner: string;

  /**
   * The comment of the task.
   *
   * @generated from field: string comment = 4;
   */
  comment: string;

  /**
   * The warehouse of the task.
   *
   * @generated from field: string warehouse = 5;
   */
  warehouse: string;

  /**
   * The schedule interval of the task.
   *
   * @generated from field: string schedule = 6;
   */
  schedule: string;

  /**
   * The predecessor tasks of the task.
   *
   * @generated from field: repeated string predecessors = 7;
   */
  predecessors: string[];

  /**
   * The state of the task.
   *
   * @generated from field: bytebase.v1.TaskMetadata.State state = 8;
   */
  state: TaskMetadata_State;

  /**
   * The condition of the task.
   *
   * @generated from field: string condition = 9;
   */
  condition: string;

  /**
   * The definition of the task.
   *
   * @generated from field: string definition = 10;
   */
  definition: string;
};

/**
 * Describes the message bytebase.v1.TaskMetadata.
 * Use `create(TaskMetadataSchema)` to create a new message.
 */
export declare const TaskMetadataSchema: GenMessage<TaskMetadata>;

/**
 * @generated from enum bytebase.v1.TaskMetadata.State
 */
export enum TaskMetadata_State {
  /**
   * @generated from enum value: STATE_UNSPECIFIED = 0;
   */
  STATE_UNSPECIFIED = 0,

  /**
   * @generated from enum value: STARTED = 1;
   */
  STARTED = 1,

  /**
   * @generated from enum value: SUSPENDED = 2;
   */
  SUSPENDED = 2,
}

/**
 * Describes the enum bytebase.v1.TaskMetadata.State.
 */
export declare const TaskMetadata_StateSchema: GenEnum<TaskMetadata_State>;

/**
 * @generated from message bytebase.v1.StreamMetadata
 */
export declare type StreamMetadata = Message<"bytebase.v1.StreamMetadata"> & {
  /**
   * The name is the name of a stream.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The table_name is the name of the table/view that the stream is created on.
   *
   * @generated from field: string table_name = 2;
   */
  tableName: string;

  /**
   * The owner of the stream.
   *
   * @generated from field: string owner = 3;
   */
  owner: string;

  /**
   * The comment of the stream.
   *
   * @generated from field: string comment = 4;
   */
  comment: string;

  /**
   * The type of the stream.
   *
   * @generated from field: bytebase.v1.StreamMetadata.Type type = 5;
   */
  type: StreamMetadata_Type;

  /**
   * Indicates whether the stream was last read before the `stale_after` time.
   *
   * @generated from field: bool stale = 6;
   */
  stale: boolean;

  /**
   * The mode of the stream.
   *
   * @generated from field: bytebase.v1.StreamMetadata.Mode mode = 7;
   */
  mode: StreamMetadata_Mode;

  /**
   * The definition of the stream.
   *
   * @generated from field: string definition = 8;
   */
  definition: string;
};

/**
 * Describes the message bytebase.v1.StreamMetadata.
 * Use `create(StreamMetadataSchema)` to create a new message.
 */
export declare const StreamMetadataSchema: GenMessage<StreamMetadata>;

/**
 * @generated from enum bytebase.v1.StreamMetadata.Type
 */
export enum StreamMetadata_Type {
  /**
   * @generated from enum value: TYPE_UNSPECIFIED = 0;
   */
  TYPE_UNSPECIFIED = 0,

  /**
   * @generated from enum value: DELTA = 1;
   */
  DELTA = 1,
}

/**
 * Describes the enum bytebase.v1.StreamMetadata.Type.
 */
export declare const StreamMetadata_TypeSchema: GenEnum<StreamMetadata_Type>;

/**
 * @generated from enum bytebase.v1.StreamMetadata.Mode
 */
export enum StreamMetadata_Mode {
  /**
   * @generated from enum value: MODE_UNSPECIFIED = 0;
   */
  MODE_UNSPECIFIED = 0,

  /**
   * @generated from enum value: DEFAULT = 1;
   */
  DEFAULT = 1,

  /**
   * @generated from enum value: APPEND_ONLY = 2;
   */
  APPEND_ONLY = 2,

  /**
   * @generated from enum value: INSERT_ONLY = 3;
   */
  INSERT_ONLY = 3,
}

/**
 * Describes the enum bytebase.v1.StreamMetadata.Mode.
 */
export declare const StreamMetadata_ModeSchema: GenEnum<StreamMetadata_Mode>;

/**
 * SpatialIndexConfig defines the spatial index configuration for spatial databases.
 *
 * @generated from message bytebase.v1.SpatialIndexConfig
 */
export declare type SpatialIndexConfig = Message<"bytebase.v1.SpatialIndexConfig"> & {
  /**
   * Spatial indexing method (e.g., "SPATIAL", "R-TREE", "GIST")
   *
   * @generated from field: string method = 1;
   */
  method: string;

  /**
   * Tessellation configuration for grid-based spatial indexes
   *
   * @generated from field: bytebase.v1.TessellationConfig tessellation = 2;
   */
  tessellation?: TessellationConfig;

  /**
   * Storage and performance configuration
   *
   * @generated from field: bytebase.v1.StorageConfig storage = 3;
   */
  storage?: StorageConfig;

  /**
   * Dimensional configuration
   *
   * @generated from field: bytebase.v1.DimensionalConfig dimensional = 4;
   */
  dimensional?: DimensionalConfig;
};

/**
 * Describes the message bytebase.v1.SpatialIndexConfig.
 * Use `create(SpatialIndexConfigSchema)` to create a new message.
 */
export declare const SpatialIndexConfigSchema: GenMessage<SpatialIndexConfig>;

/**
 * TessellationConfig defines tessellation parameters for spatial indexes.
 *
 * @generated from message bytebase.v1.TessellationConfig
 */
export declare type TessellationConfig = Message<"bytebase.v1.TessellationConfig"> & {
  /**
   * Tessellation scheme (e.g., "GEOMETRY_GRID", "GEOGRAPHY_GRID", "GEOMETRY_AUTO_GRID")
   *
   * @generated from field: string scheme = 1;
   */
  scheme: string;

  /**
   * Grid levels and densities for multi-level tessellation
   *
   * @generated from field: repeated bytebase.v1.GridLevel grid_levels = 2;
   */
  gridLevels: GridLevel[];

  /**
   * Number of cells per object (1-8192 for SQL Server)
   *
   * @generated from field: int32 cells_per_object = 3;
   */
  cellsPerObject: number;

  /**
   * Bounding box for GEOMETRY tessellation (not used for GEOGRAPHY)
   *
   * @generated from field: bytebase.v1.BoundingBox bounding_box = 4;
   */
  boundingBox?: BoundingBox;
};

/**
 * Describes the message bytebase.v1.TessellationConfig.
 * Use `create(TessellationConfigSchema)` to create a new message.
 */
export declare const TessellationConfigSchema: GenMessage<TessellationConfig>;

/**
 * GridLevel defines a tessellation grid level with its density.
 *
 * @generated from message bytebase.v1.GridLevel
 */
export declare type GridLevel = Message<"bytebase.v1.GridLevel"> & {
  /**
   * Grid level number (1-4 for SQL Server)
   *
   * @generated from field: int32 level = 1;
   */
  level: number;

  /**
   * Grid density (LOW, MEDIUM, HIGH)
   *
   * @generated from field: string density = 2;
   */
  density: string;
};

/**
 * Describes the message bytebase.v1.GridLevel.
 * Use `create(GridLevelSchema)` to create a new message.
 */
export declare const GridLevelSchema: GenMessage<GridLevel>;

/**
 * BoundingBox defines the spatial bounds for GEOMETRY spatial indexes.
 *
 * @generated from message bytebase.v1.BoundingBox
 */
export declare type BoundingBox = Message<"bytebase.v1.BoundingBox"> & {
  /**
   * Minimum X coordinate
   *
   * @generated from field: double xmin = 1;
   */
  xmin: number;

  /**
   * Minimum Y coordinate
   *
   * @generated from field: double ymin = 2;
   */
  ymin: number;

  /**
   * Maximum X coordinate
   *
   * @generated from field: double xmax = 3;
   */
  xmax: number;

  /**
   * Maximum Y coordinate
   *
   * @generated from field: double ymax = 4;
   */
  ymax: number;
};

/**
 * Describes the message bytebase.v1.BoundingBox.
 * Use `create(BoundingBoxSchema)` to create a new message.
 */
export declare const BoundingBoxSchema: GenMessage<BoundingBox>;

/**
 * StorageConfig defines storage and performance parameters for spatial indexes.
 *
 * @generated from message bytebase.v1.StorageConfig
 */
export declare type StorageConfig = Message<"bytebase.v1.StorageConfig"> & {
  /**
   * Fill factor percentage (1-100)
   *
   * @generated from field: int32 fillfactor = 1;
   */
  fillfactor: number;

  /**
   * Buffering mode for PostgreSQL (auto, on, off)
   *
   * @generated from field: string buffering = 2;
   */
  buffering: string;

  /**
   * Tablespace configuration for Oracle
   *
   * @generated from field: string tablespace = 3;
   */
  tablespace: string;

  /**
   * @generated from field: string work_tablespace = 4;
   */
  workTablespace: string;

  /**
   * @generated from field: int32 sdo_level = 5;
   */
  sdoLevel: number;

  /**
   * @generated from field: int32 commit_interval = 6;
   */
  commitInterval: number;

  /**
   * SQL Server specific parameters
   *
   * @generated from field: bool pad_index = 7;
   */
  padIndex: boolean;

  /**
   * ON, OFF
   *
   * @generated from field: string sort_in_tempdb = 8;
   */
  sortInTempdb: string;

  /**
   * @generated from field: bool drop_existing = 9;
   */
  dropExisting: boolean;

  /**
   * @generated from field: bool online = 10;
   */
  online: boolean;

  /**
   * @generated from field: bool allow_row_locks = 11;
   */
  allowRowLocks: boolean;

  /**
   * @generated from field: bool allow_page_locks = 12;
   */
  allowPageLocks: boolean;

  /**
   * @generated from field: int32 maxdop = 13;
   */
  maxdop: number;

  /**
   * NONE, ROW, PAGE
   *
   * @generated from field: string data_compression = 14;
   */
  dataCompression: string;
};

/**
 * Describes the message bytebase.v1.StorageConfig.
 * Use `create(StorageConfigSchema)` to create a new message.
 */
export declare const StorageConfigSchema: GenMessage<StorageConfig>;

/**
 * DimensionalConfig defines dimensional and constraint parameters for spatial indexes.
 *
 * @generated from message bytebase.v1.DimensionalConfig
 */
export declare type DimensionalConfig = Message<"bytebase.v1.DimensionalConfig"> & {
  /**
   * Number of dimensions (2-4, default 2)
   *
   * @generated from field: int32 dimensions = 1;
   */
  dimensions: number;

  /**
   * Spatial data type (GEOMETRY, GEOGRAPHY, POINT, POLYGON, etc.)
   *
   * @generated from field: string data_type = 2;
   */
  dataType: string;

  /**
   * Spatial reference system identifier (SRID)
   *
   * @generated from field: int32 srid = 3;
   */
  srid: number;

  /**
   * Coordinate system constraints
   *
   * @generated from field: repeated bytebase.v1.DimensionConstraint constraints = 4;
   */
  constraints: DimensionConstraint[];
};

/**
 * Describes the message bytebase.v1.DimensionalConfig.
 * Use `create(DimensionalConfigSchema)` to create a new message.
 */
export declare const DimensionalConfigSchema: GenMessage<DimensionalConfig>;

/**
 * DimensionConstraint defines constraints for a spatial dimension.
 *
 * @generated from message bytebase.v1.DimensionConstraint
 */
export declare type DimensionConstraint = Message<"bytebase.v1.DimensionConstraint"> & {
  /**
   * Dimension name/type (X, Y, Z, M, etc.)
   *
   * @generated from field: string dimension = 1;
   */
  dimension: string;

  /**
   * Minimum value for this dimension
   *
   * @generated from field: double min_value = 2;
   */
  minValue: number;

  /**
   * Maximum value for this dimension
   *
   * @generated from field: double max_value = 3;
   */
  maxValue: number;

  /**
   * Tolerance for this dimension
   *
   * @generated from field: double tolerance = 4;
   */
  tolerance: number;
};

/**
 * Describes the message bytebase.v1.DimensionConstraint.
 * Use `create(DimensionConstraintSchema)` to create a new message.
 */
export declare const DimensionConstraintSchema: GenMessage<DimensionConstraint>;

/**
 * IndexMetadata is the metadata for indexes.
 *
 * @generated from message bytebase.v1.IndexMetadata
 */
export declare type IndexMetadata = Message<"bytebase.v1.IndexMetadata"> & {
  /**
   * The name is the name of an index.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The expressions are the ordered columns or expressions of an index.
   * This could refer to a column or an expression.
   *
   * @generated from field: repeated string expressions = 2;
   */
  expressions: string[];

  /**
   * The key_lengths are the ordered key lengths of an index.
   * If the key length is not specified, it's -1.
   *
   * @generated from field: repeated int64 key_length = 3;
   */
  keyLength: bigint[];

  /**
   * The descending is the ordered descending of an index.
   *
   * @generated from field: repeated bool descending = 4;
   */
  descending: boolean[];

  /**
   * The type is the type of an index.
   *
   * @generated from field: string type = 5;
   */
  type: string;

  /**
   * The unique is whether the index is unique.
   *
   * @generated from field: bool unique = 6;
   */
  unique: boolean;

  /**
   * The primary is whether the index is a primary key index.
   *
   * @generated from field: bool primary = 7;
   */
  primary: boolean;

  /**
   * The visible is whether the index is visible.
   *
   * @generated from field: bool visible = 8;
   */
  visible: boolean;

  /**
   * The comment is the comment of an index.
   *
   * @generated from field: string comment = 9;
   */
  comment: string;

  /**
   * The definition of an index.
   *
   * @generated from field: string definition = 10;
   */
  definition: string;

  /**
   * The schema name of the parent index.
   *
   * @generated from field: string parent_index_schema = 11;
   */
  parentIndexSchema: string;

  /**
   * The index name of the parent index.
   *
   * @generated from field: string parent_index_name = 12;
   */
  parentIndexName: string;

  /**
   * The number of granules in the block. It's a ClickHouse specific field.
   *
   * @generated from field: int64 granularity = 13;
   */
  granularity: bigint;

  /**
   * It's a PostgreSQL specific field.
   * The unique constraint and unique index are not the same thing in PostgreSQL.
   *
   * @generated from field: bool is_constraint = 14;
   */
  isConstraint: boolean;

  /**
   * Spatial index configuration for spatial databases like SQL Server, PostgreSQL with PostGIS, etc.
   *
   * @generated from field: bytebase.v1.SpatialIndexConfig spatial_config = 15;
   */
  spatialConfig?: SpatialIndexConfig;

  /**
   * https://www.postgresql.org/docs/current/catalog-pg-opclass.html
   * Name of the operator class for each column. (PostgreSQL specific).
   *
   * @generated from field: repeated string opclass_names = 16;
   */
  opclassNames: string[];

  /**
   * True if the operator class is the default. (PostgreSQL specific).
   *
   * @generated from field: repeated bool opclass_defaults = 17;
   */
  opclassDefaults: boolean[];
};

/**
 * Describes the message bytebase.v1.IndexMetadata.
 * Use `create(IndexMetadataSchema)` to create a new message.
 */
export declare const IndexMetadataSchema: GenMessage<IndexMetadata>;

/**
 * ExtensionMetadata is the metadata for extensions.
 *
 * @generated from message bytebase.v1.ExtensionMetadata
 */
export declare type ExtensionMetadata = Message<"bytebase.v1.ExtensionMetadata"> & {
  /**
   * The name is the name of an extension.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The schema is the extension that is installed to. But the extension usage
   * is not limited to the schema.
   *
   * @generated from field: string schema = 2;
   */
  schema: string;

  /**
   * The version is the version of an extension.
   *
   * @generated from field: string version = 3;
   */
  version: string;

  /**
   * The description is the description of an extension.
   *
   * @generated from field: string description = 4;
   */
  description: string;
};

/**
 * Describes the message bytebase.v1.ExtensionMetadata.
 * Use `create(ExtensionMetadataSchema)` to create a new message.
 */
export declare const ExtensionMetadataSchema: GenMessage<ExtensionMetadata>;

/**
 * ForeignKeyMetadata is the metadata for foreign keys.
 *
 * @generated from message bytebase.v1.ForeignKeyMetadata
 */
export declare type ForeignKeyMetadata = Message<"bytebase.v1.ForeignKeyMetadata"> & {
  /**
   * The name is the name of a foreign key.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The columns are the ordered referencing columns of a foreign key.
   *
   * @generated from field: repeated string columns = 2;
   */
  columns: string[];

  /**
   * The referenced_schema is the referenced schema name of a foreign key.
   * It is an empty string for databases without such concept such as MySQL.
   *
   * @generated from field: string referenced_schema = 3;
   */
  referencedSchema: string;

  /**
   * The referenced_table is the referenced table name of a foreign key.
   *
   * @generated from field: string referenced_table = 4;
   */
  referencedTable: string;

  /**
   * The referenced_columns are the ordered referenced columns of a foreign key.
   *
   * @generated from field: repeated string referenced_columns = 5;
   */
  referencedColumns: string[];

  /**
   * The on_delete is the on delete action of a foreign key.
   *
   * @generated from field: string on_delete = 6;
   */
  onDelete: string;

  /**
   * The on_update is the on update action of a foreign key.
   *
   * @generated from field: string on_update = 7;
   */
  onUpdate: string;

  /**
   * The match_type is the match type of a foreign key.
   * The match_type is the PostgreSQL specific field.
   * It's empty string for other databases.
   *
   * @generated from field: string match_type = 8;
   */
  matchType: string;
};

/**
 * Describes the message bytebase.v1.ForeignKeyMetadata.
 * Use `create(ForeignKeyMetadataSchema)` to create a new message.
 */
export declare const ForeignKeyMetadataSchema: GenMessage<ForeignKeyMetadata>;

/**
 * DatabaseSchema is the metadata for databases.
 *
 * @generated from message bytebase.v1.DatabaseSchema
 */
export declare type DatabaseSchema = Message<"bytebase.v1.DatabaseSchema"> & {
  /**
   * The schema dump from database.
   *
   * @generated from field: string schema = 1;
   */
  schema: string;
};

/**
 * Describes the message bytebase.v1.DatabaseSchema.
 * Use `create(DatabaseSchemaSchema)` to create a new message.
 */
export declare const DatabaseSchemaSchema: GenMessage<DatabaseSchema>;

/**
 * DatabaseSDLSchema contains the schema in SDL format.
 *
 * @generated from message bytebase.v1.DatabaseSDLSchema
 */
export declare type DatabaseSDLSchema = Message<"bytebase.v1.DatabaseSDLSchema"> & {
  /**
   * The SDL schema content.
   * - For SINGLE_FILE format: contains the complete SDL schema as a text string.
   * - For MULTI_FILE format: contains the ZIP archive as binary data.
   *
   * @generated from field: bytes schema = 1;
   */
  schema: Uint8Array;

  /**
   * The MIME type of the schema content.
   * Indicates how the client should interpret the schema field.
   * Examples:
   * - "text/plain; charset=utf-8" for SINGLE_FILE format
   * - "application/zip" for MULTI_FILE format
   *
   * @generated from field: string content_type = 2;
   */
  contentType: string;
};

/**
 * Describes the message bytebase.v1.DatabaseSDLSchema.
 * Use `create(DatabaseSDLSchemaSchema)` to create a new message.
 */
export declare const DatabaseSDLSchemaSchema: GenMessage<DatabaseSDLSchema>;

/**
 * @generated from message bytebase.v1.ListChangelogsRequest
 */
export declare type ListChangelogsRequest = Message<"bytebase.v1.ListChangelogsRequest"> & {
  /**
   * The parent of the changelogs.
   * Format: instances/{instance}/databases/{database}
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * The maximum number of changelogs to return. The service may return fewer
   * than this value. If unspecified, at most 10 changelogs will be returned.
   * The maximum value is 1000; values above 1000 will be coerced to 1000.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize: number;

  /**
   * A page token, received from the previous call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided must match
   * the call that provided the page token.
   *
   * @generated from field: string page_token = 3;
   */
  pageToken: string;

  /**
   * @generated from field: bytebase.v1.ChangelogView view = 4;
   */
  view: ChangelogView;

  /**
   * Filter is used to filter changelogs returned in the list.
   * The syntax and semantics of CEL are documented at https://github.com/google/cel-spec
   *
   * Supported filter:
   * status: the changelog status, support "==" operation. check Changelog.Status for available values.
   * type: the changelog type, support "in" and "==" operation. check Changelog.Type for available values.
   *
   * Example:
   * status == "DONE"
   * type in ["BASELINE", "MIGRATE"]
   * status == "FAILED" && type == "SDL"
   *
   * @generated from field: string filter = 5;
   */
  filter: string;
};

/**
 * Describes the message bytebase.v1.ListChangelogsRequest.
 * Use `create(ListChangelogsRequestSchema)` to create a new message.
 */
export declare const ListChangelogsRequestSchema: GenMessage<ListChangelogsRequest>;

/**
 * @generated from message bytebase.v1.ListChangelogsResponse
 */
export declare type ListChangelogsResponse = Message<"bytebase.v1.ListChangelogsResponse"> & {
  /**
   * The list of changelogs.
   *
   * @generated from field: repeated bytebase.v1.Changelog changelogs = 1;
   */
  changelogs: Changelog[];

  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message bytebase.v1.ListChangelogsResponse.
 * Use `create(ListChangelogsResponseSchema)` to create a new message.
 */
export declare const ListChangelogsResponseSchema: GenMessage<ListChangelogsResponse>;

/**
 * @generated from message bytebase.v1.GetChangelogRequest
 */
export declare type GetChangelogRequest = Message<"bytebase.v1.GetChangelogRequest"> & {
  /**
   * The name of the changelog to retrieve.
   * Format: instances/{instance}/databases/{database}/changelogs/{changelog}
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: bytebase.v1.ChangelogView view = 2;
   */
  view: ChangelogView;
};

/**
 * Describes the message bytebase.v1.GetChangelogRequest.
 * Use `create(GetChangelogRequestSchema)` to create a new message.
 */
export declare const GetChangelogRequestSchema: GenMessage<GetChangelogRequest>;

/**
 * @generated from message bytebase.v1.Changelog
 */
export declare type Changelog = Message<"bytebase.v1.Changelog"> & {
  /**
   * Format: instances/{instance}/databases/{database}/changelogs/{changelog}
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: google.protobuf.Timestamp create_time = 2;
   */
  createTime?: Timestamp;

  /**
   * @generated from field: bytebase.v1.Changelog.Status status = 3;
   */
  status: Changelog_Status;

  /**
   * @generated from field: string schema = 7;
   */
  schema: string;

  /**
   * @generated from field: int64 schema_size = 8;
   */
  schemaSize: bigint;

  /**
   * Format: projects/{project}/plans/{plan}/rollout/stages/{stage}/tasks/{task}/taskRuns/{taskRun}
   *
   * @generated from field: string task_run = 11;
   */
  taskRun: string;

  /**
   * The title of the plan associated with this changelog's task run.
   * This field is populated by deriving the plan from task_run for display purposes.
   *
   * @generated from field: string plan_title = 15;
   */
  planTitle: string;

  /**
   * @generated from field: bytebase.v1.Changelog.Type type = 14;
   */
  type: Changelog_Type;
};

/**
 * Describes the message bytebase.v1.Changelog.
 * Use `create(ChangelogSchema)` to create a new message.
 */
export declare const ChangelogSchema: GenMessage<Changelog>;

/**
 * @generated from enum bytebase.v1.Changelog.Status
 */
export enum Changelog_Status {
  /**
   * @generated from enum value: STATUS_UNSPECIFIED = 0;
   */
  STATUS_UNSPECIFIED = 0,

  /**
   * @generated from enum value: PENDING = 1;
   */
  PENDING = 1,

  /**
   * @generated from enum value: DONE = 2;
   */
  DONE = 2,

  /**
   * @generated from enum value: FAILED = 3;
   */
  FAILED = 3,
}

/**
 * Describes the enum bytebase.v1.Changelog.Status.
 */
export declare const Changelog_StatusSchema: GenEnum<Changelog_Status>;

/**
 * @generated from enum bytebase.v1.Changelog.Type
 */
export enum Changelog_Type {
  /**
   * @generated from enum value: TYPE_UNSPECIFIED = 0;
   */
  TYPE_UNSPECIFIED = 0,

  /**
   * @generated from enum value: BASELINE = 1;
   */
  BASELINE = 1,

  /**
   * @generated from enum value: MIGRATE = 2;
   */
  MIGRATE = 2,

  /**
   * @generated from enum value: SDL = 3;
   */
  SDL = 3,
}

/**
 * Describes the enum bytebase.v1.Changelog.Type.
 */
export declare const Changelog_TypeSchema: GenEnum<Changelog_Type>;

/**
 * @generated from message bytebase.v1.GetSchemaStringRequest
 */
export declare type GetSchemaStringRequest = Message<"bytebase.v1.GetSchemaStringRequest"> & {
  /**
   * The name of the database.
   * Format: instances/{instance}/databases/{database}
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: bytebase.v1.GetSchemaStringRequest.ObjectType type = 2;
   */
  type: GetSchemaStringRequest_ObjectType;

  /**
   * It's empty for DATABASE.
   *
   * @generated from field: string schema = 3;
   */
  schema: string;

  /**
   * It's empty for DATABASE and SCHEMA.
   *
   * @generated from field: string object = 4;
   */
  object: string;

  /**
   * If use the metadata to generate the schema string, the type is OBJECT_TYPE_UNSPECIFIED.
   * Also the schema and object are empty.
   *
   * @generated from field: bytebase.v1.DatabaseMetadata metadata = 5;
   */
  metadata?: DatabaseMetadata;
};

/**
 * Describes the message bytebase.v1.GetSchemaStringRequest.
 * Use `create(GetSchemaStringRequestSchema)` to create a new message.
 */
export declare const GetSchemaStringRequestSchema: GenMessage<GetSchemaStringRequest>;

/**
 * @generated from enum bytebase.v1.GetSchemaStringRequest.ObjectType
 */
export enum GetSchemaStringRequest_ObjectType {
  /**
   * @generated from enum value: OBJECT_TYPE_UNSPECIFIED = 0;
   */
  OBJECT_TYPE_UNSPECIFIED = 0,

  /**
   * @generated from enum value: DATABASE = 1;
   */
  DATABASE = 1,

  /**
   * @generated from enum value: SCHEMA = 2;
   */
  SCHEMA = 2,

  /**
   * @generated from enum value: TABLE = 3;
   */
  TABLE = 3,

  /**
   * @generated from enum value: VIEW = 4;
   */
  VIEW = 4,

  /**
   * @generated from enum value: MATERIALIZED_VIEW = 5;
   */
  MATERIALIZED_VIEW = 5,

  /**
   * @generated from enum value: FUNCTION = 6;
   */
  FUNCTION = 6,

  /**
   * @generated from enum value: PROCEDURE = 7;
   */
  PROCEDURE = 7,

  /**
   * @generated from enum value: SEQUENCE = 8;
   */
  SEQUENCE = 8,
}

/**
 * Describes the enum bytebase.v1.GetSchemaStringRequest.ObjectType.
 */
export declare const GetSchemaStringRequest_ObjectTypeSchema: GenEnum<GetSchemaStringRequest_ObjectType>;

/**
 * @generated from message bytebase.v1.GetSchemaStringResponse
 */
export declare type GetSchemaStringResponse = Message<"bytebase.v1.GetSchemaStringResponse"> & {
  /**
   * @generated from field: string schema_string = 1;
   */
  schemaString: string;
};

/**
 * Describes the message bytebase.v1.GetSchemaStringResponse.
 * Use `create(GetSchemaStringResponseSchema)` to create a new message.
 */
export declare const GetSchemaStringResponseSchema: GenMessage<GetSchemaStringResponse>;

/**
 * @generated from enum bytebase.v1.ChangelogView
 */
export enum ChangelogView {
  /**
   * The default / unset value.
   * The API will default to the BASIC view.
   *
   * @generated from enum value: CHANGELOG_VIEW_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: CHANGELOG_VIEW_BASIC = 1;
   */
  BASIC = 1,

  /**
   * @generated from enum value: CHANGELOG_VIEW_FULL = 2;
   */
  FULL = 2,
}

/**
 * Describes the enum bytebase.v1.ChangelogView.
 */
export declare const ChangelogViewSchema: GenEnum<ChangelogView>;

/**
 * DatabaseService manages databases and their schemas.
 *
 * @generated from service bytebase.v1.DatabaseService
 */
export declare const DatabaseService: GenService<{
  /**
   * Retrieves a database by name.
   * Permissions required: bb.databases.get
   *
   * @generated from rpc bytebase.v1.DatabaseService.GetDatabase
   */
  getDatabase: {
    methodKind: "unary";
    input: typeof GetDatabaseRequestSchema;
    output: typeof DatabaseSchema$;
  },
  /**
   * Retrieves multiple databases by their names.
   * Permissions required: bb.databases.get
   *
   * @generated from rpc bytebase.v1.DatabaseService.BatchGetDatabases
   */
  batchGetDatabases: {
    methodKind: "unary";
    input: typeof BatchGetDatabasesRequestSchema;
    output: typeof BatchGetDatabasesResponseSchema;
  },
  /**
   * Lists databases in a project, instance, or workspace.
   * Permissions required: bb.projects.get (for project parent), bb.databases.list (for workspace parent), or bb.instances.get (for instance parent)
   *
   * @generated from rpc bytebase.v1.DatabaseService.ListDatabases
   */
  listDatabases: {
    methodKind: "unary";
    input: typeof ListDatabasesRequestSchema;
    output: typeof ListDatabasesResponseSchema;
  },
  /**
   * Updates database properties such as labels and project assignment.
   * Permissions required: bb.databases.update
   *
   * @generated from rpc bytebase.v1.DatabaseService.UpdateDatabase
   */
  updateDatabase: {
    methodKind: "unary";
    input: typeof UpdateDatabaseRequestSchema;
    output: typeof DatabaseSchema$;
  },
  /**
   * Updates multiple databases in a single batch operation.
   * Permissions required: bb.databases.update
   *
   * @generated from rpc bytebase.v1.DatabaseService.BatchUpdateDatabases
   */
  batchUpdateDatabases: {
    methodKind: "unary";
    input: typeof BatchUpdateDatabasesRequestSchema;
    output: typeof BatchUpdateDatabasesResponseSchema;
  },
  /**
   * Synchronizes database schema from the instance.
   * Permissions required: bb.databases.sync
   *
   * @generated from rpc bytebase.v1.DatabaseService.SyncDatabase
   */
  syncDatabase: {
    methodKind: "unary";
    input: typeof SyncDatabaseRequestSchema;
    output: typeof SyncDatabaseResponseSchema;
  },
  /**
   * Synchronizes multiple databases in a single batch operation.
   * Permissions required: bb.databases.sync
   *
   * @generated from rpc bytebase.v1.DatabaseService.BatchSyncDatabases
   */
  batchSyncDatabases: {
    methodKind: "unary";
    input: typeof BatchSyncDatabasesRequestSchema;
    output: typeof BatchSyncDatabasesResponseSchema;
  },
  /**
   * Retrieves database metadata including tables, columns, and indexes.
   * Permissions required: bb.databases.getSchema
   *
   * @generated from rpc bytebase.v1.DatabaseService.GetDatabaseMetadata
   */
  getDatabaseMetadata: {
    methodKind: "unary";
    input: typeof GetDatabaseMetadataRequestSchema;
    output: typeof DatabaseMetadataSchema;
  },
  /**
   * Retrieves database schema as DDL statements.
   * Permissions required: bb.databases.getSchema
   *
   * @generated from rpc bytebase.v1.DatabaseService.GetDatabaseSchema
   */
  getDatabaseSchema: {
    methodKind: "unary";
    input: typeof GetDatabaseSchemaRequestSchema;
    output: typeof DatabaseSchemaSchema;
  },
  /**
   * Retrieves database schema in SDL (Schema Definition Language) format.
   * Permissions required: bb.databases.getSchema
   *
   * @generated from rpc bytebase.v1.DatabaseService.GetDatabaseSDLSchema
   */
  getDatabaseSDLSchema: {
    methodKind: "unary";
    input: typeof GetDatabaseSDLSchemaRequestSchema;
    output: typeof DatabaseSDLSchemaSchema;
  },
  /**
   * Compares and generates migration statements between two schemas.
   * Permissions required: bb.databases.get
   *
   * @generated from rpc bytebase.v1.DatabaseService.DiffSchema
   */
  diffSchema: {
    methodKind: "unary";
    input: typeof DiffSchemaRequestSchema;
    output: typeof DiffSchemaResponseSchema;
  },
  /**
   * Lists migration history for a database.
   * Permissions required: bb.changelogs.list
   *
   * @generated from rpc bytebase.v1.DatabaseService.ListChangelogs
   */
  listChangelogs: {
    methodKind: "unary";
    input: typeof ListChangelogsRequestSchema;
    output: typeof ListChangelogsResponseSchema;
  },
  /**
   * Retrieves a specific changelog entry.
   * Permissions required: bb.changelogs.get
   *
   * @generated from rpc bytebase.v1.DatabaseService.GetChangelog
   */
  getChangelog: {
    methodKind: "unary";
    input: typeof GetChangelogRequestSchema;
    output: typeof ChangelogSchema;
  },
  /**
   * Generates schema DDL for a database object.
   * Permissions required: bb.databases.getSchema
   *
   * @generated from rpc bytebase.v1.DatabaseService.GetSchemaString
   */
  getSchemaString: {
    methodKind: "unary";
    input: typeof GetSchemaStringRequestSchema;
    output: typeof GetSchemaStringResponseSchema;
  },
}>;

