// @generated by protoc-gen-es v2.5.2
// @generated from file v1/database_service.proto (package bytebase.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";
import type { EmptySchema, FieldMask, Timestamp } from "@bufbuild/protobuf/wkt";
import type { Range, State } from "./common_pb";
import type { InstanceResource } from "./instance_service_pb";

/**
 * Describes the file v1/database_service.proto.
 */
export declare const file_v1_database_service: GenFile;

/**
 * @generated from message bytebase.v1.GetDatabaseRequest
 */
export declare type GetDatabaseRequest = Message<"bytebase.v1.GetDatabaseRequest"> & {
  /**
   * The name of the database to retrieve.
   * Format: instances/{instance}/databases/{database}
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message bytebase.v1.GetDatabaseRequest.
 * Use `create(GetDatabaseRequestSchema)` to create a new message.
 */
export declare const GetDatabaseRequestSchema: GenMessage<GetDatabaseRequest>;

/**
 * @generated from message bytebase.v1.BatchGetDatabasesRequest
 */
export declare type BatchGetDatabasesRequest = Message<"bytebase.v1.BatchGetDatabasesRequest"> & {
  /**
   * The parent resource shared by all databases being retrieved.
   * - projects/{project}: batch get databases in a project;
   * - instances/{instances}: batch get databases in a instance;
   * Use "-" as wildcard to batch get databases across parent.
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * The list of database names to retrieve.
   *
   * @generated from field: repeated string names = 2;
   */
  names: string[];
};

/**
 * Describes the message bytebase.v1.BatchGetDatabasesRequest.
 * Use `create(BatchGetDatabasesRequestSchema)` to create a new message.
 */
export declare const BatchGetDatabasesRequestSchema: GenMessage<BatchGetDatabasesRequest>;

/**
 * @generated from message bytebase.v1.BatchGetDatabasesResponse
 */
export declare type BatchGetDatabasesResponse = Message<"bytebase.v1.BatchGetDatabasesResponse"> & {
  /**
   * The databases from the specified request.
   *
   * @generated from field: repeated bytebase.v1.Database databases = 1;
   */
  databases: Database[];
};

/**
 * Describes the message bytebase.v1.BatchGetDatabasesResponse.
 * Use `create(BatchGetDatabasesResponseSchema)` to create a new message.
 */
export declare const BatchGetDatabasesResponseSchema: GenMessage<BatchGetDatabasesResponse>;

/**
 * @generated from message bytebase.v1.ListDatabasesRequest
 */
export declare type ListDatabasesRequest = Message<"bytebase.v1.ListDatabasesRequest"> & {
  /**
   * - projects/{project}: list databases in a project, require "bb.projects.get" permission.
   * - workspaces/-: list databases in the workspace, require "bb.databases.list" permission.
   * - instances/{instances}: list databases in a instance, require "bb.instances.get" permission
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * The maximum number of databases to return. The service may return fewer
   * than this value.
   * If unspecified, at most 10 databases will be returned.
   * The maximum value is 1000; values above 1000 will be coerced to 1000.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize: number;

  /**
   * A page token, received from a previous `ListDatabases` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListDatabases` must
   * match the call that provided the page token.
   *
   * @generated from field: string page_token = 3;
   */
  pageToken: string;

  /**
   * Filter is used to filter databases returned in the list.
   * The syntax and semantics of CEL are documented at https://github.com/google/cel-spec
   *
   * Supported filter:
   * - environment: the environment full name in "environments/{id}" format, support "==" operator.
   * - name: the database name, support ".matches()" operator.
   * - project: the project full name in "projects/{id}" format, support "==" operator.
   * - instance: the instance full name in "instances/{id}" format, support "==" operator.
   * - engine: the database engine, check Engine enum for values. Support "==", "in [xx]", "!(in [xx])" operator.
   * - label: the database label in "{key}:{value1},{value2}" format. Support "==" operator.
   * - exclude_unassigned: should be "true" or "false", will not show unassigned databases if it's true, support "==" operator.
   * - drifted: should be "true" or "false", show drifted databases if it's true, support "==" operator.
   *
   * For example:
   * environment == "environments/{environment resource id}"
   * project == "projects/{project resource id}"
   * instance == "instances/{instance resource id}"
   * name.matches("database name")
   * engine == "MYSQL"
   * engine in ["MYSQL", "POSTGRES"]
   * !(engine in ["MYSQL", "POSTGRES"])
   * label == "region:asia"
   * label == "tenant:asia,europe"
   * label == "region:asia" && label == "tenant:bytebase"
   * exclude_unassigned == true
   * drifted == true
   * You can combine filter conditions like:
   * environment == "environments/prod" && name.matches("employee")
   *
   * @generated from field: string filter = 4;
   */
  filter: string;

  /**
   * Show deleted database if specified.
   *
   * @generated from field: bool show_deleted = 5;
   */
  showDeleted: boolean;
};

/**
 * Describes the message bytebase.v1.ListDatabasesRequest.
 * Use `create(ListDatabasesRequestSchema)` to create a new message.
 */
export declare const ListDatabasesRequestSchema: GenMessage<ListDatabasesRequest>;

/**
 * @generated from message bytebase.v1.ListDatabasesResponse
 */
export declare type ListDatabasesResponse = Message<"bytebase.v1.ListDatabasesResponse"> & {
  /**
   * The databases from the specified request.
   *
   * @generated from field: repeated bytebase.v1.Database databases = 1;
   */
  databases: Database[];

  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message bytebase.v1.ListDatabasesResponse.
 * Use `create(ListDatabasesResponseSchema)` to create a new message.
 */
export declare const ListDatabasesResponseSchema: GenMessage<ListDatabasesResponse>;

/**
 * @generated from message bytebase.v1.UpdateDatabaseRequest
 */
export declare type UpdateDatabaseRequest = Message<"bytebase.v1.UpdateDatabaseRequest"> & {
  /**
   * The database to update.
   *
   * The database's `name` field is used to identify the database to update.
   * Format: instances/{instance}/databases/{database}
   *
   * @generated from field: bytebase.v1.Database database = 1;
   */
  database?: Database;

  /**
   * The list of fields to update.
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 2;
   */
  updateMask?: FieldMask;
};

/**
 * Describes the message bytebase.v1.UpdateDatabaseRequest.
 * Use `create(UpdateDatabaseRequestSchema)` to create a new message.
 */
export declare const UpdateDatabaseRequestSchema: GenMessage<UpdateDatabaseRequest>;

/**
 * @generated from message bytebase.v1.BatchUpdateDatabasesRequest
 */
export declare type BatchUpdateDatabasesRequest = Message<"bytebase.v1.BatchUpdateDatabasesRequest"> & {
  /**
   * The parent resource shared by all databases being updated.
   * Format: instances/{instance}
   * If the operation spans parents, a dash (-) may be accepted as a wildcard.
   * We only support updating the project of databases for now.
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * The request message specifying the resources to update.
   * A maximum of 1000 databases can be modified in a batch.
   *
   * @generated from field: repeated bytebase.v1.UpdateDatabaseRequest requests = 2;
   */
  requests: UpdateDatabaseRequest[];
};

/**
 * Describes the message bytebase.v1.BatchUpdateDatabasesRequest.
 * Use `create(BatchUpdateDatabasesRequestSchema)` to create a new message.
 */
export declare const BatchUpdateDatabasesRequestSchema: GenMessage<BatchUpdateDatabasesRequest>;

/**
 * @generated from message bytebase.v1.BatchUpdateDatabasesResponse
 */
export declare type BatchUpdateDatabasesResponse = Message<"bytebase.v1.BatchUpdateDatabasesResponse"> & {
  /**
   * Databases updated.
   *
   * @generated from field: repeated bytebase.v1.Database databases = 1;
   */
  databases: Database[];
};

/**
 * Describes the message bytebase.v1.BatchUpdateDatabasesResponse.
 * Use `create(BatchUpdateDatabasesResponseSchema)` to create a new message.
 */
export declare const BatchUpdateDatabasesResponseSchema: GenMessage<BatchUpdateDatabasesResponse>;

/**
 * @generated from message bytebase.v1.BatchSyncDatabasesRequest
 */
export declare type BatchSyncDatabasesRequest = Message<"bytebase.v1.BatchSyncDatabasesRequest"> & {
  /**
   * The parent resource shared by all databases being updated.
   * Format: instances/{instance}
   * If the operation spans parents, a dash (-) may be accepted as a wildcard.
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * The list of database names to sync.
   *
   * @generated from field: repeated string names = 2;
   */
  names: string[];
};

/**
 * Describes the message bytebase.v1.BatchSyncDatabasesRequest.
 * Use `create(BatchSyncDatabasesRequestSchema)` to create a new message.
 */
export declare const BatchSyncDatabasesRequestSchema: GenMessage<BatchSyncDatabasesRequest>;

/**
 * @generated from message bytebase.v1.BatchSyncDatabasesResponse
 */
export declare type BatchSyncDatabasesResponse = Message<"bytebase.v1.BatchSyncDatabasesResponse"> & {
};

/**
 * Describes the message bytebase.v1.BatchSyncDatabasesResponse.
 * Use `create(BatchSyncDatabasesResponseSchema)` to create a new message.
 */
export declare const BatchSyncDatabasesResponseSchema: GenMessage<BatchSyncDatabasesResponse>;

/**
 * @generated from message bytebase.v1.SyncDatabaseRequest
 */
export declare type SyncDatabaseRequest = Message<"bytebase.v1.SyncDatabaseRequest"> & {
  /**
   * The name of the database to sync.
   * Format: instances/{instance}/databases/{database}
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message bytebase.v1.SyncDatabaseRequest.
 * Use `create(SyncDatabaseRequestSchema)` to create a new message.
 */
export declare const SyncDatabaseRequestSchema: GenMessage<SyncDatabaseRequest>;

/**
 * @generated from message bytebase.v1.SyncDatabaseResponse
 */
export declare type SyncDatabaseResponse = Message<"bytebase.v1.SyncDatabaseResponse"> & {
};

/**
 * Describes the message bytebase.v1.SyncDatabaseResponse.
 * Use `create(SyncDatabaseResponseSchema)` to create a new message.
 */
export declare const SyncDatabaseResponseSchema: GenMessage<SyncDatabaseResponse>;

/**
 * @generated from message bytebase.v1.GetDatabaseMetadataRequest
 */
export declare type GetDatabaseMetadataRequest = Message<"bytebase.v1.GetDatabaseMetadataRequest"> & {
  /**
   * The name of the database to retrieve metadata.
   * Format: instances/{instance}/databases/{database}/metadata
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Filter is used to filter databases returned in the list.
   * The syntax and semantics of CEL are documented at https://github.com/google/cel-spec
   *
   * Supported filter:
   * - schema: the schema name, support "==" operator.
   * - table: the table name, support "==" operator.
   *
   * For example:
   * schema == "schema-a"
   * table == "table-a"
   * schema == "schema-a" && table == "table-a"
   * The filter used for a specific schema object such as
   * "schemas/schema-a/tables/table-a".
   * The column masking level will only be returned when a table filter is used.
   *
   * @generated from field: string filter = 2;
   */
  filter: string;
};

/**
 * Describes the message bytebase.v1.GetDatabaseMetadataRequest.
 * Use `create(GetDatabaseMetadataRequestSchema)` to create a new message.
 */
export declare const GetDatabaseMetadataRequestSchema: GenMessage<GetDatabaseMetadataRequest>;

/**
 * @generated from message bytebase.v1.GetDatabaseSchemaRequest
 */
export declare type GetDatabaseSchemaRequest = Message<"bytebase.v1.GetDatabaseSchemaRequest"> & {
  /**
   * The name of the database to retrieve schema.
   * Format: instances/{instance}/databases/{database}/schema
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Format the schema dump into SDL format.
   *
   * @generated from field: bool sdl_format = 2;
   */
  sdlFormat: boolean;
};

/**
 * Describes the message bytebase.v1.GetDatabaseSchemaRequest.
 * Use `create(GetDatabaseSchemaRequestSchema)` to create a new message.
 */
export declare const GetDatabaseSchemaRequestSchema: GenMessage<GetDatabaseSchemaRequest>;

/**
 * @generated from message bytebase.v1.DiffSchemaRequest
 */
export declare type DiffSchemaRequest = Message<"bytebase.v1.DiffSchemaRequest"> & {
  /**
   * The name of the database or changelog.
   * Format:
   * database: instances/{instance}/databases/{database}
   * changelog: instances/{instance}/databases/{database}/changelogs/{changelog}
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from oneof bytebase.v1.DiffSchemaRequest.target
   */
  target: {
    /**
     * The target schema.
     *
     * @generated from field: string schema = 2;
     */
    value: string;
    case: "schema";
  } | {
    /**
     * The resource name of the changelog
     * Format:
     * instances/{instance}/databases/{database}/changelogs/{changelog}
     *
     * @generated from field: string changelog = 3;
     */
    value: string;
    case: "changelog";
  } | { case: undefined; value?: undefined };

  /**
   * Format the schema dump into SDL format.
   *
   * @generated from field: bool sdl_format = 4;
   */
  sdlFormat: boolean;
};

/**
 * Describes the message bytebase.v1.DiffSchemaRequest.
 * Use `create(DiffSchemaRequestSchema)` to create a new message.
 */
export declare const DiffSchemaRequestSchema: GenMessage<DiffSchemaRequest>;

/**
 * @generated from message bytebase.v1.DiffSchemaResponse
 */
export declare type DiffSchemaResponse = Message<"bytebase.v1.DiffSchemaResponse"> & {
  /**
   * @generated from field: string diff = 1;
   */
  diff: string;
};

/**
 * Describes the message bytebase.v1.DiffSchemaResponse.
 * Use `create(DiffSchemaResponseSchema)` to create a new message.
 */
export declare const DiffSchemaResponseSchema: GenMessage<DiffSchemaResponse>;

/**
 * @generated from message bytebase.v1.Database
 */
export declare type Database = Message<"bytebase.v1.Database"> & {
  /**
   * The name of the database.
   * Format: instances/{instance}/databases/{database}
   * {database} is the database name in the instance.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The existence of a database.
   *
   * @generated from field: bytebase.v1.State state = 3;
   */
  state: State;

  /**
   * The latest synchronization time.
   *
   * @generated from field: google.protobuf.Timestamp successful_sync_time = 4;
   */
  successfulSyncTime?: Timestamp;

  /**
   * The project for a database.
   * Format: projects/{project}
   *
   * @generated from field: string project = 5;
   */
  project: string;

  /**
   * The version of database schema.
   *
   * @generated from field: string schema_version = 6;
   */
  schemaVersion: string;

  /**
   * The environment resource.
   * Format: environments/prod where prod is the environment resource ID.
   *
   * @generated from field: string environment = 7;
   */
  environment: string;

  /**
   * The effective environment based on environment tag above and environment
   * tag on the instance. Inheritance follows
   * https://cloud.google.com/resource-manager/docs/tags/tags-overview.
   *
   * @generated from field: string effective_environment = 8;
   */
  effectiveEnvironment: string;

  /**
   * Labels will be used for deployment and policy control.
   *
   * @generated from field: map<string, string> labels = 9;
   */
  labels: { [key: string]: string };

  /**
   * The instance resource.
   *
   * @generated from field: bytebase.v1.InstanceResource instance_resource = 10;
   */
  instanceResource?: InstanceResource;

  /**
   * The database is available for DML prior backup.
   *
   * @generated from field: bool backup_available = 11;
   */
  backupAvailable: boolean;

  /**
   * The schema is drifted from the source of truth.
   *
   * @generated from field: bool drifted = 12;
   */
  drifted: boolean;
};

/**
 * Describes the message bytebase.v1.Database.
 * Use `create(DatabaseSchema$)` to create a new message.
 */
export declare const DatabaseSchema$: GenMessage<Database>;

/**
 * DatabaseMetadata is the metadata for databases.
 *
 * @generated from message bytebase.v1.DatabaseMetadata
 */
export declare type DatabaseMetadata = Message<"bytebase.v1.DatabaseMetadata"> & {
  /**
   * The database metadata name.
   *
   * Format: instances/{instance}/databases/{database}/metadata
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The schemas is the list of schemas in a database.
   *
   * @generated from field: repeated bytebase.v1.SchemaMetadata schemas = 2;
   */
  schemas: SchemaMetadata[];

  /**
   * The character_set is the character set of a database.
   *
   * @generated from field: string character_set = 3;
   */
  characterSet: string;

  /**
   * The collation is the collation of a database.
   *
   * @generated from field: string collation = 4;
   */
  collation: string;

  /**
   * The extensions is the list of extensions in a database.
   *
   * @generated from field: repeated bytebase.v1.ExtensionMetadata extensions = 5;
   */
  extensions: ExtensionMetadata[];

  /**
   * @generated from field: string owner = 7;
   */
  owner: string;

  /**
   * The search_path is the search path of a PostgreSQL database.
   *
   * @generated from field: string search_path = 8;
   */
  searchPath: string;
};

/**
 * Describes the message bytebase.v1.DatabaseMetadata.
 * Use `create(DatabaseMetadataSchema)` to create a new message.
 */
export declare const DatabaseMetadataSchema: GenMessage<DatabaseMetadata>;

/**
 * SchemaMetadata is the metadata for schemas.
 * This is the concept of schema in Postgres, but it's a no-op for MySQL.
 *
 * @generated from message bytebase.v1.SchemaMetadata
 */
export declare type SchemaMetadata = Message<"bytebase.v1.SchemaMetadata"> & {
  /**
   * The name is the schema name.
   * It is an empty string for databases without such concept such as MySQL.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The tables is the list of tables in a schema.
   *
   * @generated from field: repeated bytebase.v1.TableMetadata tables = 2;
   */
  tables: TableMetadata[];

  /**
   * The external_tables is the list of external tables in a schema.
   *
   * @generated from field: repeated bytebase.v1.ExternalTableMetadata external_tables = 3;
   */
  externalTables: ExternalTableMetadata[];

  /**
   * The views is the list of views in a schema.
   *
   * @generated from field: repeated bytebase.v1.ViewMetadata views = 4;
   */
  views: ViewMetadata[];

  /**
   * The functions is the list of functions in a schema.
   *
   * @generated from field: repeated bytebase.v1.FunctionMetadata functions = 5;
   */
  functions: FunctionMetadata[];

  /**
   * The procedures is the list of procedures in a schema.
   *
   * @generated from field: repeated bytebase.v1.ProcedureMetadata procedures = 6;
   */
  procedures: ProcedureMetadata[];

  /**
   * The streams is the list of streams in a schema, currently, only used for
   * Snowflake.
   *
   * @generated from field: repeated bytebase.v1.StreamMetadata streams = 7;
   */
  streams: StreamMetadata[];

  /**
   * The routines is the list of routines in a schema, currently, only used for
   * Snowflake.
   *
   * @generated from field: repeated bytebase.v1.TaskMetadata tasks = 8;
   */
  tasks: TaskMetadata[];

  /**
   * The materialized_views is the list of materialized views in a schema.
   *
   * @generated from field: repeated bytebase.v1.MaterializedViewMetadata materialized_views = 9;
   */
  materializedViews: MaterializedViewMetadata[];

  /**
   * The packages is the list of packages in a schema.
   *
   * @generated from field: repeated bytebase.v1.PackageMetadata packages = 10;
   */
  packages: PackageMetadata[];

  /**
   * @generated from field: string owner = 11;
   */
  owner: string;

  /**
   * The sequences is the list of sequences in a schema, sorted by name.
   *
   * @generated from field: repeated bytebase.v1.SequenceMetadata sequences = 13;
   */
  sequences: SequenceMetadata[];

  /**
   * @generated from field: repeated bytebase.v1.EventMetadata events = 14;
   */
  events: EventMetadata[];

  /**
   * @generated from field: repeated bytebase.v1.EnumTypeMetadata enum_types = 15;
   */
  enumTypes: EnumTypeMetadata[];

  /**
   * @generated from field: bool skip_dump = 16;
   */
  skipDump: boolean;
};

/**
 * Describes the message bytebase.v1.SchemaMetadata.
 * Use `create(SchemaMetadataSchema)` to create a new message.
 */
export declare const SchemaMetadataSchema: GenMessage<SchemaMetadata>;

/**
 * @generated from message bytebase.v1.EnumTypeMetadata
 */
export declare type EnumTypeMetadata = Message<"bytebase.v1.EnumTypeMetadata"> & {
  /**
   * The name of a type.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The enum values of a type.
   *
   * @generated from field: repeated string values = 2;
   */
  values: string[];

  /**
   * @generated from field: string comment = 3;
   */
  comment: string;

  /**
   * @generated from field: bool skip_dump = 4;
   */
  skipDump: boolean;
};

/**
 * Describes the message bytebase.v1.EnumTypeMetadata.
 * Use `create(EnumTypeMetadataSchema)` to create a new message.
 */
export declare const EnumTypeMetadataSchema: GenMessage<EnumTypeMetadata>;

/**
 * @generated from message bytebase.v1.EventMetadata
 */
export declare type EventMetadata = Message<"bytebase.v1.EventMetadata"> & {
  /**
   * The name of the event.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The schedule of the event.
   *
   * @generated from field: string definition = 2;
   */
  definition: string;

  /**
   * The time zone of the event.
   *
   * @generated from field: string time_zone = 3;
   */
  timeZone: string;

  /**
   * @generated from field: string sql_mode = 4;
   */
  sqlMode: string;

  /**
   * @generated from field: string character_set_client = 5;
   */
  characterSetClient: string;

  /**
   * @generated from field: string collation_connection = 6;
   */
  collationConnection: string;
};

/**
 * Describes the message bytebase.v1.EventMetadata.
 * Use `create(EventMetadataSchema)` to create a new message.
 */
export declare const EventMetadataSchema: GenMessage<EventMetadata>;

/**
 * @generated from message bytebase.v1.SequenceMetadata
 */
export declare type SequenceMetadata = Message<"bytebase.v1.SequenceMetadata"> & {
  /**
   * The name of a sequence.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The data type of a sequence.
   *
   * @generated from field: string data_type = 2;
   */
  dataType: string;

  /**
   * The start value of a sequence.
   *
   * @generated from field: string start = 3;
   */
  start: string;

  /**
   * The minimum value of a sequence.
   *
   * @generated from field: string min_value = 4;
   */
  minValue: string;

  /**
   * The maximum value of a sequence.
   *
   * @generated from field: string max_value = 5;
   */
  maxValue: string;

  /**
   * Increment value of a sequence.
   *
   * @generated from field: string increment = 6;
   */
  increment: string;

  /**
   * Cycle is whether the sequence cycles.
   *
   * @generated from field: bool cycle = 7;
   */
  cycle: boolean;

  /**
   * Cache size of a sequence.
   *
   * @generated from field: string cache_size = 8;
   */
  cacheSize: string;

  /**
   * Last value of a sequence.
   *
   * @generated from field: string last_value = 9;
   */
  lastValue: string;

  /**
   * The owner table of the sequence.
   *
   * @generated from field: string owner_table = 10;
   */
  ownerTable: string;

  /**
   * The owner column of the sequence.
   *
   * @generated from field: string owner_column = 11;
   */
  ownerColumn: string;

  /**
   * @generated from field: string comment = 12;
   */
  comment: string;

  /**
   * @generated from field: bool skip_dump = 13;
   */
  skipDump: boolean;
};

/**
 * Describes the message bytebase.v1.SequenceMetadata.
 * Use `create(SequenceMetadataSchema)` to create a new message.
 */
export declare const SequenceMetadataSchema: GenMessage<SequenceMetadata>;

/**
 * @generated from message bytebase.v1.TriggerMetadata
 */
export declare type TriggerMetadata = Message<"bytebase.v1.TriggerMetadata"> & {
  /**
   * The name is the name of the trigger.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The event is the event of the trigger, such as INSERT, UPDATE, DELETE,
   * TRUNCATE.
   *
   * @generated from field: string event = 3;
   */
  event: string;

  /**
   * The timing is the timing of the trigger, such as BEFORE, AFTER.
   *
   * @generated from field: string timing = 4;
   */
  timing: string;

  /**
   * The body is the body of the trigger.
   *
   * @generated from field: string body = 5;
   */
  body: string;

  /**
   * @generated from field: string sql_mode = 6;
   */
  sqlMode: string;

  /**
   * @generated from field: string character_set_client = 7;
   */
  characterSetClient: string;

  /**
   * @generated from field: string collation_connection = 8;
   */
  collationConnection: string;

  /**
   * @generated from field: string comment = 9;
   */
  comment: string;

  /**
   * @generated from field: bool skip_dump = 10;
   */
  skipDump: boolean;
};

/**
 * Describes the message bytebase.v1.TriggerMetadata.
 * Use `create(TriggerMetadataSchema)` to create a new message.
 */
export declare const TriggerMetadataSchema: GenMessage<TriggerMetadata>;

/**
 * @generated from message bytebase.v1.ExternalTableMetadata
 */
export declare type ExternalTableMetadata = Message<"bytebase.v1.ExternalTableMetadata"> & {
  /**
   * The name is the name of a external table.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The external_server_name is the name of the external server.
   *
   * @generated from field: string external_server_name = 2;
   */
  externalServerName: string;

  /**
   * The external_database_name is the name of the external database.
   *
   * @generated from field: string external_database_name = 3;
   */
  externalDatabaseName: string;

  /**
   * The columns is the ordered list of columns in a foreign table.
   *
   * @generated from field: repeated bytebase.v1.ColumnMetadata columns = 4;
   */
  columns: ColumnMetadata[];
};

/**
 * Describes the message bytebase.v1.ExternalTableMetadata.
 * Use `create(ExternalTableMetadataSchema)` to create a new message.
 */
export declare const ExternalTableMetadataSchema: GenMessage<ExternalTableMetadata>;

/**
 * TableMetadata is the metadata for tables.
 *
 * @generated from message bytebase.v1.TableMetadata
 */
export declare type TableMetadata = Message<"bytebase.v1.TableMetadata"> & {
  /**
   * The name is the name of a table.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The columns is the ordered list of columns in a table.
   *
   * @generated from field: repeated bytebase.v1.ColumnMetadata columns = 2;
   */
  columns: ColumnMetadata[];

  /**
   * The indexes is the list of indexes in a table.
   *
   * @generated from field: repeated bytebase.v1.IndexMetadata indexes = 3;
   */
  indexes: IndexMetadata[];

  /**
   * The engine is the engine of a table.
   *
   * @generated from field: string engine = 4;
   */
  engine: string;

  /**
   * The collation is the collation of a table.
   *
   * @generated from field: string collation = 5;
   */
  collation: string;

  /**
   * The character set of table.
   *
   * @generated from field: string charset = 17;
   */
  charset: string;

  /**
   * The row_count is the estimated number of rows of a table.
   *
   * @generated from field: int64 row_count = 6;
   */
  rowCount: bigint;

  /**
   * The data_size is the estimated data size of a table.
   *
   * @generated from field: int64 data_size = 7;
   */
  dataSize: bigint;

  /**
   * The index_size is the estimated index size of a table.
   *
   * @generated from field: int64 index_size = 8;
   */
  indexSize: bigint;

  /**
   * The data_free is the estimated free data size of a table.
   *
   * @generated from field: int64 data_free = 9;
   */
  dataFree: bigint;

  /**
   * The create_options is the create option of a table.
   *
   * @generated from field: string create_options = 10;
   */
  createOptions: string;

  /**
   * The comment is the comment of a table.
   * classification and user_comment is parsed from the comment.
   *
   * @generated from field: string comment = 11;
   */
  comment: string;

  /**
   * The user_comment is the user comment of a table parsed from the comment.
   *
   * @generated from field: string user_comment = 14;
   */
  userComment: string;

  /**
   * The foreign_keys is the list of foreign keys in a table.
   *
   * @generated from field: repeated bytebase.v1.ForeignKeyMetadata foreign_keys = 12;
   */
  foreignKeys: ForeignKeyMetadata[];

  /**
   * The partitions is the list of partitions in a table.
   *
   * @generated from field: repeated bytebase.v1.TablePartitionMetadata partitions = 15;
   */
  partitions: TablePartitionMetadata[];

  /**
   * The check_constraints is the list of check constraints in a table.
   *
   * @generated from field: repeated bytebase.v1.CheckConstraintMetadata check_constraints = 16;
   */
  checkConstraints: CheckConstraintMetadata[];

  /**
   * @generated from field: string owner = 18;
   */
  owner: string;

  /**
   * The sorting_keys is a tuple of column names or arbitrary expressions. ClickHouse specific field.
   * Reference: https://clickhouse.com/docs/en/engines/table-engines/mergetree-family/mergetree#order_by
   *
   * @generated from field: repeated string sorting_keys = 19;
   */
  sortingKeys: string[];

  /**
   * @generated from field: repeated bytebase.v1.TriggerMetadata triggers = 20;
   */
  triggers: TriggerMetadata[];

  /**
   * @generated from field: bool skip_dump = 21;
   */
  skipDump: boolean;

  /**
   * https://docs.pingcap.com/tidb/stable/information-schema-tables/
   *
   * @generated from field: string sharding_info = 22;
   */
  shardingInfo: string;

  /**
   * https://docs.pingcap.com/tidb/stable/clustered-indexes/#clustered-indexes
   * CLUSTERED or NONCLUSTERED.
   *
   * @generated from field: string primary_key_type = 23;
   */
  primaryKeyType: string;
};

/**
 * Describes the message bytebase.v1.TableMetadata.
 * Use `create(TableMetadataSchema)` to create a new message.
 */
export declare const TableMetadataSchema: GenMessage<TableMetadata>;

/**
 * CheckConstraintMetadata is the metadata for check constraints.
 *
 * @generated from message bytebase.v1.CheckConstraintMetadata
 */
export declare type CheckConstraintMetadata = Message<"bytebase.v1.CheckConstraintMetadata"> & {
  /**
   * The name is the name of a check constraint.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The expression is the expression of a check constraint.
   *
   * @generated from field: string expression = 2;
   */
  expression: string;
};

/**
 * Describes the message bytebase.v1.CheckConstraintMetadata.
 * Use `create(CheckConstraintMetadataSchema)` to create a new message.
 */
export declare const CheckConstraintMetadataSchema: GenMessage<CheckConstraintMetadata>;

/**
 * TablePartitionMetadata is the metadata for table partitions.
 *
 * @generated from message bytebase.v1.TablePartitionMetadata
 */
export declare type TablePartitionMetadata = Message<"bytebase.v1.TablePartitionMetadata"> & {
  /**
   * The name is the name of a table partition.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The type of a table partition.
   *
   * @generated from field: bytebase.v1.TablePartitionMetadata.Type type = 2;
   */
  type: TablePartitionMetadata_Type;

  /**
   * The expression is the expression of a table partition.
   * For PostgreSQL, the expression is the text of {FOR VALUES
   * partition_bound_spec}, see
   * https://www.postgresql.org/docs/current/sql-createtable.html. For MySQL,
   * the expression is the `expr` or `column_list` of the following syntax.
   * PARTITION BY
   *    { [LINEAR] HASH(expr)
   *    | [LINEAR] KEY [ALGORITHM={1 | 2}] (column_list)
   *    | RANGE{(expr) | COLUMNS(column_list)}
   *    | LIST{(expr) | COLUMNS(column_list)} }.
   *
   * @generated from field: string expression = 3;
   */
  expression: string;

  /**
   * The value is the value of a table partition.
   * For MySQL, the value is for RANGE and LIST partition types,
   * - For a RANGE partition, it contains the value set in the partition's
   * VALUES LESS THAN clause, which can be either an integer or MAXVALUE.
   * - For a LIST partition, this column contains the values defined in the
   * partition's VALUES IN clause, which is a list of comma-separated integer
   * values.
   * - For others, it's an empty string.
   *
   * @generated from field: string value = 4;
   */
  value: string;

  /**
   * The use_default is whether the users use the default partition, it stores
   * the different value for different database engines. For MySQL, it's [INT]
   * type, 0 means not use default partition, otherwise, it's equals to number
   * in syntax [SUB]PARTITION {number}.
   *
   * @generated from field: string use_default = 5;
   */
  useDefault: string;

  /**
   * The subpartitions is the list of subpartitions in a table partition.
   *
   * @generated from field: repeated bytebase.v1.TablePartitionMetadata subpartitions = 6;
   */
  subpartitions: TablePartitionMetadata[];

  /**
   * @generated from field: repeated bytebase.v1.IndexMetadata indexes = 7;
   */
  indexes: IndexMetadata[];

  /**
   * @generated from field: repeated bytebase.v1.CheckConstraintMetadata check_constraints = 8;
   */
  checkConstraints: CheckConstraintMetadata[];
};

/**
 * Describes the message bytebase.v1.TablePartitionMetadata.
 * Use `create(TablePartitionMetadataSchema)` to create a new message.
 */
export declare const TablePartitionMetadataSchema: GenMessage<TablePartitionMetadata>;

/**
 * Type is the type of a table partition, some database engines may not
 * support all types. Only avilable for the following database engines now:
 * MySQL: RANGE, RANGE COLUMNS, LIST, LIST COLUMNS, HASH, LINEAR HASH, KEY,
 * LINEAR_KEY
 * (https://dev.mysql.com/doc/refman/8.0/en/partitioning-types.html) TiDB:
 * RANGE, RANGE COLUMNS, LIST, LIST COLUMNS, HASH, KEY PostgreSQL: RANGE,
 * LIST, HASH (https://www.postgresql.org/docs/current/ddl-partitioning.html)
 *
 * @generated from enum bytebase.v1.TablePartitionMetadata.Type
 */
export enum TablePartitionMetadata_Type {
  /**
   * @generated from enum value: TYPE_UNSPECIFIED = 0;
   */
  TYPE_UNSPECIFIED = 0,

  /**
   * @generated from enum value: RANGE = 1;
   */
  RANGE = 1,

  /**
   * @generated from enum value: RANGE_COLUMNS = 2;
   */
  RANGE_COLUMNS = 2,

  /**
   * @generated from enum value: LIST = 3;
   */
  LIST = 3,

  /**
   * @generated from enum value: LIST_COLUMNS = 4;
   */
  LIST_COLUMNS = 4,

  /**
   * @generated from enum value: HASH = 5;
   */
  HASH = 5,

  /**
   * @generated from enum value: LINEAR_HASH = 6;
   */
  LINEAR_HASH = 6,

  /**
   * @generated from enum value: KEY = 7;
   */
  KEY = 7,

  /**
   * @generated from enum value: LINEAR_KEY = 8;
   */
  LINEAR_KEY = 8,
}

/**
 * Describes the enum bytebase.v1.TablePartitionMetadata.Type.
 */
export declare const TablePartitionMetadata_TypeSchema: GenEnum<TablePartitionMetadata_Type>;

/**
 * ColumnMetadata is the metadata for columns.
 *
 * @generated from message bytebase.v1.ColumnMetadata
 */
export declare type ColumnMetadata = Message<"bytebase.v1.ColumnMetadata"> & {
  /**
   * The name is the name of a column.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The position is the position in columns.
   *
   * @generated from field: int32 position = 2;
   */
  position: number;

  /**
   * @generated from field: bool has_default = 3;
   */
  hasDefault: boolean;

  /**
   * The default is the default value of a column.
   *
   * @generated from oneof bytebase.v1.ColumnMetadata.default
   */
  default: {
    /**
     * @generated from field: bool default_null = 4;
     */
    value: boolean;
    case: "defaultNull";
  } | {
    /**
     * @generated from field: string default_string = 5;
     */
    value: string;
    case: "defaultString";
  } | {
    /**
     * @generated from field: string default_expression = 6;
     */
    value: string;
    case: "defaultExpression";
  } | { case: undefined; value?: undefined };

  /**
   * Oracle specific metadata.
   * The default_on_null is the default on null of a column.
   *
   * @generated from field: bool default_on_null = 18;
   */
  defaultOnNull: boolean;

  /**
   * The on_update is the on update action of a column.
   * For MySQL like databases, it's only supported for TIMESTAMP columns with
   * CURRENT_TIMESTAMP as on update value.
   *
   * @generated from field: string on_update = 15;
   */
  onUpdate: string;

  /**
   * The nullable is the nullable of a column.
   *
   * @generated from field: bool nullable = 7;
   */
  nullable: boolean;

  /**
   * The type is the type of a column.
   *
   * @generated from field: string type = 8;
   */
  type: string;

  /**
   * The character_set is the character_set of a column.
   *
   * @generated from field: string character_set = 9;
   */
  characterSet: string;

  /**
   * The collation is the collation of a column.
   *
   * @generated from field: string collation = 10;
   */
  collation: string;

  /**
   * The comment is the comment of a column.
   * classification and user_comment is parsed from the comment.
   *
   * @generated from field: string comment = 11;
   */
  comment: string;

  /**
   * The user_comment is the user comment of a column parsed from the comment.
   *
   * @generated from field: string user_comment = 13;
   */
  userComment: string;

  /**
   * The generation is the generation of a column.
   *
   * @generated from field: bytebase.v1.GenerationMetadata generation = 16;
   */
  generation?: GenerationMetadata;

  /**
   * @generated from field: bool is_identity = 19;
   */
  isIdentity: boolean;

  /**
   * The identity_generation is for identity columns, PG only.
   *
   * @generated from field: bytebase.v1.ColumnMetadata.IdentityGeneration identity_generation = 17;
   */
  identityGeneration: ColumnMetadata_IdentityGeneration;

  /**
   * The identity_seed is for identity columns, MSSQL only.
   *
   * @generated from field: int64 identity_seed = 20;
   */
  identitySeed: bigint;

  /**
   * The identity_increment is for identity columns, MSSQL only.
   *
   * @generated from field: int64 identity_increment = 21;
   */
  identityIncrement: bigint;
};

/**
 * Describes the message bytebase.v1.ColumnMetadata.
 * Use `create(ColumnMetadataSchema)` to create a new message.
 */
export declare const ColumnMetadataSchema: GenMessage<ColumnMetadata>;

/**
 * @generated from enum bytebase.v1.ColumnMetadata.IdentityGeneration
 */
export enum ColumnMetadata_IdentityGeneration {
  /**
   * @generated from enum value: IDENTITY_GENERATION_UNSPECIFIED = 0;
   */
  IDENTITY_GENERATION_UNSPECIFIED = 0,

  /**
   * @generated from enum value: ALWAYS = 1;
   */
  ALWAYS = 1,

  /**
   * @generated from enum value: BY_DEFAULT = 2;
   */
  BY_DEFAULT = 2,
}

/**
 * Describes the enum bytebase.v1.ColumnMetadata.IdentityGeneration.
 */
export declare const ColumnMetadata_IdentityGenerationSchema: GenEnum<ColumnMetadata_IdentityGeneration>;

/**
 * @generated from message bytebase.v1.GenerationMetadata
 */
export declare type GenerationMetadata = Message<"bytebase.v1.GenerationMetadata"> & {
  /**
   * @generated from field: bytebase.v1.GenerationMetadata.Type type = 1;
   */
  type: GenerationMetadata_Type;

  /**
   * @generated from field: string expression = 2;
   */
  expression: string;
};

/**
 * Describes the message bytebase.v1.GenerationMetadata.
 * Use `create(GenerationMetadataSchema)` to create a new message.
 */
export declare const GenerationMetadataSchema: GenMessage<GenerationMetadata>;

/**
 * @generated from enum bytebase.v1.GenerationMetadata.Type
 */
export enum GenerationMetadata_Type {
  /**
   * @generated from enum value: TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: TYPE_VIRTUAL = 1;
   */
  VIRTUAL = 1,

  /**
   * @generated from enum value: TYPE_STORED = 2;
   */
  STORED = 2,
}

/**
 * Describes the enum bytebase.v1.GenerationMetadata.Type.
 */
export declare const GenerationMetadata_TypeSchema: GenEnum<GenerationMetadata_Type>;

/**
 * ViewMetadata is the metadata for views.
 *
 * @generated from message bytebase.v1.ViewMetadata
 */
export declare type ViewMetadata = Message<"bytebase.v1.ViewMetadata"> & {
  /**
   * The name is the name of a view.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The definition is the definition of a view.
   *
   * @generated from field: string definition = 2;
   */
  definition: string;

  /**
   * The comment is the comment of a view.
   *
   * @generated from field: string comment = 3;
   */
  comment: string;

  /**
   * The dependency_columns is the list of dependency columns of a view.
   *
   * @generated from field: repeated bytebase.v1.DependencyColumn dependency_columns = 4;
   */
  dependencyColumns: DependencyColumn[];

  /**
   * The columns is the ordered list of columns in a table.
   *
   * @generated from field: repeated bytebase.v1.ColumnMetadata columns = 5;
   */
  columns: ColumnMetadata[];

  /**
   * The triggers is the list of triggers in a view.
   *
   * @generated from field: repeated bytebase.v1.TriggerMetadata triggers = 6;
   */
  triggers: TriggerMetadata[];

  /**
   * @generated from field: bool skip_dump = 7;
   */
  skipDump: boolean;
};

/**
 * Describes the message bytebase.v1.ViewMetadata.
 * Use `create(ViewMetadataSchema)` to create a new message.
 */
export declare const ViewMetadataSchema: GenMessage<ViewMetadata>;

/**
 * DependencyColumn is the metadata for dependency columns.
 *
 * @generated from message bytebase.v1.DependencyColumn
 */
export declare type DependencyColumn = Message<"bytebase.v1.DependencyColumn"> & {
  /**
   * The schema is the schema of a reference column.
   *
   * @generated from field: string schema = 1;
   */
  schema: string;

  /**
   * The table is the table of a reference column.
   *
   * @generated from field: string table = 2;
   */
  table: string;

  /**
   * The column is the name of a reference column.
   *
   * @generated from field: string column = 3;
   */
  column: string;
};

/**
 * Describes the message bytebase.v1.DependencyColumn.
 * Use `create(DependencyColumnSchema)` to create a new message.
 */
export declare const DependencyColumnSchema: GenMessage<DependencyColumn>;

/**
 * MaterializedViewMetadata is the metadata for materialized views.
 *
 * @generated from message bytebase.v1.MaterializedViewMetadata
 */
export declare type MaterializedViewMetadata = Message<"bytebase.v1.MaterializedViewMetadata"> & {
  /**
   * The name is the name of a materialized view.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The definition is the definition of a materialized view.
   *
   * @generated from field: string definition = 2;
   */
  definition: string;

  /**
   * The comment is the comment of a materialized view.
   *
   * @generated from field: string comment = 3;
   */
  comment: string;

  /**
   * The dependency_columns is the list of dependency columns of a materialized
   * view.
   *
   * @generated from field: repeated bytebase.v1.DependencyColumn dependency_columns = 4;
   */
  dependencyColumns: DependencyColumn[];

  /**
   * The columns is the ordered list of columns in a table.
   *
   * @generated from field: repeated bytebase.v1.TriggerMetadata triggers = 5;
   */
  triggers: TriggerMetadata[];

  /**
   * The indexes is the list of indexes in a table.
   *
   * @generated from field: repeated bytebase.v1.IndexMetadata indexes = 6;
   */
  indexes: IndexMetadata[];

  /**
   * @generated from field: bool skip_dump = 7;
   */
  skipDump: boolean;
};

/**
 * Describes the message bytebase.v1.MaterializedViewMetadata.
 * Use `create(MaterializedViewMetadataSchema)` to create a new message.
 */
export declare const MaterializedViewMetadataSchema: GenMessage<MaterializedViewMetadata>;

/**
 * @generated from message bytebase.v1.DependencyTable
 */
export declare type DependencyTable = Message<"bytebase.v1.DependencyTable"> & {
  /**
   * The schema is the schema of a reference table.
   *
   * @generated from field: string schema = 1;
   */
  schema: string;

  /**
   * The table is the name of a reference table.
   *
   * @generated from field: string table = 2;
   */
  table: string;
};

/**
 * Describes the message bytebase.v1.DependencyTable.
 * Use `create(DependencyTableSchema)` to create a new message.
 */
export declare const DependencyTableSchema: GenMessage<DependencyTable>;

/**
 * FunctionMetadata is the metadata for functions.
 *
 * @generated from message bytebase.v1.FunctionMetadata
 */
export declare type FunctionMetadata = Message<"bytebase.v1.FunctionMetadata"> & {
  /**
   * The name is the name of a function.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The definition is the definition of a function.
   *
   * @generated from field: string definition = 2;
   */
  definition: string;

  /**
   * The signature is the name with the number and type of input arguments the
   * function takes.
   *
   * @generated from field: string signature = 3;
   */
  signature: string;

  /**
   * MySQL specific metadata.
   *
   * @generated from field: string character_set_client = 4;
   */
  characterSetClient: string;

  /**
   * @generated from field: string collation_connection = 5;
   */
  collationConnection: string;

  /**
   * @generated from field: string database_collation = 6;
   */
  databaseCollation: string;

  /**
   * @generated from field: string sql_mode = 7;
   */
  sqlMode: string;

  /**
   * @generated from field: string comment = 8;
   */
  comment: string;

  /**
   * The dependency_tables is the list of dependency tables of a function.
   * For PostgreSQL, it's the list of tables that the function depends on the return type definition.
   *
   * @generated from field: repeated bytebase.v1.DependencyTable dependency_tables = 9;
   */
  dependencyTables: DependencyTable[];

  /**
   * @generated from field: bool skip_dump = 10;
   */
  skipDump: boolean;
};

/**
 * Describes the message bytebase.v1.FunctionMetadata.
 * Use `create(FunctionMetadataSchema)` to create a new message.
 */
export declare const FunctionMetadataSchema: GenMessage<FunctionMetadata>;

/**
 * ProcedureMetadata is the metadata for procedures.
 *
 * @generated from message bytebase.v1.ProcedureMetadata
 */
export declare type ProcedureMetadata = Message<"bytebase.v1.ProcedureMetadata"> & {
  /**
   * The name is the name of a procedure.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The definition is the definition of a procedure.
   *
   * @generated from field: string definition = 2;
   */
  definition: string;

  /**
   * The signature is the name with the number and type of input arguments the
   * function takes.
   *
   * @generated from field: string signature = 3;
   */
  signature: string;

  /**
   * MySQL specific metadata.
   *
   * @generated from field: string character_set_client = 4;
   */
  characterSetClient: string;

  /**
   * @generated from field: string collation_connection = 5;
   */
  collationConnection: string;

  /**
   * @generated from field: string database_collation = 6;
   */
  databaseCollation: string;

  /**
   * @generated from field: string sql_mode = 7;
   */
  sqlMode: string;

  /**
   * @generated from field: bool skip_dump = 8;
   */
  skipDump: boolean;
};

/**
 * Describes the message bytebase.v1.ProcedureMetadata.
 * Use `create(ProcedureMetadataSchema)` to create a new message.
 */
export declare const ProcedureMetadataSchema: GenMessage<ProcedureMetadata>;

/**
 * PackageMetadata is the metadata for packages.
 *
 * @generated from message bytebase.v1.PackageMetadata
 */
export declare type PackageMetadata = Message<"bytebase.v1.PackageMetadata"> & {
  /**
   * The name is the name of a package.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The definition is the definition of a package.
   *
   * @generated from field: string definition = 2;
   */
  definition: string;
};

/**
 * Describes the message bytebase.v1.PackageMetadata.
 * Use `create(PackageMetadataSchema)` to create a new message.
 */
export declare const PackageMetadataSchema: GenMessage<PackageMetadata>;

/**
 * @generated from message bytebase.v1.TaskMetadata
 */
export declare type TaskMetadata = Message<"bytebase.v1.TaskMetadata"> & {
  /**
   * The name is the name of a task.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The id is the snowflake-generated id of a task.
   * Example: 01ad32a0-1bb6-5e93-0000-000000000001
   *
   * @generated from field: string id = 2;
   */
  id: string;

  /**
   * The owner of the task.
   *
   * @generated from field: string owner = 3;
   */
  owner: string;

  /**
   * The comment of the task.
   *
   * @generated from field: string comment = 4;
   */
  comment: string;

  /**
   * The warehouse of the task.
   *
   * @generated from field: string warehouse = 5;
   */
  warehouse: string;

  /**
   * The schedule interval of the task.
   *
   * @generated from field: string schedule = 6;
   */
  schedule: string;

  /**
   * The predecessor tasks of the task.
   *
   * @generated from field: repeated string predecessors = 7;
   */
  predecessors: string[];

  /**
   * The state of the task.
   *
   * @generated from field: bytebase.v1.TaskMetadata.State state = 8;
   */
  state: TaskMetadata_State;

  /**
   * The condition of the task.
   *
   * @generated from field: string condition = 9;
   */
  condition: string;

  /**
   * The definition of the task.
   *
   * @generated from field: string definition = 10;
   */
  definition: string;
};

/**
 * Describes the message bytebase.v1.TaskMetadata.
 * Use `create(TaskMetadataSchema)` to create a new message.
 */
export declare const TaskMetadataSchema: GenMessage<TaskMetadata>;

/**
 * @generated from enum bytebase.v1.TaskMetadata.State
 */
export enum TaskMetadata_State {
  /**
   * @generated from enum value: STATE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: STATE_STARTED = 1;
   */
  STARTED = 1,

  /**
   * @generated from enum value: STATE_SUSPENDED = 2;
   */
  SUSPENDED = 2,
}

/**
 * Describes the enum bytebase.v1.TaskMetadata.State.
 */
export declare const TaskMetadata_StateSchema: GenEnum<TaskMetadata_State>;

/**
 * @generated from message bytebase.v1.StreamMetadata
 */
export declare type StreamMetadata = Message<"bytebase.v1.StreamMetadata"> & {
  /**
   * The name is the name of a stream.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The table_name is the name of the table/view that the stream is created on.
   *
   * @generated from field: string table_name = 2;
   */
  tableName: string;

  /**
   * The owner of the stream.
   *
   * @generated from field: string owner = 3;
   */
  owner: string;

  /**
   * The comment of the stream.
   *
   * @generated from field: string comment = 4;
   */
  comment: string;

  /**
   * The type of the stream.
   *
   * @generated from field: bytebase.v1.StreamMetadata.Type type = 5;
   */
  type: StreamMetadata_Type;

  /**
   * Indicates whether the stream was last read before the `stale_after` time.
   *
   * @generated from field: bool stale = 6;
   */
  stale: boolean;

  /**
   * The mode of the stream.
   *
   * @generated from field: bytebase.v1.StreamMetadata.Mode mode = 7;
   */
  mode: StreamMetadata_Mode;

  /**
   * The definition of the stream.
   *
   * @generated from field: string definition = 8;
   */
  definition: string;
};

/**
 * Describes the message bytebase.v1.StreamMetadata.
 * Use `create(StreamMetadataSchema)` to create a new message.
 */
export declare const StreamMetadataSchema: GenMessage<StreamMetadata>;

/**
 * @generated from enum bytebase.v1.StreamMetadata.Type
 */
export enum StreamMetadata_Type {
  /**
   * @generated from enum value: TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: TYPE_DELTA = 1;
   */
  DELTA = 1,
}

/**
 * Describes the enum bytebase.v1.StreamMetadata.Type.
 */
export declare const StreamMetadata_TypeSchema: GenEnum<StreamMetadata_Type>;

/**
 * @generated from enum bytebase.v1.StreamMetadata.Mode
 */
export enum StreamMetadata_Mode {
  /**
   * @generated from enum value: MODE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: MODE_DEFAULT = 1;
   */
  DEFAULT = 1,

  /**
   * @generated from enum value: MODE_APPEND_ONLY = 2;
   */
  APPEND_ONLY = 2,

  /**
   * @generated from enum value: MODE_INSERT_ONLY = 3;
   */
  INSERT_ONLY = 3,
}

/**
 * Describes the enum bytebase.v1.StreamMetadata.Mode.
 */
export declare const StreamMetadata_ModeSchema: GenEnum<StreamMetadata_Mode>;

/**
 * IndexMetadata is the metadata for indexes.
 *
 * @generated from message bytebase.v1.IndexMetadata
 */
export declare type IndexMetadata = Message<"bytebase.v1.IndexMetadata"> & {
  /**
   * The name is the name of an index.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The expressions are the ordered columns or expressions of an index.
   * This could refer to a column or an expression.
   *
   * @generated from field: repeated string expressions = 2;
   */
  expressions: string[];

  /**
   * The key_lengths are the ordered key lengths of an index.
   * If the key length is not specified, it's -1.
   *
   * @generated from field: repeated int64 key_length = 9;
   */
  keyLength: bigint[];

  /**
   * The descending is the ordered descending of an index.
   *
   * @generated from field: repeated bool descending = 10;
   */
  descending: boolean[];

  /**
   * The type is the type of an index.
   *
   * @generated from field: string type = 3;
   */
  type: string;

  /**
   * The unique is whether the index is unique.
   *
   * @generated from field: bool unique = 4;
   */
  unique: boolean;

  /**
   * The primary is whether the index is a primary key index.
   *
   * @generated from field: bool primary = 5;
   */
  primary: boolean;

  /**
   * The visible is whether the index is visible.
   *
   * @generated from field: bool visible = 6;
   */
  visible: boolean;

  /**
   * The comment is the comment of an index.
   *
   * @generated from field: string comment = 7;
   */
  comment: string;

  /**
   * The definition of an index.
   *
   * @generated from field: string definition = 8;
   */
  definition: string;

  /**
   * The schema name of the parent index.
   *
   * @generated from field: string parent_index_schema = 11;
   */
  parentIndexSchema: string;

  /**
   * The index name of the parent index.
   *
   * @generated from field: string parent_index_name = 12;
   */
  parentIndexName: string;

  /**
   * The number of granules in the block. It's a ClickHouse specific field.
   *
   * @generated from field: int64 granularity = 13;
   */
  granularity: bigint;

  /**
   * It's a PostgreSQL specific field.
   * The unique constraint and unique index are not the same thing in PostgreSQL.
   *
   * @generated from field: bool is_constraint = 14;
   */
  isConstraint: boolean;
};

/**
 * Describes the message bytebase.v1.IndexMetadata.
 * Use `create(IndexMetadataSchema)` to create a new message.
 */
export declare const IndexMetadataSchema: GenMessage<IndexMetadata>;

/**
 * ExtensionMetadata is the metadata for extensions.
 *
 * @generated from message bytebase.v1.ExtensionMetadata
 */
export declare type ExtensionMetadata = Message<"bytebase.v1.ExtensionMetadata"> & {
  /**
   * The name is the name of an extension.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The schema is the extension that is installed to. But the extension usage
   * is not limited to the schema.
   *
   * @generated from field: string schema = 2;
   */
  schema: string;

  /**
   * The version is the version of an extension.
   *
   * @generated from field: string version = 3;
   */
  version: string;

  /**
   * The description is the description of an extension.
   *
   * @generated from field: string description = 4;
   */
  description: string;
};

/**
 * Describes the message bytebase.v1.ExtensionMetadata.
 * Use `create(ExtensionMetadataSchema)` to create a new message.
 */
export declare const ExtensionMetadataSchema: GenMessage<ExtensionMetadata>;

/**
 * ForeignKeyMetadata is the metadata for foreign keys.
 *
 * @generated from message bytebase.v1.ForeignKeyMetadata
 */
export declare type ForeignKeyMetadata = Message<"bytebase.v1.ForeignKeyMetadata"> & {
  /**
   * The name is the name of a foreign key.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The columns are the ordered referencing columns of a foreign key.
   *
   * @generated from field: repeated string columns = 2;
   */
  columns: string[];

  /**
   * The referenced_schema is the referenced schema name of a foreign key.
   * It is an empty string for databases without such concept such as MySQL.
   *
   * @generated from field: string referenced_schema = 3;
   */
  referencedSchema: string;

  /**
   * The referenced_table is the referenced table name of a foreign key.
   *
   * @generated from field: string referenced_table = 4;
   */
  referencedTable: string;

  /**
   * The referenced_columns are the ordered referenced columns of a foreign key.
   *
   * @generated from field: repeated string referenced_columns = 5;
   */
  referencedColumns: string[];

  /**
   * The on_delete is the on delete action of a foreign key.
   *
   * @generated from field: string on_delete = 6;
   */
  onDelete: string;

  /**
   * The on_update is the on update action of a foreign key.
   *
   * @generated from field: string on_update = 7;
   */
  onUpdate: string;

  /**
   * The match_type is the match type of a foreign key.
   * The match_type is the PostgreSQL specific field.
   * It's empty string for other databases.
   *
   * @generated from field: string match_type = 8;
   */
  matchType: string;
};

/**
 * Describes the message bytebase.v1.ForeignKeyMetadata.
 * Use `create(ForeignKeyMetadataSchema)` to create a new message.
 */
export declare const ForeignKeyMetadataSchema: GenMessage<ForeignKeyMetadata>;

/**
 * DatabaseSchema is the metadata for databases.
 *
 * @generated from message bytebase.v1.DatabaseSchema
 */
export declare type DatabaseSchema = Message<"bytebase.v1.DatabaseSchema"> & {
  /**
   * The schema dump from database.
   *
   * @generated from field: string schema = 1;
   */
  schema: string;
};

/**
 * Describes the message bytebase.v1.DatabaseSchema.
 * Use `create(DatabaseSchemaSchema)` to create a new message.
 */
export declare const DatabaseSchemaSchema: GenMessage<DatabaseSchema>;

/**
 * @generated from message bytebase.v1.ListSecretsRequest
 */
export declare type ListSecretsRequest = Message<"bytebase.v1.ListSecretsRequest"> & {
  /**
   * The parent of the secret.
   * Format: instances/{instance}/databases/{database}
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * Not used.
   * The maximum number of secrets to return. The service may return fewer than
   * this value.
   * If unspecified, at most 10 secrets will be returned.
   * The maximum value is 1000; values above 1000 will be coerced to 1000.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize: number;

  /**
   * Not used.
   * A page token, received from a previous `ListSecrets` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListSecrets` must match
   * the call that provided the page token.
   *
   * @generated from field: string page_token = 3;
   */
  pageToken: string;
};

/**
 * Describes the message bytebase.v1.ListSecretsRequest.
 * Use `create(ListSecretsRequestSchema)` to create a new message.
 */
export declare const ListSecretsRequestSchema: GenMessage<ListSecretsRequest>;

/**
 * @generated from message bytebase.v1.ListSecretsResponse
 */
export declare type ListSecretsResponse = Message<"bytebase.v1.ListSecretsResponse"> & {
  /**
   * The list of secrets.
   *
   * @generated from field: repeated bytebase.v1.Secret secrets = 1;
   */
  secrets: Secret[];

  /**
   * Not used. A token, which can be sent as `page_token` to retrieve the next
   * page. If this field is omitted, there are no subsequent pages.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message bytebase.v1.ListSecretsResponse.
 * Use `create(ListSecretsResponseSchema)` to create a new message.
 */
export declare const ListSecretsResponseSchema: GenMessage<ListSecretsResponse>;

/**
 * @generated from message bytebase.v1.UpdateSecretRequest
 */
export declare type UpdateSecretRequest = Message<"bytebase.v1.UpdateSecretRequest"> & {
  /**
   * The secret to be created or updated.
   *
   * @generated from field: bytebase.v1.Secret secret = 1;
   */
  secret?: Secret;

  /**
   * The mask of the fields to be updated.
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 2;
   */
  updateMask?: FieldMask;

  /**
   * If true, the secret will be created if it does not exist.
   *
   * @generated from field: bool allow_missing = 3;
   */
  allowMissing: boolean;
};

/**
 * Describes the message bytebase.v1.UpdateSecretRequest.
 * Use `create(UpdateSecretRequestSchema)` to create a new message.
 */
export declare const UpdateSecretRequestSchema: GenMessage<UpdateSecretRequest>;

/**
 * @generated from message bytebase.v1.DeleteSecretRequest
 */
export declare type DeleteSecretRequest = Message<"bytebase.v1.DeleteSecretRequest"> & {
  /**
   * The name of the secret to be deleted.
   * Format:
   * instances/{instance}/databases/{database}/secrets/{secret}
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message bytebase.v1.DeleteSecretRequest.
 * Use `create(DeleteSecretRequestSchema)` to create a new message.
 */
export declare const DeleteSecretRequestSchema: GenMessage<DeleteSecretRequest>;

/**
 * Secret is the secret of the database now.
 *
 * @generated from message bytebase.v1.Secret
 */
export declare type Secret = Message<"bytebase.v1.Secret"> & {
  /**
   * name is the unique name of the secret, which is specified by the client.
   * Format:
   * instances/{instance}/databases/{database}/secrets/{secret}
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Not used. The timestamp when the secret resource was created initially.
   *
   * @generated from field: google.protobuf.Timestamp created_time = 2;
   */
  createdTime?: Timestamp;

  /**
   * Not used. The timestamp when the secret resource was updated.
   *
   * @generated from field: google.protobuf.Timestamp updated_time = 3;
   */
  updatedTime?: Timestamp;

  /**
   * The value of the secret.
   *
   * @generated from field: string value = 4;
   */
  value: string;

  /**
   * The description of the secret.
   *
   * @generated from field: string description = 5;
   */
  description: string;
};

/**
 * Describes the message bytebase.v1.Secret.
 * Use `create(SecretSchema)` to create a new message.
 */
export declare const SecretSchema: GenMessage<Secret>;

/**
 * @generated from message bytebase.v1.ChangedResources
 */
export declare type ChangedResources = Message<"bytebase.v1.ChangedResources"> & {
  /**
   * @generated from field: repeated bytebase.v1.ChangedResourceDatabase databases = 1;
   */
  databases: ChangedResourceDatabase[];
};

/**
 * Describes the message bytebase.v1.ChangedResources.
 * Use `create(ChangedResourcesSchema)` to create a new message.
 */
export declare const ChangedResourcesSchema: GenMessage<ChangedResources>;

/**
 * @generated from message bytebase.v1.ChangedResourceDatabase
 */
export declare type ChangedResourceDatabase = Message<"bytebase.v1.ChangedResourceDatabase"> & {
  /**
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: repeated bytebase.v1.ChangedResourceSchema schemas = 2;
   */
  schemas: ChangedResourceSchema[];
};

/**
 * Describes the message bytebase.v1.ChangedResourceDatabase.
 * Use `create(ChangedResourceDatabaseSchema)` to create a new message.
 */
export declare const ChangedResourceDatabaseSchema: GenMessage<ChangedResourceDatabase>;

/**
 * @generated from message bytebase.v1.ChangedResourceSchema
 */
export declare type ChangedResourceSchema = Message<"bytebase.v1.ChangedResourceSchema"> & {
  /**
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: repeated bytebase.v1.ChangedResourceTable tables = 2;
   */
  tables: ChangedResourceTable[];

  /**
   * @generated from field: repeated bytebase.v1.ChangedResourceView views = 3;
   */
  views: ChangedResourceView[];

  /**
   * @generated from field: repeated bytebase.v1.ChangedResourceFunction functions = 4;
   */
  functions: ChangedResourceFunction[];

  /**
   * @generated from field: repeated bytebase.v1.ChangedResourceProcedure procedures = 5;
   */
  procedures: ChangedResourceProcedure[];
};

/**
 * Describes the message bytebase.v1.ChangedResourceSchema.
 * Use `create(ChangedResourceSchemaSchema)` to create a new message.
 */
export declare const ChangedResourceSchemaSchema: GenMessage<ChangedResourceSchema>;

/**
 * @generated from message bytebase.v1.ChangedResourceTable
 */
export declare type ChangedResourceTable = Message<"bytebase.v1.ChangedResourceTable"> & {
  /**
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The ranges of sub-strings correspond to the statements on the sheet.
   *
   * @generated from field: repeated bytebase.v1.Range ranges = 3;
   */
  ranges: Range[];
};

/**
 * Describes the message bytebase.v1.ChangedResourceTable.
 * Use `create(ChangedResourceTableSchema)` to create a new message.
 */
export declare const ChangedResourceTableSchema: GenMessage<ChangedResourceTable>;

/**
 * @generated from message bytebase.v1.ChangedResourceView
 */
export declare type ChangedResourceView = Message<"bytebase.v1.ChangedResourceView"> & {
  /**
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The ranges of sub-strings correspond to the statements on the sheet.
   *
   * @generated from field: repeated bytebase.v1.Range ranges = 2;
   */
  ranges: Range[];
};

/**
 * Describes the message bytebase.v1.ChangedResourceView.
 * Use `create(ChangedResourceViewSchema)` to create a new message.
 */
export declare const ChangedResourceViewSchema: GenMessage<ChangedResourceView>;

/**
 * @generated from message bytebase.v1.ChangedResourceFunction
 */
export declare type ChangedResourceFunction = Message<"bytebase.v1.ChangedResourceFunction"> & {
  /**
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The ranges of sub-strings correspond to the statements on the sheet.
   *
   * @generated from field: repeated bytebase.v1.Range ranges = 2;
   */
  ranges: Range[];
};

/**
 * Describes the message bytebase.v1.ChangedResourceFunction.
 * Use `create(ChangedResourceFunctionSchema)` to create a new message.
 */
export declare const ChangedResourceFunctionSchema: GenMessage<ChangedResourceFunction>;

/**
 * @generated from message bytebase.v1.ChangedResourceProcedure
 */
export declare type ChangedResourceProcedure = Message<"bytebase.v1.ChangedResourceProcedure"> & {
  /**
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The ranges of sub-strings correspond to the statements on the sheet.
   *
   * @generated from field: repeated bytebase.v1.Range ranges = 2;
   */
  ranges: Range[];
};

/**
 * Describes the message bytebase.v1.ChangedResourceProcedure.
 * Use `create(ChangedResourceProcedureSchema)` to create a new message.
 */
export declare const ChangedResourceProcedureSchema: GenMessage<ChangedResourceProcedure>;

/**
 * @generated from message bytebase.v1.ListChangelogsRequest
 */
export declare type ListChangelogsRequest = Message<"bytebase.v1.ListChangelogsRequest"> & {
  /**
   * The parent of the changelogs.
   * Format: instances/{instance}/databases/{database}
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * The maximum number of changelogs to return. The service may return fewer
   * than this value. If unspecified, at most 10 changelogs will be returned.
   * The maximum value is 1000; values above 1000 will be coerced to 1000.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize: number;

  /**
   * A page token, received from the previous call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided must match
   * the call that provided the page token.
   *
   * @generated from field: string page_token = 3;
   */
  pageToken: string;

  /**
   * @generated from field: bytebase.v1.ChangelogView view = 4;
   */
  view: ChangelogView;

  /**
   * The filter of the changelogs.
   * follow the
   * [ebnf](https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form)
   * syntax. Support filter by type, source or table. For example: table =
   * "tableExists('{database}', '{schema}', '{table}')" table =
   * "tableExists('db', 'public', 'table1') || tableExists('db', 'public',
   * 'table2')"
   *
   * The table filter follow the CEL syntax.
   * currently, we have one function for CEL:
   * - tableExists(database, schema, table): return true if the table exists in
   * changed resources.
   *
   * examples:
   * Use
   *   tableExists("db", "public", "table1")
   * to filter the changelogs which have the table "table1" in the schema
   * "public" of the database "db". For MySQL, the schema is always "", such as
   * tableExists("db", "", "table1").
   *
   * Combine multiple functions with "&&" and "||", we MUST use the Disjunctive
   * Normal Form(DNF). In other words, the CEL expression consists of several
   * parts connected by OR operators. For example, the following expression is
   * valid:
   * (
   *  tableExists("db", "public", "table1") &&
   *  tableExists("db", "public", "table2")
   * ) || (
   *  tableExists("db", "public", "table3")
   * )
   *
   * @generated from field: string filter = 5;
   */
  filter: string;
};

/**
 * Describes the message bytebase.v1.ListChangelogsRequest.
 * Use `create(ListChangelogsRequestSchema)` to create a new message.
 */
export declare const ListChangelogsRequestSchema: GenMessage<ListChangelogsRequest>;

/**
 * @generated from message bytebase.v1.ListChangelogsResponse
 */
export declare type ListChangelogsResponse = Message<"bytebase.v1.ListChangelogsResponse"> & {
  /**
   * The list of changelogs.
   *
   * @generated from field: repeated bytebase.v1.Changelog changelogs = 1;
   */
  changelogs: Changelog[];

  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message bytebase.v1.ListChangelogsResponse.
 * Use `create(ListChangelogsResponseSchema)` to create a new message.
 */
export declare const ListChangelogsResponseSchema: GenMessage<ListChangelogsResponse>;

/**
 * @generated from message bytebase.v1.GetChangelogRequest
 */
export declare type GetChangelogRequest = Message<"bytebase.v1.GetChangelogRequest"> & {
  /**
   * The name of the changelog to retrieve.
   * Format: instances/{instance}/databases/{database}/changelogs/{changelog}
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: bytebase.v1.ChangelogView view = 2;
   */
  view: ChangelogView;

  /**
   * Format the schema dump into SDL format.
   *
   * @generated from field: bool sdl_format = 3;
   */
  sdlFormat: boolean;
};

/**
 * Describes the message bytebase.v1.GetChangelogRequest.
 * Use `create(GetChangelogRequestSchema)` to create a new message.
 */
export declare const GetChangelogRequestSchema: GenMessage<GetChangelogRequest>;

/**
 * @generated from message bytebase.v1.Changelog
 */
export declare type Changelog = Message<"bytebase.v1.Changelog"> & {
  /**
   * Format: instances/{instance}/databases/{database}/changelogs/{changelog}
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: google.protobuf.Timestamp create_time = 3;
   */
  createTime?: Timestamp;

  /**
   * @generated from field: bytebase.v1.Changelog.Status status = 4;
   */
  status: Changelog_Status;

  /**
   * The statement is used for preview purpose.
   *
   * @generated from field: string statement = 5;
   */
  statement: string;

  /**
   * @generated from field: int64 statement_size = 6;
   */
  statementSize: bigint;

  /**
   * The name of the sheet resource.
   * Format: projects/{project}/sheets/{sheet}
   *
   * @generated from field: string statement_sheet = 7;
   */
  statementSheet: string;

  /**
   * @generated from field: string schema = 8;
   */
  schema: string;

  /**
   * @generated from field: int64 schema_size = 9;
   */
  schemaSize: bigint;

  /**
   * @generated from field: string prev_schema = 10;
   */
  prevSchema: string;

  /**
   * @generated from field: int64 prev_schema_size = 11;
   */
  prevSchemaSize: bigint;

  /**
   * Format: projects/{project}/issues/{issue}
   *
   * @generated from field: string issue = 12;
   */
  issue: string;

  /**
   * Format: projects/{projects}/rollouts/{rollout}/stages/{stage}/tasks/{task}/taskRuns/{taskRun}
   *
   * @generated from field: string task_run = 13;
   */
  taskRun: string;

  /**
   * Could be empty
   *
   * @generated from field: string version = 14;
   */
  version: string;

  /**
   * Could be empty
   * Or present but not found if deleted
   *
   * @generated from field: string revision = 15;
   */
  revision: string;

  /**
   * @generated from field: bytebase.v1.ChangedResources changed_resources = 16;
   */
  changedResources?: ChangedResources;

  /**
   * @generated from field: bytebase.v1.Changelog.Type type = 17;
   */
  type: Changelog_Type;
};

/**
 * Describes the message bytebase.v1.Changelog.
 * Use `create(ChangelogSchema)` to create a new message.
 */
export declare const ChangelogSchema: GenMessage<Changelog>;

/**
 * @generated from enum bytebase.v1.Changelog.Status
 */
export enum Changelog_Status {
  /**
   * @generated from enum value: STATUS_UNSPECIFIED = 0;
   */
  STATUS_UNSPECIFIED = 0,

  /**
   * @generated from enum value: PENDING = 1;
   */
  PENDING = 1,

  /**
   * @generated from enum value: DONE = 2;
   */
  DONE = 2,

  /**
   * @generated from enum value: FAILED = 3;
   */
  FAILED = 3,
}

/**
 * Describes the enum bytebase.v1.Changelog.Status.
 */
export declare const Changelog_StatusSchema: GenEnum<Changelog_Status>;

/**
 * @generated from enum bytebase.v1.Changelog.Type
 */
export enum Changelog_Type {
  /**
   * @generated from enum value: TYPE_UNSPECIFIED = 0;
   */
  TYPE_UNSPECIFIED = 0,

  /**
   * @generated from enum value: BASELINE = 1;
   */
  BASELINE = 1,

  /**
   * @generated from enum value: MIGRATE = 2;
   */
  MIGRATE = 2,

  /**
   * @generated from enum value: MIGRATE_SDL = 3;
   */
  MIGRATE_SDL = 3,

  /**
   * @generated from enum value: MIGRATE_GHOST = 4;
   */
  MIGRATE_GHOST = 4,

  /**
   * @generated from enum value: DATA = 6;
   */
  DATA = 6,
}

/**
 * Describes the enum bytebase.v1.Changelog.Type.
 */
export declare const Changelog_TypeSchema: GenEnum<Changelog_Type>;

/**
 * @generated from message bytebase.v1.GetSchemaStringRequest
 */
export declare type GetSchemaStringRequest = Message<"bytebase.v1.GetSchemaStringRequest"> & {
  /**
   * The name of the database.
   * Format: instances/{instance}/databases/{database}
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: bytebase.v1.GetSchemaStringRequest.ObjectType type = 2;
   */
  type: GetSchemaStringRequest_ObjectType;

  /**
   * It's empty for DATABASE.
   *
   * @generated from field: string schema = 3;
   */
  schema: string;

  /**
   * It's empty for DATABASE and SCHEMA.
   *
   * @generated from field: string object = 4;
   */
  object: string;

  /**
   * If use the metadata to generate the schema string, the type is OBJECT_TYPE_UNSPECIFIED.
   * Also the schema and object are empty.
   *
   * @generated from field: bytebase.v1.DatabaseMetadata metadata = 5;
   */
  metadata?: DatabaseMetadata;
};

/**
 * Describes the message bytebase.v1.GetSchemaStringRequest.
 * Use `create(GetSchemaStringRequestSchema)` to create a new message.
 */
export declare const GetSchemaStringRequestSchema: GenMessage<GetSchemaStringRequest>;

/**
 * @generated from enum bytebase.v1.GetSchemaStringRequest.ObjectType
 */
export enum GetSchemaStringRequest_ObjectType {
  /**
   * @generated from enum value: OBJECT_TYPE_UNSPECIFIED = 0;
   */
  OBJECT_TYPE_UNSPECIFIED = 0,

  /**
   * @generated from enum value: DATABASE = 1;
   */
  DATABASE = 1,

  /**
   * @generated from enum value: SCHEMA = 2;
   */
  SCHEMA = 2,

  /**
   * @generated from enum value: TABLE = 3;
   */
  TABLE = 3,

  /**
   * @generated from enum value: VIEW = 4;
   */
  VIEW = 4,

  /**
   * @generated from enum value: MATERIALIZED_VIEW = 5;
   */
  MATERIALIZED_VIEW = 5,

  /**
   * @generated from enum value: FUNCTION = 6;
   */
  FUNCTION = 6,

  /**
   * @generated from enum value: PROCEDURE = 7;
   */
  PROCEDURE = 7,

  /**
   * @generated from enum value: SEQUENCE = 8;
   */
  SEQUENCE = 8,
}

/**
 * Describes the enum bytebase.v1.GetSchemaStringRequest.ObjectType.
 */
export declare const GetSchemaStringRequest_ObjectTypeSchema: GenEnum<GetSchemaStringRequest_ObjectType>;

/**
 * @generated from message bytebase.v1.GetSchemaStringResponse
 */
export declare type GetSchemaStringResponse = Message<"bytebase.v1.GetSchemaStringResponse"> & {
  /**
   * @generated from field: string schema_string = 1;
   */
  schemaString: string;
};

/**
 * Describes the message bytebase.v1.GetSchemaStringResponse.
 * Use `create(GetSchemaStringResponseSchema)` to create a new message.
 */
export declare const GetSchemaStringResponseSchema: GenMessage<GetSchemaStringResponse>;

/**
 * @generated from enum bytebase.v1.ChangelogView
 */
export enum ChangelogView {
  /**
   * The default / unset value.
   * The API will default to the BASIC view.
   *
   * @generated from enum value: CHANGELOG_VIEW_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: CHANGELOG_VIEW_BASIC = 1;
   */
  BASIC = 1,

  /**
   * @generated from enum value: CHANGELOG_VIEW_FULL = 2;
   */
  FULL = 2,
}

/**
 * Describes the enum bytebase.v1.ChangelogView.
 */
export declare const ChangelogViewSchema: GenEnum<ChangelogView>;

/**
 * @generated from service bytebase.v1.DatabaseService
 */
export declare const DatabaseService: GenService<{
  /**
   * @generated from rpc bytebase.v1.DatabaseService.GetDatabase
   */
  getDatabase: {
    methodKind: "unary";
    input: typeof GetDatabaseRequestSchema;
    output: typeof DatabaseSchema$;
  },
  /**
   * @generated from rpc bytebase.v1.DatabaseService.BatchGetDatabases
   */
  batchGetDatabases: {
    methodKind: "unary";
    input: typeof BatchGetDatabasesRequestSchema;
    output: typeof BatchGetDatabasesResponseSchema;
  },
  /**
   * @generated from rpc bytebase.v1.DatabaseService.ListDatabases
   */
  listDatabases: {
    methodKind: "unary";
    input: typeof ListDatabasesRequestSchema;
    output: typeof ListDatabasesResponseSchema;
  },
  /**
   * @generated from rpc bytebase.v1.DatabaseService.UpdateDatabase
   */
  updateDatabase: {
    methodKind: "unary";
    input: typeof UpdateDatabaseRequestSchema;
    output: typeof DatabaseSchema$;
  },
  /**
   * @generated from rpc bytebase.v1.DatabaseService.BatchUpdateDatabases
   */
  batchUpdateDatabases: {
    methodKind: "unary";
    input: typeof BatchUpdateDatabasesRequestSchema;
    output: typeof BatchUpdateDatabasesResponseSchema;
  },
  /**
   * @generated from rpc bytebase.v1.DatabaseService.SyncDatabase
   */
  syncDatabase: {
    methodKind: "unary";
    input: typeof SyncDatabaseRequestSchema;
    output: typeof SyncDatabaseResponseSchema;
  },
  /**
   * @generated from rpc bytebase.v1.DatabaseService.BatchSyncDatabases
   */
  batchSyncDatabases: {
    methodKind: "unary";
    input: typeof BatchSyncDatabasesRequestSchema;
    output: typeof BatchSyncDatabasesResponseSchema;
  },
  /**
   * @generated from rpc bytebase.v1.DatabaseService.GetDatabaseMetadata
   */
  getDatabaseMetadata: {
    methodKind: "unary";
    input: typeof GetDatabaseMetadataRequestSchema;
    output: typeof DatabaseMetadataSchema;
  },
  /**
   * @generated from rpc bytebase.v1.DatabaseService.GetDatabaseSchema
   */
  getDatabaseSchema: {
    methodKind: "unary";
    input: typeof GetDatabaseSchemaRequestSchema;
    output: typeof DatabaseSchemaSchema;
  },
  /**
   * @generated from rpc bytebase.v1.DatabaseService.DiffSchema
   */
  diffSchema: {
    methodKind: "unary";
    input: typeof DiffSchemaRequestSchema;
    output: typeof DiffSchemaResponseSchema;
  },
  /**
   * @generated from rpc bytebase.v1.DatabaseService.ListSecrets
   */
  listSecrets: {
    methodKind: "unary";
    input: typeof ListSecretsRequestSchema;
    output: typeof ListSecretsResponseSchema;
  },
  /**
   * @generated from rpc bytebase.v1.DatabaseService.UpdateSecret
   */
  updateSecret: {
    methodKind: "unary";
    input: typeof UpdateSecretRequestSchema;
    output: typeof SecretSchema;
  },
  /**
   * @generated from rpc bytebase.v1.DatabaseService.DeleteSecret
   */
  deleteSecret: {
    methodKind: "unary";
    input: typeof DeleteSecretRequestSchema;
    output: typeof EmptySchema;
  },
  /**
   * @generated from rpc bytebase.v1.DatabaseService.ListChangelogs
   */
  listChangelogs: {
    methodKind: "unary";
    input: typeof ListChangelogsRequestSchema;
    output: typeof ListChangelogsResponseSchema;
  },
  /**
   * @generated from rpc bytebase.v1.DatabaseService.GetChangelog
   */
  getChangelog: {
    methodKind: "unary";
    input: typeof GetChangelogRequestSchema;
    output: typeof ChangelogSchema;
  },
  /**
   * @generated from rpc bytebase.v1.DatabaseService.GetSchemaString
   */
  getSchemaString: {
    methodKind: "unary";
    input: typeof GetSchemaStringRequestSchema;
    output: typeof GetSchemaStringResponseSchema;
  },
}>;

