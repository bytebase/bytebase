// @generated by protoc-gen-es v2.5.2
// @generated from file v1/sql_service.proto (package bytebase.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";
import type { Duration, NullValue, Timestamp, Value } from "@bufbuild/protobuf/wkt";
import type { Engine, ExportFormat, Position } from "./common_pb";
import type { DatabaseMetadata } from "./database_service_pb";

/**
 * Describes the file v1/sql_service.proto.
 */
export declare const file_v1_sql_service: GenFile;

/**
 * @generated from message bytebase.v1.AdminExecuteRequest
 */
export declare type AdminExecuteRequest = Message<"bytebase.v1.AdminExecuteRequest"> & {
  /**
   * The name is the instance name to execute the query against.
   * Format: instances/{instance}/databases/{databaseName}
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The SQL statement to execute.
   *
   * @generated from field: string statement = 2;
   */
  statement: string;

  /**
   * The maximum number of rows to return.
   *
   * @generated from field: int32 limit = 3;
   */
  limit: number;

  /**
   * The default schema to execute the statement. Equals to the current schema
   * in Oracle and search path in Postgres.
   *
   * @generated from field: optional string schema = 4;
   */
  schema?: string;

  /**
   * Container is the container name to execute the query against, used for
   * CosmosDB only.
   *
   * @generated from field: optional string container = 5;
   */
  container?: string;
};

/**
 * Describes the message bytebase.v1.AdminExecuteRequest.
 * Use `create(AdminExecuteRequestSchema)` to create a new message.
 */
export declare const AdminExecuteRequestSchema: GenMessage<AdminExecuteRequest>;

/**
 * @generated from message bytebase.v1.AdminExecuteResponse
 */
export declare type AdminExecuteResponse = Message<"bytebase.v1.AdminExecuteResponse"> & {
  /**
   * The query results.
   *
   * @generated from field: repeated bytebase.v1.QueryResult results = 1;
   */
  results: QueryResult[];
};

/**
 * Describes the message bytebase.v1.AdminExecuteResponse.
 * Use `create(AdminExecuteResponseSchema)` to create a new message.
 */
export declare const AdminExecuteResponseSchema: GenMessage<AdminExecuteResponse>;

/**
 * @generated from message bytebase.v1.QueryRequest
 */
export declare type QueryRequest = Message<"bytebase.v1.QueryRequest"> & {
  /**
   * The name is the instance name to execute the query against.
   * Format: instances/{instance}/databases/{databaseName}
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The SQL statement to execute.
   *
   * @generated from field: string statement = 2;
   */
  statement: string;

  /**
   * The maximum number of rows to return.
   *
   * @generated from field: int32 limit = 3;
   */
  limit: number;

  /**
   * The id of data source.
   * It is used for querying admin data source even if the instance has
   * read-only data sources. Or it can be used to query a specific read-only
   * data source.
   *
   * @generated from field: string data_source_id = 4;
   */
  dataSourceId: string;

  /**
   * Explain the statement.
   *
   * @generated from field: bool explain = 5;
   */
  explain: boolean;

  /**
   * The default schema to search objects. Equals to the current schema in
   * Oracle and search path in Postgres.
   *
   * @generated from field: optional string schema = 6;
   */
  schema?: string;

  /**
   * @generated from field: bytebase.v1.QueryOption query_option = 7;
   */
  queryOption?: QueryOption;

  /**
   * Container is the container name to execute the query against, used for
   * CosmosDB only.
   *
   * @generated from field: optional string container = 8;
   */
  container?: string;
};

/**
 * Describes the message bytebase.v1.QueryRequest.
 * Use `create(QueryRequestSchema)` to create a new message.
 */
export declare const QueryRequestSchema: GenMessage<QueryRequest>;

/**
 * @generated from message bytebase.v1.QueryResponse
 */
export declare type QueryResponse = Message<"bytebase.v1.QueryResponse"> & {
  /**
   * The query results.
   *
   * @generated from field: repeated bytebase.v1.QueryResult results = 1;
   */
  results: QueryResult[];
};

/**
 * Describes the message bytebase.v1.QueryResponse.
 * Use `create(QueryResponseSchema)` to create a new message.
 */
export declare const QueryResponseSchema: GenMessage<QueryResponse>;

/**
 * @generated from message bytebase.v1.QueryOption
 */
export declare type QueryOption = Message<"bytebase.v1.QueryOption"> & {
  /**
   * @generated from field: bytebase.v1.QueryOption.RedisRunCommandsOn redis_run_commands_on = 1;
   */
  redisRunCommandsOn: QueryOption_RedisRunCommandsOn;

  /**
   * @generated from field: bytebase.v1.QueryOption.MSSQLExplainFormat mssql_explain_format = 2;
   */
  mssqlExplainFormat: QueryOption_MSSQLExplainFormat;
};

/**
 * Describes the message bytebase.v1.QueryOption.
 * Use `create(QueryOptionSchema)` to create a new message.
 */
export declare const QueryOptionSchema: GenMessage<QueryOption>;

/**
 * @generated from enum bytebase.v1.QueryOption.RedisRunCommandsOn
 */
export enum QueryOption_RedisRunCommandsOn {
  /**
   * UNSPECIFIED defaults to SINGLE_NODE.
   *
   * @generated from enum value: REDIS_RUN_COMMANDS_ON_UNSPECIFIED = 0;
   */
  REDIS_RUN_COMMANDS_ON_UNSPECIFIED = 0,

  /**
   * Execute Redis commands on a single node in the cluster.
   *
   * @generated from enum value: SINGLE_NODE = 1;
   */
  SINGLE_NODE = 1,

  /**
   * Execute Redis commands on all nodes in the cluster for cluster-wide operations.
   *
   * @generated from enum value: ALL_NODES = 2;
   */
  ALL_NODES = 2,
}

/**
 * Describes the enum bytebase.v1.QueryOption.RedisRunCommandsOn.
 */
export declare const QueryOption_RedisRunCommandsOnSchema: GenEnum<QueryOption_RedisRunCommandsOn>;

/**
 * @generated from enum bytebase.v1.QueryOption.MSSQLExplainFormat
 */
export enum QueryOption_MSSQLExplainFormat {
  /**
   * defaults to SHOWPLAN_ALL
   *
   * @generated from enum value: MSSQL_EXPLAIN_FORMAT_UNSPECIFIED = 0;
   */
  MSSQL_EXPLAIN_FORMAT_UNSPECIFIED = 0,

  /**
   * SHOWPLAN_ALL
   *
   * @generated from enum value: MSSQL_EXPLAIN_FORMAT_ALL = 1;
   */
  MSSQL_EXPLAIN_FORMAT_ALL = 1,

  /**
   * SHOWPLAN_XML
   *
   * @generated from enum value: MSSQL_EXPLAIN_FORMAT_XML = 2;
   */
  MSSQL_EXPLAIN_FORMAT_XML = 2,
}

/**
 * Describes the enum bytebase.v1.QueryOption.MSSQLExplainFormat.
 */
export declare const QueryOption_MSSQLExplainFormatSchema: GenEnum<QueryOption_MSSQLExplainFormat>;

/**
 * @generated from message bytebase.v1.QueryResult
 */
export declare type QueryResult = Message<"bytebase.v1.QueryResult"> & {
  /**
   * Column names of the query result.
   *
   * @generated from field: repeated string column_names = 1;
   */
  columnNames: string[];

  /**
   * Column types of the query result.
   * The types come from the Golang SQL driver.
   *
   * @generated from field: repeated string column_type_names = 2;
   */
  columnTypeNames: string[];

  /**
   * Rows of the query result.
   *
   * @generated from field: repeated bytebase.v1.QueryRow rows = 3;
   */
  rows: QueryRow[];

  /**
   * @generated from field: int64 rows_count = 4;
   */
  rowsCount: bigint;

  /**
   * The error message if the query failed.
   *
   * @generated from field: string error = 5;
   */
  error: string;

  /**
   * The time it takes to execute the query.
   *
   * @generated from field: google.protobuf.Duration latency = 6;
   */
  latency?: Duration;

  /**
   * The query statement for the result.
   *
   * @generated from field: string statement = 7;
   */
  statement: string;

  /**
   * @generated from oneof bytebase.v1.QueryResult.detailed_error
   */
  detailedError: {
    /**
     * @generated from field: bytebase.v1.QueryResult.PostgresError postgres_error = 8;
     */
    value: QueryResult_PostgresError;
    case: "postgresError";
  } | {
    /**
     * @generated from field: bytebase.v1.QueryResult.SyntaxError syntax_error = 9;
     */
    value: QueryResult_SyntaxError;
    case: "syntaxError";
  } | {
    /**
     * @generated from field: bytebase.v1.QueryResult.PermissionDenied permission_denied = 10;
     */
    value: QueryResult_PermissionDenied;
    case: "permissionDenied";
  } | { case: undefined; value?: undefined };

  /**
   * Informational or debug messages returned by the database engine during query execution.
   * Examples include PostgreSQL's RAISE NOTICE, MSSQL's PRINT, or Oracle's DBMS_OUTPUT.PUT_LINE.
   *
   * @generated from field: repeated bytebase.v1.QueryResult.Message messages = 11;
   */
  messages: QueryResult_Message[];

  /**
   * Masking reasons for each column (empty for non-masked columns).
   *
   * @generated from field: repeated bytebase.v1.MaskingReason masked = 12;
   */
  masked: MaskingReason[];
};

/**
 * Describes the message bytebase.v1.QueryResult.
 * Use `create(QueryResultSchema)` to create a new message.
 */
export declare const QueryResultSchema: GenMessage<QueryResult>;

/**
 * refer https://www.postgresql.org/docs/11/protocol-error-fields.html
 * for field description.
 *
 * @generated from message bytebase.v1.QueryResult.PostgresError
 */
export declare type QueryResult_PostgresError = Message<"bytebase.v1.QueryResult.PostgresError"> & {
  /**
   * @generated from field: string severity = 1;
   */
  severity: string;

  /**
   * @generated from field: string code = 2;
   */
  code: string;

  /**
   * @generated from field: string message = 3;
   */
  message: string;

  /**
   * @generated from field: string detail = 4;
   */
  detail: string;

  /**
   * @generated from field: string hint = 5;
   */
  hint: string;

  /**
   * @generated from field: int32 position = 6;
   */
  position: number;

  /**
   * @generated from field: int32 internal_position = 7;
   */
  internalPosition: number;

  /**
   * @generated from field: string internal_query = 8;
   */
  internalQuery: string;

  /**
   * @generated from field: string where = 9;
   */
  where: string;

  /**
   * @generated from field: string schema_name = 10;
   */
  schemaName: string;

  /**
   * @generated from field: string table_name = 11;
   */
  tableName: string;

  /**
   * @generated from field: string column_name = 12;
   */
  columnName: string;

  /**
   * @generated from field: string data_type_name = 13;
   */
  dataTypeName: string;

  /**
   * @generated from field: string constraint_name = 14;
   */
  constraintName: string;

  /**
   * @generated from field: string file = 15;
   */
  file: string;

  /**
   * @generated from field: int32 line = 16;
   */
  line: number;

  /**
   * @generated from field: string routine = 17;
   */
  routine: string;
};

/**
 * Describes the message bytebase.v1.QueryResult.PostgresError.
 * Use `create(QueryResult_PostgresErrorSchema)` to create a new message.
 */
export declare const QueryResult_PostgresErrorSchema: GenMessage<QueryResult_PostgresError>;

/**
 * Syntax error with position information for editor highlighting
 *
 * @generated from message bytebase.v1.QueryResult.SyntaxError
 */
export declare type QueryResult_SyntaxError = Message<"bytebase.v1.QueryResult.SyntaxError"> & {
  /**
   * Position information for highlighting in editor
   *
   * @generated from field: bytebase.v1.Position start_position = 1;
   */
  startPosition?: Position;
};

/**
 * Describes the message bytebase.v1.QueryResult.SyntaxError.
 * Use `create(QueryResult_SyntaxErrorSchema)` to create a new message.
 */
export declare const QueryResult_SyntaxErrorSchema: GenMessage<QueryResult_SyntaxError>;

/**
 * Permission denied with resource information or disallowed command_type.
 * Either resources or command_type is available.
 *
 * @generated from message bytebase.v1.QueryResult.PermissionDenied
 */
export declare type QueryResult_PermissionDenied = Message<"bytebase.v1.QueryResult.PermissionDenied"> & {
  /**
   * Denied to access the resources.
   * Format:
   * instances/{instance}/databases/{database}
   * instances/{instance}/databases/{database}/schemas/{schema}
   * instances/{instance}/databases/{database}/tables/{table}
   * instances/{instance}/databases/{database}/schemas/{schema}/tables/{table}
   *
   * @generated from field: repeated string resources = 1;
   */
  resources: string[];

  /**
   * Disallowed command_type.
   *
   * @generated from field: bytebase.v1.QueryResult.PermissionDenied.CommandType command_type = 2;
   */
  commandType: QueryResult_PermissionDenied_CommandType;
};

/**
 * Describes the message bytebase.v1.QueryResult.PermissionDenied.
 * Use `create(QueryResult_PermissionDeniedSchema)` to create a new message.
 */
export declare const QueryResult_PermissionDeniedSchema: GenMessage<QueryResult_PermissionDenied>;

/**
 * @generated from enum bytebase.v1.QueryResult.PermissionDenied.CommandType
 */
export enum QueryResult_PermissionDenied_CommandType {
  /**
   * @generated from enum value: COMMAND_TYPE_UNSPECIFIED = 0;
   */
  COMMAND_TYPE_UNSPECIFIED = 0,

  /**
   * @generated from enum value: DDL = 1;
   */
  DDL = 1,

  /**
   * @generated from enum value: DML = 2;
   */
  DML = 2,

  /**
   * @generated from enum value: NON_READ_ONLY = 3;
   */
  NON_READ_ONLY = 3,
}

/**
 * Describes the enum bytebase.v1.QueryResult.PermissionDenied.CommandType.
 */
export declare const QueryResult_PermissionDenied_CommandTypeSchema: GenEnum<QueryResult_PermissionDenied_CommandType>;

/**
 * @generated from message bytebase.v1.QueryResult.Message
 */
export declare type QueryResult_Message = Message<"bytebase.v1.QueryResult.Message"> & {
  /**
   * @generated from field: bytebase.v1.QueryResult.Message.Level level = 1;
   */
  level: QueryResult_Message_Level;

  /**
   * @generated from field: string content = 2;
   */
  content: string;
};

/**
 * Describes the message bytebase.v1.QueryResult.Message.
 * Use `create(QueryResult_MessageSchema)` to create a new message.
 */
export declare const QueryResult_MessageSchema: GenMessage<QueryResult_Message>;

/**
 * @generated from enum bytebase.v1.QueryResult.Message.Level
 */
export enum QueryResult_Message_Level {
  /**
   * Unspecified message level.
   *
   * @generated from enum value: LEVEL_UNSPECIFIED = 0;
   */
  LEVEL_UNSPECIFIED = 0,

  /**
   * Informational message.
   *
   * @generated from enum value: INFO = 1;
   */
  INFO = 1,

  /**
   * Warning message indicating potential issues.
   *
   * @generated from enum value: WARNING = 2;
   */
  WARNING = 2,

  /**
   * Debug message for development and troubleshooting.
   *
   * @generated from enum value: DEBUG = 3;
   */
  DEBUG = 3,

  /**
   * General log message.
   *
   * @generated from enum value: LOG = 4;
   */
  LOG = 4,

  /**
   * Notice message for important information.
   *
   * @generated from enum value: NOTICE = 5;
   */
  NOTICE = 5,

  /**
   * Exception message indicating error conditions.
   *
   * @generated from enum value: EXCEPTION = 6;
   */
  EXCEPTION = 6,
}

/**
 * Describes the enum bytebase.v1.QueryResult.Message.Level.
 */
export declare const QueryResult_Message_LevelSchema: GenEnum<QueryResult_Message_Level>;

/**
 * @generated from message bytebase.v1.MaskingReason
 */
export declare type MaskingReason = Message<"bytebase.v1.MaskingReason"> & {
  /**
   * The semantic type that triggered masking (e.g., "SSN", "email", "phone").
   *
   * @generated from field: string semantic_type_id = 1;
   */
  semanticTypeId: string;

  /**
   * Human-readable semantic type title.
   *
   * @generated from field: string semantic_type_title = 2;
   */
  semanticTypeTitle: string;

  /**
   * The masking rule ID that matched (if applicable).
   *
   * @generated from field: string masking_rule_id = 3;
   */
  maskingRuleId: string;

  /**
   * The masking algorithm used.
   *
   * @generated from field: string algorithm = 4;
   */
  algorithm: string;

  /**
   * Additional context (e.g., "Matched global rule: PII Protection").
   *
   * @generated from field: string context = 5;
   */
  context: string;

  /**
   * Whether masking was due to classification level.
   *
   * @generated from field: string classification_level = 6;
   */
  classificationLevel: string;

  /**
   * Icon associated with the semantic type (if any).
   *
   * @generated from field: string semantic_type_icon = 7;
   */
  semanticTypeIcon: string;
};

/**
 * Describes the message bytebase.v1.MaskingReason.
 * Use `create(MaskingReasonSchema)` to create a new message.
 */
export declare const MaskingReasonSchema: GenMessage<MaskingReason>;

/**
 * @generated from message bytebase.v1.QueryRow
 */
export declare type QueryRow = Message<"bytebase.v1.QueryRow"> & {
  /**
   * Row values of the query result.
   *
   * @generated from field: repeated bytebase.v1.RowValue values = 1;
   */
  values: RowValue[];
};

/**
 * Describes the message bytebase.v1.QueryRow.
 * Use `create(QueryRowSchema)` to create a new message.
 */
export declare const QueryRowSchema: GenMessage<QueryRow>;

/**
 * @generated from message bytebase.v1.RowValue
 */
export declare type RowValue = Message<"bytebase.v1.RowValue"> & {
  /**
   * @generated from oneof bytebase.v1.RowValue.kind
   */
  kind: {
    /**
     * @generated from field: google.protobuf.NullValue null_value = 1;
     */
    value: NullValue;
    case: "nullValue";
  } | {
    /**
     * @generated from field: bool bool_value = 2;
     */
    value: boolean;
    case: "boolValue";
  } | {
    /**
     * @generated from field: bytes bytes_value = 3;
     */
    value: Uint8Array;
    case: "bytesValue";
  } | {
    /**
     * @generated from field: double double_value = 4;
     */
    value: number;
    case: "doubleValue";
  } | {
    /**
     * @generated from field: float float_value = 5;
     */
    value: number;
    case: "floatValue";
  } | {
    /**
     * @generated from field: int32 int32_value = 6;
     */
    value: number;
    case: "int32Value";
  } | {
    /**
     * @generated from field: int64 int64_value = 7;
     */
    value: bigint;
    case: "int64Value";
  } | {
    /**
     * @generated from field: string string_value = 8;
     */
    value: string;
    case: "stringValue";
  } | {
    /**
     * @generated from field: uint32 uint32_value = 9;
     */
    value: number;
    case: "uint32Value";
  } | {
    /**
     * @generated from field: uint64 uint64_value = 10;
     */
    value: bigint;
    case: "uint64Value";
  } | {
    /**
     * value_value is used for Spanner and TUPLE ARRAY MAP in Clickhouse only.
     *
     * @generated from field: google.protobuf.Value value_value = 11;
     */
    value: Value;
    case: "valueValue";
  } | {
    /**
     * timestamp_value is used for the timestamp without time zone data type,
     * meaning it only includes the timestamp without any time zone or location
     * info. Although it may be expressed as a UTC value, it should be seen as a
     * timestamp missing location context.
     *
     * @generated from field: bytebase.v1.RowValue.Timestamp timestamp_value = 12;
     */
    value: RowValue_Timestamp;
    case: "timestampValue";
  } | {
    /**
     * timestamp_tz_value is used for the timestamptz data type, which
     * accurately represents the timestamp with location information.
     *
     * @generated from field: bytebase.v1.RowValue.TimestampTZ timestamp_tz_value = 13;
     */
    value: RowValue_TimestampTZ;
    case: "timestampTzValue";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message bytebase.v1.RowValue.
 * Use `create(RowValueSchema)` to create a new message.
 */
export declare const RowValueSchema: GenMessage<RowValue>;

/**
 * @generated from message bytebase.v1.RowValue.Timestamp
 */
export declare type RowValue_Timestamp = Message<"bytebase.v1.RowValue.Timestamp"> & {
  /**
   * @generated from field: google.protobuf.Timestamp google_timestamp = 1;
   */
  googleTimestamp?: Timestamp;

  /**
   * The accuracy is the number of digits after the decimal point.
   *
   * @generated from field: int32 accuracy = 2;
   */
  accuracy: number;
};

/**
 * Describes the message bytebase.v1.RowValue.Timestamp.
 * Use `create(RowValue_TimestampSchema)` to create a new message.
 */
export declare const RowValue_TimestampSchema: GenMessage<RowValue_Timestamp>;

/**
 * @generated from message bytebase.v1.RowValue.TimestampTZ
 */
export declare type RowValue_TimestampTZ = Message<"bytebase.v1.RowValue.TimestampTZ"> & {
  /**
   * @generated from field: google.protobuf.Timestamp google_timestamp = 1;
   */
  googleTimestamp?: Timestamp;

  /**
   * Zone is the time zone abbreviations in timezone database such as "PDT",
   * "PST". https://en.wikipedia.org/wiki/List_of_tz_database_time_zones We
   * retrieve the time zone information from the timestamptz field in the
   * database. A timestamp is in UTC or epoch time, and with zone info, we can
   * convert it to a local time string. Zone and offset are returned by
   * time.Time.Zone()
   *
   * @generated from field: string zone = 2;
   */
  zone: string;

  /**
   * The offset is in seconds east of UTC
   *
   * @generated from field: int32 offset = 3;
   */
  offset: number;

  /**
   * @generated from field: int32 accuracy = 4;
   */
  accuracy: number;
};

/**
 * Describes the message bytebase.v1.RowValue.TimestampTZ.
 * Use `create(RowValue_TimestampTZSchema)` to create a new message.
 */
export declare const RowValue_TimestampTZSchema: GenMessage<RowValue_TimestampTZ>;

/**
 * @generated from message bytebase.v1.Advice
 */
export declare type Advice = Message<"bytebase.v1.Advice"> & {
  /**
   * The advice level.
   *
   * @generated from field: bytebase.v1.Advice.Level status = 1;
   */
  status: Advice_Level;

  /**
   * The advice code.
   *
   * @generated from field: int32 code = 2;
   */
  code: number;

  /**
   * The advice title.
   *
   * @generated from field: string title = 3;
   */
  title: string;

  /**
   * The advice content.
   *
   * @generated from field: string content = 4;
   */
  content: string;

  /**
   * The start_position is inclusive and the end_position is exclusive.
   * TODO: use range instead
   *
   * @generated from field: bytebase.v1.Position start_position = 5;
   */
  startPosition?: Position;

  /**
   * @generated from field: bytebase.v1.Position end_position = 6;
   */
  endPosition?: Position;

  /**
   * The type of linting rule that generated this advice.
   *
   * @generated from field: bytebase.v1.Advice.RuleType rule_type = 7;
   */
  ruleType: Advice_RuleType;
};

/**
 * Describes the message bytebase.v1.Advice.
 * Use `create(AdviceSchema)` to create a new message.
 */
export declare const AdviceSchema: GenMessage<Advice>;

/**
 * Level represents the severity level of the advice.
 *
 * @generated from enum bytebase.v1.Advice.Level
 */
export enum Advice_Level {
  /**
   * Unspecified advice level.
   *
   * @generated from enum value: ADVICE_LEVEL_UNSPECIFIED = 0;
   */
  ADVICE_LEVEL_UNSPECIFIED = 0,

  /**
   * Success status indicating the check passed without issues.
   *
   * @generated from enum value: SUCCESS = 1;
   */
  SUCCESS = 1,

  /**
   * Warning status indicating potential issues that should be reviewed.
   *
   * @generated from enum value: WARNING = 2;
   */
  WARNING = 2,

  /**
   * Error status indicating critical issues that must be addressed.
   *
   * @generated from enum value: ERROR = 3;
   */
  ERROR = 3,
}

/**
 * Describes the enum bytebase.v1.Advice.Level.
 */
export declare const Advice_LevelSchema: GenEnum<Advice_Level>;

/**
 * RuleType indicates the source of the linting rule.
 *
 * @generated from enum bytebase.v1.Advice.RuleType
 */
export enum Advice_RuleType {
  /**
   * Unspecified rule type.
   *
   * @generated from enum value: RULE_TYPE_UNSPECIFIED = 0;
   */
  RULE_TYPE_UNSPECIFIED = 0,

  /**
   * Parser-based rule enforced by the built-in SQL parser.
   * These are non-configurable, mandatory checks for schema health.
   *
   * @generated from enum value: PARSER_BASED = 1;
   */
  PARSER_BASED = 1,

  /**
   * AI-powered rule defined by user in natural language.
   * These are custom, flexible checks powered by AI models.
   *
   * @generated from enum value: AI_POWERED = 2;
   */
  AI_POWERED = 2,
}

/**
 * Describes the enum bytebase.v1.Advice.RuleType.
 */
export declare const Advice_RuleTypeSchema: GenEnum<Advice_RuleType>;

/**
 * @generated from message bytebase.v1.ExportRequest
 */
export declare type ExportRequest = Message<"bytebase.v1.ExportRequest"> & {
  /**
   * The name is the resource name to execute the export against.
   * Format: instances/{instance}/databases/{database}
   * Format: instances/{instance}
   * Format: projects/{project}/rollouts/{rollout}
   * Format: projects/{project}/rollouts/{rollout}/stages/{stage}
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The SQL statement to execute.
   *
   * @generated from field: string statement = 2;
   */
  statement: string;

  /**
   * The maximum number of rows to return.
   *
   * @generated from field: int32 limit = 3;
   */
  limit: number;

  /**
   * The export format.
   *
   * @generated from field: bytebase.v1.ExportFormat format = 4;
   */
  format: ExportFormat;

  /**
   * The admin is used for workspace owner and DBA for exporting data from SQL
   * Editor Admin mode. The exported data is not masked.
   *
   * @generated from field: bool admin = 5;
   */
  admin: boolean;

  /**
   * The zip password provide by users.
   *
   * @generated from field: string password = 6;
   */
  password: string;

  /**
   * The id of data source.
   * It is used for querying admin data source even if the instance has
   * read-only data sources. Or it can be used to query a specific read-only
   * data source.
   *
   * @generated from field: string data_source_id = 7;
   */
  dataSourceId: string;

  /**
   * The default schema to search objects. Equals to the current schema in
   * Oracle and search path in Postgres.
   *
   * @generated from field: optional string schema = 8;
   */
  schema?: string;
};

/**
 * Describes the message bytebase.v1.ExportRequest.
 * Use `create(ExportRequestSchema)` to create a new message.
 */
export declare const ExportRequestSchema: GenMessage<ExportRequest>;

/**
 * @generated from message bytebase.v1.ExportResponse
 */
export declare type ExportResponse = Message<"bytebase.v1.ExportResponse"> & {
  /**
   * The export file content.
   *
   * @generated from field: bytes content = 1;
   */
  content: Uint8Array;
};

/**
 * Describes the message bytebase.v1.ExportResponse.
 * Use `create(ExportResponseSchema)` to create a new message.
 */
export declare const ExportResponseSchema: GenMessage<ExportResponse>;

/**
 * @generated from message bytebase.v1.DiffMetadataRequest
 */
export declare type DiffMetadataRequest = Message<"bytebase.v1.DiffMetadataRequest"> & {
  /**
   * The metadata of the source schema.
   *
   * @generated from field: bytebase.v1.DatabaseMetadata source_metadata = 1;
   */
  sourceMetadata?: DatabaseMetadata;

  /**
   * The metadata of the target schema.
   *
   * @generated from field: bytebase.v1.DatabaseMetadata target_metadata = 2;
   */
  targetMetadata?: DatabaseMetadata;

  /**
   * The database engine of the schema.
   *
   * @generated from field: bytebase.v1.Engine engine = 3;
   */
  engine: Engine;
};

/**
 * Describes the message bytebase.v1.DiffMetadataRequest.
 * Use `create(DiffMetadataRequestSchema)` to create a new message.
 */
export declare const DiffMetadataRequestSchema: GenMessage<DiffMetadataRequest>;

/**
 * @generated from message bytebase.v1.DiffMetadataResponse
 */
export declare type DiffMetadataResponse = Message<"bytebase.v1.DiffMetadataResponse"> & {
  /**
   * The diff of the metadata.
   *
   * @generated from field: string diff = 1;
   */
  diff: string;
};

/**
 * Describes the message bytebase.v1.DiffMetadataResponse.
 * Use `create(DiffMetadataResponseSchema)` to create a new message.
 */
export declare const DiffMetadataResponseSchema: GenMessage<DiffMetadataResponse>;

/**
 * @generated from message bytebase.v1.SearchQueryHistoriesRequest
 */
export declare type SearchQueryHistoriesRequest = Message<"bytebase.v1.SearchQueryHistoriesRequest"> & {
  /**
   * The maximum number of histories to return.
   * The service may return fewer than this value.
   * If unspecified, at most 10 history entries will be returned.
   * The maximum value is 1000; values above 1000 will be coerced to 1000.
   *
   * @generated from field: int32 page_size = 1;
   */
  pageSize: number;

  /**
   * A page token, received from a previous `ListQueryHistory` call.
   * Provide this to retrieve the subsequent page.
   *
   * @generated from field: string page_token = 2;
   */
  pageToken: string;

  /**
   * Filter is the filter to apply on the search query history
   * The syntax and semantics of CEL are documented at https://github.com/google/cel-spec
   *
   * Supported filter:
   * - project: the project full name in "projects/{id}" format, support "==" operator.
   * - database: the database full name in "instances/{id}/databases/{name}" format, support "==" operator.
   * - instance: the instance full name in "instances/{id}" format, support "==" operator.
   * - type: the type, should be "QUERY" or "EXPORT", support "==" operator.
   * - statement: the SQL statement, support ".matches()" operator.
   *
   * For example:
   * project == "projects/{project}"
   * database == "instances/{instance}/databases/{database}"
   * instance == "instances/{instance}"
   * type == "QUERY"
   * type == "EXPORT"
   * statement.matches("select")
   * type == "QUERY" && statement.matches("select")
   *
   * @generated from field: string filter = 3;
   */
  filter: string;
};

/**
 * Describes the message bytebase.v1.SearchQueryHistoriesRequest.
 * Use `create(SearchQueryHistoriesRequestSchema)` to create a new message.
 */
export declare const SearchQueryHistoriesRequestSchema: GenMessage<SearchQueryHistoriesRequest>;

/**
 * @generated from message bytebase.v1.SearchQueryHistoriesResponse
 */
export declare type SearchQueryHistoriesResponse = Message<"bytebase.v1.SearchQueryHistoriesResponse"> & {
  /**
   * The list of history.
   *
   * @generated from field: repeated bytebase.v1.QueryHistory query_histories = 1;
   */
  queryHistories: QueryHistory[];

  /**
   * A token to retrieve next page of history.
   * Pass this value in the page_token field in the subsequent call to
   * `ListQueryHistory` method to retrieve the next page of history.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message bytebase.v1.SearchQueryHistoriesResponse.
 * Use `create(SearchQueryHistoriesResponseSchema)` to create a new message.
 */
export declare const SearchQueryHistoriesResponseSchema: GenMessage<SearchQueryHistoriesResponse>;

/**
 * @generated from message bytebase.v1.QueryHistory
 */
export declare type QueryHistory = Message<"bytebase.v1.QueryHistory"> & {
  /**
   * The name for the query history.
   * Format: queryHistories/{uid}
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The database name to execute the query.
   * Format: instances/{instance}/databases/{databaseName}
   *
   * @generated from field: string database = 2;
   */
  database: string;

  /**
   * @generated from field: string creator = 3;
   */
  creator: string;

  /**
   * @generated from field: google.protobuf.Timestamp create_time = 4;
   */
  createTime?: Timestamp;

  /**
   * @generated from field: string statement = 5;
   */
  statement: string;

  /**
   * @generated from field: optional string error = 6;
   */
  error?: string;

  /**
   * @generated from field: google.protobuf.Duration duration = 7;
   */
  duration?: Duration;

  /**
   * @generated from field: bytebase.v1.QueryHistory.Type type = 8;
   */
  type: QueryHistory_Type;
};

/**
 * Describes the message bytebase.v1.QueryHistory.
 * Use `create(QueryHistorySchema)` to create a new message.
 */
export declare const QueryHistorySchema: GenMessage<QueryHistory>;

/**
 * @generated from enum bytebase.v1.QueryHistory.Type
 */
export enum QueryHistory_Type {
  /**
   * Unspecified query history type.
   *
   * @generated from enum value: TYPE_UNSPECIFIED = 0;
   */
  TYPE_UNSPECIFIED = 0,

  /**
   * Query execution for data retrieval.
   *
   * @generated from enum value: QUERY = 1;
   */
  QUERY = 1,

  /**
   * Data export operation to file.
   *
   * @generated from enum value: EXPORT = 2;
   */
  EXPORT = 2,
}

/**
 * Describes the enum bytebase.v1.QueryHistory.Type.
 */
export declare const QueryHistory_TypeSchema: GenEnum<QueryHistory_Type>;

/**
 * @generated from message bytebase.v1.AICompletionRequest
 */
export declare type AICompletionRequest = Message<"bytebase.v1.AICompletionRequest"> & {
  /**
   * @generated from field: repeated bytebase.v1.AICompletionRequest.Message messages = 1;
   */
  messages: AICompletionRequest_Message[];
};

/**
 * Describes the message bytebase.v1.AICompletionRequest.
 * Use `create(AICompletionRequestSchema)` to create a new message.
 */
export declare const AICompletionRequestSchema: GenMessage<AICompletionRequest>;

/**
 * @generated from message bytebase.v1.AICompletionRequest.Message
 */
export declare type AICompletionRequest_Message = Message<"bytebase.v1.AICompletionRequest.Message"> & {
  /**
   * @generated from field: string role = 1;
   */
  role: string;

  /**
   * @generated from field: string content = 2;
   */
  content: string;
};

/**
 * Describes the message bytebase.v1.AICompletionRequest.Message.
 * Use `create(AICompletionRequest_MessageSchema)` to create a new message.
 */
export declare const AICompletionRequest_MessageSchema: GenMessage<AICompletionRequest_Message>;

/**
 * @generated from message bytebase.v1.AICompletionResponse
 */
export declare type AICompletionResponse = Message<"bytebase.v1.AICompletionResponse"> & {
  /**
   * candidates is used for results with multiple choices and candidates. Used
   * for OpenAI and Gemini.
   *
   * @generated from field: repeated bytebase.v1.AICompletionResponse.Candidate candidates = 1;
   */
  candidates: AICompletionResponse_Candidate[];
};

/**
 * Describes the message bytebase.v1.AICompletionResponse.
 * Use `create(AICompletionResponseSchema)` to create a new message.
 */
export declare const AICompletionResponseSchema: GenMessage<AICompletionResponse>;

/**
 * @generated from message bytebase.v1.AICompletionResponse.Candidate
 */
export declare type AICompletionResponse_Candidate = Message<"bytebase.v1.AICompletionResponse.Candidate"> & {
  /**
   * @generated from field: bytebase.v1.AICompletionResponse.Candidate.Content content = 1;
   */
  content?: AICompletionResponse_Candidate_Content;
};

/**
 * Describes the message bytebase.v1.AICompletionResponse.Candidate.
 * Use `create(AICompletionResponse_CandidateSchema)` to create a new message.
 */
export declare const AICompletionResponse_CandidateSchema: GenMessage<AICompletionResponse_Candidate>;

/**
 * @generated from message bytebase.v1.AICompletionResponse.Candidate.Content
 */
export declare type AICompletionResponse_Candidate_Content = Message<"bytebase.v1.AICompletionResponse.Candidate.Content"> & {
  /**
   * parts is used for a result content with multiple parts.
   *
   * @generated from field: repeated bytebase.v1.AICompletionResponse.Candidate.Content.Part parts = 1;
   */
  parts: AICompletionResponse_Candidate_Content_Part[];
};

/**
 * Describes the message bytebase.v1.AICompletionResponse.Candidate.Content.
 * Use `create(AICompletionResponse_Candidate_ContentSchema)` to create a new message.
 */
export declare const AICompletionResponse_Candidate_ContentSchema: GenMessage<AICompletionResponse_Candidate_Content>;

/**
 * @generated from message bytebase.v1.AICompletionResponse.Candidate.Content.Part
 */
export declare type AICompletionResponse_Candidate_Content_Part = Message<"bytebase.v1.AICompletionResponse.Candidate.Content.Part"> & {
  /**
   * @generated from field: string text = 1;
   */
  text: string;
};

/**
 * Describes the message bytebase.v1.AICompletionResponse.Candidate.Content.Part.
 * Use `create(AICompletionResponse_Candidate_Content_PartSchema)` to create a new message.
 */
export declare const AICompletionResponse_Candidate_Content_PartSchema: GenMessage<AICompletionResponse_Candidate_Content_Part>;

/**
 * SQLService executes SQL queries and manages query operations.
 *
 * @generated from service bytebase.v1.SQLService
 */
export declare const SQLService: GenService<{
  /**
   * Executes a read-only SQL query against a database.
   * Permissions required: bb.databases.get
   *
   * @generated from rpc bytebase.v1.SQLService.Query
   */
  query: {
    methodKind: "unary";
    input: typeof QueryRequestSchema;
    output: typeof QueryResponseSchema;
  },
  /**
   * Executes SQL with admin privileges via streaming connection.
   * Permissions required: bb.sql.admin
   *
   * @generated from rpc bytebase.v1.SQLService.AdminExecute
   */
  adminExecute: {
    methodKind: "bidi_streaming";
    input: typeof AdminExecuteRequestSchema;
    output: typeof AdminExecuteResponseSchema;
  },
  /**
   * SearchQueryHistories searches query histories for the caller.
   * Permissions required: None (only returns caller's own query histories)
   *
   * @generated from rpc bytebase.v1.SQLService.SearchQueryHistories
   */
  searchQueryHistories: {
    methodKind: "unary";
    input: typeof SearchQueryHistoriesRequestSchema;
    output: typeof SearchQueryHistoriesResponseSchema;
  },
  /**
   * Exports query results to a file format.
   * Permissions required: bb.databases.get
   *
   * @generated from rpc bytebase.v1.SQLService.Export
   */
  export: {
    methodKind: "unary";
    input: typeof ExportRequestSchema;
    output: typeof ExportResponseSchema;
  },
  /**
   * Computes schema differences between two database metadata.
   * Permissions required: None
   *
   * @generated from rpc bytebase.v1.SQLService.DiffMetadata
   */
  diffMetadata: {
    methodKind: "unary";
    input: typeof DiffMetadataRequestSchema;
    output: typeof DiffMetadataResponseSchema;
  },
  /**
   * Provides AI-powered SQL completion and generation.
   * Permissions required: None (authenticated users only, requires AI to be enabled)
   *
   * @generated from rpc bytebase.v1.SQLService.AICompletion
   */
  aICompletion: {
    methodKind: "unary";
    input: typeof AICompletionRequestSchema;
    output: typeof AICompletionResponseSchema;
  },
}>;

