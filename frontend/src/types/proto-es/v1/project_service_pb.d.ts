// @generated by protoc-gen-es v2.5.2
// @generated from file v1/project_service.proto (package bytebase.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";
import type { EmptySchema, FieldMask } from "@bufbuild/protobuf/wkt";
import type { State, WebhookType } from "./common_pb";
import type { GetIamPolicyRequestSchema, IamPolicySchema, SetIamPolicyRequestSchema } from "./iam_policy_pb";

/**
 * Describes the file v1/project_service.proto.
 */
export declare const file_v1_project_service: GenFile;

/**
 * @generated from message bytebase.v1.GetProjectRequest
 */
export declare type GetProjectRequest = Message<"bytebase.v1.GetProjectRequest"> & {
  /**
   * The name of the project to retrieve.
   * Format: projects/{project}
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message bytebase.v1.GetProjectRequest.
 * Use `create(GetProjectRequestSchema)` to create a new message.
 */
export declare const GetProjectRequestSchema: GenMessage<GetProjectRequest>;

/**
 * @generated from message bytebase.v1.BatchGetProjectsRequest
 */
export declare type BatchGetProjectsRequest = Message<"bytebase.v1.BatchGetProjectsRequest"> & {
  /**
   * The names of projects to retrieve.
   * Format: projects/{project}
   *
   * @generated from field: repeated string names = 1;
   */
  names: string[];
};

/**
 * Describes the message bytebase.v1.BatchGetProjectsRequest.
 * Use `create(BatchGetProjectsRequestSchema)` to create a new message.
 */
export declare const BatchGetProjectsRequestSchema: GenMessage<BatchGetProjectsRequest>;

/**
 * @generated from message bytebase.v1.BatchGetProjectsResponse
 */
export declare type BatchGetProjectsResponse = Message<"bytebase.v1.BatchGetProjectsResponse"> & {
  /**
   * The projects from the specified request.
   *
   * @generated from field: repeated bytebase.v1.Project projects = 1;
   */
  projects: Project[];
};

/**
 * Describes the message bytebase.v1.BatchGetProjectsResponse.
 * Use `create(BatchGetProjectsResponseSchema)` to create a new message.
 */
export declare const BatchGetProjectsResponseSchema: GenMessage<BatchGetProjectsResponse>;

/**
 * @generated from message bytebase.v1.ListProjectsRequest
 */
export declare type ListProjectsRequest = Message<"bytebase.v1.ListProjectsRequest"> & {
  /**
   * The maximum number of projects to return. The service may return fewer than
   * this value.
   * If unspecified, at most 10 projects will be returned.
   * The maximum value is 1000; values above 1000 will be coerced to 1000.
   *
   * @generated from field: int32 page_size = 1;
   */
  pageSize: number;

  /**
   * A page token, received from a previous `ListProjects` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListProjects` must match
   * the call that provided the page token.
   *
   * @generated from field: string page_token = 2;
   */
  pageToken: string;

  /**
   * Show deleted projects if specified.
   *
   * @generated from field: bool show_deleted = 3;
   */
  showDeleted: boolean;

  /**
   * Filter the project.
   * Check filter for SearchProjectsRequest for details.
   * Supports filtering by name, resource_id, state, and labels (e.g., labels.environment == "production").
   *
   * @generated from field: string filter = 4;
   */
  filter: string;

  /**
   * The order by of projects.
   * Support title. The default sorting order is ascending.
   * For example:
   * - order_by = "title"
   * - order_by = "title desc"
   * - order_by = "title asc"
   *
   * @generated from field: string order_by = 5;
   */
  orderBy: string;
};

/**
 * Describes the message bytebase.v1.ListProjectsRequest.
 * Use `create(ListProjectsRequestSchema)` to create a new message.
 */
export declare const ListProjectsRequestSchema: GenMessage<ListProjectsRequest>;

/**
 * @generated from message bytebase.v1.ListProjectsResponse
 */
export declare type ListProjectsResponse = Message<"bytebase.v1.ListProjectsResponse"> & {
  /**
   * The projects from the specified request.
   *
   * @generated from field: repeated bytebase.v1.Project projects = 1;
   */
  projects: Project[];

  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message bytebase.v1.ListProjectsResponse.
 * Use `create(ListProjectsResponseSchema)` to create a new message.
 */
export declare const ListProjectsResponseSchema: GenMessage<ListProjectsResponse>;

/**
 * @generated from message bytebase.v1.SearchProjectsRequest
 */
export declare type SearchProjectsRequest = Message<"bytebase.v1.SearchProjectsRequest"> & {
  /**
   * Show deleted projects if specified.
   *
   * @generated from field: bool show_deleted = 1;
   */
  showDeleted: boolean;

  /**
   * Filter the project.
   * The syntax and semantics of CEL are documented at https://github.com/google/cel-spec
   *
   * Supported filters:
   * - name: the project name, support "==" and ".matches()" operator.
   * - resource_id: the project id, support "==" and ".matches()" operator.
   * - exclude_default: if not include the default project, should be "true" or "false", support "==" operator.
   * - state: check the State enum for the values, support "==" operator.
   * - labels.{key}: the project label, support "==" and "in" operators.
   *
   * For example:
   * name == "project name"
   * name.matches("project name")
   * resource_id == "project id"
   * resource_id.matches("project id")
   * exclude_default == true
   * state == "DELETED"
   * labels.environment == "production"
   * labels.tier == "critical"
   * labels.environment in ["staging", "prod"]
   * You can combine filter conditions like:
   * name == "project name" && resource_id.matches("project id")
   * name.matches("project name") || resource_id == "project id"
   * labels.environment == "production" && labels.tier == "critical"
   *
   * @generated from field: string filter = 2;
   */
  filter: string;

  /**
   * The maximum number of projects to return. The service may return fewer than
   * this value.
   * If unspecified, at most 10 projects will be returned.
   * The maximum value is 1000; values above 1000 will be coerced to 1000.
   *
   * @generated from field: int32 page_size = 3;
   */
  pageSize: number;

  /**
   * A page token, received from a previous `SearchProjects` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `SearchProjects` must match
   * the call that provided the page token.
   *
   * @generated from field: string page_token = 4;
   */
  pageToken: string;

  /**
   * The order by of projects.
   * Support title. The default sorting order is ascending.
   * For example:
   * - order_by = "title"
   * - order_by = "title desc"
   * - order_by = "title asc"
   *
   * @generated from field: string order_by = 5;
   */
  orderBy: string;
};

/**
 * Describes the message bytebase.v1.SearchProjectsRequest.
 * Use `create(SearchProjectsRequestSchema)` to create a new message.
 */
export declare const SearchProjectsRequestSchema: GenMessage<SearchProjectsRequest>;

/**
 * @generated from message bytebase.v1.SearchProjectsResponse
 */
export declare type SearchProjectsResponse = Message<"bytebase.v1.SearchProjectsResponse"> & {
  /**
   * The projects from the specified request.
   *
   * @generated from field: repeated bytebase.v1.Project projects = 1;
   */
  projects: Project[];

  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message bytebase.v1.SearchProjectsResponse.
 * Use `create(SearchProjectsResponseSchema)` to create a new message.
 */
export declare const SearchProjectsResponseSchema: GenMessage<SearchProjectsResponse>;

/**
 * @generated from message bytebase.v1.CreateProjectRequest
 */
export declare type CreateProjectRequest = Message<"bytebase.v1.CreateProjectRequest"> & {
  /**
   * The project to create.
   *
   * @generated from field: bytebase.v1.Project project = 1;
   */
  project?: Project;

  /**
   * The ID to use for the project, which will become the final component of
   * the project's resource name.
   *
   * This value should be 4-63 characters, and valid characters
   * are /[a-z][0-9]-/.
   *
   * @generated from field: string project_id = 2;
   */
  projectId: string;
};

/**
 * Describes the message bytebase.v1.CreateProjectRequest.
 * Use `create(CreateProjectRequestSchema)` to create a new message.
 */
export declare const CreateProjectRequestSchema: GenMessage<CreateProjectRequest>;

/**
 * @generated from message bytebase.v1.UpdateProjectRequest
 */
export declare type UpdateProjectRequest = Message<"bytebase.v1.UpdateProjectRequest"> & {
  /**
   * The project to update.
   *
   * The project's `name` field is used to identify the project to update.
   * Format: projects/{project}
   *
   * @generated from field: bytebase.v1.Project project = 1;
   */
  project?: Project;

  /**
   * The list of fields to update.
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 2;
   */
  updateMask?: FieldMask;

  /**
   * If set to true, and the project is not found, a new project will be created.
   * In this situation, `update_mask` is ignored.
   *
   * @generated from field: bool allow_missing = 3;
   */
  allowMissing: boolean;
};

/**
 * Describes the message bytebase.v1.UpdateProjectRequest.
 * Use `create(UpdateProjectRequestSchema)` to create a new message.
 */
export declare const UpdateProjectRequestSchema: GenMessage<UpdateProjectRequest>;

/**
 * @generated from message bytebase.v1.DeleteProjectRequest
 */
export declare type DeleteProjectRequest = Message<"bytebase.v1.DeleteProjectRequest"> & {
  /**
   * The name of the project to delete.
   * Format: projects/{project}
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * If set to true, any databases from this project will be moved to default project.
   * Sheets are not moved since BYTEBASE_ARTIFACT sheets belong to the issue and issue project.
   * Open issues will remain open but associated with the deleted project.
   * If set to false, the operation will fail if the project has databases or open issues.
   *
   * @generated from field: bool force = 2;
   */
  force: boolean;

  /**
   * If set to true, permanently purge the soft-deleted project and all related resources.
   * This operation is irreversible. Following AIP-165, this should only be used for
   * administrative cleanup of old soft-deleted projects.
   * The project must already be soft-deleted for this to work.
   *
   * @generated from field: bool purge = 3;
   */
  purge: boolean;
};

/**
 * Describes the message bytebase.v1.DeleteProjectRequest.
 * Use `create(DeleteProjectRequestSchema)` to create a new message.
 */
export declare const DeleteProjectRequestSchema: GenMessage<DeleteProjectRequest>;

/**
 * @generated from message bytebase.v1.UndeleteProjectRequest
 */
export declare type UndeleteProjectRequest = Message<"bytebase.v1.UndeleteProjectRequest"> & {
  /**
   * The name of the deleted project.
   * Format: projects/{project}
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message bytebase.v1.UndeleteProjectRequest.
 * Use `create(UndeleteProjectRequestSchema)` to create a new message.
 */
export declare const UndeleteProjectRequestSchema: GenMessage<UndeleteProjectRequest>;

/**
 * @generated from message bytebase.v1.BatchDeleteProjectsRequest
 */
export declare type BatchDeleteProjectsRequest = Message<"bytebase.v1.BatchDeleteProjectsRequest"> & {
  /**
   * The names of the projects to delete.
   * Format: projects/{project}
   *
   * @generated from field: repeated string names = 1;
   */
  names: string[];

  /**
   * If set to true, any databases from this project will be moved to default project.
   * Sheets are not moved since BYTEBASE_ARTIFACT sheets belong to the issue and issue project.
   * Open issues will remain open but associated with the deleted project.
   * If set to false, the operation will fail if the project has databases or open issues.
   *
   * @generated from field: bool force = 2;
   */
  force: boolean;
};

/**
 * Describes the message bytebase.v1.BatchDeleteProjectsRequest.
 * Use `create(BatchDeleteProjectsRequestSchema)` to create a new message.
 */
export declare const BatchDeleteProjectsRequestSchema: GenMessage<BatchDeleteProjectsRequest>;

/**
 * A label for categorizing and organizing issues.
 *
 * @generated from message bytebase.v1.Label
 */
export declare type Label = Message<"bytebase.v1.Label"> & {
  /**
   * The label value/name.
   *
   * @generated from field: string value = 1;
   */
  value: string;

  /**
   * The color code for the label (e.g., hex color).
   *
   * @generated from field: string color = 2;
   */
  color: string;

  /**
   * The group this label belongs to.
   *
   * @generated from field: string group = 3;
   */
  group: string;
};

/**
 * Describes the message bytebase.v1.Label.
 * Use `create(LabelSchema)` to create a new message.
 */
export declare const LabelSchema: GenMessage<Label>;

/**
 * @generated from message bytebase.v1.Project
 */
export declare type Project = Message<"bytebase.v1.Project"> & {
  /**
   * The name of the project.
   * Format: projects/{project}
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The lifecycle state of the project.
   *
   * @generated from field: bytebase.v1.State state = 2;
   */
  state: State;

  /**
   * The title or name of a project. It's not unique within the workspace.
   *
   * @generated from field: string title = 3;
   */
  title: string;

  /**
   * The list of webhooks configured for the project.
   *
   * @generated from field: repeated bytebase.v1.Webhook webhooks = 4;
   */
  webhooks: Webhook[];

  /**
   * The data classification configuration ID for the project.
   *
   * @generated from field: string data_classification_config_id = 5;
   */
  dataClassificationConfigId: string;

  /**
   * Labels available for tagging issues in this project.
   *
   * @generated from field: repeated bytebase.v1.Label issue_labels = 6;
   */
  issueLabels: Label[];

  /**
   * Force issue labels to be used when creating an issue.
   *
   * @generated from field: bool force_issue_labels = 7;
   */
  forceIssueLabels: boolean;

  /**
   * Enforce issue title to be created by user instead of generated by Bytebase.
   *
   * @generated from field: bool enforce_issue_title = 10;
   */
  enforceIssueTitle: boolean;

  /**
   * Whether to automatically enable backup for database changes.
   *
   * @generated from field: bool auto_enable_backup = 11;
   */
  autoEnableBackup: boolean;

  /**
   * Whether to skip backup errors and continue with data migration.
   *
   * @generated from field: bool skip_backup_errors = 12;
   */
  skipBackupErrors: boolean;

  /**
   * Whether to enable database tenant mode for PostgreSQL.
   * If enabled, issues will include "set role <db_owner>" statement.
   *
   * @generated from field: bool postgres_database_tenant_mode = 13;
   */
  postgresDatabaseTenantMode: boolean;

  /**
   * Whether to allow issue creators to self-approve their own issues.
   *
   * @generated from field: bool allow_self_approval = 14;
   */
  allowSelfApproval: boolean;

  /**
   * Execution retry policy for task runs.
   *
   * @generated from field: bytebase.v1.Project.ExecutionRetryPolicy execution_retry_policy = 15;
   */
  executionRetryPolicy?: Project_ExecutionRetryPolicy;

  /**
   * The maximum number of database rows to sample during CI data validation.
   * Without specification, sampling is disabled, resulting in full validation.
   *
   * @generated from field: int32 ci_sampling_size = 16;
   */
  ciSamplingSize: number;

  /**
   * The maximum number of parallel tasks allowed during rollout execution.
   *
   * @generated from field: int32 parallel_tasks_per_rollout = 17;
   */
  parallelTasksPerRollout: number;

  /**
   * Labels are key-value pairs that can be attached to the project.
   * For example, { "environment": "production", "team": "backend" }
   *
   * @generated from field: map<string, string> labels = 18;
   */
  labels: { [key: string]: string };

  /**
   * Whether to enforce SQL review checks to pass before issue creation.
   * If enabled, issues cannot be created when SQL review finds errors.
   *
   * @generated from field: bool enforce_sql_review = 19;
   */
  enforceSqlReview: boolean;

  /**
   * Whether to require issue approval before rollout.
   *
   * @generated from field: bool require_issue_approval = 20;
   */
  requireIssueApproval: boolean;

  /**
   * Whether to require plan check to have no error before rollout.
   *
   * @generated from field: bool require_plan_check_no_error = 21;
   */
  requirePlanCheckNoError: boolean;
};

/**
 * Describes the message bytebase.v1.Project.
 * Use `create(ProjectSchema)` to create a new message.
 */
export declare const ProjectSchema: GenMessage<Project>;

/**
 * Execution retry policy configuration.
 *
 * @generated from message bytebase.v1.Project.ExecutionRetryPolicy
 */
export declare type Project_ExecutionRetryPolicy = Message<"bytebase.v1.Project.ExecutionRetryPolicy"> & {
  /**
   * The maximum number of retries for lock timeout errors.
   *
   * @generated from field: int32 maximum_retries = 1;
   */
  maximumRetries: number;
};

/**
 * Describes the message bytebase.v1.Project.ExecutionRetryPolicy.
 * Use `create(Project_ExecutionRetryPolicySchema)` to create a new message.
 */
export declare const Project_ExecutionRetryPolicySchema: GenMessage<Project_ExecutionRetryPolicy>;

/**
 * @generated from message bytebase.v1.AddWebhookRequest
 */
export declare type AddWebhookRequest = Message<"bytebase.v1.AddWebhookRequest"> & {
  /**
   * The name of the project to add the webhook to.
   * Format: projects/{project}
   *
   * @generated from field: string project = 1;
   */
  project: string;

  /**
   * The webhook to add.
   *
   * @generated from field: bytebase.v1.Webhook webhook = 2;
   */
  webhook?: Webhook;
};

/**
 * Describes the message bytebase.v1.AddWebhookRequest.
 * Use `create(AddWebhookRequestSchema)` to create a new message.
 */
export declare const AddWebhookRequestSchema: GenMessage<AddWebhookRequest>;

/**
 * @generated from message bytebase.v1.UpdateWebhookRequest
 */
export declare type UpdateWebhookRequest = Message<"bytebase.v1.UpdateWebhookRequest"> & {
  /**
   * The webhook to modify.
   *
   * @generated from field: bytebase.v1.Webhook webhook = 1;
   */
  webhook?: Webhook;

  /**
   * The list of fields to update.
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 2;
   */
  updateMask?: FieldMask;

  /**
   * If set to true, and the webhook is not found, a new webhook will be created.
   * In this situation, `update_mask` is ignored.
   *
   * @generated from field: bool allow_missing = 3;
   */
  allowMissing: boolean;
};

/**
 * Describes the message bytebase.v1.UpdateWebhookRequest.
 * Use `create(UpdateWebhookRequestSchema)` to create a new message.
 */
export declare const UpdateWebhookRequestSchema: GenMessage<UpdateWebhookRequest>;

/**
 * @generated from message bytebase.v1.RemoveWebhookRequest
 */
export declare type RemoveWebhookRequest = Message<"bytebase.v1.RemoveWebhookRequest"> & {
  /**
   * The webhook to remove. Identified by its url.
   *
   * @generated from field: bytebase.v1.Webhook webhook = 1;
   */
  webhook?: Webhook;
};

/**
 * Describes the message bytebase.v1.RemoveWebhookRequest.
 * Use `create(RemoveWebhookRequestSchema)` to create a new message.
 */
export declare const RemoveWebhookRequestSchema: GenMessage<RemoveWebhookRequest>;

/**
 * @generated from message bytebase.v1.TestWebhookRequest
 */
export declare type TestWebhookRequest = Message<"bytebase.v1.TestWebhookRequest"> & {
  /**
   * The name of the project which owns the webhook to test.
   * Format: projects/{project}
   *
   * @generated from field: string project = 1;
   */
  project: string;

  /**
   * The webhook to test. Identified by its url.
   *
   * @generated from field: bytebase.v1.Webhook webhook = 2;
   */
  webhook?: Webhook;
};

/**
 * Describes the message bytebase.v1.TestWebhookRequest.
 * Use `create(TestWebhookRequestSchema)` to create a new message.
 */
export declare const TestWebhookRequestSchema: GenMessage<TestWebhookRequest>;

/**
 * @generated from message bytebase.v1.TestWebhookResponse
 */
export declare type TestWebhookResponse = Message<"bytebase.v1.TestWebhookResponse"> & {
  /**
   * The result of the test, empty if the test is successful.
   *
   * @generated from field: string error = 1;
   */
  error: string;
};

/**
 * Describes the message bytebase.v1.TestWebhookResponse.
 * Use `create(TestWebhookResponseSchema)` to create a new message.
 */
export declare const TestWebhookResponseSchema: GenMessage<TestWebhookResponse>;

/**
 * @generated from message bytebase.v1.Webhook
 */
export declare type Webhook = Message<"bytebase.v1.Webhook"> & {
  /**
   * name is the name of the webhook, generated by the server.
   * format: projects/{project}/webhooks/{webhook}
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Webhook integration type.
   * type is the type of the webhook.
   *
   * @generated from field: bytebase.v1.WebhookType type = 2;
   */
  type: WebhookType;

  /**
   * title is the title of the webhook.
   *
   * @generated from field: string title = 3;
   */
  title: string;

  /**
   * url is the url of the webhook, should be unique within the project.
   *
   * @generated from field: string url = 4;
   */
  url: string;

  /**
   * if direct_message is set, the notification is sent directly
   * to the persons and url will be ignored.
   * IM integration setting should be set for this function to work.
   *
   * @generated from field: bool direct_message = 6;
   */
  directMessage: boolean;

  /**
   * notification_types is the list of activities types that the webhook is interested in.
   * Bytebase will only send notifications to the webhook if the activity type is in the list.
   * It should not be empty, and should be a subset of the following:
   * - ISSUE_CREATED
   * - ISSUE_APPROVAL_REQUESTED
   * - ISSUE_SENT_BACK
   * - PIPELINE_FAILED
   * - PIPELINE_COMPLETED
   *
   * @generated from field: repeated bytebase.v1.Activity.Type notification_types = 5;
   */
  notificationTypes: Activity_Type[];
};

/**
 * Describes the message bytebase.v1.Webhook.
 * Use `create(WebhookSchema)` to create a new message.
 */
export declare const WebhookSchema: GenMessage<Webhook>;

/**
 * Activity types for webhook notifications.
 *
 * @generated from message bytebase.v1.Activity
 */
export declare type Activity = Message<"bytebase.v1.Activity"> & {
};

/**
 * Describes the message bytebase.v1.Activity.
 * Use `create(ActivitySchema)` to create a new message.
 */
export declare const ActivitySchema: GenMessage<Activity>;

/**
 * Activity type enumeration.
 *
 * @generated from enum bytebase.v1.Activity.Type
 */
export enum Activity_Type {
  /**
   * Unspecified type.
   *
   * @generated from enum value: TYPE_UNSPECIFIED = 0;
   */
  TYPE_UNSPECIFIED = 0,

  /**
   * ISSUE_CREATED represents a new issue creation event.
   *
   * @generated from enum value: ISSUE_CREATED = 10;
   */
  ISSUE_CREATED = 10,

  /**
   * ISSUE_APPROVAL_REQUESTED represents an approval request event.
   *
   * @generated from enum value: ISSUE_APPROVAL_REQUESTED = 11;
   */
  ISSUE_APPROVAL_REQUESTED = 11,

  /**
   * ISSUE_SENT_BACK represents an issue being sent back by an approver.
   *
   * @generated from enum value: ISSUE_SENT_BACK = 12;
   */
  ISSUE_SENT_BACK = 12,

  /**
   * PIPELINE_FAILED represents a pipeline failure event.
   *
   * @generated from enum value: PIPELINE_FAILED = 13;
   */
  PIPELINE_FAILED = 13,

  /**
   * PIPELINE_COMPLETED represents a pipeline completion event.
   *
   * @generated from enum value: PIPELINE_COMPLETED = 14;
   */
  PIPELINE_COMPLETED = 14,
}

/**
 * Describes the enum bytebase.v1.Activity.Type.
 */
export declare const Activity_TypeSchema: GenEnum<Activity_Type>;

/**
 * ProjectService manages projects that group databases and changes.
 *
 * @generated from service bytebase.v1.ProjectService
 */
export declare const ProjectService: GenService<{
  /**
   * GetProject retrieves a project by name.
   * Users with "bb.projects.get" permission on the workspace or the project owner can access this method.
   * Permissions required: bb.projects.get
   *
   * @generated from rpc bytebase.v1.ProjectService.GetProject
   */
  getProject: {
    methodKind: "unary";
    input: typeof GetProjectRequestSchema;
    output: typeof ProjectSchema;
  },
  /**
   * BatchGetProjects retrieves multiple projects by their names.
   * Permissions required: bb.projects.get
   *
   * @generated from rpc bytebase.v1.ProjectService.BatchGetProjects
   */
  batchGetProjects: {
    methodKind: "unary";
    input: typeof BatchGetProjectsRequestSchema;
    output: typeof BatchGetProjectsResponseSchema;
  },
  /**
   * Lists all projects in the workspace with optional filtering.
   * Permissions required: bb.projects.list
   *
   * @generated from rpc bytebase.v1.ProjectService.ListProjects
   */
  listProjects: {
    methodKind: "unary";
    input: typeof ListProjectsRequestSchema;
    output: typeof ListProjectsResponseSchema;
  },
  /**
   * Searches for projects with advanced filtering capabilities.
   * Permissions required: bb.projects.get (or project-level bb.projects.get for specific projects)
   *
   * @generated from rpc bytebase.v1.ProjectService.SearchProjects
   */
  searchProjects: {
    methodKind: "unary";
    input: typeof SearchProjectsRequestSchema;
    output: typeof SearchProjectsResponseSchema;
  },
  /**
   * Creates a new project in the workspace.
   * Permissions required: bb.projects.create
   *
   * @generated from rpc bytebase.v1.ProjectService.CreateProject
   */
  createProject: {
    methodKind: "unary";
    input: typeof CreateProjectRequestSchema;
    output: typeof ProjectSchema;
  },
  /**
   * Updates an existing project's properties.
   * Permissions required: bb.projects.update
   *
   * @generated from rpc bytebase.v1.ProjectService.UpdateProject
   */
  updateProject: {
    methodKind: "unary";
    input: typeof UpdateProjectRequestSchema;
    output: typeof ProjectSchema;
  },
  /**
   * Deletes (soft-delete or purge) a project.
   * Permissions required: bb.projects.delete
   *
   * @generated from rpc bytebase.v1.ProjectService.DeleteProject
   */
  deleteProject: {
    methodKind: "unary";
    input: typeof DeleteProjectRequestSchema;
    output: typeof EmptySchema;
  },
  /**
   * Restores a soft-deleted project.
   * Permissions required: bb.projects.undelete
   *
   * @generated from rpc bytebase.v1.ProjectService.UndeleteProject
   */
  undeleteProject: {
    methodKind: "unary";
    input: typeof UndeleteProjectRequestSchema;
    output: typeof ProjectSchema;
  },
  /**
   * Deletes multiple projects in a single operation.
   * Permissions required: bb.projects.delete
   *
   * @generated from rpc bytebase.v1.ProjectService.BatchDeleteProjects
   */
  batchDeleteProjects: {
    methodKind: "unary";
    input: typeof BatchDeleteProjectsRequestSchema;
    output: typeof EmptySchema;
  },
  /**
   * Retrieves the IAM policy for a project.
   * Permissions required: bb.projects.getIamPolicy
   *
   * @generated from rpc bytebase.v1.ProjectService.GetIamPolicy
   */
  getIamPolicy: {
    methodKind: "unary";
    input: typeof GetIamPolicyRequestSchema;
    output: typeof IamPolicySchema;
  },
  /**
   * Sets the IAM policy for a project.
   * Permissions required: bb.projects.setIamPolicy
   *
   * @generated from rpc bytebase.v1.ProjectService.SetIamPolicy
   */
  setIamPolicy: {
    methodKind: "unary";
    input: typeof SetIamPolicyRequestSchema;
    output: typeof IamPolicySchema;
  },
  /**
   * Adds a webhook to a project for notifications.
   * Permissions required: bb.projects.update
   *
   * @generated from rpc bytebase.v1.ProjectService.AddWebhook
   */
  addWebhook: {
    methodKind: "unary";
    input: typeof AddWebhookRequestSchema;
    output: typeof ProjectSchema;
  },
  /**
   * Updates an existing webhook configuration.
   * Permissions required: bb.projects.update
   *
   * @generated from rpc bytebase.v1.ProjectService.UpdateWebhook
   */
  updateWebhook: {
    methodKind: "unary";
    input: typeof UpdateWebhookRequestSchema;
    output: typeof ProjectSchema;
  },
  /**
   * Removes a webhook from a project.
   * Permissions required: bb.projects.update
   *
   * @generated from rpc bytebase.v1.ProjectService.RemoveWebhook
   */
  removeWebhook: {
    methodKind: "unary";
    input: typeof RemoveWebhookRequestSchema;
    output: typeof ProjectSchema;
  },
  /**
   * Tests a webhook by sending a test notification.
   * Permissions required: bb.projects.update
   *
   * @generated from rpc bytebase.v1.ProjectService.TestWebhook
   */
  testWebhook: {
    methodKind: "unary";
    input: typeof TestWebhookRequestSchema;
    output: typeof TestWebhookResponseSchema;
  },
}>;

