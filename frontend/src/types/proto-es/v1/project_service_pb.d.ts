// @generated by protoc-gen-es v2.5.2
// @generated from file v1/project_service.proto (package bytebase.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";
import type { EmptySchema, FieldMask } from "@bufbuild/protobuf/wkt";
import type { GetIamPolicyRequestSchema, IamPolicy, IamPolicySchema, SetIamPolicyRequestSchema } from "./iam_policy_pb";
import type { State } from "./common_pb";

/**
 * Describes the file v1/project_service.proto.
 */
export declare const file_v1_project_service: GenFile;

/**
 * @generated from message bytebase.v1.GetProjectRequest
 */
export declare type GetProjectRequest = Message<"bytebase.v1.GetProjectRequest"> & {
  /**
   * The name of the project to retrieve.
   * Format: projects/{project}
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message bytebase.v1.GetProjectRequest.
 * Use `create(GetProjectRequestSchema)` to create a new message.
 */
export declare const GetProjectRequestSchema: GenMessage<GetProjectRequest>;

/**
 * @generated from message bytebase.v1.ListProjectsRequest
 */
export declare type ListProjectsRequest = Message<"bytebase.v1.ListProjectsRequest"> & {
  /**
   * The maximum number of projects to return. The service may return fewer than
   * this value.
   * If unspecified, at most 10 projects will be returned.
   * The maximum value is 1000; values above 1000 will be coerced to 1000.
   *
   * @generated from field: int32 page_size = 1;
   */
  pageSize: number;

  /**
   * A page token, received from a previous `ListProjects` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListProjects` must match
   * the call that provided the page token.
   *
   * @generated from field: string page_token = 2;
   */
  pageToken: string;

  /**
   * Show deleted projects if specified.
   *
   * @generated from field: bool show_deleted = 3;
   */
  showDeleted: boolean;

  /**
   * Filter the project.
   * Check filter for SearchProjectsRequest for details.
   * Supports filtering by name, resource_id, state, and labels (e.g., labels.environment == "production").
   *
   * @generated from field: string filter = 4;
   */
  filter: string;
};

/**
 * Describes the message bytebase.v1.ListProjectsRequest.
 * Use `create(ListProjectsRequestSchema)` to create a new message.
 */
export declare const ListProjectsRequestSchema: GenMessage<ListProjectsRequest>;

/**
 * @generated from message bytebase.v1.ListProjectsResponse
 */
export declare type ListProjectsResponse = Message<"bytebase.v1.ListProjectsResponse"> & {
  /**
   * The projects from the specified request.
   *
   * @generated from field: repeated bytebase.v1.Project projects = 1;
   */
  projects: Project[];

  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message bytebase.v1.ListProjectsResponse.
 * Use `create(ListProjectsResponseSchema)` to create a new message.
 */
export declare const ListProjectsResponseSchema: GenMessage<ListProjectsResponse>;

/**
 * @generated from message bytebase.v1.SearchProjectsRequest
 */
export declare type SearchProjectsRequest = Message<"bytebase.v1.SearchProjectsRequest"> & {
  /**
   * Show deleted projects if specified.
   *
   * @generated from field: bool show_deleted = 1;
   */
  showDeleted: boolean;

  /**
   * Filter the project.
   * The syntax and semantics of CEL are documented at https://github.com/google/cel-spec
   *
   * Supported filters:
   * - name: the project name, support "==" and ".matches()" operator.
   * - resource_id: the project id, support "==" and ".matches()" operator.
   * - exclude_default: if not include the default project, should be "true" or "false", support "==" operator.
   * - state: check the State enum for the values, support "==" operator.
   * - labels.{key}: the project label, support "==" and "in" operators.
   *
   * For example:
   * name = "project name"
   * name.matches("project name")
   * resource_id = "project id"
   * resource_id.matches("project id")
   * exclude_default == true
   * state == "DELETED"
   * labels.environment == "production"
   * labels.tier == "critical"
   * labels.environment in ["staging", "prod"]
   * You can combine filter conditions like:
   * name = "project name" && resource_id.matches("project id")
   * name.matches("project name") || resource_id = "project id"
   * labels.environment == "production" && labels.tier == "critical"
   *
   * @generated from field: string filter = 2;
   */
  filter: string;

  /**
   * The maximum number of projects to return. The service may return fewer than
   * this value.
   * If unspecified, at most 10 projects will be returned.
   * The maximum value is 1000; values above 1000 will be coerced to 1000.
   *
   * @generated from field: int32 page_size = 3;
   */
  pageSize: number;

  /**
   * A page token, received from a previous `SearchProjects` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `SearchProjects` must match
   * the call that provided the page token.
   *
   * @generated from field: string page_token = 4;
   */
  pageToken: string;
};

/**
 * Describes the message bytebase.v1.SearchProjectsRequest.
 * Use `create(SearchProjectsRequestSchema)` to create a new message.
 */
export declare const SearchProjectsRequestSchema: GenMessage<SearchProjectsRequest>;

/**
 * @generated from message bytebase.v1.SearchProjectsResponse
 */
export declare type SearchProjectsResponse = Message<"bytebase.v1.SearchProjectsResponse"> & {
  /**
   * The projects from the specified request.
   *
   * @generated from field: repeated bytebase.v1.Project projects = 1;
   */
  projects: Project[];

  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message bytebase.v1.SearchProjectsResponse.
 * Use `create(SearchProjectsResponseSchema)` to create a new message.
 */
export declare const SearchProjectsResponseSchema: GenMessage<SearchProjectsResponse>;

/**
 * @generated from message bytebase.v1.CreateProjectRequest
 */
export declare type CreateProjectRequest = Message<"bytebase.v1.CreateProjectRequest"> & {
  /**
   * The project to create.
   *
   * @generated from field: bytebase.v1.Project project = 1;
   */
  project?: Project;

  /**
   * The ID to use for the project, which will become the final component of
   * the project's resource name.
   *
   * This value should be 4-63 characters, and valid characters
   * are /[a-z][0-9]-/.
   *
   * @generated from field: string project_id = 2;
   */
  projectId: string;
};

/**
 * Describes the message bytebase.v1.CreateProjectRequest.
 * Use `create(CreateProjectRequestSchema)` to create a new message.
 */
export declare const CreateProjectRequestSchema: GenMessage<CreateProjectRequest>;

/**
 * @generated from message bytebase.v1.UpdateProjectRequest
 */
export declare type UpdateProjectRequest = Message<"bytebase.v1.UpdateProjectRequest"> & {
  /**
   * The project to update.
   *
   * The project's `name` field is used to identify the project to update.
   * Format: projects/{project}
   *
   * @generated from field: bytebase.v1.Project project = 1;
   */
  project?: Project;

  /**
   * The list of fields to update.
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 2;
   */
  updateMask?: FieldMask;

  /**
   * If set to true, and the project is not found, a new project will be created.
   * In this situation, `update_mask` is ignored.
   *
   * @generated from field: bool allow_missing = 3;
   */
  allowMissing: boolean;
};

/**
 * Describes the message bytebase.v1.UpdateProjectRequest.
 * Use `create(UpdateProjectRequestSchema)` to create a new message.
 */
export declare const UpdateProjectRequestSchema: GenMessage<UpdateProjectRequest>;

/**
 * @generated from message bytebase.v1.DeleteProjectRequest
 */
export declare type DeleteProjectRequest = Message<"bytebase.v1.DeleteProjectRequest"> & {
  /**
   * The name of the project to delete.
   * Format: projects/{project}
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * If set to true, any databases from this project will be moved to default project.
   * Sheets are not moved since BYTEBASE_ARTIFACT sheets belong to the issue and issue project.
   * Open issues will remain open but associated with the deleted project.
   * If set to false, the operation will fail if the project has databases or open issues.
   *
   * @generated from field: bool force = 2;
   */
  force: boolean;

  /**
   * If set to true, permanently purge the soft-deleted project and all related resources.
   * This operation is irreversible. Following AIP-165, this should only be used for
   * administrative cleanup of old soft-deleted projects.
   * The project must already be soft-deleted for this to work.
   *
   * @generated from field: bool purge = 3;
   */
  purge: boolean;
};

/**
 * Describes the message bytebase.v1.DeleteProjectRequest.
 * Use `create(DeleteProjectRequestSchema)` to create a new message.
 */
export declare const DeleteProjectRequestSchema: GenMessage<DeleteProjectRequest>;

/**
 * @generated from message bytebase.v1.UndeleteProjectRequest
 */
export declare type UndeleteProjectRequest = Message<"bytebase.v1.UndeleteProjectRequest"> & {
  /**
   * The name of the deleted project.
   * Format: projects/{project}
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message bytebase.v1.UndeleteProjectRequest.
 * Use `create(UndeleteProjectRequestSchema)` to create a new message.
 */
export declare const UndeleteProjectRequestSchema: GenMessage<UndeleteProjectRequest>;

/**
 * @generated from message bytebase.v1.BatchDeleteProjectsRequest
 */
export declare type BatchDeleteProjectsRequest = Message<"bytebase.v1.BatchDeleteProjectsRequest"> & {
  /**
   * The names of the projects to delete.
   * Format: projects/{project}
   *
   * @generated from field: repeated string names = 1;
   */
  names: string[];

  /**
   * If set to true, any databases from this project will be moved to default project.
   * Sheets are not moved since BYTEBASE_ARTIFACT sheets belong to the issue and issue project.
   * Open issues will remain open but associated with the deleted project.
   * If set to false, the operation will fail if the project has databases or open issues.
   *
   * @generated from field: bool force = 2;
   */
  force: boolean;
};

/**
 * Describes the message bytebase.v1.BatchDeleteProjectsRequest.
 * Use `create(BatchDeleteProjectsRequestSchema)` to create a new message.
 */
export declare const BatchDeleteProjectsRequestSchema: GenMessage<BatchDeleteProjectsRequest>;

/**
 * @generated from message bytebase.v1.BatchGetIamPolicyRequest
 */
export declare type BatchGetIamPolicyRequest = Message<"bytebase.v1.BatchGetIamPolicyRequest"> & {
  /**
   * The scope of the batch get. Typically it's "projects/-".
   *
   * @generated from field: string scope = 1;
   */
  scope: string;

  /**
   * @generated from field: repeated string names = 2;
   */
  names: string[];
};

/**
 * Describes the message bytebase.v1.BatchGetIamPolicyRequest.
 * Use `create(BatchGetIamPolicyRequestSchema)` to create a new message.
 */
export declare const BatchGetIamPolicyRequestSchema: GenMessage<BatchGetIamPolicyRequest>;

/**
 * @generated from message bytebase.v1.BatchGetIamPolicyResponse
 */
export declare type BatchGetIamPolicyResponse = Message<"bytebase.v1.BatchGetIamPolicyResponse"> & {
  /**
   * @generated from field: repeated bytebase.v1.BatchGetIamPolicyResponse.PolicyResult policy_results = 1;
   */
  policyResults: BatchGetIamPolicyResponse_PolicyResult[];
};

/**
 * Describes the message bytebase.v1.BatchGetIamPolicyResponse.
 * Use `create(BatchGetIamPolicyResponseSchema)` to create a new message.
 */
export declare const BatchGetIamPolicyResponseSchema: GenMessage<BatchGetIamPolicyResponse>;

/**
 * @generated from message bytebase.v1.BatchGetIamPolicyResponse.PolicyResult
 */
export declare type BatchGetIamPolicyResponse_PolicyResult = Message<"bytebase.v1.BatchGetIamPolicyResponse.PolicyResult"> & {
  /**
   * @generated from field: string project = 1;
   */
  project: string;

  /**
   * @generated from field: bytebase.v1.IamPolicy policy = 2;
   */
  policy?: IamPolicy;
};

/**
 * Describes the message bytebase.v1.BatchGetIamPolicyResponse.PolicyResult.
 * Use `create(BatchGetIamPolicyResponse_PolicyResultSchema)` to create a new message.
 */
export declare const BatchGetIamPolicyResponse_PolicyResultSchema: GenMessage<BatchGetIamPolicyResponse_PolicyResult>;

/**
 * @generated from message bytebase.v1.Label
 */
export declare type Label = Message<"bytebase.v1.Label"> & {
  /**
   * @generated from field: string value = 1;
   */
  value: string;

  /**
   * @generated from field: string color = 2;
   */
  color: string;

  /**
   * @generated from field: string group = 3;
   */
  group: string;
};

/**
 * Describes the message bytebase.v1.Label.
 * Use `create(LabelSchema)` to create a new message.
 */
export declare const LabelSchema: GenMessage<Label>;

/**
 * @generated from message bytebase.v1.Project
 */
export declare type Project = Message<"bytebase.v1.Project"> & {
  /**
   * The name of the project.
   * Format: projects/{project}
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: bytebase.v1.State state = 3;
   */
  state: State;

  /**
   * The title or name of a project. It's not unique within the workspace.
   *
   * @generated from field: string title = 4;
   */
  title: string;

  /**
   * @generated from field: repeated bytebase.v1.Webhook webhooks = 11;
   */
  webhooks: Webhook[];

  /**
   * @generated from field: string data_classification_config_id = 12;
   */
  dataClassificationConfigId: string;

  /**
   * @generated from field: repeated bytebase.v1.Label issue_labels = 13;
   */
  issueLabels: Label[];

  /**
   * Force issue labels to be used when creating an issue.
   *
   * @generated from field: bool force_issue_labels = 14;
   */
  forceIssueLabels: boolean;

  /**
   * Allow modifying statement after issue is created.
   *
   * @generated from field: bool allow_modify_statement = 15;
   */
  allowModifyStatement: boolean;

  /**
   * Enable auto resolve issue.
   *
   * @generated from field: bool auto_resolve_issue = 16;
   */
  autoResolveIssue: boolean;

  /**
   * Enforce issue title created by user instead of generated by Bytebase.
   *
   * @generated from field: bool enforce_issue_title = 17;
   */
  enforceIssueTitle: boolean;

  /**
   * Whether to automatically enable backup.
   *
   * @generated from field: bool auto_enable_backup = 18;
   */
  autoEnableBackup: boolean;

  /**
   * Whether to skip backup errors and continue the data migration.
   *
   * @generated from field: bool skip_backup_errors = 19;
   */
  skipBackupErrors: boolean;

  /**
   * Whether to enable the database tenant mode for PostgreSQL.
   * If enabled, the issue will be created with the prepend "set role <db_owner>" statement.
   *
   * @generated from field: bool postgres_database_tenant_mode = 20;
   */
  postgresDatabaseTenantMode: boolean;

  /**
   * Whether to allow the issue creator to self-approve the issue.
   *
   * @generated from field: bool allow_self_approval = 21;
   */
  allowSelfApproval: boolean;

  /**
   * Execution retry policy for the task run.
   *
   * @generated from field: bytebase.v1.Project.ExecutionRetryPolicy execution_retry_policy = 22;
   */
  executionRetryPolicy?: Project_ExecutionRetryPolicy;

  /**
   * The maximum databases of rows to sample during CI data validation.
   * Without specification, sampling is disabled, resulting in a full validation.
   *
   * @generated from field: int32 ci_sampling_size = 23;
   */
  ciSamplingSize: number;

  /**
   * The maximum number of parallel tasks to run during the rollout.
   *
   * @generated from field: int32 parallel_tasks_per_rollout = 24;
   */
  parallelTasksPerRollout: number;

  /**
   * Labels are key-value pairs that can be attached to the project.
   * For example, { "environment": "production", "team": "backend" }
   *
   * @generated from field: map<string, string> labels = 25;
   */
  labels: { [key: string]: string };
};

/**
 * Describes the message bytebase.v1.Project.
 * Use `create(ProjectSchema)` to create a new message.
 */
export declare const ProjectSchema: GenMessage<Project>;

/**
 * @generated from message bytebase.v1.Project.ExecutionRetryPolicy
 */
export declare type Project_ExecutionRetryPolicy = Message<"bytebase.v1.Project.ExecutionRetryPolicy"> & {
  /**
   * The maximum number of retries for the lock timeout issue.
   *
   * @generated from field: int32 maximum_retries = 1;
   */
  maximumRetries: number;
};

/**
 * Describes the message bytebase.v1.Project.ExecutionRetryPolicy.
 * Use `create(Project_ExecutionRetryPolicySchema)` to create a new message.
 */
export declare const Project_ExecutionRetryPolicySchema: GenMessage<Project_ExecutionRetryPolicy>;

/**
 * @generated from message bytebase.v1.AddWebhookRequest
 */
export declare type AddWebhookRequest = Message<"bytebase.v1.AddWebhookRequest"> & {
  /**
   * The name of the project to add the webhook to.
   * Format: projects/{project}
   *
   * @generated from field: string project = 1;
   */
  project: string;

  /**
   * The webhook to add.
   *
   * @generated from field: bytebase.v1.Webhook webhook = 2;
   */
  webhook?: Webhook;
};

/**
 * Describes the message bytebase.v1.AddWebhookRequest.
 * Use `create(AddWebhookRequestSchema)` to create a new message.
 */
export declare const AddWebhookRequestSchema: GenMessage<AddWebhookRequest>;

/**
 * @generated from message bytebase.v1.UpdateWebhookRequest
 */
export declare type UpdateWebhookRequest = Message<"bytebase.v1.UpdateWebhookRequest"> & {
  /**
   * The webhook to modify.
   *
   * @generated from field: bytebase.v1.Webhook webhook = 1;
   */
  webhook?: Webhook;

  /**
   * The list of fields to update.
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 2;
   */
  updateMask?: FieldMask;

  /**
   * If set to true, and the webhook is not found, a new webhook will be created.
   * In this situation, `update_mask` is ignored.
   *
   * @generated from field: bool allow_missing = 3;
   */
  allowMissing: boolean;
};

/**
 * Describes the message bytebase.v1.UpdateWebhookRequest.
 * Use `create(UpdateWebhookRequestSchema)` to create a new message.
 */
export declare const UpdateWebhookRequestSchema: GenMessage<UpdateWebhookRequest>;

/**
 * @generated from message bytebase.v1.RemoveWebhookRequest
 */
export declare type RemoveWebhookRequest = Message<"bytebase.v1.RemoveWebhookRequest"> & {
  /**
   * The webhook to remove. Identified by its url.
   *
   * @generated from field: bytebase.v1.Webhook webhook = 1;
   */
  webhook?: Webhook;
};

/**
 * Describes the message bytebase.v1.RemoveWebhookRequest.
 * Use `create(RemoveWebhookRequestSchema)` to create a new message.
 */
export declare const RemoveWebhookRequestSchema: GenMessage<RemoveWebhookRequest>;

/**
 * @generated from message bytebase.v1.TestWebhookRequest
 */
export declare type TestWebhookRequest = Message<"bytebase.v1.TestWebhookRequest"> & {
  /**
   * The name of the project which owns the webhook to test.
   * Format: projects/{project}
   *
   * @generated from field: string project = 1;
   */
  project: string;

  /**
   * The webhook to test. Identified by its url.
   *
   * @generated from field: bytebase.v1.Webhook webhook = 2;
   */
  webhook?: Webhook;
};

/**
 * Describes the message bytebase.v1.TestWebhookRequest.
 * Use `create(TestWebhookRequestSchema)` to create a new message.
 */
export declare const TestWebhookRequestSchema: GenMessage<TestWebhookRequest>;

/**
 * @generated from message bytebase.v1.TestWebhookResponse
 */
export declare type TestWebhookResponse = Message<"bytebase.v1.TestWebhookResponse"> & {
  /**
   * The result of the test, empty if the test is successful.
   *
   * @generated from field: string error = 1;
   */
  error: string;
};

/**
 * Describes the message bytebase.v1.TestWebhookResponse.
 * Use `create(TestWebhookResponseSchema)` to create a new message.
 */
export declare const TestWebhookResponseSchema: GenMessage<TestWebhookResponse>;

/**
 * @generated from message bytebase.v1.Webhook
 */
export declare type Webhook = Message<"bytebase.v1.Webhook"> & {
  /**
   * name is the name of the webhook, generated by the server.
   * format: projects/{project}/webhooks/{webhook}
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * type is the type of the webhook.
   *
   * @generated from field: bytebase.v1.Webhook.Type type = 2;
   */
  type: Webhook_Type;

  /**
   * title is the title of the webhook.
   *
   * @generated from field: string title = 3;
   */
  title: string;

  /**
   * url is the url of the webhook, should be unique within the project.
   *
   * @generated from field: string url = 4;
   */
  url: string;

  /**
   * if direct_message is set, the notification is sent directly
   * to the persons and url will be ignored.
   * IM integration setting should be set for this function to work.
   *
   * @generated from field: bool direct_message = 6;
   */
  directMessage: boolean;

  /**
   * notification_types is the list of activities types that the webhook is interested in.
   * Bytebase will only send notifications to the webhook if the activity type is in the list.
   * It should not be empty, and should be a subset of the following:
   * - TYPE_ISSUE_CREATED
   * - TYPE_ISSUE_STATUS_UPDATE
   * - TYPE_ISSUE_PIPELINE_STAGE_UPDATE
   * - TYPE_ISSUE_PIPELINE_TASK_STATUS_UPDATE
   * - TYPE_ISSUE_FIELD_UPDATE
   * - TYPE_ISSUE_COMMENT_CREATE
   *
   * @generated from field: repeated bytebase.v1.Activity.Type notification_types = 5;
   */
  notificationTypes: Activity_Type[];
};

/**
 * Describes the message bytebase.v1.Webhook.
 * Use `create(WebhookSchema)` to create a new message.
 */
export declare const WebhookSchema: GenMessage<Webhook>;

/**
 * @generated from enum bytebase.v1.Webhook.Type
 */
export enum Webhook_Type {
  /**
   * @generated from enum value: TYPE_UNSPECIFIED = 0;
   */
  TYPE_UNSPECIFIED = 0,

  /**
   * @generated from enum value: SLACK = 1;
   */
  SLACK = 1,

  /**
   * @generated from enum value: DISCORD = 2;
   */
  DISCORD = 2,

  /**
   * @generated from enum value: TEAMS = 3;
   */
  TEAMS = 3,

  /**
   * @generated from enum value: DINGTALK = 4;
   */
  DINGTALK = 4,

  /**
   * @generated from enum value: FEISHU = 5;
   */
  FEISHU = 5,

  /**
   * @generated from enum value: WECOM = 6;
   */
  WECOM = 6,

  /**
   * @generated from enum value: LARK = 8;
   */
  LARK = 8,
}

/**
 * Describes the enum bytebase.v1.Webhook.Type.
 */
export declare const Webhook_TypeSchema: GenEnum<Webhook_Type>;

/**
 * TODO(zp): move to activity later.
 *
 * @generated from message bytebase.v1.Activity
 */
export declare type Activity = Message<"bytebase.v1.Activity"> & {
};

/**
 * Describes the message bytebase.v1.Activity.
 * Use `create(ActivitySchema)` to create a new message.
 */
export declare const ActivitySchema: GenMessage<Activity>;

/**
 * @generated from enum bytebase.v1.Activity.Type
 */
export enum Activity_Type {
  /**
   * @generated from enum value: TYPE_UNSPECIFIED = 0;
   */
  TYPE_UNSPECIFIED = 0,

  /**
   * Notifications via webhooks.
   *
   * NOTIFY_ISSUE_APPROVED represents the issue approved notification.
   *
   * @generated from enum value: NOTIFY_ISSUE_APPROVED = 23;
   */
  NOTIFY_ISSUE_APPROVED = 23,

  /**
   * NOTIFY_PIPELINE_ROLLOUT represents the pipeline rollout notification.
   *
   * @generated from enum value: NOTIFY_PIPELINE_ROLLOUT = 24;
   */
  NOTIFY_PIPELINE_ROLLOUT = 24,

  /**
   * Issue related activity types.
   *
   * ISSUE_CREATE represents creating an issue.
   *
   * @generated from enum value: ISSUE_CREATE = 1;
   */
  ISSUE_CREATE = 1,

  /**
   * ISSUE_COMMENT_CREATE represents commenting on an issue.
   *
   * @generated from enum value: ISSUE_COMMENT_CREATE = 2;
   */
  ISSUE_COMMENT_CREATE = 2,

  /**
   * ISSUE_FIELD_UPDATE represents updating the issue field, likes title, description, etc.
   *
   * @generated from enum value: ISSUE_FIELD_UPDATE = 3;
   */
  ISSUE_FIELD_UPDATE = 3,

  /**
   * ISSUE_STATUS_UPDATE represents the issue status change, including OPEN, CLOSE, CANCEL fow now.
   *
   * @generated from enum value: ISSUE_STATUS_UPDATE = 4;
   */
  ISSUE_STATUS_UPDATE = 4,

  /**
   * ISSUE_APPROVAL_NOTIFY is the type for notifying issue approval.
   *
   * @generated from enum value: ISSUE_APPROVAL_NOTIFY = 21;
   */
  ISSUE_APPROVAL_NOTIFY = 21,

  /**
   * ISSUE_PIPELINE_STAGE_STATUS_UPDATE represents the pipeline stage status change, including BEGIN, END for now.
   *
   * @generated from enum value: ISSUE_PIPELINE_STAGE_STATUS_UPDATE = 5;
   */
  ISSUE_PIPELINE_STAGE_STATUS_UPDATE = 5,

  /**
   * ISSUE_PIPELINE_TASK_RUN_STATUS_UPDATE represents the pipeline task run status change, including PENDING, RUNNING, DONE, FAILED, CANCELED.
   *
   * @generated from enum value: ISSUE_PIPELINE_TASK_RUN_STATUS_UPDATE = 22;
   */
  ISSUE_PIPELINE_TASK_RUN_STATUS_UPDATE = 22,
}

/**
 * Describes the enum bytebase.v1.Activity.Type.
 */
export declare const Activity_TypeSchema: GenEnum<Activity_Type>;

/**
 * @generated from service bytebase.v1.ProjectService
 */
export declare const ProjectService: GenService<{
  /**
   * GetProject retrieves a project by name.
   * Users with "bb.projects.get" permission on the workspace or the project owner can access this method.
   * Permissions required: bb.projects.get
   *
   * @generated from rpc bytebase.v1.ProjectService.GetProject
   */
  getProject: {
    methodKind: "unary";
    input: typeof GetProjectRequestSchema;
    output: typeof ProjectSchema;
  },
  /**
   * Permissions required: bb.projects.list
   *
   * @generated from rpc bytebase.v1.ProjectService.ListProjects
   */
  listProjects: {
    methodKind: "unary";
    input: typeof ListProjectsRequestSchema;
    output: typeof ListProjectsResponseSchema;
  },
  /**
   * Permissions required: None
   *
   * @generated from rpc bytebase.v1.ProjectService.SearchProjects
   */
  searchProjects: {
    methodKind: "unary";
    input: typeof SearchProjectsRequestSchema;
    output: typeof SearchProjectsResponseSchema;
  },
  /**
   * Permissions required: bb.projects.create
   *
   * @generated from rpc bytebase.v1.ProjectService.CreateProject
   */
  createProject: {
    methodKind: "unary";
    input: typeof CreateProjectRequestSchema;
    output: typeof ProjectSchema;
  },
  /**
   * Permissions required: bb.projects.update
   *
   * @generated from rpc bytebase.v1.ProjectService.UpdateProject
   */
  updateProject: {
    methodKind: "unary";
    input: typeof UpdateProjectRequestSchema;
    output: typeof ProjectSchema;
  },
  /**
   * Permissions required: bb.projects.delete
   *
   * @generated from rpc bytebase.v1.ProjectService.DeleteProject
   */
  deleteProject: {
    methodKind: "unary";
    input: typeof DeleteProjectRequestSchema;
    output: typeof EmptySchema;
  },
  /**
   * Permissions required: bb.projects.undelete
   *
   * @generated from rpc bytebase.v1.ProjectService.UndeleteProject
   */
  undeleteProject: {
    methodKind: "unary";
    input: typeof UndeleteProjectRequestSchema;
    output: typeof ProjectSchema;
  },
  /**
   * Permissions required: bb.projects.delete
   *
   * @generated from rpc bytebase.v1.ProjectService.BatchDeleteProjects
   */
  batchDeleteProjects: {
    methodKind: "unary";
    input: typeof BatchDeleteProjectsRequestSchema;
    output: typeof EmptySchema;
  },
  /**
   * Permissions required: bb.projects.getIamPolicy
   *
   * @generated from rpc bytebase.v1.ProjectService.GetIamPolicy
   */
  getIamPolicy: {
    methodKind: "unary";
    input: typeof GetIamPolicyRequestSchema;
    output: typeof IamPolicySchema;
  },
  /**
   * Deprecated.
   * Permissions required: bb.projects.getIamPolicy
   *
   * @generated from rpc bytebase.v1.ProjectService.BatchGetIamPolicy
   */
  batchGetIamPolicy: {
    methodKind: "unary";
    input: typeof BatchGetIamPolicyRequestSchema;
    output: typeof BatchGetIamPolicyResponseSchema;
  },
  /**
   * Permissions required: bb.projects.setIamPolicy
   *
   * @generated from rpc bytebase.v1.ProjectService.SetIamPolicy
   */
  setIamPolicy: {
    methodKind: "unary";
    input: typeof SetIamPolicyRequestSchema;
    output: typeof IamPolicySchema;
  },
  /**
   * Permissions required: bb.projects.update
   *
   * @generated from rpc bytebase.v1.ProjectService.AddWebhook
   */
  addWebhook: {
    methodKind: "unary";
    input: typeof AddWebhookRequestSchema;
    output: typeof ProjectSchema;
  },
  /**
   * Permissions required: bb.projects.update
   *
   * @generated from rpc bytebase.v1.ProjectService.UpdateWebhook
   */
  updateWebhook: {
    methodKind: "unary";
    input: typeof UpdateWebhookRequestSchema;
    output: typeof ProjectSchema;
  },
  /**
   * Permissions required: bb.projects.update
   *
   * @generated from rpc bytebase.v1.ProjectService.RemoveWebhook
   */
  removeWebhook: {
    methodKind: "unary";
    input: typeof RemoveWebhookRequestSchema;
    output: typeof ProjectSchema;
  },
  /**
   * Permissions required: bb.projects.update
   *
   * @generated from rpc bytebase.v1.ProjectService.TestWebhook
   */
  testWebhook: {
    methodKind: "unary";
    input: typeof TestWebhookRequestSchema;
    output: typeof TestWebhookResponseSchema;
  },
}>;

