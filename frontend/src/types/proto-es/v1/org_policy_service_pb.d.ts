// @generated by protoc-gen-es v2.5.2
// @generated from file v1/org_policy_service.proto (package bytebase.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";
import type { Duration, EmptySchema, FieldMask } from "@bufbuild/protobuf/wkt";
import type { Expr } from "../google/type/expr_pb";

/**
 * Describes the file v1/org_policy_service.proto.
 */
export declare const file_v1_org_policy_service: GenFile;

/**
 * @generated from message bytebase.v1.CreatePolicyRequest
 */
export declare type CreatePolicyRequest = Message<"bytebase.v1.CreatePolicyRequest"> & {
  /**
   * The parent resource where this instance will be created.
   * Workspace resource name: "".
   * Environment resource name: environments/environment-id.
   * Instance resource name: instances/instance-id.
   * Database resource name: instances/instance-id/databases/database-name.
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * The policy to create.
   *
   * @generated from field: bytebase.v1.Policy policy = 2;
   */
  policy?: Policy;

  /**
   * The type of policy to create.
   *
   * @generated from field: bytebase.v1.PolicyType type = 3;
   */
  type: PolicyType;
};

/**
 * Describes the message bytebase.v1.CreatePolicyRequest.
 * Use `create(CreatePolicyRequestSchema)` to create a new message.
 */
export declare const CreatePolicyRequestSchema: GenMessage<CreatePolicyRequest>;

/**
 * @generated from message bytebase.v1.UpdatePolicyRequest
 */
export declare type UpdatePolicyRequest = Message<"bytebase.v1.UpdatePolicyRequest"> & {
  /**
   * The policy to update.
   *
   * The policy's `name` field is used to identify the instance to update.
   * Format: {resource name}/policies/{policy type}
   * Workspace resource name: "".
   * Environment resource name: environments/environment-id.
   * Instance resource name: instances/instance-id.
   * Database resource name: instances/instance-id/databases/database-name.
   *
   * @generated from field: bytebase.v1.Policy policy = 1;
   */
  policy?: Policy;

  /**
   * The list of fields to update.
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 2;
   */
  updateMask?: FieldMask;

  /**
   * If set to true, and the policy is not found, a new policy will be created.
   * In this situation, `update_mask` is ignored.
   *
   * @generated from field: bool allow_missing = 3;
   */
  allowMissing: boolean;
};

/**
 * Describes the message bytebase.v1.UpdatePolicyRequest.
 * Use `create(UpdatePolicyRequestSchema)` to create a new message.
 */
export declare const UpdatePolicyRequestSchema: GenMessage<UpdatePolicyRequest>;

/**
 * @generated from message bytebase.v1.DeletePolicyRequest
 */
export declare type DeletePolicyRequest = Message<"bytebase.v1.DeletePolicyRequest"> & {
  /**
   * The policy's `name` field is used to identify the instance to update.
   * Format: {resource name}/policies/{policy type}
   * Workspace resource name: "".
   * Environment resource name: environments/environment-id.
   * Instance resource name: instances/instance-id.
   * Database resource name: instances/instance-id/databases/database-name.
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message bytebase.v1.DeletePolicyRequest.
 * Use `create(DeletePolicyRequestSchema)` to create a new message.
 */
export declare const DeletePolicyRequestSchema: GenMessage<DeletePolicyRequest>;

/**
 * @generated from message bytebase.v1.GetPolicyRequest
 */
export declare type GetPolicyRequest = Message<"bytebase.v1.GetPolicyRequest"> & {
  /**
   * The name of the policy to retrieve.
   * Format: {resource type}/{resource id}/policies/{policy type}
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message bytebase.v1.GetPolicyRequest.
 * Use `create(GetPolicyRequestSchema)` to create a new message.
 */
export declare const GetPolicyRequestSchema: GenMessage<GetPolicyRequest>;

/**
 * @generated from message bytebase.v1.ListPoliciesRequest
 */
export declare type ListPoliciesRequest = Message<"bytebase.v1.ListPoliciesRequest"> & {
  /**
   * The parent, which owns this collection of policies.
   * Format: {resource type}/{resource id}
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * Filter by specific policy type.
   *
   * @generated from field: optional bytebase.v1.PolicyType policy_type = 2;
   */
  policyType?: PolicyType;

  /**
   * Show deleted policies if specified.
   *
   * @generated from field: bool show_deleted = 3;
   */
  showDeleted: boolean;
};

/**
 * Describes the message bytebase.v1.ListPoliciesRequest.
 * Use `create(ListPoliciesRequestSchema)` to create a new message.
 */
export declare const ListPoliciesRequestSchema: GenMessage<ListPoliciesRequest>;

/**
 * @generated from message bytebase.v1.ListPoliciesResponse
 */
export declare type ListPoliciesResponse = Message<"bytebase.v1.ListPoliciesResponse"> & {
  /**
   * The policies from the specified request.
   *
   * @generated from field: repeated bytebase.v1.Policy policies = 1;
   */
  policies: Policy[];
};

/**
 * Describes the message bytebase.v1.ListPoliciesResponse.
 * Use `create(ListPoliciesResponseSchema)` to create a new message.
 */
export declare const ListPoliciesResponseSchema: GenMessage<ListPoliciesResponse>;

/**
 * @generated from message bytebase.v1.Policy
 */
export declare type Policy = Message<"bytebase.v1.Policy"> & {
  /**
   * The name of the policy.
   * Format: {resource name}/policies/{policy type}
   * Workspace resource name: "".
   * Environment resource name: environments/environment-id.
   * Instance resource name: instances/instance-id.
   * Database resource name: instances/instance-id/databases/database-name.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Whether this policy inherits from its parent resource.
   *
   * @generated from field: bool inherit_from_parent = 2;
   */
  inheritFromParent: boolean;

  /**
   * The type of policy.
   *
   * @generated from field: bytebase.v1.PolicyType type = 3;
   */
  type: PolicyType;

  /**
   * The policy configuration.
   *
   * @generated from oneof bytebase.v1.Policy.policy
   */
  policy: {
    /**
     * @generated from field: bytebase.v1.RolloutPolicy rollout_policy = 4;
     */
    value: RolloutPolicy;
    case: "rolloutPolicy";
  } | {
    /**
     * @generated from field: bytebase.v1.MaskingRulePolicy masking_rule_policy = 5;
     */
    value: MaskingRulePolicy;
    case: "maskingRulePolicy";
  } | {
    /**
     * @generated from field: bytebase.v1.MaskingExemptionPolicy masking_exemption_policy = 6;
     */
    value: MaskingExemptionPolicy;
    case: "maskingExemptionPolicy";
  } | {
    /**
     * @generated from field: bytebase.v1.TagPolicy tag_policy = 7;
     */
    value: TagPolicy;
    case: "tagPolicy";
  } | {
    /**
     * @generated from field: bytebase.v1.DataSourceQueryPolicy data_source_query_policy = 8;
     */
    value: DataSourceQueryPolicy;
    case: "dataSourceQueryPolicy";
  } | {
    /**
     * @generated from field: bytebase.v1.QueryDataPolicy query_data_policy = 9;
     */
    value: QueryDataPolicy;
    case: "queryDataPolicy";
  } | { case: undefined; value?: undefined };

  /**
   * Whether the policy is enforced.
   *
   * @generated from field: bool enforce = 10;
   */
  enforce: boolean;

  /**
   * The resource type for the policy.
   *
   * @generated from field: bytebase.v1.PolicyResourceType resource_type = 11;
   */
  resourceType: PolicyResourceType;
};

/**
 * Describes the message bytebase.v1.Policy.
 * Use `create(PolicySchema)` to create a new message.
 */
export declare const PolicySchema: GenMessage<Policy>;

/**
 * Rollout policy configuration.
 *
 * @generated from message bytebase.v1.RolloutPolicy
 */
export declare type RolloutPolicy = Message<"bytebase.v1.RolloutPolicy"> & {
  /**
   * Whether rollout is automatic without manual approval.
   *
   * @generated from field: bool automatic = 1;
   */
  automatic: boolean;

  /**
   * The roles that can approve rollout execution.
   *
   * @generated from field: repeated string roles = 2;
   */
  roles: string[];
};

/**
 * Describes the message bytebase.v1.RolloutPolicy.
 * Use `create(RolloutPolicySchema)` to create a new message.
 */
export declare const RolloutPolicySchema: GenMessage<RolloutPolicy>;

/**
 * QueryDataPolicy is the policy configuration for querying data.
 *
 * @generated from message bytebase.v1.QueryDataPolicy
 */
export declare type QueryDataPolicy = Message<"bytebase.v1.QueryDataPolicy"> & {
  /**
   * The query timeout duration.
   *
   * @generated from field: google.protobuf.Duration timeout = 1;
   */
  timeout?: Duration;

  /**
   * Disable data export in the SQL editor.
   *
   * @generated from field: bool disable_export = 2;
   */
  disableExport: boolean;

  /**
   * The maximum result size limit in bytes.
   * The default value is 100MB, we will use the default value if the setting not exists, or the limit <= 0.
   *
   * @generated from field: int64 maximum_result_size = 3;
   */
  maximumResultSize: bigint;

  /**
   * The maximum number of rows to return.
   * The default value is -1, means no limit.
   *
   * @generated from field: int32 maximum_result_rows = 4;
   */
  maximumResultRows: number;

  /**
   * Disable copying query results.
   *
   * @generated from field: bool disable_copy_data = 5;
   */
  disableCopyData: boolean;
};

/**
 * Describes the message bytebase.v1.QueryDataPolicy.
 * Use `create(QueryDataPolicySchema)` to create a new message.
 */
export declare const QueryDataPolicySchema: GenMessage<QueryDataPolicy>;

/**
 * MaskingExemptionPolicy is the allowlist of users who can access sensitive data.
 *
 * @generated from message bytebase.v1.MaskingExemptionPolicy
 */
export declare type MaskingExemptionPolicy = Message<"bytebase.v1.MaskingExemptionPolicy"> & {
  /**
   * @generated from field: repeated bytebase.v1.MaskingExemptionPolicy.Exemption exemptions = 1;
   */
  exemptions: MaskingExemptionPolicy_Exemption[];
};

/**
 * Describes the message bytebase.v1.MaskingExemptionPolicy.
 * Use `create(MaskingExemptionPolicySchema)` to create a new message.
 */
export declare const MaskingExemptionPolicySchema: GenMessage<MaskingExemptionPolicy>;

/**
 * @generated from message bytebase.v1.MaskingExemptionPolicy.Exemption
 */
export declare type MaskingExemptionPolicy_Exemption = Message<"bytebase.v1.MaskingExemptionPolicy.Exemption"> & {
  /**
   * Specifies the principals who are exempt from masking.
   * For users, the member should be: user:{email}
   * For groups, the member should be: group:{email}
   *
   * @generated from field: repeated string members = 1;
   */
  members: string[];

  /**
   * The condition that is associated with this exception policy instance.
   * The syntax and semantics of CEL are documented at https://github.com/google/cel-spec
   * If the condition is empty, means the user can access all databases without expiration.
   *
   * Support variables:
   * resource.instance_id: the instance resource id. Only support "==" operation.
   * resource.database_name: the database name. Only support "==" operation.
   * resource.schema_name: the schema name. Only support "==" operation.
   * resource.table_name: the table name. Only support "==" operation.
   * resource.column_name: the column name. Only support "==" operation.
   * request.time: the expiration. Only support "<" operation in `request.time < timestamp("{ISO datetime string format}")`
   * All variables should join with "&&" condition.
   *
   * For example:
   * resource.instance_id == "local" && resource.database_name == "employee" && request.time < timestamp("2025-04-30T11:10:39.000Z")
   * resource.instance_id == "local" && resource.database_name == "employee"
   *
   * @generated from field: google.type.Expr condition = 2;
   */
  condition?: Expr;
};

/**
 * Describes the message bytebase.v1.MaskingExemptionPolicy.Exemption.
 * Use `create(MaskingExemptionPolicy_ExemptionSchema)` to create a new message.
 */
export declare const MaskingExemptionPolicy_ExemptionSchema: GenMessage<MaskingExemptionPolicy_Exemption>;

/**
 * Policy for configuring data masking rules.
 *
 * @generated from message bytebase.v1.MaskingRulePolicy
 */
export declare type MaskingRulePolicy = Message<"bytebase.v1.MaskingRulePolicy"> & {
  /**
   * The list of masking rules.
   *
   * @generated from field: repeated bytebase.v1.MaskingRulePolicy.MaskingRule rules = 1;
   */
  rules: MaskingRulePolicy_MaskingRule[];
};

/**
 * Describes the message bytebase.v1.MaskingRulePolicy.
 * Use `create(MaskingRulePolicySchema)` to create a new message.
 */
export declare const MaskingRulePolicySchema: GenMessage<MaskingRulePolicy>;

/**
 * A rule that defines when and how to mask data.
 *
 * @generated from message bytebase.v1.MaskingRulePolicy.MaskingRule
 */
export declare type MaskingRulePolicy_MaskingRule = Message<"bytebase.v1.MaskingRulePolicy.MaskingRule"> & {
  /**
   * A unique identifier for the rule in UUID format.
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * The condition for the masking rule.
   * The syntax and semantics of CEL are documented at https://github.com/google/cel-spec
   *
   * Support variables:
   * resource.environment_id: the environment resource id.
   * resource.project_id: the project resource id.
   * resource.instance_id: the instance resource id.
   * resource.database_name: the database name.
   * resource.table_name: the table name.
   * resource.column_name: the column name.
   * resource.classification_level: the classification level.
   *
   * Each variable support following operations:
   * ==: the value equals the target.
   * !=: the value not equals the target.
   * in: the value matches one of the targets.
   * !(in): the value not matches any of the targets.
   *
   * For example:
   * resource.environment_id == "test" && resource.project_id == "sample-project"
   * resource.instance_id == "sample-instance" && resource.database_name == "employee" && resource.table_name in ["table1", "table2"]
   * resource.environment_id != "test" || !(resource.project_id in ["poject1", "prject2"])
   * resource.instance_id == "sample-instance" && (resource.database_name == "db1" || resource.database_name == "db2")
   *
   * @generated from field: google.type.Expr condition = 2;
   */
  condition?: Expr;

  /**
   * The semantic type of data to mask (e.g., "SSN", "EMAIL").
   *
   * @generated from field: string semantic_type = 3;
   */
  semanticType: string;
};

/**
 * Describes the message bytebase.v1.MaskingRulePolicy.MaskingRule.
 * Use `create(MaskingRulePolicy_MaskingRuleSchema)` to create a new message.
 */
export declare const MaskingRulePolicy_MaskingRuleSchema: GenMessage<MaskingRulePolicy_MaskingRule>;

/**
 * Policy for tagging resources with metadata.
 *
 * @generated from message bytebase.v1.TagPolicy
 */
export declare type TagPolicy = Message<"bytebase.v1.TagPolicy"> & {
  /**
   * tags is the key - value map for resources.
   * for example, the environment resource can have the sql review config tag, like "bb.tag.review_config": "reviewConfigs/{review config resource id}"
   *
   * @generated from field: map<string, string> tags = 1;
   */
  tags: { [key: string]: string };
};

/**
 * Describes the message bytebase.v1.TagPolicy.
 * Use `create(TagPolicySchema)` to create a new message.
 */
export declare const TagPolicySchema: GenMessage<TagPolicy>;

/**
 * Policy for controlling which data sources can be queried in the SQL editor.
 *
 * @generated from message bytebase.v1.DataSourceQueryPolicy
 */
export declare type DataSourceQueryPolicy = Message<"bytebase.v1.DataSourceQueryPolicy"> & {
  /**
   * Restriction for admin data source queries.
   *
   * @generated from field: bytebase.v1.DataSourceQueryPolicy.Restriction admin_data_source_restriction = 1;
   */
  adminDataSourceRestriction: DataSourceQueryPolicy_Restriction;

  /**
   * Disallow running DDL statements in the SQL editor.
   *
   * @generated from field: bool disallow_ddl = 2;
   */
  disallowDdl: boolean;

  /**
   * Disallow running DML statements in the SQL editor.
   *
   * @generated from field: bool disallow_dml = 3;
   */
  disallowDml: boolean;
};

/**
 * Describes the message bytebase.v1.DataSourceQueryPolicy.
 * Use `create(DataSourceQueryPolicySchema)` to create a new message.
 */
export declare const DataSourceQueryPolicySchema: GenMessage<DataSourceQueryPolicy>;

/**
 * Restriction level for admin data source access.
 *
 * @generated from enum bytebase.v1.DataSourceQueryPolicy.Restriction
 */
export enum DataSourceQueryPolicy_Restriction {
  /**
   * Unspecified restriction.
   *
   * @generated from enum value: RESTRICTION_UNSPECIFIED = 0;
   */
  RESTRICTION_UNSPECIFIED = 0,

  /**
   * Allow querying admin data sources when there is no read-only data source.
   *
   * @generated from enum value: FALLBACK = 1;
   */
  FALLBACK = 1,

  /**
   * Disallow querying admin data sources.
   *
   * @generated from enum value: DISALLOW = 2;
   */
  DISALLOW = 2,
}

/**
 * Describes the enum bytebase.v1.DataSourceQueryPolicy.Restriction.
 */
export declare const DataSourceQueryPolicy_RestrictionSchema: GenEnum<DataSourceQueryPolicy_Restriction>;

/**
 * The type of organizational policy.
 *
 * @generated from enum bytebase.v1.PolicyType
 */
export enum PolicyType {
  /**
   * Unspecified policy type.
   *
   * @generated from enum value: POLICY_TYPE_UNSPECIFIED = 0;
   */
  POLICY_TYPE_UNSPECIFIED = 0,

  /**
   * Data masking rule policy.
   *
   * @generated from enum value: MASKING_RULE = 1;
   */
  MASKING_RULE = 1,

  /**
   * Data masking exemption policy.
   *
   * @generated from enum value: MASKING_EXEMPTION = 2;
   */
  MASKING_EXEMPTION = 2,

  /**
   * Rollout deployment policy.
   *
   * @generated from enum value: ROLLOUT_POLICY = 3;
   */
  ROLLOUT_POLICY = 3,

  /**
   * Resource tag policy.
   *
   * @generated from enum value: TAG = 4;
   */
  TAG = 4,

  /**
   * Data source query restrictions policy.
   *
   * @generated from enum value: DATA_SOURCE_QUERY = 5;
   */
  DATA_SOURCE_QUERY = 5,

  /**
   * Query data access policy.
   *
   * @generated from enum value: DATA_QUERY = 6;
   */
  DATA_QUERY = 6,
}

/**
 * Describes the enum bytebase.v1.PolicyType.
 */
export declare const PolicyTypeSchema: GenEnum<PolicyType>;

/**
 * The resource type that a policy can be attached to.
 *
 * @generated from enum bytebase.v1.PolicyResourceType
 */
export enum PolicyResourceType {
  /**
   * Unspecified resource type.
   *
   * @generated from enum value: RESOURCE_TYPE_UNSPECIFIED = 0;
   */
  RESOURCE_TYPE_UNSPECIFIED = 0,

  /**
   * Workspace-level policy.
   *
   * @generated from enum value: WORKSPACE = 1;
   */
  WORKSPACE = 1,

  /**
   * Environment-level policy.
   *
   * @generated from enum value: ENVIRONMENT = 2;
   */
  ENVIRONMENT = 2,

  /**
   * Project-level policy.
   *
   * @generated from enum value: PROJECT = 3;
   */
  PROJECT = 3,
}

/**
 * Describes the enum bytebase.v1.PolicyResourceType.
 */
export declare const PolicyResourceTypeSchema: GenEnum<PolicyResourceType>;

/**
 * OrgPolicyService manages organizational policies at various resource levels.
 *
 * @generated from service bytebase.v1.OrgPolicyService
 */
export declare const OrgPolicyService: GenService<{
  /**
   * Retrieves a policy by name.
   * Permissions required: bb.policies.get
   *
   * @generated from rpc bytebase.v1.OrgPolicyService.GetPolicy
   */
  getPolicy: {
    methodKind: "unary";
    input: typeof GetPolicyRequestSchema;
    output: typeof PolicySchema;
  },
  /**
   * Lists policies at a specified resource level.
   * Permissions required: bb.policies.list
   *
   * @generated from rpc bytebase.v1.OrgPolicyService.ListPolicies
   */
  listPolicies: {
    methodKind: "unary";
    input: typeof ListPoliciesRequestSchema;
    output: typeof ListPoliciesResponseSchema;
  },
  /**
   * Creates a new organizational policy.
   * Permissions required: bb.policies.create
   *
   * @generated from rpc bytebase.v1.OrgPolicyService.CreatePolicy
   */
  createPolicy: {
    methodKind: "unary";
    input: typeof CreatePolicyRequestSchema;
    output: typeof PolicySchema;
  },
  /**
   * Updates an existing organizational policy.
   * Permissions required: bb.policies.update
   *
   * @generated from rpc bytebase.v1.OrgPolicyService.UpdatePolicy
   */
  updatePolicy: {
    methodKind: "unary";
    input: typeof UpdatePolicyRequestSchema;
    output: typeof PolicySchema;
  },
  /**
   * Deletes an organizational policy.
   * Permissions required: bb.policies.delete
   *
   * @generated from rpc bytebase.v1.OrgPolicyService.DeletePolicy
   */
  deletePolicy: {
    methodKind: "unary";
    input: typeof DeletePolicyRequestSchema;
    output: typeof EmptySchema;
  },
}>;

