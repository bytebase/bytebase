// @generated by protoc-gen-es v2.5.2
// @generated from file v1/plan_service.proto (package bytebase.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";
import type { FieldMask, Timestamp } from "@bufbuild/protobuf/wkt";
import type { ExportFormat, Position, State } from "./common_pb";
import type { Advice_Level } from "./sql_service_pb";

/**
 * Describes the file v1/plan_service.proto.
 */
export declare const file_v1_plan_service: GenFile;

/**
 * @generated from message bytebase.v1.GetPlanRequest
 */
export declare type GetPlanRequest = Message<"bytebase.v1.GetPlanRequest"> & {
  /**
   * The name of the plan to retrieve.
   * Format: projects/{project}/plans/{plan}
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message bytebase.v1.GetPlanRequest.
 * Use `create(GetPlanRequestSchema)` to create a new message.
 */
export declare const GetPlanRequestSchema: GenMessage<GetPlanRequest>;

/**
 * @generated from message bytebase.v1.ListPlansRequest
 */
export declare type ListPlansRequest = Message<"bytebase.v1.ListPlansRequest"> & {
  /**
   * The parent, which owns this collection of plans.
   * Format: projects/{project}
   * Use "projects/-" to list all plans from all projects.
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * The maximum number of plans to return. The service may return fewer than
   * this value.
   * If unspecified, at most 10 plans will be returned.
   * The maximum value is 1000; values above 1000 will be coerced to 1000.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize: number;

  /**
   * A page token, received from a previous `ListPlans` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListPlans` must match
   * the call that provided the page token.
   *
   * @generated from field: string page_token = 3;
   */
  pageToken: string;

  /**
   * Filter is used to filter plans returned in the list.
   * The syntax and semantics of CEL are documented at https://github.com/google/cel-spec
   *
   * Supported filters:
   * - creator: the plan creator full name in "users/{email or id}" format, support "==" operator.
   * - create_time: the plan create time in "2006-01-02T15:04:05Z07:00" format, support ">=" or "<=" operator.
   * - has_rollout: whether the plan has rollout, support "==" operator, the value should be "true" or "false".
   * - has_issue: the plan has issue or not, support "==" operator, the value should be "true" or "false".
   * - title: the plan title, support "==" operator for exact match and ".matches()" operator for case-insensitive substring match.
   * - spec_type: the plan spec config type, support "==" operator, the value should be "create_database_config", "change_database_config", or "export_data_config".
   * - state: the plan state, support "==" operator, the value should be "ACTIVE" or "DELETED".
   *
   * For example:
   * creator == "users/ed@bytebase.com" && create_time >= "2025-01-02T15:04:05Z07:00"
   * has_rollout == false && has_issue == true
   * title == "My Plan"
   * title.matches("database migration")
   * spec_type == "change_database_config"
   * state == "ACTIVE"
   *
   * @generated from field: string filter = 4;
   */
  filter: string;
};

/**
 * Describes the message bytebase.v1.ListPlansRequest.
 * Use `create(ListPlansRequestSchema)` to create a new message.
 */
export declare const ListPlansRequestSchema: GenMessage<ListPlansRequest>;

/**
 * @generated from message bytebase.v1.ListPlansResponse
 */
export declare type ListPlansResponse = Message<"bytebase.v1.ListPlansResponse"> & {
  /**
   * The plans from the specified request.
   *
   * @generated from field: repeated bytebase.v1.Plan plans = 1;
   */
  plans: Plan[];

  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message bytebase.v1.ListPlansResponse.
 * Use `create(ListPlansResponseSchema)` to create a new message.
 */
export declare const ListPlansResponseSchema: GenMessage<ListPlansResponse>;

/**
 * @generated from message bytebase.v1.CreatePlanRequest
 */
export declare type CreatePlanRequest = Message<"bytebase.v1.CreatePlanRequest"> & {
  /**
   * The parent project where this plan will be created.
   * Format: projects/{project}
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * The plan to create.
   *
   * @generated from field: bytebase.v1.Plan plan = 2;
   */
  plan?: Plan;
};

/**
 * Describes the message bytebase.v1.CreatePlanRequest.
 * Use `create(CreatePlanRequestSchema)` to create a new message.
 */
export declare const CreatePlanRequestSchema: GenMessage<CreatePlanRequest>;

/**
 * @generated from message bytebase.v1.UpdatePlanRequest
 */
export declare type UpdatePlanRequest = Message<"bytebase.v1.UpdatePlanRequest"> & {
  /**
   * The plan to update.
   *
   * The plan's `name` field is used to identify the plan to update.
   * Format: projects/{project}/plans/{plan}
   *
   * @generated from field: bytebase.v1.Plan plan = 1;
   */
  plan?: Plan;

  /**
   * The list of fields to update.
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 2;
   */
  updateMask?: FieldMask;

  /**
   * If set to true, and the plan is not found, a new plan will be created.
   * In this situation, `update_mask` is ignored.
   *
   * @generated from field: bool allow_missing = 3;
   */
  allowMissing: boolean;
};

/**
 * Describes the message bytebase.v1.UpdatePlanRequest.
 * Use `create(UpdatePlanRequestSchema)` to create a new message.
 */
export declare const UpdatePlanRequestSchema: GenMessage<UpdatePlanRequest>;

/**
 * @generated from message bytebase.v1.Plan
 */
export declare type Plan = Message<"bytebase.v1.Plan"> & {
  /**
   * The name of the plan.
   * `plan` is a system generated ID.
   * Format: projects/{project}/plans/{plan}
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The state of the plan.
   *
   * @generated from field: bytebase.v1.State state = 2;
   */
  state: State;

  /**
   * The issue associated with the plan.
   * Can be empty.
   * Format: projects/{project}/issues/{issue}
   *
   * @generated from field: string issue = 3;
   */
  issue: string;

  /**
   * The title of the plan.
   *
   * @generated from field: string title = 5;
   */
  title: string;

  /**
   * The description of the plan.
   *
   * @generated from field: string description = 6;
   */
  description: string;

  /**
   * The deployment specs for the plan.
   *
   * @generated from field: repeated bytebase.v1.Plan.Spec specs = 7;
   */
  specs: Plan_Spec[];

  /**
   * Format: users/hello@world.com
   *
   * @generated from field: string creator = 8;
   */
  creator: string;

  /**
   * @generated from field: google.protobuf.Timestamp create_time = 9;
   */
  createTime?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp update_time = 10;
   */
  updateTime?: Timestamp;

  /**
   * The status count of the latest plan check runs.
   * Keys are:
   * - SUCCESS
   * - WARNING
   * - ERROR
   * - RUNNING
   *
   * @generated from field: map<string, int32> plan_check_run_status_count = 11;
   */
  planCheckRunStatusCount: { [key: string]: number };

  /**
   * Whether the plan has started the rollout.
   *
   * @generated from field: bool has_rollout = 12;
   */
  hasRollout: boolean;
};

/**
 * Describes the message bytebase.v1.Plan.
 * Use `create(PlanSchema)` to create a new message.
 */
export declare const PlanSchema: GenMessage<Plan>;

/**
 * @generated from message bytebase.v1.Plan.Spec
 */
export declare type Plan_Spec = Message<"bytebase.v1.Plan.Spec"> & {
  /**
   * A UUID4 string that uniquely identifies the Spec.
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * @generated from oneof bytebase.v1.Plan.Spec.config
   */
  config: {
    /**
     * @generated from field: bytebase.v1.Plan.CreateDatabaseConfig create_database_config = 2;
     */
    value: Plan_CreateDatabaseConfig;
    case: "createDatabaseConfig";
  } | {
    /**
     * @generated from field: bytebase.v1.Plan.ChangeDatabaseConfig change_database_config = 3;
     */
    value: Plan_ChangeDatabaseConfig;
    case: "changeDatabaseConfig";
  } | {
    /**
     * @generated from field: bytebase.v1.Plan.ExportDataConfig export_data_config = 4;
     */
    value: Plan_ExportDataConfig;
    case: "exportDataConfig";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message bytebase.v1.Plan.Spec.
 * Use `create(Plan_SpecSchema)` to create a new message.
 */
export declare const Plan_SpecSchema: GenMessage<Plan_Spec>;

/**
 * @generated from message bytebase.v1.Plan.CreateDatabaseConfig
 */
export declare type Plan_CreateDatabaseConfig = Message<"bytebase.v1.Plan.CreateDatabaseConfig"> & {
  /**
   * The resource name of the instance on which the database is created.
   * Format: instances/{instance}
   *
   * @generated from field: string target = 1;
   */
  target: string;

  /**
   * The name of the database to create.
   *
   * @generated from field: string database = 2;
   */
  database: string;

  /**
   * table is the name of the table, if it is not empty, Bytebase should create a table after creating the database.
   * For example, in MongoDB, it only creates the database when we first store data in that database.
   *
   * @generated from field: string table = 3;
   */
  table: string;

  /**
   * character_set is the character set of the database.
   *
   * @generated from field: string character_set = 4;
   */
  characterSet: string;

  /**
   * collation is the collation of the database.
   *
   * @generated from field: string collation = 5;
   */
  collation: string;

  /**
   * cluster is the cluster of the database. This is only applicable to ClickHouse for "ON CLUSTER <<cluster>>".
   *
   * @generated from field: string cluster = 6;
   */
  cluster: string;

  /**
   * owner is the owner of the database. This is only applicable to Postgres for "WITH OWNER <<owner>>".
   *
   * @generated from field: string owner = 7;
   */
  owner: string;

  /**
   * The environment resource.
   * Format: environments/prod where prod is the environment resource ID.
   *
   * @generated from field: string environment = 9;
   */
  environment: string;
};

/**
 * Describes the message bytebase.v1.Plan.CreateDatabaseConfig.
 * Use `create(Plan_CreateDatabaseConfigSchema)` to create a new message.
 */
export declare const Plan_CreateDatabaseConfigSchema: GenMessage<Plan_CreateDatabaseConfig>;

/**
 * @generated from message bytebase.v1.Plan.ChangeDatabaseConfig
 */
export declare type Plan_ChangeDatabaseConfig = Message<"bytebase.v1.Plan.ChangeDatabaseConfig"> & {
  /**
   * The list of targets.
   * Multi-database format: [instances/{instance-id}/databases/{database-name}].
   * Single database group format: [projects/{project}/databaseGroups/{databaseGroup}].
   *
   * @generated from field: repeated string targets = 1;
   */
  targets: string[];

  /**
   * The resource name of the sheet.
   * Format: projects/{project}/sheets/{sheet}
   *
   * @generated from field: string sheet = 2;
   */
  sheet: string;

  /**
   * The resource name of the release.
   * Format: projects/{project}/releases/{release}
   *
   * @generated from field: string release = 3;
   */
  release: string;

  /**
   * @generated from field: map<string, string> ghost_flags = 5;
   */
  ghostFlags: { [key: string]: string };

  /**
   * If set, a backup of the modified data will be created automatically before any changes are applied.
   *
   * @generated from field: bool enable_prior_backup = 6;
   */
  enablePriorBackup: boolean;

  /**
   * Whether to use gh-ost for online schema migration.
   *
   * @generated from field: bool enable_ghost = 7;
   */
  enableGhost: boolean;
};

/**
 * Describes the message bytebase.v1.Plan.ChangeDatabaseConfig.
 * Use `create(Plan_ChangeDatabaseConfigSchema)` to create a new message.
 */
export declare const Plan_ChangeDatabaseConfigSchema: GenMessage<Plan_ChangeDatabaseConfig>;

/**
 * @generated from message bytebase.v1.Plan.ExportDataConfig
 */
export declare type Plan_ExportDataConfig = Message<"bytebase.v1.Plan.ExportDataConfig"> & {
  /**
   * The list of targets.
   * Multi-database format: [instances/{instance-id}/databases/{database-name}].
   * Single database group format: [projects/{project}/databaseGroups/{databaseGroup}].
   *
   * @generated from field: repeated string targets = 1;
   */
  targets: string[];

  /**
   * The resource name of the sheet.
   * Format: projects/{project}/sheets/{sheet}
   *
   * @generated from field: string sheet = 2;
   */
  sheet: string;

  /**
   * The format of the exported file.
   *
   * @generated from field: bytebase.v1.ExportFormat format = 3;
   */
  format: ExportFormat;

  /**
   * The zip password provide by users.
   * Leave it empty if no needs to encrypt the zip file.
   *
   * @generated from field: optional string password = 4;
   */
  password?: string;
};

/**
 * Describes the message bytebase.v1.Plan.ExportDataConfig.
 * Use `create(Plan_ExportDataConfigSchema)` to create a new message.
 */
export declare const Plan_ExportDataConfigSchema: GenMessage<Plan_ExportDataConfig>;

/**
 * @generated from message bytebase.v1.GetPlanCheckRunRequest
 */
export declare type GetPlanCheckRunRequest = Message<"bytebase.v1.GetPlanCheckRunRequest"> & {
  /**
   * The name of the plan check run to retrieve.
   * Format: projects/{project}/plans/{plan}/planCheckRun
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message bytebase.v1.GetPlanCheckRunRequest.
 * Use `create(GetPlanCheckRunRequestSchema)` to create a new message.
 */
export declare const GetPlanCheckRunRequestSchema: GenMessage<GetPlanCheckRunRequest>;

/**
 * @generated from message bytebase.v1.RunPlanChecksRequest
 */
export declare type RunPlanChecksRequest = Message<"bytebase.v1.RunPlanChecksRequest"> & {
  /**
   * The plan to run plan checks.
   * Format: projects/{project}/plans/{plan}
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The UUID of the specific spec to run plan checks for.
   * This should match the spec.id field in Plan.Spec.
   * If not set, all specs in the plan will be used.
   *
   * @generated from field: optional string spec_id = 2;
   */
  specId?: string;
};

/**
 * Describes the message bytebase.v1.RunPlanChecksRequest.
 * Use `create(RunPlanChecksRequestSchema)` to create a new message.
 */
export declare const RunPlanChecksRequestSchema: GenMessage<RunPlanChecksRequest>;

/**
 * @generated from message bytebase.v1.RunPlanChecksResponse
 */
export declare type RunPlanChecksResponse = Message<"bytebase.v1.RunPlanChecksResponse"> & {
};

/**
 * Describes the message bytebase.v1.RunPlanChecksResponse.
 * Use `create(RunPlanChecksResponseSchema)` to create a new message.
 */
export declare const RunPlanChecksResponseSchema: GenMessage<RunPlanChecksResponse>;

/**
 * @generated from message bytebase.v1.CancelPlanCheckRunRequest
 */
export declare type CancelPlanCheckRunRequest = Message<"bytebase.v1.CancelPlanCheckRunRequest"> & {
  /**
   * The name of the plan check run to cancel.
   * Format: projects/{project}/plans/{plan}/planCheckRun
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message bytebase.v1.CancelPlanCheckRunRequest.
 * Use `create(CancelPlanCheckRunRequestSchema)` to create a new message.
 */
export declare const CancelPlanCheckRunRequestSchema: GenMessage<CancelPlanCheckRunRequest>;

/**
 * @generated from message bytebase.v1.CancelPlanCheckRunResponse
 */
export declare type CancelPlanCheckRunResponse = Message<"bytebase.v1.CancelPlanCheckRunResponse"> & {
};

/**
 * Describes the message bytebase.v1.CancelPlanCheckRunResponse.
 * Use `create(CancelPlanCheckRunResponseSchema)` to create a new message.
 */
export declare const CancelPlanCheckRunResponseSchema: GenMessage<CancelPlanCheckRunResponse>;

/**
 * @generated from message bytebase.v1.PlanCheckRun
 */
export declare type PlanCheckRun = Message<"bytebase.v1.PlanCheckRun"> & {
  /**
   * Format: projects/{project}/plans/{plan}/planCheckRun
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: bytebase.v1.PlanCheckRun.Status status = 3;
   */
  status: PlanCheckRun_Status;

  /**
   * @generated from field: repeated bytebase.v1.PlanCheckRun.Result results = 6;
   */
  results: PlanCheckRun_Result[];

  /**
   * error is set if the Status is FAILED.
   *
   * @generated from field: string error = 7;
   */
  error: string;

  /**
   * @generated from field: google.protobuf.Timestamp create_time = 8;
   */
  createTime?: Timestamp;
};

/**
 * Describes the message bytebase.v1.PlanCheckRun.
 * Use `create(PlanCheckRunSchema)` to create a new message.
 */
export declare const PlanCheckRunSchema: GenMessage<PlanCheckRun>;

/**
 * @generated from message bytebase.v1.PlanCheckRun.Result
 */
export declare type PlanCheckRun_Result = Message<"bytebase.v1.PlanCheckRun.Result"> & {
  /**
   * @generated from field: bytebase.v1.Advice.Level status = 1;
   */
  status: Advice_Level;

  /**
   * @generated from field: string title = 2;
   */
  title: string;

  /**
   * @generated from field: string content = 3;
   */
  content: string;

  /**
   * @generated from field: int32 code = 4;
   */
  code: number;

  /**
   * Target identification for consolidated results.
   * Format: instances/{instance}/databases/{database}
   *
   * @generated from field: string target = 7;
   */
  target: string;

  /**
   * @generated from field: bytebase.v1.PlanCheckRun.Result.Type type = 8;
   */
  type: PlanCheckRun_Result_Type;

  /**
   * @generated from oneof bytebase.v1.PlanCheckRun.Result.report
   */
  report: {
    /**
     * @generated from field: bytebase.v1.PlanCheckRun.Result.SqlSummaryReport sql_summary_report = 5;
     */
    value: PlanCheckRun_Result_SqlSummaryReport;
    case: "sqlSummaryReport";
  } | {
    /**
     * @generated from field: bytebase.v1.PlanCheckRun.Result.SqlReviewReport sql_review_report = 6;
     */
    value: PlanCheckRun_Result_SqlReviewReport;
    case: "sqlReviewReport";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message bytebase.v1.PlanCheckRun.Result.
 * Use `create(PlanCheckRun_ResultSchema)` to create a new message.
 */
export declare const PlanCheckRun_ResultSchema: GenMessage<PlanCheckRun_Result>;

/**
 * @generated from message bytebase.v1.PlanCheckRun.Result.SqlSummaryReport
 */
export declare type PlanCheckRun_Result_SqlSummaryReport = Message<"bytebase.v1.PlanCheckRun.Result.SqlSummaryReport"> & {
  /**
   * statement_types are the types of statements that are found in the sql.
   *
   * @generated from field: repeated string statement_types = 2;
   */
  statementTypes: string[];

  /**
   * @generated from field: int64 affected_rows = 3;
   */
  affectedRows: bigint;
};

/**
 * Describes the message bytebase.v1.PlanCheckRun.Result.SqlSummaryReport.
 * Use `create(PlanCheckRun_Result_SqlSummaryReportSchema)` to create a new message.
 */
export declare const PlanCheckRun_Result_SqlSummaryReportSchema: GenMessage<PlanCheckRun_Result_SqlSummaryReport>;

/**
 * @generated from message bytebase.v1.PlanCheckRun.Result.SqlReviewReport
 */
export declare type PlanCheckRun_Result_SqlReviewReport = Message<"bytebase.v1.PlanCheckRun.Result.SqlReviewReport"> & {
  /**
   * Position of the SQL statement.
   *
   * @generated from field: bytebase.v1.Position start_position = 5;
   */
  startPosition?: Position;

  /**
   * @generated from field: bytebase.v1.Position end_position = 6;
   */
  endPosition?: Position;
};

/**
 * Describes the message bytebase.v1.PlanCheckRun.Result.SqlReviewReport.
 * Use `create(PlanCheckRun_Result_SqlReviewReportSchema)` to create a new message.
 */
export declare const PlanCheckRun_Result_SqlReviewReportSchema: GenMessage<PlanCheckRun_Result_SqlReviewReport>;

/**
 * @generated from enum bytebase.v1.PlanCheckRun.Result.Type
 */
export enum PlanCheckRun_Result_Type {
  /**
   * @generated from enum value: TYPE_UNSPECIFIED = 0;
   */
  TYPE_UNSPECIFIED = 0,

  /**
   * @generated from enum value: STATEMENT_ADVISE = 1;
   */
  STATEMENT_ADVISE = 1,

  /**
   * @generated from enum value: STATEMENT_SUMMARY_REPORT = 2;
   */
  STATEMENT_SUMMARY_REPORT = 2,

  /**
   * @generated from enum value: GHOST_SYNC = 3;
   */
  GHOST_SYNC = 3,
}

/**
 * Describes the enum bytebase.v1.PlanCheckRun.Result.Type.
 */
export declare const PlanCheckRun_Result_TypeSchema: GenEnum<PlanCheckRun_Result_Type>;

/**
 * @generated from enum bytebase.v1.PlanCheckRun.Status
 */
export enum PlanCheckRun_Status {
  /**
   * @generated from enum value: STATUS_UNSPECIFIED = 0;
   */
  STATUS_UNSPECIFIED = 0,

  /**
   * @generated from enum value: RUNNING = 1;
   */
  RUNNING = 1,

  /**
   * @generated from enum value: DONE = 2;
   */
  DONE = 2,

  /**
   * @generated from enum value: FAILED = 3;
   */
  FAILED = 3,

  /**
   * @generated from enum value: CANCELED = 4;
   */
  CANCELED = 4,
}

/**
 * Describes the enum bytebase.v1.PlanCheckRun.Status.
 */
export declare const PlanCheckRun_StatusSchema: GenEnum<PlanCheckRun_Status>;

/**
 * PlanService manages deployment plans for database changes.
 *
 * @generated from service bytebase.v1.PlanService
 */
export declare const PlanService: GenService<{
  /**
   * Retrieves a deployment plan by name.
   * Permissions required: bb.plans.get
   *
   * @generated from rpc bytebase.v1.PlanService.GetPlan
   */
  getPlan: {
    methodKind: "unary";
    input: typeof GetPlanRequestSchema;
    output: typeof PlanSchema;
  },
  /**
   * Lists deployment plans in a project.
   * Permissions required: bb.plans.list
   *
   * @generated from rpc bytebase.v1.PlanService.ListPlans
   */
  listPlans: {
    methodKind: "unary";
    input: typeof ListPlansRequestSchema;
    output: typeof ListPlansResponseSchema;
  },
  /**
   * Creates a new deployment plan.
   * Permissions required: bb.plans.create
   *
   * @generated from rpc bytebase.v1.PlanService.CreatePlan
   */
  createPlan: {
    methodKind: "unary";
    input: typeof CreatePlanRequestSchema;
    output: typeof PlanSchema;
  },
  /**
   * UpdatePlan updates the plan.
   * The plan creator and the user with bb.plans.update permission on the project can update the plan.
   * Permissions required: bb.plans.update (or creator)
   *
   * @generated from rpc bytebase.v1.PlanService.UpdatePlan
   */
  updatePlan: {
    methodKind: "unary";
    input: typeof UpdatePlanRequestSchema;
    output: typeof PlanSchema;
  },
  /**
   * Gets the plan check run for a deployment plan.
   * Permissions required: bb.planCheckRuns.get
   *
   * @generated from rpc bytebase.v1.PlanService.GetPlanCheckRun
   */
  getPlanCheckRun: {
    methodKind: "unary";
    input: typeof GetPlanCheckRunRequestSchema;
    output: typeof PlanCheckRunSchema;
  },
  /**
   * Executes validation checks on a deployment plan.
   * Permissions required: bb.planCheckRuns.run
   *
   * @generated from rpc bytebase.v1.PlanService.RunPlanChecks
   */
  runPlanChecks: {
    methodKind: "unary";
    input: typeof RunPlanChecksRequestSchema;
    output: typeof RunPlanChecksResponseSchema;
  },
  /**
   * Cancels the plan check run for a deployment plan.
   * Permissions required: bb.planCheckRuns.run
   *
   * @generated from rpc bytebase.v1.PlanService.CancelPlanCheckRun
   */
  cancelPlanCheckRun: {
    methodKind: "unary";
    input: typeof CancelPlanCheckRunRequestSchema;
    output: typeof CancelPlanCheckRunResponseSchema;
  },
}>;

