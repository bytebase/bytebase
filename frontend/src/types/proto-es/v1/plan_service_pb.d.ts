// @generated by protoc-gen-es v2.5.2
// @generated from file v1/plan_service.proto (package bytebase.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";
import type { FieldMask, Timestamp } from "@bufbuild/protobuf/wkt";
import type { ExportFormat, Position, State } from "./common_pb";
import type { ChangedResources } from "./database_service_pb";

/**
 * Describes the file v1/plan_service.proto.
 */
export declare const file_v1_plan_service: GenFile;

/**
 * @generated from message bytebase.v1.GetPlanRequest
 */
export declare type GetPlanRequest = Message<"bytebase.v1.GetPlanRequest"> & {
  /**
   * The name of the plan to retrieve.
   * Format: projects/{project}/plans/{plan}
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message bytebase.v1.GetPlanRequest.
 * Use `create(GetPlanRequestSchema)` to create a new message.
 */
export declare const GetPlanRequestSchema: GenMessage<GetPlanRequest>;

/**
 * @generated from message bytebase.v1.ListPlansRequest
 */
export declare type ListPlansRequest = Message<"bytebase.v1.ListPlansRequest"> & {
  /**
   * The parent, which owns this collection of plans.
   * Format: projects/{project}
   * Use "projects/-" to list all plans from all projects.
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * The maximum number of plans to return. The service may return fewer than
   * this value.
   * If unspecified, at most 10 plans will be returned.
   * The maximum value is 1000; values above 1000 will be coerced to 1000.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize: number;

  /**
   * A page token, received from a previous `ListPlans` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListPlans` must match
   * the call that provided the page token.
   *
   * @generated from field: string page_token = 3;
   */
  pageToken: string;
};

/**
 * Describes the message bytebase.v1.ListPlansRequest.
 * Use `create(ListPlansRequestSchema)` to create a new message.
 */
export declare const ListPlansRequestSchema: GenMessage<ListPlansRequest>;

/**
 * @generated from message bytebase.v1.ListPlansResponse
 */
export declare type ListPlansResponse = Message<"bytebase.v1.ListPlansResponse"> & {
  /**
   * The plans from the specified request.
   *
   * @generated from field: repeated bytebase.v1.Plan plans = 1;
   */
  plans: Plan[];

  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message bytebase.v1.ListPlansResponse.
 * Use `create(ListPlansResponseSchema)` to create a new message.
 */
export declare const ListPlansResponseSchema: GenMessage<ListPlansResponse>;

/**
 * @generated from message bytebase.v1.SearchPlansRequest
 */
export declare type SearchPlansRequest = Message<"bytebase.v1.SearchPlansRequest"> & {
  /**
   * The parent, which owns this collection of plans.
   * Format: projects/{project}
   * Use "projects/-" to list all plans from all projects.
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * The maximum number of plans to return. The service may return fewer than
   * this value.
   * If unspecified, at most 10 plans will be returned.
   * The maximum value is 1000; values above 1000 will be coerced to 1000.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize: number;

  /**
   * A page token, received from a previous `SearchPlans` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `SearchPlans` must match
   * the call that provided the page token.
   *
   * @generated from field: string page_token = 3;
   */
  pageToken: string;

  /**
   * Filter is used to filter plans returned in the list.
   * The syntax and semantics of CEL are documented at https://github.com/google/cel-spec
   *
   * Supported filters:
   * - creator: the plan creator full name in "users/{email or id}" format, support "==" operator.
   * - create_time: the plan create time in "2006-01-02T15:04:05Z07:00" format, support ">=" or "<=" operator.
   * - has_pipeline: the plan has pipeline or not, support "==" operator, the value should be "true" or "false".
   * - has_issue: the plan has issue or not, support "==" operator, the value should be "true" or "false".
   * - title: the plan title, support "==" operator for exact match and ".matches()" operator for case-insensitive substring match.
   * - spec_type: the plan spec config type, support "==" operator, the value should be "create_database_config", "change_database_config", or "export_data_config".
   * - state: the plan state, support "==" operator, the value should be "ACTIVE" or "DELETED".
   *
   * For example:
   * creator == "users/ed@bytebase.com" && create_time >= "2025-01-02T15:04:05Z07:00"
   * has_pipeline == false && has_issue == true
   * title == "My Plan"
   * title.matches("database migration")
   * spec_type == "change_database_config"
   * state == "ACTIVE"
   *
   * @generated from field: string filter = 4;
   */
  filter: string;
};

/**
 * Describes the message bytebase.v1.SearchPlansRequest.
 * Use `create(SearchPlansRequestSchema)` to create a new message.
 */
export declare const SearchPlansRequestSchema: GenMessage<SearchPlansRequest>;

/**
 * @generated from message bytebase.v1.SearchPlansResponse
 */
export declare type SearchPlansResponse = Message<"bytebase.v1.SearchPlansResponse"> & {
  /**
   * The plans from the specified request.
   *
   * @generated from field: repeated bytebase.v1.Plan plans = 1;
   */
  plans: Plan[];

  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message bytebase.v1.SearchPlansResponse.
 * Use `create(SearchPlansResponseSchema)` to create a new message.
 */
export declare const SearchPlansResponseSchema: GenMessage<SearchPlansResponse>;

/**
 * @generated from message bytebase.v1.CreatePlanRequest
 */
export declare type CreatePlanRequest = Message<"bytebase.v1.CreatePlanRequest"> & {
  /**
   * The parent project where this plan will be created.
   * Format: projects/{project}
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * The plan to create.
   *
   * @generated from field: bytebase.v1.Plan plan = 2;
   */
  plan?: Plan;
};

/**
 * Describes the message bytebase.v1.CreatePlanRequest.
 * Use `create(CreatePlanRequestSchema)` to create a new message.
 */
export declare const CreatePlanRequestSchema: GenMessage<CreatePlanRequest>;

/**
 * @generated from message bytebase.v1.UpdatePlanRequest
 */
export declare type UpdatePlanRequest = Message<"bytebase.v1.UpdatePlanRequest"> & {
  /**
   * The plan to update.
   *
   * The plan's `name` field is used to identify the plan to update.
   * Format: projects/{project}/plans/{plan}
   *
   * @generated from field: bytebase.v1.Plan plan = 1;
   */
  plan?: Plan;

  /**
   * The list of fields to update.
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 2;
   */
  updateMask?: FieldMask;
};

/**
 * Describes the message bytebase.v1.UpdatePlanRequest.
 * Use `create(UpdatePlanRequestSchema)` to create a new message.
 */
export declare const UpdatePlanRequestSchema: GenMessage<UpdatePlanRequest>;

/**
 * @generated from message bytebase.v1.Plan
 */
export declare type Plan = Message<"bytebase.v1.Plan"> & {
  /**
   * The name of the plan.
   * `plan` is a system generated ID.
   * Format: projects/{project}/plans/{plan}
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The state of the plan.
   *
   * @generated from field: bytebase.v1.State state = 2;
   */
  state: State;

  /**
   * The issue associated with the plan.
   * Can be empty.
   * Format: projects/{project}/issues/{issue}
   *
   * @generated from field: string issue = 3;
   */
  issue: string;

  /**
   * The rollout associated with the plan.
   * Can be empty.
   * Format: projects/{project}/rollouts/{rollout}
   *
   * @generated from field: string rollout = 15;
   */
  rollout: string;

  /**
   * @generated from field: string title = 4;
   */
  title: string;

  /**
   * @generated from field: string description = 5;
   */
  description: string;

  /**
   * @generated from field: repeated bytebase.v1.Plan.Spec specs = 14;
   */
  specs: Plan_Spec[];

  /**
   * Format: users/hello@world.com
   *
   * @generated from field: string creator = 8;
   */
  creator: string;

  /**
   * @generated from field: google.protobuf.Timestamp create_time = 9;
   */
  createTime?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp update_time = 10;
   */
  updateTime?: Timestamp;

  /**
   * The status count of the latest plan check runs.
   * Keys are:
   * - SUCCESS
   * - WARNING
   * - ERROR
   * - RUNNING
   *
   * @generated from field: map<string, int32> plan_check_run_status_count = 11;
   */
  planCheckRunStatusCount: { [key: string]: number };

  /**
   * @generated from field: bytebase.v1.Plan.Deployment deployment = 13;
   */
  deployment?: Plan_Deployment;
};

/**
 * Describes the message bytebase.v1.Plan.
 * Use `create(PlanSchema)` to create a new message.
 */
export declare const PlanSchema: GenMessage<Plan>;

/**
 * @generated from message bytebase.v1.Plan.Spec
 */
export declare type Plan_Spec = Message<"bytebase.v1.Plan.Spec"> & {
  /**
   * A UUID4 string that uniquely identifies the Spec.
   *
   * @generated from field: string id = 5;
   */
  id: string;

  /**
   * @generated from oneof bytebase.v1.Plan.Spec.config
   */
  config: {
    /**
     * @generated from field: bytebase.v1.Plan.CreateDatabaseConfig create_database_config = 1;
     */
    value: Plan_CreateDatabaseConfig;
    case: "createDatabaseConfig";
  } | {
    /**
     * @generated from field: bytebase.v1.Plan.ChangeDatabaseConfig change_database_config = 2;
     */
    value: Plan_ChangeDatabaseConfig;
    case: "changeDatabaseConfig";
  } | {
    /**
     * @generated from field: bytebase.v1.Plan.ExportDataConfig export_data_config = 7;
     */
    value: Plan_ExportDataConfig;
    case: "exportDataConfig";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message bytebase.v1.Plan.Spec.
 * Use `create(Plan_SpecSchema)` to create a new message.
 */
export declare const Plan_SpecSchema: GenMessage<Plan_Spec>;

/**
 * @generated from message bytebase.v1.Plan.CreateDatabaseConfig
 */
export declare type Plan_CreateDatabaseConfig = Message<"bytebase.v1.Plan.CreateDatabaseConfig"> & {
  /**
   * The resource name of the instance on which the database is created.
   * Format: instances/{instance}
   *
   * @generated from field: string target = 1;
   */
  target: string;

  /**
   * The name of the database to create.
   *
   * @generated from field: string database = 2;
   */
  database: string;

  /**
   * table is the name of the table, if it is not empty, Bytebase should create a table after creating the database.
   * For example, in MongoDB, it only creates the database when we first store data in that database.
   *
   * @generated from field: string table = 3;
   */
  table: string;

  /**
   * character_set is the character set of the database.
   *
   * @generated from field: string character_set = 4;
   */
  characterSet: string;

  /**
   * collation is the collation of the database.
   *
   * @generated from field: string collation = 5;
   */
  collation: string;

  /**
   * cluster is the cluster of the database. This is only applicable to ClickHouse for "ON CLUSTER <<cluster>>".
   *
   * @generated from field: string cluster = 6;
   */
  cluster: string;

  /**
   * owner is the owner of the database. This is only applicable to Postgres for "WITH OWNER <<owner>>".
   *
   * @generated from field: string owner = 7;
   */
  owner: string;

  /**
   * The environment resource.
   * Format: environments/prod where prod is the environment resource ID.
   *
   * @generated from field: string environment = 9;
   */
  environment: string;
};

/**
 * Describes the message bytebase.v1.Plan.CreateDatabaseConfig.
 * Use `create(Plan_CreateDatabaseConfigSchema)` to create a new message.
 */
export declare const Plan_CreateDatabaseConfigSchema: GenMessage<Plan_CreateDatabaseConfig>;

/**
 * @generated from message bytebase.v1.Plan.ChangeDatabaseConfig
 */
export declare type Plan_ChangeDatabaseConfig = Message<"bytebase.v1.Plan.ChangeDatabaseConfig"> & {
  /**
   * The list of targets.
   * Multi-database format: [instances/{instance-id}/databases/{database-name}].
   * Single database group format: [projects/{project}/databaseGroups/{databaseGroup}].
   *
   * @generated from field: repeated string targets = 10;
   */
  targets: string[];

  /**
   * The resource name of the sheet.
   * Format: projects/{project}/sheets/{sheet}
   *
   * @generated from field: string sheet = 2;
   */
  sheet: string;

  /**
   * The resource name of the release.
   * Format: projects/{project}/releases/{release}
   *
   * @generated from field: string release = 9;
   */
  release: string;

  /**
   * @generated from field: bytebase.v1.Plan.ChangeDatabaseConfig.Type type = 3;
   */
  type: Plan_ChangeDatabaseConfig_Type;

  /**
   * @generated from field: map<string, string> ghost_flags = 7;
   */
  ghostFlags: { [key: string]: string };

  /**
   * If set, a backup of the modified data will be created automatically before any changes are applied.
   *
   * @generated from field: bool enable_prior_backup = 8;
   */
  enablePriorBackup: boolean;
};

/**
 * Describes the message bytebase.v1.Plan.ChangeDatabaseConfig.
 * Use `create(Plan_ChangeDatabaseConfigSchema)` to create a new message.
 */
export declare const Plan_ChangeDatabaseConfigSchema: GenMessage<Plan_ChangeDatabaseConfig>;

/**
 * Type is the database change type.
 *
 * @generated from enum bytebase.v1.Plan.ChangeDatabaseConfig.Type
 */
export enum Plan_ChangeDatabaseConfig_Type {
  /**
   * @generated from enum value: TYPE_UNSPECIFIED = 0;
   */
  TYPE_UNSPECIFIED = 0,

  /**
   * Used for DDL changes including CREATE DATABASE.
   *
   * @generated from enum value: MIGRATE = 2;
   */
  MIGRATE = 2,

  /**
   * Used for schema changes via state-based schema migration including CREATE DATABASE.
   *
   * @generated from enum value: MIGRATE_SDL = 3;
   */
  MIGRATE_SDL = 3,

  /**
   * Used for DDL changes using gh-ost.
   *
   * @generated from enum value: MIGRATE_GHOST = 4;
   */
  MIGRATE_GHOST = 4,

  /**
   * Used for DML change.
   *
   * @generated from enum value: DATA = 6;
   */
  DATA = 6,
}

/**
 * Describes the enum bytebase.v1.Plan.ChangeDatabaseConfig.Type.
 */
export declare const Plan_ChangeDatabaseConfig_TypeSchema: GenEnum<Plan_ChangeDatabaseConfig_Type>;

/**
 * @generated from message bytebase.v1.Plan.ExportDataConfig
 */
export declare type Plan_ExportDataConfig = Message<"bytebase.v1.Plan.ExportDataConfig"> & {
  /**
   * The list of targets.
   * Multi-database format: [instances/{instance-id}/databases/{database-name}].
   * Single database group format: [projects/{project}/databaseGroups/{databaseGroup}].
   *
   * @generated from field: repeated string targets = 5;
   */
  targets: string[];

  /**
   * The resource name of the sheet.
   * Format: projects/{project}/sheets/{sheet}
   *
   * @generated from field: string sheet = 2;
   */
  sheet: string;

  /**
   * The format of the exported file.
   *
   * @generated from field: bytebase.v1.ExportFormat format = 3;
   */
  format: ExportFormat;

  /**
   * The zip password provide by users.
   * Leave it empty if no needs to encrypt the zip file.
   *
   * @generated from field: optional string password = 4;
   */
  password?: string;
};

/**
 * Describes the message bytebase.v1.Plan.ExportDataConfig.
 * Use `create(Plan_ExportDataConfigSchema)` to create a new message.
 */
export declare const Plan_ExportDataConfigSchema: GenMessage<Plan_ExportDataConfig>;

/**
 * @generated from message bytebase.v1.Plan.Deployment
 */
export declare type Plan_Deployment = Message<"bytebase.v1.Plan.Deployment"> & {
  /**
   * The environments deploy order.
   *
   * @generated from field: repeated string environments = 1;
   */
  environments: string[];

  /**
   * The database group mapping.
   *
   * @generated from field: repeated bytebase.v1.Plan.Deployment.DatabaseGroupMapping database_group_mappings = 2;
   */
  databaseGroupMappings: Plan_Deployment_DatabaseGroupMapping[];
};

/**
 * Describes the message bytebase.v1.Plan.Deployment.
 * Use `create(Plan_DeploymentSchema)` to create a new message.
 */
export declare const Plan_DeploymentSchema: GenMessage<Plan_Deployment>;

/**
 * @generated from message bytebase.v1.Plan.Deployment.DatabaseGroupMapping
 */
export declare type Plan_Deployment_DatabaseGroupMapping = Message<"bytebase.v1.Plan.Deployment.DatabaseGroupMapping"> & {
  /**
   * Format: projects/{project}/databaseGroups/{databaseGroup}.
   *
   * @generated from field: string database_group = 1;
   */
  databaseGroup: string;

  /**
   * Format: instances/{instance-id}/databases/{database-name}.
   *
   * @generated from field: repeated string databases = 2;
   */
  databases: string[];
};

/**
 * Describes the message bytebase.v1.Plan.Deployment.DatabaseGroupMapping.
 * Use `create(Plan_Deployment_DatabaseGroupMappingSchema)` to create a new message.
 */
export declare const Plan_Deployment_DatabaseGroupMappingSchema: GenMessage<Plan_Deployment_DatabaseGroupMapping>;

/**
 * @generated from message bytebase.v1.ListPlanCheckRunsRequest
 */
export declare type ListPlanCheckRunsRequest = Message<"bytebase.v1.ListPlanCheckRunsRequest"> & {
  /**
   * The parent, which owns this collection of plan check runs.
   * Format: projects/{project}/plans/{plan}
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * Not used.
   * The maximum number of plan check runs to return. The service may return fewer than
   * this value.
   * If unspecified, at most 10 plan check runs will be returned.
   * The maximum value is 1000; values above 1000 will be coerced to 1000.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize: number;

  /**
   * Not used.
   * A page token, received from a previous `ListPlanCheckRuns` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListPlanCheckRuns` must match
   * the call that provided the page token.
   *
   * @generated from field: string page_token = 3;
   */
  pageToken: string;

  /**
   * If set to true, only the latest plan check run will be returned.
   *
   * @generated from field: bool latest_only = 4;
   */
  latestOnly: boolean;

  /**
   * Filter is used to filter plan check runs returned in the list.
   * The syntax and semantics of CEL are documented at https://github.com/google/cel-spec
   *
   * Supported filters:
   * - status: the plan check run status, support "==" and "in" operator, check the Status enum in the PlanCheckRun message for the values.
   * - result_status: the plan check run result status, support "==" and "in" operator, check the Result.Status enum in the PlanCheckRun message for the values.
   *
   * For example:
   * status in ["DONE", "FAILED"]
   * status == "RUNNING"
   * result_status in ["SUCCESS", "ERROR"]
   * result_status == "WARNING"
   *
   * @generated from field: string filter = 5;
   */
  filter: string;
};

/**
 * Describes the message bytebase.v1.ListPlanCheckRunsRequest.
 * Use `create(ListPlanCheckRunsRequestSchema)` to create a new message.
 */
export declare const ListPlanCheckRunsRequestSchema: GenMessage<ListPlanCheckRunsRequest>;

/**
 * @generated from message bytebase.v1.ListPlanCheckRunsResponse
 */
export declare type ListPlanCheckRunsResponse = Message<"bytebase.v1.ListPlanCheckRunsResponse"> & {
  /**
   * The plan check runs from the specified request.
   *
   * @generated from field: repeated bytebase.v1.PlanCheckRun plan_check_runs = 1;
   */
  planCheckRuns: PlanCheckRun[];

  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message bytebase.v1.ListPlanCheckRunsResponse.
 * Use `create(ListPlanCheckRunsResponseSchema)` to create a new message.
 */
export declare const ListPlanCheckRunsResponseSchema: GenMessage<ListPlanCheckRunsResponse>;

/**
 * @generated from message bytebase.v1.RunPlanChecksRequest
 */
export declare type RunPlanChecksRequest = Message<"bytebase.v1.RunPlanChecksRequest"> & {
  /**
   * The plan to run plan checks.
   * Format: projects/{project}/plans/{plan}
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The UUID of the specific spec to run plan checks for.
   * This should match the spec.id field in Plan.Spec.
   * If not set, all specs in the plan will be used.
   *
   * @generated from field: optional string spec_id = 2;
   */
  specId?: string;
};

/**
 * Describes the message bytebase.v1.RunPlanChecksRequest.
 * Use `create(RunPlanChecksRequestSchema)` to create a new message.
 */
export declare const RunPlanChecksRequestSchema: GenMessage<RunPlanChecksRequest>;

/**
 * @generated from message bytebase.v1.RunPlanChecksResponse
 */
export declare type RunPlanChecksResponse = Message<"bytebase.v1.RunPlanChecksResponse"> & {
};

/**
 * Describes the message bytebase.v1.RunPlanChecksResponse.
 * Use `create(RunPlanChecksResponseSchema)` to create a new message.
 */
export declare const RunPlanChecksResponseSchema: GenMessage<RunPlanChecksResponse>;

/**
 * @generated from message bytebase.v1.BatchCancelPlanCheckRunsRequest
 */
export declare type BatchCancelPlanCheckRunsRequest = Message<"bytebase.v1.BatchCancelPlanCheckRunsRequest"> & {
  /**
   * The name of the parent of the planChecks.
   * Format: projects/{project}/plans/{plan}
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * TODO(d): update this API.
   * The planCheckRuns to cancel.
   * Format: projects/{project}/plans/{plan}/planCheckRuns/{planCheckRun}
   *
   * @generated from field: repeated string plan_check_runs = 2;
   */
  planCheckRuns: string[];
};

/**
 * Describes the message bytebase.v1.BatchCancelPlanCheckRunsRequest.
 * Use `create(BatchCancelPlanCheckRunsRequestSchema)` to create a new message.
 */
export declare const BatchCancelPlanCheckRunsRequestSchema: GenMessage<BatchCancelPlanCheckRunsRequest>;

/**
 * @generated from message bytebase.v1.BatchCancelPlanCheckRunsResponse
 */
export declare type BatchCancelPlanCheckRunsResponse = Message<"bytebase.v1.BatchCancelPlanCheckRunsResponse"> & {
};

/**
 * Describes the message bytebase.v1.BatchCancelPlanCheckRunsResponse.
 * Use `create(BatchCancelPlanCheckRunsResponseSchema)` to create a new message.
 */
export declare const BatchCancelPlanCheckRunsResponseSchema: GenMessage<BatchCancelPlanCheckRunsResponse>;

/**
 * @generated from message bytebase.v1.PlanCheckRun
 */
export declare type PlanCheckRun = Message<"bytebase.v1.PlanCheckRun"> & {
  /**
   * Format: projects/{project}/plans/{plan}/planCheckRuns/{planCheckRun}
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: bytebase.v1.PlanCheckRun.Type type = 3;
   */
  type: PlanCheckRun_Type;

  /**
   * @generated from field: bytebase.v1.PlanCheckRun.Status status = 4;
   */
  status: PlanCheckRun_Status;

  /**
   * Format: instances/{instance}/databases/{database}
   *
   * @generated from field: string target = 5;
   */
  target: string;

  /**
   * Format: project/{project}/sheets/{sheet}
   *
   * @generated from field: string sheet = 6;
   */
  sheet: string;

  /**
   * @generated from field: repeated bytebase.v1.PlanCheckRun.Result results = 7;
   */
  results: PlanCheckRun_Result[];

  /**
   * error is set if the Status is FAILED.
   *
   * @generated from field: string error = 8;
   */
  error: string;

  /**
   * @generated from field: google.protobuf.Timestamp create_time = 9;
   */
  createTime?: Timestamp;
};

/**
 * Describes the message bytebase.v1.PlanCheckRun.
 * Use `create(PlanCheckRunSchema)` to create a new message.
 */
export declare const PlanCheckRunSchema: GenMessage<PlanCheckRun>;

/**
 * @generated from message bytebase.v1.PlanCheckRun.Result
 */
export declare type PlanCheckRun_Result = Message<"bytebase.v1.PlanCheckRun.Result"> & {
  /**
   * @generated from field: bytebase.v1.PlanCheckRun.Result.Status status = 1;
   */
  status: PlanCheckRun_Result_Status;

  /**
   * @generated from field: string title = 2;
   */
  title: string;

  /**
   * @generated from field: string content = 3;
   */
  content: string;

  /**
   * @generated from field: int32 code = 4;
   */
  code: number;

  /**
   * @generated from oneof bytebase.v1.PlanCheckRun.Result.report
   */
  report: {
    /**
     * @generated from field: bytebase.v1.PlanCheckRun.Result.SqlSummaryReport sql_summary_report = 5;
     */
    value: PlanCheckRun_Result_SqlSummaryReport;
    case: "sqlSummaryReport";
  } | {
    /**
     * @generated from field: bytebase.v1.PlanCheckRun.Result.SqlReviewReport sql_review_report = 6;
     */
    value: PlanCheckRun_Result_SqlReviewReport;
    case: "sqlReviewReport";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message bytebase.v1.PlanCheckRun.Result.
 * Use `create(PlanCheckRun_ResultSchema)` to create a new message.
 */
export declare const PlanCheckRun_ResultSchema: GenMessage<PlanCheckRun_Result>;

/**
 * @generated from message bytebase.v1.PlanCheckRun.Result.SqlSummaryReport
 */
export declare type PlanCheckRun_Result_SqlSummaryReport = Message<"bytebase.v1.PlanCheckRun.Result.SqlSummaryReport"> & {
  /**
   * statement_types are the types of statements that are found in the sql.
   *
   * @generated from field: repeated string statement_types = 2;
   */
  statementTypes: string[];

  /**
   * @generated from field: int64 affected_rows = 3;
   */
  affectedRows: bigint;

  /**
   * @generated from field: bytebase.v1.ChangedResources changed_resources = 4;
   */
  changedResources?: ChangedResources;
};

/**
 * Describes the message bytebase.v1.PlanCheckRun.Result.SqlSummaryReport.
 * Use `create(PlanCheckRun_Result_SqlSummaryReportSchema)` to create a new message.
 */
export declare const PlanCheckRun_Result_SqlSummaryReportSchema: GenMessage<PlanCheckRun_Result_SqlSummaryReport>;

/**
 * @generated from message bytebase.v1.PlanCheckRun.Result.SqlReviewReport
 */
export declare type PlanCheckRun_Result_SqlReviewReport = Message<"bytebase.v1.PlanCheckRun.Result.SqlReviewReport"> & {
  /**
   * @generated from field: int32 line = 1;
   */
  line: number;

  /**
   * @generated from field: int32 column = 2;
   */
  column: number;

  /**
   * 1-based Position of the SQL statement.
   * To supersede `line` and `column` above.
   *
   * @generated from field: bytebase.v1.Position start_position = 5;
   */
  startPosition?: Position;

  /**
   * @generated from field: bytebase.v1.Position end_position = 6;
   */
  endPosition?: Position;
};

/**
 * Describes the message bytebase.v1.PlanCheckRun.Result.SqlReviewReport.
 * Use `create(PlanCheckRun_Result_SqlReviewReportSchema)` to create a new message.
 */
export declare const PlanCheckRun_Result_SqlReviewReportSchema: GenMessage<PlanCheckRun_Result_SqlReviewReport>;

/**
 * @generated from enum bytebase.v1.PlanCheckRun.Result.Status
 */
export enum PlanCheckRun_Result_Status {
  /**
   * @generated from enum value: STATUS_UNSPECIFIED = 0;
   */
  STATUS_UNSPECIFIED = 0,

  /**
   * @generated from enum value: ERROR = 1;
   */
  ERROR = 1,

  /**
   * @generated from enum value: WARNING = 2;
   */
  WARNING = 2,

  /**
   * @generated from enum value: SUCCESS = 3;
   */
  SUCCESS = 3,
}

/**
 * Describes the enum bytebase.v1.PlanCheckRun.Result.Status.
 */
export declare const PlanCheckRun_Result_StatusSchema: GenEnum<PlanCheckRun_Result_Status>;

/**
 * @generated from enum bytebase.v1.PlanCheckRun.Type
 */
export enum PlanCheckRun_Type {
  /**
   * @generated from enum value: TYPE_UNSPECIFIED = 0;
   */
  TYPE_UNSPECIFIED = 0,

  /**
   * @generated from enum value: DATABASE_STATEMENT_FAKE_ADVISE = 1;
   */
  DATABASE_STATEMENT_FAKE_ADVISE = 1,

  /**
   * @generated from enum value: DATABASE_STATEMENT_ADVISE = 3;
   */
  DATABASE_STATEMENT_ADVISE = 3,

  /**
   * @generated from enum value: DATABASE_STATEMENT_SUMMARY_REPORT = 5;
   */
  DATABASE_STATEMENT_SUMMARY_REPORT = 5,

  /**
   * @generated from enum value: DATABASE_CONNECT = 6;
   */
  DATABASE_CONNECT = 6,

  /**
   * @generated from enum value: DATABASE_GHOST_SYNC = 7;
   */
  DATABASE_GHOST_SYNC = 7,
}

/**
 * Describes the enum bytebase.v1.PlanCheckRun.Type.
 */
export declare const PlanCheckRun_TypeSchema: GenEnum<PlanCheckRun_Type>;

/**
 * @generated from enum bytebase.v1.PlanCheckRun.Status
 */
export enum PlanCheckRun_Status {
  /**
   * @generated from enum value: STATUS_UNSPECIFIED = 0;
   */
  STATUS_UNSPECIFIED = 0,

  /**
   * @generated from enum value: RUNNING = 1;
   */
  RUNNING = 1,

  /**
   * @generated from enum value: DONE = 2;
   */
  DONE = 2,

  /**
   * @generated from enum value: FAILED = 3;
   */
  FAILED = 3,

  /**
   * @generated from enum value: CANCELED = 4;
   */
  CANCELED = 4,
}

/**
 * Describes the enum bytebase.v1.PlanCheckRun.Status.
 */
export declare const PlanCheckRun_StatusSchema: GenEnum<PlanCheckRun_Status>;

/**
 * @generated from service bytebase.v1.PlanService
 */
export declare const PlanService: GenService<{
  /**
   * Permissions required: bb.plans.get
   *
   * @generated from rpc bytebase.v1.PlanService.GetPlan
   */
  getPlan: {
    methodKind: "unary";
    input: typeof GetPlanRequestSchema;
    output: typeof PlanSchema;
  },
  /**
   * Permissions required: bb.plans.list
   *
   * @generated from rpc bytebase.v1.PlanService.ListPlans
   */
  listPlans: {
    methodKind: "unary";
    input: typeof ListPlansRequestSchema;
    output: typeof ListPlansResponseSchema;
  },
  /**
   * Search for plans that the caller has the bb.plans.get permission on and also satisfy the specified filter & query.
   * Permissions required: bb.plans.get
   *
   * @generated from rpc bytebase.v1.PlanService.SearchPlans
   */
  searchPlans: {
    methodKind: "unary";
    input: typeof SearchPlansRequestSchema;
    output: typeof SearchPlansResponseSchema;
  },
  /**
   * Permissions required: bb.plans.create
   *
   * @generated from rpc bytebase.v1.PlanService.CreatePlan
   */
  createPlan: {
    methodKind: "unary";
    input: typeof CreatePlanRequestSchema;
    output: typeof PlanSchema;
  },
  /**
   * UpdatePlan updates the plan.
   * The plan creator and the user with bb.plans.update permission on the project can update the plan.
   * Permissions required: bb.plans.update
   *
   * @generated from rpc bytebase.v1.PlanService.UpdatePlan
   */
  updatePlan: {
    methodKind: "unary";
    input: typeof UpdatePlanRequestSchema;
    output: typeof PlanSchema;
  },
  /**
   * Permissions required: bb.planCheckRuns.list
   *
   * @generated from rpc bytebase.v1.PlanService.ListPlanCheckRuns
   */
  listPlanCheckRuns: {
    methodKind: "unary";
    input: typeof ListPlanCheckRunsRequestSchema;
    output: typeof ListPlanCheckRunsResponseSchema;
  },
  /**
   * Permissions required: bb.planCheckRuns.run
   *
   * @generated from rpc bytebase.v1.PlanService.RunPlanChecks
   */
  runPlanChecks: {
    methodKind: "unary";
    input: typeof RunPlanChecksRequestSchema;
    output: typeof RunPlanChecksResponseSchema;
  },
  /**
   * Permissions required: bb.planCheckRuns.run
   *
   * @generated from rpc bytebase.v1.PlanService.BatchCancelPlanCheckRuns
   */
  batchCancelPlanCheckRuns: {
    methodKind: "unary";
    input: typeof BatchCancelPlanCheckRunsRequestSchema;
    output: typeof BatchCancelPlanCheckRunsResponseSchema;
  },
}>;

