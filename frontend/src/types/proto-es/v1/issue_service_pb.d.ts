// @generated by protoc-gen-es v2.5.2
// @generated from file v1/issue_service.proto (package bytebase.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";
import type { Duration, FieldMask, Timestamp } from "@bufbuild/protobuf/wkt";
import type { Expr } from "../google/type/expr_pb";

/**
 * Describes the file v1/issue_service.proto.
 */
export declare const file_v1_issue_service: GenFile;

/**
 * @generated from message bytebase.v1.GetIssueRequest
 */
export declare type GetIssueRequest = Message<"bytebase.v1.GetIssueRequest"> & {
  /**
   * The name of the issue to retrieve.
   * Format: projects/{project}/issues/{issue}
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: bool force = 2;
   */
  force: boolean;
};

/**
 * Describes the message bytebase.v1.GetIssueRequest.
 * Use `create(GetIssueRequestSchema)` to create a new message.
 */
export declare const GetIssueRequestSchema: GenMessage<GetIssueRequest>;

/**
 * @generated from message bytebase.v1.CreateIssueRequest
 */
export declare type CreateIssueRequest = Message<"bytebase.v1.CreateIssueRequest"> & {
  /**
   * The parent, which owns this collection of issues.
   * Format: projects/{project}
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * The issue to create.
   *
   * @generated from field: bytebase.v1.Issue issue = 2;
   */
  issue?: Issue;
};

/**
 * Describes the message bytebase.v1.CreateIssueRequest.
 * Use `create(CreateIssueRequestSchema)` to create a new message.
 */
export declare const CreateIssueRequestSchema: GenMessage<CreateIssueRequest>;

/**
 * @generated from message bytebase.v1.ListIssuesRequest
 */
export declare type ListIssuesRequest = Message<"bytebase.v1.ListIssuesRequest"> & {
  /**
   * The parent, which owns this collection of issues.
   * Format: projects/{project}
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * The maximum number of issues to return. The service may return fewer than
   * this value.
   * If unspecified, at most 10 issues will be returned.
   * The maximum value is 1000; values above 1000 will be coerced to 1000.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize: number;

  /**
   * A page token, received from a previous `ListIssues` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListIssues` must match
   * the call that provided the page token.
   *
   * @generated from field: string page_token = 3;
   */
  pageToken: string;

  /**
   * Filter is used to filter issues returned in the list.
   * The syntax and semantics of CEL are documented at https://github.com/google/cel-spec
   *
   * Supported filters:
   * - creator: issue creator full name in "users/{email or id}" format, support "==" operator.
   * - status: the issue status, support "==" and "in" operator, check the IssueStatus enum for the values.
   * - create_time: issue create time in "2006-01-02T15:04:05Z07:00" format, support ">=" or "<=" operator.
   * - type: the issue type, support "==" and "in" operator, check the Type enum in the Issue message for the values.
   * - task_type: support "==" operator, the value can be "DDL", "DML" or "DATA_EXPORT"
   * - instance: the instance full name in the "instances/{id}" format, support "==" operator.
   * - database: the database full name in the "instances/{id}/databases/{name}" format, support "==" operator.
   * - labels: the issue labels, support "==" and "in" operator.
   * - has_pipeline: the issue has pipeline or not, support "==" operator, the value should be "true" or "false".
   *
   * For example:
   * creator == "users/ed@bytebase.com" && status in ["OPEN", "DONE"]
   * status == "CANCELED" && type == "DATABASE_CHANGE"
   * instance == "instances/sample" && labels in ["label1", "label2"]
   * has_pipeline == true && create_time >= "2025-01-02T15:04:05Z07:00"
   *
   * @generated from field: string filter = 4;
   */
  filter: string;

  /**
   * Query is the query statement.
   *
   * @generated from field: string query = 5;
   */
  query: string;
};

/**
 * Describes the message bytebase.v1.ListIssuesRequest.
 * Use `create(ListIssuesRequestSchema)` to create a new message.
 */
export declare const ListIssuesRequestSchema: GenMessage<ListIssuesRequest>;

/**
 * @generated from message bytebase.v1.ListIssuesResponse
 */
export declare type ListIssuesResponse = Message<"bytebase.v1.ListIssuesResponse"> & {
  /**
   * The issues from the specified request.
   *
   * @generated from field: repeated bytebase.v1.Issue issues = 1;
   */
  issues: Issue[];

  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message bytebase.v1.ListIssuesResponse.
 * Use `create(ListIssuesResponseSchema)` to create a new message.
 */
export declare const ListIssuesResponseSchema: GenMessage<ListIssuesResponse>;

/**
 * @generated from message bytebase.v1.SearchIssuesRequest
 */
export declare type SearchIssuesRequest = Message<"bytebase.v1.SearchIssuesRequest"> & {
  /**
   * The parent, which owns this collection of issues.
   * Format: projects/{project}
   * Use "projects/-" to list all issues from all projects.
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * The maximum number of issues to return. The service may return fewer than
   * this value.
   * If unspecified, at most 10 issues will be returned.
   * The maximum value is 1000; values above 1000 will be coerced to 1000.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize: number;

  /**
   * A page token, received from a previous `SearchIssues` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `SearchIssues` must match
   * the call that provided the page token.
   *
   * @generated from field: string page_token = 3;
   */
  pageToken: string;

  /**
   * Filter is used to filter issues returned in the list.
   * Check the filter field in the ListIssuesRequest message.
   *
   * @generated from field: string filter = 4;
   */
  filter: string;

  /**
   * Query is the query statement.
   *
   * @generated from field: string query = 5;
   */
  query: string;
};

/**
 * Describes the message bytebase.v1.SearchIssuesRequest.
 * Use `create(SearchIssuesRequestSchema)` to create a new message.
 */
export declare const SearchIssuesRequestSchema: GenMessage<SearchIssuesRequest>;

/**
 * @generated from message bytebase.v1.SearchIssuesResponse
 */
export declare type SearchIssuesResponse = Message<"bytebase.v1.SearchIssuesResponse"> & {
  /**
   * The issues from the specified request.
   *
   * @generated from field: repeated bytebase.v1.Issue issues = 1;
   */
  issues: Issue[];

  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message bytebase.v1.SearchIssuesResponse.
 * Use `create(SearchIssuesResponseSchema)` to create a new message.
 */
export declare const SearchIssuesResponseSchema: GenMessage<SearchIssuesResponse>;

/**
 * @generated from message bytebase.v1.UpdateIssueRequest
 */
export declare type UpdateIssueRequest = Message<"bytebase.v1.UpdateIssueRequest"> & {
  /**
   * The issue to update.
   *
   * The issue's `name` field is used to identify the issue to update.
   * Format: projects/{project}/issues/{issue}
   *
   * @generated from field: bytebase.v1.Issue issue = 1;
   */
  issue?: Issue;

  /**
   * The list of fields to update.
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 2;
   */
  updateMask?: FieldMask;

  /**
   * If set to true, and the issue is not found, a new issue will be created.
   * In this situation, `update_mask` is ignored.
   *
   * @generated from field: bool allow_missing = 3;
   */
  allowMissing: boolean;
};

/**
 * Describes the message bytebase.v1.UpdateIssueRequest.
 * Use `create(UpdateIssueRequestSchema)` to create a new message.
 */
export declare const UpdateIssueRequestSchema: GenMessage<UpdateIssueRequest>;

/**
 * @generated from message bytebase.v1.BatchUpdateIssuesStatusRequest
 */
export declare type BatchUpdateIssuesStatusRequest = Message<"bytebase.v1.BatchUpdateIssuesStatusRequest"> & {
  /**
   * The parent resource shared by all issues being updated.
   * Format: projects/{project}
   * If the operation spans parents, a dash (-) may be accepted as a wildcard.
   * We only support updating the status of databases for now.
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * The list of issues to update.
   * Format: projects/{project}/issues/{issue}
   *
   * @generated from field: repeated string issues = 2;
   */
  issues: string[];

  /**
   * The new status.
   *
   * @generated from field: bytebase.v1.IssueStatus status = 3;
   */
  status: IssueStatus;

  /**
   * @generated from field: string reason = 4;
   */
  reason: string;
};

/**
 * Describes the message bytebase.v1.BatchUpdateIssuesStatusRequest.
 * Use `create(BatchUpdateIssuesStatusRequestSchema)` to create a new message.
 */
export declare const BatchUpdateIssuesStatusRequestSchema: GenMessage<BatchUpdateIssuesStatusRequest>;

/**
 * @generated from message bytebase.v1.BatchUpdateIssuesStatusResponse
 */
export declare type BatchUpdateIssuesStatusResponse = Message<"bytebase.v1.BatchUpdateIssuesStatusResponse"> & {
};

/**
 * Describes the message bytebase.v1.BatchUpdateIssuesStatusResponse.
 * Use `create(BatchUpdateIssuesStatusResponseSchema)` to create a new message.
 */
export declare const BatchUpdateIssuesStatusResponseSchema: GenMessage<BatchUpdateIssuesStatusResponse>;

/**
 * @generated from message bytebase.v1.ApproveIssueRequest
 */
export declare type ApproveIssueRequest = Message<"bytebase.v1.ApproveIssueRequest"> & {
  /**
   * The name of the issue to add an approver.
   * Format: projects/{project}/issues/{issue}
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: string comment = 2;
   */
  comment: string;
};

/**
 * Describes the message bytebase.v1.ApproveIssueRequest.
 * Use `create(ApproveIssueRequestSchema)` to create a new message.
 */
export declare const ApproveIssueRequestSchema: GenMessage<ApproveIssueRequest>;

/**
 * @generated from message bytebase.v1.RejectIssueRequest
 */
export declare type RejectIssueRequest = Message<"bytebase.v1.RejectIssueRequest"> & {
  /**
   * The name of the issue to add an rejection.
   * Format: projects/{project}/issues/{issue}
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: string comment = 2;
   */
  comment: string;
};

/**
 * Describes the message bytebase.v1.RejectIssueRequest.
 * Use `create(RejectIssueRequestSchema)` to create a new message.
 */
export declare const RejectIssueRequestSchema: GenMessage<RejectIssueRequest>;

/**
 * @generated from message bytebase.v1.RequestIssueRequest
 */
export declare type RequestIssueRequest = Message<"bytebase.v1.RequestIssueRequest"> & {
  /**
   * The name of the issue to request a issue.
   * Format: projects/{project}/issues/{issue}
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: string comment = 2;
   */
  comment: string;
};

/**
 * Describes the message bytebase.v1.RequestIssueRequest.
 * Use `create(RequestIssueRequestSchema)` to create a new message.
 */
export declare const RequestIssueRequestSchema: GenMessage<RequestIssueRequest>;

/**
 * @generated from message bytebase.v1.Issue
 */
export declare type Issue = Message<"bytebase.v1.Issue"> & {
  /**
   * The name of the issue.
   * Format: projects/{project}/issues/{issue}
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: string title = 3;
   */
  title: string;

  /**
   * @generated from field: string description = 4;
   */
  description: string;

  /**
   * @generated from field: bytebase.v1.Issue.Type type = 5;
   */
  type: Issue_Type;

  /**
   * @generated from field: bytebase.v1.IssueStatus status = 6;
   */
  status: IssueStatus;

  /**
   * @generated from field: repeated bytebase.v1.Issue.Approver approvers = 9;
   */
  approvers: Issue_Approver[];

  /**
   * @generated from field: repeated bytebase.v1.ApprovalTemplate approval_templates = 10;
   */
  approvalTemplates: ApprovalTemplate[];

  /**
   * If the value is `false`, it means that the backend is still finding matching approval templates.
   * If `true`, approval_templates & approvers & approval_finding_error are available.
   *
   * @generated from field: bool approval_finding_done = 11;
   */
  approvalFindingDone: boolean;

  /**
   * @generated from field: string approval_finding_error = 12;
   */
  approvalFindingError: string;

  /**
   * Format: users/hello@world.com
   *
   * @generated from field: string creator = 14;
   */
  creator: string;

  /**
   * @generated from field: google.protobuf.Timestamp create_time = 15;
   */
  createTime?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp update_time = 16;
   */
  updateTime?: Timestamp;

  /**
   * The plan associated with the issue.
   * Can be empty.
   * Format: projects/{project}/plans/{plan}
   *
   * @generated from field: string plan = 17;
   */
  plan: string;

  /**
   * The rollout associated with the issue.
   * Can be empty.
   * Format: projects/{project}/rollouts/{rollout}
   *
   * @generated from field: string rollout = 18;
   */
  rollout: string;

  /**
   * Used if the issue type is GRANT_REQUEST.
   *
   * @generated from field: bytebase.v1.GrantRequest grant_request = 19;
   */
  grantRequest?: GrantRequest;

  /**
   * The releasers of the pending stage of the issue rollout, judging
   * from the rollout policy.
   * Format:
   * - roles/workspaceOwner
   * - roles/workspaceDBA
   * - roles/projectOwner
   * - roles/projectReleaser
   * - users/{email}
   *
   * @generated from field: repeated string releasers = 20;
   */
  releasers: string[];

  /**
   * @generated from field: bytebase.v1.Issue.RiskLevel risk_level = 21;
   */
  riskLevel: Issue_RiskLevel;

  /**
   * The status count of the issue.
   * Keys are the following:
   * - NOT_STARTED
   * - SKIPPED
   * - PENDING
   * - RUNNING
   * - DONE
   * - FAILED
   * - CANCELED
   *
   * @generated from field: map<string, int32> task_status_count = 22;
   */
  taskStatusCount: { [key: string]: number };

  /**
   * @generated from field: repeated string labels = 23;
   */
  labels: string[];
};

/**
 * Describes the message bytebase.v1.Issue.
 * Use `create(IssueSchema)` to create a new message.
 */
export declare const IssueSchema: GenMessage<Issue>;

/**
 * @generated from message bytebase.v1.Issue.Approver
 */
export declare type Issue_Approver = Message<"bytebase.v1.Issue.Approver"> & {
  /**
   * The new status.
   *
   * @generated from field: bytebase.v1.Issue.Approver.Status status = 1;
   */
  status: Issue_Approver_Status;

  /**
   * Format: users/hello@world.com
   *
   * @generated from field: string principal = 2;
   */
  principal: string;
};

/**
 * Describes the message bytebase.v1.Issue.Approver.
 * Use `create(Issue_ApproverSchema)` to create a new message.
 */
export declare const Issue_ApproverSchema: GenMessage<Issue_Approver>;

/**
 * @generated from enum bytebase.v1.Issue.Approver.Status
 */
export enum Issue_Approver_Status {
  /**
   * @generated from enum value: STATUS_UNSPECIFIED = 0;
   */
  STATUS_UNSPECIFIED = 0,

  /**
   * @generated from enum value: PENDING = 1;
   */
  PENDING = 1,

  /**
   * @generated from enum value: APPROVED = 2;
   */
  APPROVED = 2,

  /**
   * @generated from enum value: REJECTED = 3;
   */
  REJECTED = 3,
}

/**
 * Describes the enum bytebase.v1.Issue.Approver.Status.
 */
export declare const Issue_Approver_StatusSchema: GenEnum<Issue_Approver_Status>;

/**
 * @generated from enum bytebase.v1.Issue.Type
 */
export enum Issue_Type {
  /**
   * @generated from enum value: TYPE_UNSPECIFIED = 0;
   */
  TYPE_UNSPECIFIED = 0,

  /**
   * @generated from enum value: DATABASE_CHANGE = 1;
   */
  DATABASE_CHANGE = 1,

  /**
   * @generated from enum value: GRANT_REQUEST = 2;
   */
  GRANT_REQUEST = 2,

  /**
   * @generated from enum value: DATABASE_EXPORT = 3;
   */
  DATABASE_EXPORT = 3,
}

/**
 * Describes the enum bytebase.v1.Issue.Type.
 */
export declare const Issue_TypeSchema: GenEnum<Issue_Type>;

/**
 * @generated from enum bytebase.v1.Issue.RiskLevel
 */
export enum Issue_RiskLevel {
  /**
   * @generated from enum value: RISK_LEVEL_UNSPECIFIED = 0;
   */
  RISK_LEVEL_UNSPECIFIED = 0,

  /**
   * @generated from enum value: LOW = 1;
   */
  LOW = 1,

  /**
   * @generated from enum value: MODERATE = 2;
   */
  MODERATE = 2,

  /**
   * @generated from enum value: HIGH = 3;
   */
  HIGH = 3,
}

/**
 * Describes the enum bytebase.v1.Issue.RiskLevel.
 */
export declare const Issue_RiskLevelSchema: GenEnum<Issue_RiskLevel>;

/**
 * @generated from message bytebase.v1.GrantRequest
 */
export declare type GrantRequest = Message<"bytebase.v1.GrantRequest"> & {
  /**
   * The requested role.
   * Format: roles/EXPORTER.
   *
   * @generated from field: string role = 1;
   */
  role: string;

  /**
   * The user to be granted.
   * Format: users/{email}.
   *
   * @generated from field: string user = 2;
   */
  user: string;

  /**
   * The condition for the role. Same as the condtion in IAM Binding message.
   *
   * @generated from field: google.type.Expr condition = 3;
   */
  condition?: Expr;

  /**
   * @generated from field: google.protobuf.Duration expiration = 4;
   */
  expiration?: Duration;
};

/**
 * Describes the message bytebase.v1.GrantRequest.
 * Use `create(GrantRequestSchema)` to create a new message.
 */
export declare const GrantRequestSchema: GenMessage<GrantRequest>;

/**
 * @generated from message bytebase.v1.ApprovalTemplate
 */
export declare type ApprovalTemplate = Message<"bytebase.v1.ApprovalTemplate"> & {
  /**
   * @generated from field: bytebase.v1.ApprovalFlow flow = 1;
   */
  flow?: ApprovalFlow;

  /**
   * @generated from field: string title = 2;
   */
  title: string;

  /**
   * @generated from field: string description = 3;
   */
  description: string;
};

/**
 * Describes the message bytebase.v1.ApprovalTemplate.
 * Use `create(ApprovalTemplateSchema)` to create a new message.
 */
export declare const ApprovalTemplateSchema: GenMessage<ApprovalTemplate>;

/**
 * @generated from message bytebase.v1.ApprovalFlow
 */
export declare type ApprovalFlow = Message<"bytebase.v1.ApprovalFlow"> & {
  /**
   * @generated from field: repeated bytebase.v1.ApprovalStep steps = 1;
   */
  steps: ApprovalStep[];
};

/**
 * Describes the message bytebase.v1.ApprovalFlow.
 * Use `create(ApprovalFlowSchema)` to create a new message.
 */
export declare const ApprovalFlowSchema: GenMessage<ApprovalFlow>;

/**
 * @generated from message bytebase.v1.ApprovalStep
 */
export declare type ApprovalStep = Message<"bytebase.v1.ApprovalStep"> & {
  /**
   * @generated from field: bytebase.v1.ApprovalStep.Type type = 1;
   */
  type: ApprovalStep_Type;

  /**
   * @generated from field: repeated bytebase.v1.ApprovalNode nodes = 2;
   */
  nodes: ApprovalNode[];
};

/**
 * Describes the message bytebase.v1.ApprovalStep.
 * Use `create(ApprovalStepSchema)` to create a new message.
 */
export declare const ApprovalStepSchema: GenMessage<ApprovalStep>;

/**
 * Type of the ApprovalStep
 * ALL means every node must be approved to proceed.
 * ANY means approving any node will proceed.
 *
 * @generated from enum bytebase.v1.ApprovalStep.Type
 */
export enum ApprovalStep_Type {
  /**
   * @generated from enum value: TYPE_UNSPECIFIED = 0;
   */
  TYPE_UNSPECIFIED = 0,

  /**
   * @generated from enum value: ALL = 1;
   */
  ALL = 1,

  /**
   * @generated from enum value: ANY = 2;
   */
  ANY = 2,
}

/**
 * Describes the enum bytebase.v1.ApprovalStep.Type.
 */
export declare const ApprovalStep_TypeSchema: GenEnum<ApprovalStep_Type>;

/**
 * @generated from message bytebase.v1.ApprovalNode
 */
export declare type ApprovalNode = Message<"bytebase.v1.ApprovalNode"> & {
  /**
   * @generated from field: bytebase.v1.ApprovalNode.Type type = 1;
   */
  type: ApprovalNode_Type;

  /**
   * @generated from field: string role = 2;
   */
  role: string;
};

/**
 * Describes the message bytebase.v1.ApprovalNode.
 * Use `create(ApprovalNodeSchema)` to create a new message.
 */
export declare const ApprovalNodeSchema: GenMessage<ApprovalNode>;

/**
 * Type of the ApprovalNode.
 * type determines who should approve this node.
 * ANY_IN_GROUP means the ApprovalNode can be approved by an user from our predefined user group.
 * See GroupValue below for the predefined user groups.
 *
 * @generated from enum bytebase.v1.ApprovalNode.Type
 */
export enum ApprovalNode_Type {
  /**
   * @generated from enum value: TYPE_UNSPECIFIED = 0;
   */
  TYPE_UNSPECIFIED = 0,

  /**
   * @generated from enum value: ANY_IN_GROUP = 1;
   */
  ANY_IN_GROUP = 1,
}

/**
 * Describes the enum bytebase.v1.ApprovalNode.Type.
 */
export declare const ApprovalNode_TypeSchema: GenEnum<ApprovalNode_Type>;

/**
 * @generated from message bytebase.v1.ListIssueCommentsRequest
 */
export declare type ListIssueCommentsRequest = Message<"bytebase.v1.ListIssueCommentsRequest"> & {
  /**
   * Format: projects/{projects}/issues/{issue}
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * The maximum number of issue comments to return. The service may return fewer than
   * this value.
   * If unspecified, at most 10 issue comments will be returned.
   * The maximum value is 1000; values above 1000 will be coerced to 1000.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize: number;

  /**
   * A page token, received from a previous `ListIssueComments` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListIssueComments` must match
   * the call that provided the page token.
   *
   * @generated from field: string page_token = 3;
   */
  pageToken: string;
};

/**
 * Describes the message bytebase.v1.ListIssueCommentsRequest.
 * Use `create(ListIssueCommentsRequestSchema)` to create a new message.
 */
export declare const ListIssueCommentsRequestSchema: GenMessage<ListIssueCommentsRequest>;

/**
 * @generated from message bytebase.v1.ListIssueCommentsResponse
 */
export declare type ListIssueCommentsResponse = Message<"bytebase.v1.ListIssueCommentsResponse"> & {
  /**
   * @generated from field: repeated bytebase.v1.IssueComment issue_comments = 1;
   */
  issueComments: IssueComment[];

  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message bytebase.v1.ListIssueCommentsResponse.
 * Use `create(ListIssueCommentsResponseSchema)` to create a new message.
 */
export declare const ListIssueCommentsResponseSchema: GenMessage<ListIssueCommentsResponse>;

/**
 * @generated from message bytebase.v1.CreateIssueCommentRequest
 */
export declare type CreateIssueCommentRequest = Message<"bytebase.v1.CreateIssueCommentRequest"> & {
  /**
   * The issue name
   * Format: projects/{project}/issues/{issue}
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * @generated from field: bytebase.v1.IssueComment issue_comment = 2;
   */
  issueComment?: IssueComment;
};

/**
 * Describes the message bytebase.v1.CreateIssueCommentRequest.
 * Use `create(CreateIssueCommentRequestSchema)` to create a new message.
 */
export declare const CreateIssueCommentRequestSchema: GenMessage<CreateIssueCommentRequest>;

/**
 * @generated from message bytebase.v1.UpdateIssueCommentRequest
 */
export declare type UpdateIssueCommentRequest = Message<"bytebase.v1.UpdateIssueCommentRequest"> & {
  /**
   * The issue name
   * Format: projects/{project}/issues/{issue}
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * @generated from field: bytebase.v1.IssueComment issue_comment = 2;
   */
  issueComment?: IssueComment;

  /**
   * The list of fields to update.
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 3;
   */
  updateMask?: FieldMask;

  /**
   * If set to true, and the issue comment is not found, a new issue comment will be created.
   * In this situation, `update_mask` is ignored.
   *
   * @generated from field: bool allow_missing = 4;
   */
  allowMissing: boolean;
};

/**
 * Describes the message bytebase.v1.UpdateIssueCommentRequest.
 * Use `create(UpdateIssueCommentRequestSchema)` to create a new message.
 */
export declare const UpdateIssueCommentRequestSchema: GenMessage<UpdateIssueCommentRequest>;

/**
 * @generated from message bytebase.v1.IssueComment
 */
export declare type IssueComment = Message<"bytebase.v1.IssueComment"> & {
  /**
   * Format: projects/{project}/issues/{issue}/issueComments/{issueComment-uid}
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: string comment = 2;
   */
  comment: string;

  /**
   * TODO: use struct message instead.
   *
   * @generated from field: string payload = 3;
   */
  payload: string;

  /**
   * @generated from field: google.protobuf.Timestamp create_time = 4;
   */
  createTime?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp update_time = 5;
   */
  updateTime?: Timestamp;

  /**
   * Format: users/{email}
   *
   * @generated from field: string creator = 7;
   */
  creator: string;

  /**
   * @generated from oneof bytebase.v1.IssueComment.event
   */
  event: {
    /**
     * @generated from field: bytebase.v1.IssueComment.Approval approval = 8;
     */
    value: IssueComment_Approval;
    case: "approval";
  } | {
    /**
     * @generated from field: bytebase.v1.IssueComment.IssueUpdate issue_update = 9;
     */
    value: IssueComment_IssueUpdate;
    case: "issueUpdate";
  } | {
    /**
     * @generated from field: bytebase.v1.IssueComment.StageEnd stage_end = 10;
     */
    value: IssueComment_StageEnd;
    case: "stageEnd";
  } | {
    /**
     * @generated from field: bytebase.v1.IssueComment.TaskUpdate task_update = 11;
     */
    value: IssueComment_TaskUpdate;
    case: "taskUpdate";
  } | {
    /**
     * @generated from field: bytebase.v1.IssueComment.TaskPriorBackup task_prior_backup = 12;
     */
    value: IssueComment_TaskPriorBackup;
    case: "taskPriorBackup";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message bytebase.v1.IssueComment.
 * Use `create(IssueCommentSchema)` to create a new message.
 */
export declare const IssueCommentSchema: GenMessage<IssueComment>;

/**
 * @generated from message bytebase.v1.IssueComment.Approval
 */
export declare type IssueComment_Approval = Message<"bytebase.v1.IssueComment.Approval"> & {
  /**
   * @generated from field: bytebase.v1.IssueComment.Approval.Status status = 1;
   */
  status: IssueComment_Approval_Status;
};

/**
 * Describes the message bytebase.v1.IssueComment.Approval.
 * Use `create(IssueComment_ApprovalSchema)` to create a new message.
 */
export declare const IssueComment_ApprovalSchema: GenMessage<IssueComment_Approval>;

/**
 * @generated from enum bytebase.v1.IssueComment.Approval.Status
 */
export enum IssueComment_Approval_Status {
  /**
   * @generated from enum value: STATUS_UNSPECIFIED = 0;
   */
  STATUS_UNSPECIFIED = 0,

  /**
   * @generated from enum value: PENDING = 1;
   */
  PENDING = 1,

  /**
   * @generated from enum value: APPROVED = 2;
   */
  APPROVED = 2,

  /**
   * @generated from enum value: REJECTED = 3;
   */
  REJECTED = 3,
}

/**
 * Describes the enum bytebase.v1.IssueComment.Approval.Status.
 */
export declare const IssueComment_Approval_StatusSchema: GenEnum<IssueComment_Approval_Status>;

/**
 * @generated from message bytebase.v1.IssueComment.IssueUpdate
 */
export declare type IssueComment_IssueUpdate = Message<"bytebase.v1.IssueComment.IssueUpdate"> & {
  /**
   * @generated from field: optional string from_title = 1;
   */
  fromTitle?: string;

  /**
   * @generated from field: optional string to_title = 2;
   */
  toTitle?: string;

  /**
   * @generated from field: optional string from_description = 3;
   */
  fromDescription?: string;

  /**
   * @generated from field: optional string to_description = 4;
   */
  toDescription?: string;

  /**
   * @generated from field: optional bytebase.v1.IssueStatus from_status = 5;
   */
  fromStatus?: IssueStatus;

  /**
   * @generated from field: optional bytebase.v1.IssueStatus to_status = 6;
   */
  toStatus?: IssueStatus;

  /**
   * @generated from field: repeated string from_labels = 9;
   */
  fromLabels: string[];

  /**
   * @generated from field: repeated string to_labels = 10;
   */
  toLabels: string[];
};

/**
 * Describes the message bytebase.v1.IssueComment.IssueUpdate.
 * Use `create(IssueComment_IssueUpdateSchema)` to create a new message.
 */
export declare const IssueComment_IssueUpdateSchema: GenMessage<IssueComment_IssueUpdate>;

/**
 * @generated from message bytebase.v1.IssueComment.StageEnd
 */
export declare type IssueComment_StageEnd = Message<"bytebase.v1.IssueComment.StageEnd"> & {
  /**
   * @generated from field: string stage = 1;
   */
  stage: string;
};

/**
 * Describes the message bytebase.v1.IssueComment.StageEnd.
 * Use `create(IssueComment_StageEndSchema)` to create a new message.
 */
export declare const IssueComment_StageEndSchema: GenMessage<IssueComment_StageEnd>;

/**
 * @generated from message bytebase.v1.IssueComment.TaskUpdate
 */
export declare type IssueComment_TaskUpdate = Message<"bytebase.v1.IssueComment.TaskUpdate"> & {
  /**
   * @generated from field: repeated string tasks = 1;
   */
  tasks: string[];

  /**
   * Format: projects/{project}/sheets/{sheet}
   *
   * @generated from field: optional string from_sheet = 2;
   */
  fromSheet?: string;

  /**
   * Format: projects/{project}/sheets/{sheet}
   *
   * @generated from field: optional string to_sheet = 3;
   */
  toSheet?: string;

  /**
   * @generated from field: optional bytebase.v1.IssueComment.TaskUpdate.Status to_status = 6;
   */
  toStatus?: IssueComment_TaskUpdate_Status;
};

/**
 * Describes the message bytebase.v1.IssueComment.TaskUpdate.
 * Use `create(IssueComment_TaskUpdateSchema)` to create a new message.
 */
export declare const IssueComment_TaskUpdateSchema: GenMessage<IssueComment_TaskUpdate>;

/**
 * @generated from enum bytebase.v1.IssueComment.TaskUpdate.Status
 */
export enum IssueComment_TaskUpdate_Status {
  /**
   * @generated from enum value: STATUS_UNSPECIFIED = 0;
   */
  STATUS_UNSPECIFIED = 0,

  /**
   * @generated from enum value: PENDING = 1;
   */
  PENDING = 1,

  /**
   * @generated from enum value: RUNNING = 2;
   */
  RUNNING = 2,

  /**
   * @generated from enum value: DONE = 3;
   */
  DONE = 3,

  /**
   * @generated from enum value: FAILED = 4;
   */
  FAILED = 4,

  /**
   * @generated from enum value: SKIPPED = 5;
   */
  SKIPPED = 5,

  /**
   * @generated from enum value: CANCELED = 6;
   */
  CANCELED = 6,
}

/**
 * Describes the enum bytebase.v1.IssueComment.TaskUpdate.Status.
 */
export declare const IssueComment_TaskUpdate_StatusSchema: GenEnum<IssueComment_TaskUpdate_Status>;

/**
 * @generated from message bytebase.v1.IssueComment.TaskPriorBackup
 */
export declare type IssueComment_TaskPriorBackup = Message<"bytebase.v1.IssueComment.TaskPriorBackup"> & {
  /**
   * @generated from field: string task = 1;
   */
  task: string;

  /**
   * @generated from field: repeated bytebase.v1.IssueComment.TaskPriorBackup.Table tables = 2;
   */
  tables: IssueComment_TaskPriorBackup_Table[];

  /**
   * @generated from field: optional int32 original_line = 3;
   */
  originalLine?: number;

  /**
   * @generated from field: string database = 4;
   */
  database: string;

  /**
   * @generated from field: string error = 5;
   */
  error: string;
};

/**
 * Describes the message bytebase.v1.IssueComment.TaskPriorBackup.
 * Use `create(IssueComment_TaskPriorBackupSchema)` to create a new message.
 */
export declare const IssueComment_TaskPriorBackupSchema: GenMessage<IssueComment_TaskPriorBackup>;

/**
 * @generated from message bytebase.v1.IssueComment.TaskPriorBackup.Table
 */
export declare type IssueComment_TaskPriorBackup_Table = Message<"bytebase.v1.IssueComment.TaskPriorBackup.Table"> & {
  /**
   * @generated from field: string schema = 1;
   */
  schema: string;

  /**
   * @generated from field: string table = 2;
   */
  table: string;
};

/**
 * Describes the message bytebase.v1.IssueComment.TaskPriorBackup.Table.
 * Use `create(IssueComment_TaskPriorBackup_TableSchema)` to create a new message.
 */
export declare const IssueComment_TaskPriorBackup_TableSchema: GenMessage<IssueComment_TaskPriorBackup_Table>;

/**
 * @generated from enum bytebase.v1.IssueStatus
 */
export enum IssueStatus {
  /**
   * @generated from enum value: ISSUE_STATUS_UNSPECIFIED = 0;
   */
  ISSUE_STATUS_UNSPECIFIED = 0,

  /**
   * @generated from enum value: OPEN = 1;
   */
  OPEN = 1,

  /**
   * @generated from enum value: DONE = 2;
   */
  DONE = 2,

  /**
   * @generated from enum value: CANCELED = 3;
   */
  CANCELED = 3,
}

/**
 * Describes the enum bytebase.v1.IssueStatus.
 */
export declare const IssueStatusSchema: GenEnum<IssueStatus>;

/**
 * @generated from service bytebase.v1.IssueService
 */
export declare const IssueService: GenService<{
  /**
   * Permissions required: bb.issues.get
   *
   * @generated from rpc bytebase.v1.IssueService.GetIssue
   */
  getIssue: {
    methodKind: "unary";
    input: typeof GetIssueRequestSchema;
    output: typeof IssueSchema;
  },
  /**
   * Permissions required: bb.issues.create
   *
   * @generated from rpc bytebase.v1.IssueService.CreateIssue
   */
  createIssue: {
    methodKind: "unary";
    input: typeof CreateIssueRequestSchema;
    output: typeof IssueSchema;
  },
  /**
   * Permissions required: bb.issues.list
   *
   * @generated from rpc bytebase.v1.IssueService.ListIssues
   */
  listIssues: {
    methodKind: "unary";
    input: typeof ListIssuesRequestSchema;
    output: typeof ListIssuesResponseSchema;
  },
  /**
   * Search for issues that the caller has the bb.issues.get permission on and also satisfy the specified filter & query.
   * Permissions required: bb.issues.get
   *
   * @generated from rpc bytebase.v1.IssueService.SearchIssues
   */
  searchIssues: {
    methodKind: "unary";
    input: typeof SearchIssuesRequestSchema;
    output: typeof SearchIssuesResponseSchema;
  },
  /**
   * Permissions required: bb.issues.update
   *
   * @generated from rpc bytebase.v1.IssueService.UpdateIssue
   */
  updateIssue: {
    methodKind: "unary";
    input: typeof UpdateIssueRequestSchema;
    output: typeof IssueSchema;
  },
  /**
   * Permissions required: bb.issueComments.list
   *
   * @generated from rpc bytebase.v1.IssueService.ListIssueComments
   */
  listIssueComments: {
    methodKind: "unary";
    input: typeof ListIssueCommentsRequestSchema;
    output: typeof ListIssueCommentsResponseSchema;
  },
  /**
   * Permissions required: bb.issueComments.create
   *
   * @generated from rpc bytebase.v1.IssueService.CreateIssueComment
   */
  createIssueComment: {
    methodKind: "unary";
    input: typeof CreateIssueCommentRequestSchema;
    output: typeof IssueCommentSchema;
  },
  /**
   * Permissions required: bb.issueComments.update
   *
   * @generated from rpc bytebase.v1.IssueService.UpdateIssueComment
   */
  updateIssueComment: {
    methodKind: "unary";
    input: typeof UpdateIssueCommentRequestSchema;
    output: typeof IssueCommentSchema;
  },
  /**
   * Permissions required: bb.issues.update
   *
   * @generated from rpc bytebase.v1.IssueService.BatchUpdateIssuesStatus
   */
  batchUpdateIssuesStatus: {
    methodKind: "unary";
    input: typeof BatchUpdateIssuesStatusRequestSchema;
    output: typeof BatchUpdateIssuesStatusResponseSchema;
  },
  /**
   * ApproveIssue approves the issue.
   * The access is based on approval flow.
   * Permissions required: None
   *
   * @generated from rpc bytebase.v1.IssueService.ApproveIssue
   */
  approveIssue: {
    methodKind: "unary";
    input: typeof ApproveIssueRequestSchema;
    output: typeof IssueSchema;
  },
  /**
   * RejectIssue rejects the issue.
   * The access is based on approval flow.
   * Permissions required: None
   *
   * @generated from rpc bytebase.v1.IssueService.RejectIssue
   */
  rejectIssue: {
    methodKind: "unary";
    input: typeof RejectIssueRequestSchema;
    output: typeof IssueSchema;
  },
  /**
   * RequestIssue requests the issue.
   * The access is based on approval flow.
   * Permissions required: None
   *
   * @generated from rpc bytebase.v1.IssueService.RequestIssue
   */
  requestIssue: {
    methodKind: "unary";
    input: typeof RequestIssueRequestSchema;
    output: typeof IssueSchema;
  },
}>;

