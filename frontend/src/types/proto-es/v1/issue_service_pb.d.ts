// @generated by protoc-gen-es v2.5.2
// @generated from file v1/issue_service.proto (package bytebase.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";
import type { Duration, FieldMask, Timestamp } from "@bufbuild/protobuf/wkt";
import type { RiskLevel } from "./common_pb";
import type { Expr } from "../google/type/expr_pb";

/**
 * Describes the file v1/issue_service.proto.
 */
export declare const file_v1_issue_service: GenFile;

/**
 * @generated from message bytebase.v1.GetIssueRequest
 */
export declare type GetIssueRequest = Message<"bytebase.v1.GetIssueRequest"> & {
  /**
   * The name of the issue to retrieve.
   * Format: projects/{project}/issues/{issue}
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * If set to true, bypass cache and fetch the latest data.
   *
   * @generated from field: bool force = 2;
   */
  force: boolean;
};

/**
 * Describes the message bytebase.v1.GetIssueRequest.
 * Use `create(GetIssueRequestSchema)` to create a new message.
 */
export declare const GetIssueRequestSchema: GenMessage<GetIssueRequest>;

/**
 * @generated from message bytebase.v1.CreateIssueRequest
 */
export declare type CreateIssueRequest = Message<"bytebase.v1.CreateIssueRequest"> & {
  /**
   * The parent, which owns this collection of issues.
   * Format: projects/{project}
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * The issue to create.
   *
   * @generated from field: bytebase.v1.Issue issue = 2;
   */
  issue?: Issue;
};

/**
 * Describes the message bytebase.v1.CreateIssueRequest.
 * Use `create(CreateIssueRequestSchema)` to create a new message.
 */
export declare const CreateIssueRequestSchema: GenMessage<CreateIssueRequest>;

/**
 * @generated from message bytebase.v1.ListIssuesRequest
 */
export declare type ListIssuesRequest = Message<"bytebase.v1.ListIssuesRequest"> & {
  /**
   * The parent, which owns this collection of issues.
   * Format: projects/{project}
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * The maximum number of issues to return. The service may return fewer than
   * this value.
   * If unspecified, at most 10 issues will be returned.
   * The maximum value is 1000; values above 1000 will be coerced to 1000.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize: number;

  /**
   * A page token, received from a previous `ListIssues` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListIssues` must match
   * the call that provided the page token.
   *
   * @generated from field: string page_token = 3;
   */
  pageToken: string;

  /**
   * Filter is used to filter issues returned in the list.
   * The syntax and semantics of CEL are documented at https://github.com/google/cel-spec
   *
   * Supported filters:
   * - creator: issue creator full name in "users/{email or id}" format, support "==" operator.
   * - status: the issue status, support "==" and "in" operator, check the IssueStatus enum for the values.
   * - create_time: issue create time in "2006-01-02T15:04:05Z07:00" format, support ">=" or "<=" operator.
   * - type: the issue type, support "==" and "in" operator, check the Type enum in the Issue message for the values.
   * - labels: the issue labels, support "==" and "in" operator.
   * - approval_status: issue approval status, support "==" operator.
   * - current_approver: the issue approver, should in "users/{email} format", support "==" operator.
   *
   * For example:
   * creator == "users/ed@bytebase.com" && status in ["OPEN", "DONE"]
   * status == "CANCELED" && type == "DATABASE_CHANGE"
   * labels in ["label1", "label2"]
   * create_time >= "2025-01-02T15:04:05Z07:00"
   *
   * @generated from field: string filter = 4;
   */
  filter: string;

  /**
   * Query is the query statement.
   *
   * @generated from field: string query = 5;
   */
  query: string;
};

/**
 * Describes the message bytebase.v1.ListIssuesRequest.
 * Use `create(ListIssuesRequestSchema)` to create a new message.
 */
export declare const ListIssuesRequestSchema: GenMessage<ListIssuesRequest>;

/**
 * @generated from message bytebase.v1.ListIssuesResponse
 */
export declare type ListIssuesResponse = Message<"bytebase.v1.ListIssuesResponse"> & {
  /**
   * The issues from the specified request.
   *
   * @generated from field: repeated bytebase.v1.Issue issues = 1;
   */
  issues: Issue[];

  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message bytebase.v1.ListIssuesResponse.
 * Use `create(ListIssuesResponseSchema)` to create a new message.
 */
export declare const ListIssuesResponseSchema: GenMessage<ListIssuesResponse>;

/**
 * @generated from message bytebase.v1.SearchIssuesRequest
 */
export declare type SearchIssuesRequest = Message<"bytebase.v1.SearchIssuesRequest"> & {
  /**
   * The parent, which owns this collection of issues.
   * Format: projects/{project}
   * Use "projects/-" to list all issues from all projects.
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * The maximum number of issues to return. The service may return fewer than
   * this value.
   * If unspecified, at most 10 issues will be returned.
   * The maximum value is 1000; values above 1000 will be coerced to 1000.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize: number;

  /**
   * A page token, received from a previous `SearchIssues` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `SearchIssues` must match
   * the call that provided the page token.
   *
   * @generated from field: string page_token = 3;
   */
  pageToken: string;

  /**
   * Filter is used to filter issues returned in the list.
   * Check the filter field in the ListIssuesRequest message.
   *
   * @generated from field: string filter = 4;
   */
  filter: string;

  /**
   * Query is the query statement.
   *
   * @generated from field: string query = 5;
   */
  query: string;
};

/**
 * Describes the message bytebase.v1.SearchIssuesRequest.
 * Use `create(SearchIssuesRequestSchema)` to create a new message.
 */
export declare const SearchIssuesRequestSchema: GenMessage<SearchIssuesRequest>;

/**
 * @generated from message bytebase.v1.SearchIssuesResponse
 */
export declare type SearchIssuesResponse = Message<"bytebase.v1.SearchIssuesResponse"> & {
  /**
   * The issues from the specified request.
   *
   * @generated from field: repeated bytebase.v1.Issue issues = 1;
   */
  issues: Issue[];

  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message bytebase.v1.SearchIssuesResponse.
 * Use `create(SearchIssuesResponseSchema)` to create a new message.
 */
export declare const SearchIssuesResponseSchema: GenMessage<SearchIssuesResponse>;

/**
 * @generated from message bytebase.v1.UpdateIssueRequest
 */
export declare type UpdateIssueRequest = Message<"bytebase.v1.UpdateIssueRequest"> & {
  /**
   * The issue to update.
   *
   * The issue's `name` field is used to identify the issue to update.
   * Format: projects/{project}/issues/{issue}
   *
   * @generated from field: bytebase.v1.Issue issue = 1;
   */
  issue?: Issue;

  /**
   * The list of fields to update.
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 2;
   */
  updateMask?: FieldMask;

  /**
   * If set to true, and the issue is not found, a new issue will be created.
   * In this situation, `update_mask` is ignored.
   *
   * @generated from field: bool allow_missing = 3;
   */
  allowMissing: boolean;
};

/**
 * Describes the message bytebase.v1.UpdateIssueRequest.
 * Use `create(UpdateIssueRequestSchema)` to create a new message.
 */
export declare const UpdateIssueRequestSchema: GenMessage<UpdateIssueRequest>;

/**
 * @generated from message bytebase.v1.BatchUpdateIssuesStatusRequest
 */
export declare type BatchUpdateIssuesStatusRequest = Message<"bytebase.v1.BatchUpdateIssuesStatusRequest"> & {
  /**
   * The parent resource shared by all issues being updated.
   * Format: projects/{project}
   * If the operation spans parents, a dash (-) may be accepted as a wildcard.
   * We only support updating the status of databases for now.
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * The list of issues to update.
   * Format: projects/{project}/issues/{issue}
   *
   * @generated from field: repeated string issues = 2;
   */
  issues: string[];

  /**
   * The new status.
   *
   * @generated from field: bytebase.v1.IssueStatus status = 3;
   */
  status: IssueStatus;

  /**
   * The reason for the status change.
   *
   * @generated from field: string reason = 4;
   */
  reason: string;
};

/**
 * Describes the message bytebase.v1.BatchUpdateIssuesStatusRequest.
 * Use `create(BatchUpdateIssuesStatusRequestSchema)` to create a new message.
 */
export declare const BatchUpdateIssuesStatusRequestSchema: GenMessage<BatchUpdateIssuesStatusRequest>;

/**
 * @generated from message bytebase.v1.BatchUpdateIssuesStatusResponse
 */
export declare type BatchUpdateIssuesStatusResponse = Message<"bytebase.v1.BatchUpdateIssuesStatusResponse"> & {
};

/**
 * Describes the message bytebase.v1.BatchUpdateIssuesStatusResponse.
 * Use `create(BatchUpdateIssuesStatusResponseSchema)` to create a new message.
 */
export declare const BatchUpdateIssuesStatusResponseSchema: GenMessage<BatchUpdateIssuesStatusResponse>;

/**
 * @generated from message bytebase.v1.ApproveIssueRequest
 */
export declare type ApproveIssueRequest = Message<"bytebase.v1.ApproveIssueRequest"> & {
  /**
   * The name of the issue to add an approver.
   * Format: projects/{project}/issues/{issue}
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The comment explaining the approval decision.
   *
   * @generated from field: string comment = 2;
   */
  comment: string;
};

/**
 * Describes the message bytebase.v1.ApproveIssueRequest.
 * Use `create(ApproveIssueRequestSchema)` to create a new message.
 */
export declare const ApproveIssueRequestSchema: GenMessage<ApproveIssueRequest>;

/**
 * @generated from message bytebase.v1.RejectIssueRequest
 */
export declare type RejectIssueRequest = Message<"bytebase.v1.RejectIssueRequest"> & {
  /**
   * The name of the issue to add a rejection.
   * Format: projects/{project}/issues/{issue}
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The comment explaining the rejection decision.
   *
   * @generated from field: string comment = 2;
   */
  comment: string;
};

/**
 * Describes the message bytebase.v1.RejectIssueRequest.
 * Use `create(RejectIssueRequestSchema)` to create a new message.
 */
export declare const RejectIssueRequestSchema: GenMessage<RejectIssueRequest>;

/**
 * @generated from message bytebase.v1.RequestIssueRequest
 */
export declare type RequestIssueRequest = Message<"bytebase.v1.RequestIssueRequest"> & {
  /**
   * The name of the issue to request a issue.
   * Format: projects/{project}/issues/{issue}
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The comment explaining the request.
   *
   * @generated from field: string comment = 2;
   */
  comment: string;
};

/**
 * Describes the message bytebase.v1.RequestIssueRequest.
 * Use `create(RequestIssueRequestSchema)` to create a new message.
 */
export declare const RequestIssueRequestSchema: GenMessage<RequestIssueRequest>;

/**
 * @generated from message bytebase.v1.Issue
 */
export declare type Issue = Message<"bytebase.v1.Issue"> & {
  /**
   * The name of the issue.
   * Format: projects/{project}/issues/{issue}
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The title of the issue.
   *
   * @generated from field: string title = 2;
   */
  title: string;

  /**
   * The description of the issue.
   *
   * @generated from field: string description = 3;
   */
  description: string;

  /**
   * @generated from field: bytebase.v1.Issue.Type type = 4;
   */
  type: Issue_Type;

  /**
   * The status of the issue.
   *
   * @generated from field: bytebase.v1.IssueStatus status = 5;
   */
  status: IssueStatus;

  /**
   * @generated from field: repeated bytebase.v1.Issue.Approver approvers = 6;
   */
  approvers: Issue_Approver[];

  /**
   * The approval template for the issue.
   *
   * @generated from field: bytebase.v1.ApprovalTemplate approval_template = 7;
   */
  approvalTemplate?: ApprovalTemplate;

  /**
   * Format: users/hello@world.com
   *
   * @generated from field: string creator = 8;
   */
  creator: string;

  /**
   * @generated from field: google.protobuf.Timestamp create_time = 9;
   */
  createTime?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp update_time = 10;
   */
  updateTime?: Timestamp;

  /**
   * The plan associated with the issue.
   * Can be empty.
   * Format: projects/{project}/plans/{plan}
   *
   * @generated from field: string plan = 11;
   */
  plan: string;

  /**
   * Used if the issue type is GRANT_REQUEST.
   *
   * @generated from field: bytebase.v1.GrantRequest grant_request = 13;
   */
  grantRequest?: GrantRequest;

  /**
   * The risk level of the issue.
   *
   * @generated from field: bytebase.v1.RiskLevel risk_level = 15;
   */
  riskLevel: RiskLevel;

  /**
   * Labels attached to the issue for categorization and filtering.
   *
   * @generated from field: repeated string labels = 17;
   */
  labels: string[];

  /**
   * @generated from field: bytebase.v1.Issue.ApprovalStatus approval_status = 18;
   */
  approvalStatus: Issue_ApprovalStatus;
};

/**
 * Describes the message bytebase.v1.Issue.
 * Use `create(IssueSchema)` to create a new message.
 */
export declare const IssueSchema: GenMessage<Issue>;

/**
 * Approvers and their approval status for the issue.
 *
 * @generated from message bytebase.v1.Issue.Approver
 */
export declare type Issue_Approver = Message<"bytebase.v1.Issue.Approver"> & {
  /**
   * The new status.
   *
   * @generated from field: bytebase.v1.Issue.Approver.Status status = 1;
   */
  status: Issue_Approver_Status;

  /**
   * Format: users/hello@world.com
   *
   * @generated from field: string principal = 2;
   */
  principal: string;
};

/**
 * Describes the message bytebase.v1.Issue.Approver.
 * Use `create(Issue_ApproverSchema)` to create a new message.
 */
export declare const Issue_ApproverSchema: GenMessage<Issue_Approver>;

/**
 * The approval status of an approver.
 *
 * @generated from enum bytebase.v1.Issue.Approver.Status
 */
export enum Issue_Approver_Status {
  /**
   * Unspecified status.
   *
   * @generated from enum value: STATUS_UNSPECIFIED = 0;
   */
  STATUS_UNSPECIFIED = 0,

  /**
   * Awaiting approval.
   *
   * @generated from enum value: PENDING = 1;
   */
  PENDING = 1,

  /**
   * Approved.
   *
   * @generated from enum value: APPROVED = 2;
   */
  APPROVED = 2,

  /**
   * Rejected.
   *
   * @generated from enum value: REJECTED = 3;
   */
  REJECTED = 3,
}

/**
 * Describes the enum bytebase.v1.Issue.Approver.Status.
 */
export declare const Issue_Approver_StatusSchema: GenEnum<Issue_Approver_Status>;

/**
 * The type of issue.
 *
 * @generated from enum bytebase.v1.Issue.Type
 */
export enum Issue_Type {
  /**
   * Unspecified issue type.
   *
   * @generated from enum value: TYPE_UNSPECIFIED = 0;
   */
  TYPE_UNSPECIFIED = 0,

  /**
   * Database schema or data change.
   *
   * @generated from enum value: DATABASE_CHANGE = 1;
   */
  DATABASE_CHANGE = 1,

  /**
   * Database access grant request.
   *
   * @generated from enum value: GRANT_REQUEST = 2;
   */
  GRANT_REQUEST = 2,

  /**
   * Database data export request.
   *
   * @generated from enum value: DATABASE_EXPORT = 3;
   */
  DATABASE_EXPORT = 3,
}

/**
 * Describes the enum bytebase.v1.Issue.Type.
 */
export declare const Issue_TypeSchema: GenEnum<Issue_Type>;

/**
 * The overall approval status for the issue.
 *
 * @generated from enum bytebase.v1.Issue.ApprovalStatus
 */
export enum Issue_ApprovalStatus {
  /**
   * Unspecified approval status.
   *
   * @generated from enum value: APPROVAL_STATUS_UNSPECIFIED = 0;
   */
  APPROVAL_STATUS_UNSPECIFIED = 0,

  /**
   * Approval checks are being evaluated.
   *
   * @generated from enum value: CHECKING = 1;
   */
  CHECKING = 1,

  /**
   * Approval is pending.
   *
   * @generated from enum value: PENDING = 2;
   */
  PENDING = 2,

  /**
   * Issue has been approved.
   *
   * @generated from enum value: APPROVED = 3;
   */
  APPROVED = 3,

  /**
   * Issue has been rejected.
   *
   * @generated from enum value: REJECTED = 4;
   */
  REJECTED = 4,

  /**
   * Approval was skipped.
   *
   * @generated from enum value: SKIPPED = 5;
   */
  SKIPPED = 5,
}

/**
 * Describes the enum bytebase.v1.Issue.ApprovalStatus.
 */
export declare const Issue_ApprovalStatusSchema: GenEnum<Issue_ApprovalStatus>;

/**
 * @generated from message bytebase.v1.GrantRequest
 */
export declare type GrantRequest = Message<"bytebase.v1.GrantRequest"> & {
  /**
   * The requested role.
   * Format: roles/EXPORTER.
   *
   * @generated from field: string role = 1;
   */
  role: string;

  /**
   * The user to be granted.
   * Format: users/{email}.
   *
   * @generated from field: string user = 2;
   */
  user: string;

  /**
   * The condition for the role. Same as the condition in IAM Binding message.
   *
   * @generated from field: google.type.Expr condition = 3;
   */
  condition?: Expr;

  /**
   * The duration for which the grant is valid.
   *
   * @generated from field: google.protobuf.Duration expiration = 4;
   */
  expiration?: Duration;
};

/**
 * Describes the message bytebase.v1.GrantRequest.
 * Use `create(GrantRequestSchema)` to create a new message.
 */
export declare const GrantRequestSchema: GenMessage<GrantRequest>;

/**
 * @generated from message bytebase.v1.ApprovalTemplate
 */
export declare type ApprovalTemplate = Message<"bytebase.v1.ApprovalTemplate"> & {
  /**
   * The approval flow definition.
   *
   * @generated from field: bytebase.v1.ApprovalFlow flow = 1;
   */
  flow?: ApprovalFlow;

  /**
   * The title of the approval template.
   *
   * @generated from field: string title = 2;
   */
  title: string;

  /**
   * The description of the approval template.
   *
   * @generated from field: string description = 3;
   */
  description: string;
};

/**
 * Describes the message bytebase.v1.ApprovalTemplate.
 * Use `create(ApprovalTemplateSchema)` to create a new message.
 */
export declare const ApprovalTemplateSchema: GenMessage<ApprovalTemplate>;

/**
 * @generated from message bytebase.v1.ApprovalFlow
 */
export declare type ApprovalFlow = Message<"bytebase.v1.ApprovalFlow"> & {
  /**
   * The roles required for approval in order.
   *
   * @generated from field: repeated string roles = 1;
   */
  roles: string[];
};

/**
 * Describes the message bytebase.v1.ApprovalFlow.
 * Use `create(ApprovalFlowSchema)` to create a new message.
 */
export declare const ApprovalFlowSchema: GenMessage<ApprovalFlow>;

/**
 * @generated from message bytebase.v1.ListIssueCommentsRequest
 */
export declare type ListIssueCommentsRequest = Message<"bytebase.v1.ListIssueCommentsRequest"> & {
  /**
   * Format: projects/{projects}/issues/{issue}
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * The maximum number of issue comments to return. The service may return fewer than
   * this value.
   * If unspecified, at most 10 issue comments will be returned.
   * The maximum value is 1000; values above 1000 will be coerced to 1000.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize: number;

  /**
   * A page token, received from a previous `ListIssueComments` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListIssueComments` must match
   * the call that provided the page token.
   *
   * @generated from field: string page_token = 3;
   */
  pageToken: string;
};

/**
 * Describes the message bytebase.v1.ListIssueCommentsRequest.
 * Use `create(ListIssueCommentsRequestSchema)` to create a new message.
 */
export declare const ListIssueCommentsRequestSchema: GenMessage<ListIssueCommentsRequest>;

/**
 * @generated from message bytebase.v1.ListIssueCommentsResponse
 */
export declare type ListIssueCommentsResponse = Message<"bytebase.v1.ListIssueCommentsResponse"> & {
  /**
   * The issue comments from the specified request.
   *
   * @generated from field: repeated bytebase.v1.IssueComment issue_comments = 1;
   */
  issueComments: IssueComment[];

  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message bytebase.v1.ListIssueCommentsResponse.
 * Use `create(ListIssueCommentsResponseSchema)` to create a new message.
 */
export declare const ListIssueCommentsResponseSchema: GenMessage<ListIssueCommentsResponse>;

/**
 * @generated from message bytebase.v1.CreateIssueCommentRequest
 */
export declare type CreateIssueCommentRequest = Message<"bytebase.v1.CreateIssueCommentRequest"> & {
  /**
   * The issue name
   * Format: projects/{project}/issues/{issue}
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * The comment to create.
   *
   * @generated from field: bytebase.v1.IssueComment issue_comment = 2;
   */
  issueComment?: IssueComment;
};

/**
 * Describes the message bytebase.v1.CreateIssueCommentRequest.
 * Use `create(CreateIssueCommentRequestSchema)` to create a new message.
 */
export declare const CreateIssueCommentRequestSchema: GenMessage<CreateIssueCommentRequest>;

/**
 * @generated from message bytebase.v1.UpdateIssueCommentRequest
 */
export declare type UpdateIssueCommentRequest = Message<"bytebase.v1.UpdateIssueCommentRequest"> & {
  /**
   * The issue name
   * Format: projects/{project}/issues/{issue}
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * The comment to update.
   *
   * @generated from field: bytebase.v1.IssueComment issue_comment = 2;
   */
  issueComment?: IssueComment;

  /**
   * The list of fields to update.
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 3;
   */
  updateMask?: FieldMask;

  /**
   * If set to true, and the issue comment is not found, a new issue comment will be created.
   * In this situation, `update_mask` is ignored.
   *
   * @generated from field: bool allow_missing = 4;
   */
  allowMissing: boolean;
};

/**
 * Describes the message bytebase.v1.UpdateIssueCommentRequest.
 * Use `create(UpdateIssueCommentRequestSchema)` to create a new message.
 */
export declare const UpdateIssueCommentRequestSchema: GenMessage<UpdateIssueCommentRequest>;

/**
 * A comment on an issue.
 *
 * @generated from message bytebase.v1.IssueComment
 */
export declare type IssueComment = Message<"bytebase.v1.IssueComment"> & {
  /**
   * Format: projects/{project}/issues/{issue}/issueComments/{issueComment-uid}
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The text content of the comment.
   *
   * @generated from field: string comment = 2;
   */
  comment: string;

  /**
   * TODO: use struct message instead.
   *
   * @generated from field: string payload = 3;
   */
  payload: string;

  /**
   * @generated from field: google.protobuf.Timestamp create_time = 4;
   */
  createTime?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp update_time = 5;
   */
  updateTime?: Timestamp;

  /**
   * Format: users/{email}
   *
   * @generated from field: string creator = 6;
   */
  creator: string;

  /**
   * The event associated with this comment.
   *
   * @generated from oneof bytebase.v1.IssueComment.event
   */
  event: {
    /**
     * Approval event.
     *
     * @generated from field: bytebase.v1.IssueComment.Approval approval = 7;
     */
    value: IssueComment_Approval;
    case: "approval";
  } | {
    /**
     * Issue update event.
     *
     * @generated from field: bytebase.v1.IssueComment.IssueUpdate issue_update = 8;
     */
    value: IssueComment_IssueUpdate;
    case: "issueUpdate";
  } | {
    /**
     * Plan spec update event.
     *
     * @generated from field: bytebase.v1.IssueComment.PlanSpecUpdate plan_spec_update = 12;
     */
    value: IssueComment_PlanSpecUpdate;
    case: "planSpecUpdate";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message bytebase.v1.IssueComment.
 * Use `create(IssueCommentSchema)` to create a new message.
 */
export declare const IssueCommentSchema: GenMessage<IssueComment>;

/**
 * Approval event information.
 *
 * @generated from message bytebase.v1.IssueComment.Approval
 */
export declare type IssueComment_Approval = Message<"bytebase.v1.IssueComment.Approval"> & {
  /**
   * The approval status.
   *
   * @generated from field: bytebase.v1.IssueComment.Approval.Status status = 1;
   */
  status: IssueComment_Approval_Status;
};

/**
 * Describes the message bytebase.v1.IssueComment.Approval.
 * Use `create(IssueComment_ApprovalSchema)` to create a new message.
 */
export declare const IssueComment_ApprovalSchema: GenMessage<IssueComment_Approval>;

/**
 * Approval status values.
 *
 * @generated from enum bytebase.v1.IssueComment.Approval.Status
 */
export enum IssueComment_Approval_Status {
  /**
   * Unspecified status.
   *
   * @generated from enum value: STATUS_UNSPECIFIED = 0;
   */
  STATUS_UNSPECIFIED = 0,

  /**
   * Approval pending.
   *
   * @generated from enum value: PENDING = 1;
   */
  PENDING = 1,

  /**
   * Approved.
   *
   * @generated from enum value: APPROVED = 2;
   */
  APPROVED = 2,

  /**
   * Rejected.
   *
   * @generated from enum value: REJECTED = 3;
   */
  REJECTED = 3,
}

/**
 * Describes the enum bytebase.v1.IssueComment.Approval.Status.
 */
export declare const IssueComment_Approval_StatusSchema: GenEnum<IssueComment_Approval_Status>;

/**
 * Issue update event information.
 *
 * @generated from message bytebase.v1.IssueComment.IssueUpdate
 */
export declare type IssueComment_IssueUpdate = Message<"bytebase.v1.IssueComment.IssueUpdate"> & {
  /**
   * @generated from field: optional string from_title = 1;
   */
  fromTitle?: string;

  /**
   * @generated from field: optional string to_title = 2;
   */
  toTitle?: string;

  /**
   * @generated from field: optional string from_description = 3;
   */
  fromDescription?: string;

  /**
   * @generated from field: optional string to_description = 4;
   */
  toDescription?: string;

  /**
   * @generated from field: optional bytebase.v1.IssueStatus from_status = 5;
   */
  fromStatus?: IssueStatus;

  /**
   * @generated from field: optional bytebase.v1.IssueStatus to_status = 6;
   */
  toStatus?: IssueStatus;

  /**
   * @generated from field: repeated string from_labels = 7;
   */
  fromLabels: string[];

  /**
   * @generated from field: repeated string to_labels = 8;
   */
  toLabels: string[];
};

/**
 * Describes the message bytebase.v1.IssueComment.IssueUpdate.
 * Use `create(IssueComment_IssueUpdateSchema)` to create a new message.
 */
export declare const IssueComment_IssueUpdateSchema: GenMessage<IssueComment_IssueUpdate>;

/**
 * Plan spec update event information (tracks sheet changes to plan specs).
 *
 * @generated from message bytebase.v1.IssueComment.PlanSpecUpdate
 */
export declare type IssueComment_PlanSpecUpdate = Message<"bytebase.v1.IssueComment.PlanSpecUpdate"> & {
  /**
   * The spec that was updated.
   * Format: projects/{project}/plans/{plan}/specs/{spec}
   *
   * @generated from field: string spec = 1;
   */
  spec: string;

  /**
   * The previous sheet.
   * Format: projects/{project}/sheets/{sheet}
   *
   * @generated from field: optional string from_sheet = 2;
   */
  fromSheet?: string;

  /**
   * The new sheet.
   * Format: projects/{project}/sheets/{sheet}
   *
   * @generated from field: optional string to_sheet = 3;
   */
  toSheet?: string;
};

/**
 * Describes the message bytebase.v1.IssueComment.PlanSpecUpdate.
 * Use `create(IssueComment_PlanSpecUpdateSchema)` to create a new message.
 */
export declare const IssueComment_PlanSpecUpdateSchema: GenMessage<IssueComment_PlanSpecUpdate>;

/**
 * The status of an issue.
 *
 * @generated from enum bytebase.v1.IssueStatus
 */
export enum IssueStatus {
  /**
   * Unspecified status.
   *
   * @generated from enum value: ISSUE_STATUS_UNSPECIFIED = 0;
   */
  ISSUE_STATUS_UNSPECIFIED = 0,

  /**
   * Issue is open and active.
   *
   * @generated from enum value: OPEN = 1;
   */
  OPEN = 1,

  /**
   * Issue is completed.
   *
   * @generated from enum value: DONE = 2;
   */
  DONE = 2,

  /**
   * Issue is canceled.
   *
   * @generated from enum value: CANCELED = 3;
   */
  CANCELED = 3,
}

/**
 * Describes the enum bytebase.v1.IssueStatus.
 */
export declare const IssueStatusSchema: GenEnum<IssueStatus>;

/**
 * IssueService manages issues for tracking database changes and tasks.
 *
 * @generated from service bytebase.v1.IssueService
 */
export declare const IssueService: GenService<{
  /**
   * Retrieves an issue by name.
   * Permissions required: bb.issues.get
   *
   * @generated from rpc bytebase.v1.IssueService.GetIssue
   */
  getIssue: {
    methodKind: "unary";
    input: typeof GetIssueRequestSchema;
    output: typeof IssueSchema;
  },
  /**
   * Creates a new issue for database changes or tasks.
   * Permissions required: bb.issues.create
   *
   * @generated from rpc bytebase.v1.IssueService.CreateIssue
   */
  createIssue: {
    methodKind: "unary";
    input: typeof CreateIssueRequestSchema;
    output: typeof IssueSchema;
  },
  /**
   * Lists issues in a project.
   * Permissions required: bb.issues.list
   *
   * @generated from rpc bytebase.v1.IssueService.ListIssues
   */
  listIssues: {
    methodKind: "unary";
    input: typeof ListIssuesRequestSchema;
    output: typeof ListIssuesResponseSchema;
  },
  /**
   * Search for issues that the caller has the bb.issues.get permission on and also satisfy the specified filter & query.
   * Permissions required: bb.issues.get
   *
   * @generated from rpc bytebase.v1.IssueService.SearchIssues
   */
  searchIssues: {
    methodKind: "unary";
    input: typeof SearchIssuesRequestSchema;
    output: typeof SearchIssuesResponseSchema;
  },
  /**
   * Updates an issue's properties such as title, description, or labels.
   * Permissions required: bb.issues.update
   *
   * @generated from rpc bytebase.v1.IssueService.UpdateIssue
   */
  updateIssue: {
    methodKind: "unary";
    input: typeof UpdateIssueRequestSchema;
    output: typeof IssueSchema;
  },
  /**
   * Lists comments on an issue.
   * Permissions required: bb.issueComments.list
   *
   * @generated from rpc bytebase.v1.IssueService.ListIssueComments
   */
  listIssueComments: {
    methodKind: "unary";
    input: typeof ListIssueCommentsRequestSchema;
    output: typeof ListIssueCommentsResponseSchema;
  },
  /**
   * Adds a comment to an issue.
   * Permissions required: bb.issueComments.create
   *
   * @generated from rpc bytebase.v1.IssueService.CreateIssueComment
   */
  createIssueComment: {
    methodKind: "unary";
    input: typeof CreateIssueCommentRequestSchema;
    output: typeof IssueCommentSchema;
  },
  /**
   * Updates an existing issue comment.
   * Permissions required: bb.issueComments.update
   *
   * @generated from rpc bytebase.v1.IssueService.UpdateIssueComment
   */
  updateIssueComment: {
    methodKind: "unary";
    input: typeof UpdateIssueCommentRequestSchema;
    output: typeof IssueCommentSchema;
  },
  /**
   * Updates the status of multiple issues in a single operation.
   * Permissions required: bb.issues.update
   *
   * @generated from rpc bytebase.v1.IssueService.BatchUpdateIssuesStatus
   */
  batchUpdateIssuesStatus: {
    methodKind: "unary";
    input: typeof BatchUpdateIssuesStatusRequestSchema;
    output: typeof BatchUpdateIssuesStatusResponseSchema;
  },
  /**
   * Approves an issue. Access determined by approval flow configuration - caller must be a designated approver for the current approval step.
   * Permissions required: None (determined by approval flow)
   *
   * @generated from rpc bytebase.v1.IssueService.ApproveIssue
   */
  approveIssue: {
    methodKind: "unary";
    input: typeof ApproveIssueRequestSchema;
    output: typeof IssueSchema;
  },
  /**
   * Rejects an issue. Access determined by approval flow configuration - caller must be a designated approver for the current approval step.
   * Permissions required: None (determined by approval flow)
   *
   * @generated from rpc bytebase.v1.IssueService.RejectIssue
   */
  rejectIssue: {
    methodKind: "unary";
    input: typeof RejectIssueRequestSchema;
    output: typeof IssueSchema;
  },
  /**
   * Requests changes on an issue. Access determined by approval flow configuration - caller must be a designated approver for the current approval step.
   * Permissions required: None (determined by approval flow)
   *
   * @generated from rpc bytebase.v1.IssueService.RequestIssue
   */
  requestIssue: {
    methodKind: "unary";
    input: typeof RequestIssueRequestSchema;
    output: typeof IssueSchema;
  },
}>;

