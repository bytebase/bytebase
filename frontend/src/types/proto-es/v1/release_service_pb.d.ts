// @generated by protoc-gen-es v2.5.2
// @generated from file v1/release_service.proto (package bytebase.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";
import type { EmptySchema, FieldMask, Timestamp } from "@bufbuild/protobuf/wkt";
import type { RiskLevel, State, VCSType } from "./common_pb";
import type { Advice } from "./sql_service_pb";

/**
 * Describes the file v1/release_service.proto.
 */
export declare const file_v1_release_service: GenFile;

/**
 * @generated from message bytebase.v1.GetReleaseRequest
 */
export declare type GetReleaseRequest = Message<"bytebase.v1.GetReleaseRequest"> & {
  /**
   * Format: projects/{project}/releases/{release}
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message bytebase.v1.GetReleaseRequest.
 * Use `create(GetReleaseRequestSchema)` to create a new message.
 */
export declare const GetReleaseRequestSchema: GenMessage<GetReleaseRequest>;

/**
 * @generated from message bytebase.v1.ListReleasesRequest
 */
export declare type ListReleasesRequest = Message<"bytebase.v1.ListReleasesRequest"> & {
  /**
   * Format: projects/{project}
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * The maximum number of releases to return. The service may return fewer than this value.
   * If unspecified, at most 10 releases will be returned.
   * The maximum value is 1000; values above 1000 will be coerced to 1000.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize: number;

  /**
   * A page token, received from a previous `ListReleases` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListReleases` must match
   * the call that provided the page token.
   *
   * @generated from field: string page_token = 3;
   */
  pageToken: string;

  /**
   * Show deleted releases if specified.
   *
   * @generated from field: bool show_deleted = 4;
   */
  showDeleted: boolean;
};

/**
 * Describes the message bytebase.v1.ListReleasesRequest.
 * Use `create(ListReleasesRequestSchema)` to create a new message.
 */
export declare const ListReleasesRequestSchema: GenMessage<ListReleasesRequest>;

/**
 * @generated from message bytebase.v1.ListReleasesResponse
 */
export declare type ListReleasesResponse = Message<"bytebase.v1.ListReleasesResponse"> & {
  /**
   * The releases from the specified request.
   *
   * @generated from field: repeated bytebase.v1.Release releases = 1;
   */
  releases: Release[];

  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message bytebase.v1.ListReleasesResponse.
 * Use `create(ListReleasesResponseSchema)` to create a new message.
 */
export declare const ListReleasesResponseSchema: GenMessage<ListReleasesResponse>;

/**
 * @generated from message bytebase.v1.SearchReleasesRequest
 */
export declare type SearchReleasesRequest = Message<"bytebase.v1.SearchReleasesRequest"> & {
  /**
   * Format: projects/{project}
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * The maximum number of releases to return. The service may return fewer than this value.
   * If unspecified, at most 10 releases will be returned.
   * The maximum value is 1000; values above 1000 will be coerced to 1000.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize: number;

  /**
   * A page token, received from a previous `ListReleases` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListReleases` must match
   * the call that provided the page token.
   *
   * @generated from field: string page_token = 3;
   */
  pageToken: string;

  /**
   * Search by the digest of the release.
   *
   * @generated from field: optional string digest = 4;
   */
  digest?: string;
};

/**
 * Describes the message bytebase.v1.SearchReleasesRequest.
 * Use `create(SearchReleasesRequestSchema)` to create a new message.
 */
export declare const SearchReleasesRequestSchema: GenMessage<SearchReleasesRequest>;

/**
 * @generated from message bytebase.v1.SearchReleasesResponse
 */
export declare type SearchReleasesResponse = Message<"bytebase.v1.SearchReleasesResponse"> & {
  /**
   * The releases matching the search criteria.
   *
   * @generated from field: repeated bytebase.v1.Release releases = 1;
   */
  releases: Release[];

  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message bytebase.v1.SearchReleasesResponse.
 * Use `create(SearchReleasesResponseSchema)` to create a new message.
 */
export declare const SearchReleasesResponseSchema: GenMessage<SearchReleasesResponse>;

/**
 * @generated from message bytebase.v1.CreateReleaseRequest
 */
export declare type CreateReleaseRequest = Message<"bytebase.v1.CreateReleaseRequest"> & {
  /**
   * Format: projects/{project}
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * The release to create.
   *
   * @generated from field: bytebase.v1.Release release = 2;
   */
  release?: Release;
};

/**
 * Describes the message bytebase.v1.CreateReleaseRequest.
 * Use `create(CreateReleaseRequestSchema)` to create a new message.
 */
export declare const CreateReleaseRequestSchema: GenMessage<CreateReleaseRequest>;

/**
 * @generated from message bytebase.v1.UpdateReleaseRequest
 */
export declare type UpdateReleaseRequest = Message<"bytebase.v1.UpdateReleaseRequest"> & {
  /**
   * The release to update.
   *
   * @generated from field: bytebase.v1.Release release = 1;
   */
  release?: Release;

  /**
   * The list of fields to be updated.
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 2;
   */
  updateMask?: FieldMask;

  /**
   * If set to true, and the release is not found, a new release will be created.
   * In this situation, `update_mask` is ignored.
   *
   * @generated from field: bool allow_missing = 3;
   */
  allowMissing: boolean;
};

/**
 * Describes the message bytebase.v1.UpdateReleaseRequest.
 * Use `create(UpdateReleaseRequestSchema)` to create a new message.
 */
export declare const UpdateReleaseRequestSchema: GenMessage<UpdateReleaseRequest>;

/**
 * @generated from message bytebase.v1.DeleteReleaseRequest
 */
export declare type DeleteReleaseRequest = Message<"bytebase.v1.DeleteReleaseRequest"> & {
  /**
   * The name of the release to delete.
   * Format: projects/{project}/releases/{release}
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message bytebase.v1.DeleteReleaseRequest.
 * Use `create(DeleteReleaseRequestSchema)` to create a new message.
 */
export declare const DeleteReleaseRequestSchema: GenMessage<DeleteReleaseRequest>;

/**
 * @generated from message bytebase.v1.UndeleteReleaseRequest
 */
export declare type UndeleteReleaseRequest = Message<"bytebase.v1.UndeleteReleaseRequest"> & {
  /**
   * The name of the deleted release.
   * Format: projects/{project}/releases/{release}
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message bytebase.v1.UndeleteReleaseRequest.
 * Use `create(UndeleteReleaseRequestSchema)` to create a new message.
 */
export declare const UndeleteReleaseRequestSchema: GenMessage<UndeleteReleaseRequest>;

/**
 * @generated from message bytebase.v1.CheckReleaseRequest
 */
export declare type CheckReleaseRequest = Message<"bytebase.v1.CheckReleaseRequest"> & {
  /**
   * Format: projects/{project}
   *
   * @generated from field: string parent = 1;
   */
  parent: string;

  /**
   * The release to check.
   *
   * @generated from field: bytebase.v1.Release release = 2;
   */
  release?: Release;

  /**
   * The targets to dry-run the release.
   * Can be database or databaseGroup.
   * Format:
   * projects/{project}/databaseGroups/{databaseGroup}
   * instances/{instance}/databases/{database}
   *
   * @generated from field: repeated string targets = 3;
   */
  targets: string[];
};

/**
 * Describes the message bytebase.v1.CheckReleaseRequest.
 * Use `create(CheckReleaseRequestSchema)` to create a new message.
 */
export declare const CheckReleaseRequestSchema: GenMessage<CheckReleaseRequest>;

/**
 * @generated from message bytebase.v1.CheckReleaseResponse
 */
export declare type CheckReleaseResponse = Message<"bytebase.v1.CheckReleaseResponse"> & {
  /**
   * The check results for each file and target combination.
   *
   * @generated from field: repeated bytebase.v1.CheckReleaseResponse.CheckResult results = 1;
   */
  results: CheckReleaseResponse_CheckResult[];

  /**
   * The total affected rows across all checks.
   *
   * @generated from field: int64 affected_rows = 2;
   */
  affectedRows: bigint;

  /**
   * The aggregated risk level of the check.
   *
   * @generated from field: bytebase.v1.RiskLevel risk_level = 3;
   */
  riskLevel: RiskLevel;
};

/**
 * Describes the message bytebase.v1.CheckReleaseResponse.
 * Use `create(CheckReleaseResponseSchema)` to create a new message.
 */
export declare const CheckReleaseResponseSchema: GenMessage<CheckReleaseResponse>;

/**
 * Check result for a single release file on a target database.
 *
 * @generated from message bytebase.v1.CheckReleaseResponse.CheckResult
 */
export declare type CheckReleaseResponse_CheckResult = Message<"bytebase.v1.CheckReleaseResponse.CheckResult"> & {
  /**
   * The file path that is being checked.
   *
   * @generated from field: string file = 1;
   */
  file: string;

  /**
   * The target that the check is performed on.
   * Should be a database. Format: instances/{instance}/databases/{database}
   *
   * @generated from field: string target = 2;
   */
  target: string;

  /**
   * The list of advice for the file and the target.
   *
   * @generated from field: repeated bytebase.v1.Advice advices = 3;
   */
  advices: Advice[];

  /**
   * The count of affected rows of the statement on the target.
   *
   * @generated from field: int64 affected_rows = 4;
   */
  affectedRows: bigint;

  /**
   * The risk level of the statement on the target.
   *
   * @generated from field: bytebase.v1.RiskLevel risk_level = 5;
   */
  riskLevel: RiskLevel;
};

/**
 * Describes the message bytebase.v1.CheckReleaseResponse.CheckResult.
 * Use `create(CheckReleaseResponse_CheckResultSchema)` to create a new message.
 */
export declare const CheckReleaseResponse_CheckResultSchema: GenMessage<CheckReleaseResponse_CheckResult>;

/**
 * @generated from message bytebase.v1.Release
 */
export declare type Release = Message<"bytebase.v1.Release"> & {
  /**
   * Format: projects/{project}/releases/{release}
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The title of the release.
   *
   * @generated from field: string title = 2;
   */
  title: string;

  /**
   * The SQL files included in the release.
   *
   * @generated from field: repeated bytebase.v1.Release.File files = 3;
   */
  files: Release_File[];

  /**
   * The version control source of the release.
   *
   * @generated from field: bytebase.v1.Release.VCSSource vcs_source = 4;
   */
  vcsSource?: Release_VCSSource;

  /**
   * Format: users/hello@world.com
   *
   * @generated from field: string creator = 5;
   */
  creator: string;

  /**
   * @generated from field: google.protobuf.Timestamp create_time = 6;
   */
  createTime?: Timestamp;

  /**
   * The lifecycle state of the release.
   *
   * @generated from field: bytebase.v1.State state = 7;
   */
  state: State;

  /**
   * The digest of the release.
   * The user can provide the digest of the release. It can be used later to retrieve the release in GetRelease.
   * Whether to provide digest and how to generate it is up to the user.
   * If the digest is not empty, it must be unique in the project. Otherwise, an ALREADY_EXISTS error will be returned.
   *
   * @generated from field: string digest = 8;
   */
  digest: string;
};

/**
 * Describes the message bytebase.v1.Release.
 * Use `create(ReleaseSchema)` to create a new message.
 */
export declare const ReleaseSchema: GenMessage<Release>;

/**
 * A SQL file in a release.
 *
 * @generated from message bytebase.v1.Release.File
 */
export declare type Release_File = Message<"bytebase.v1.Release.File"> & {
  /**
   * The unique identifier for the file.
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * The path of the file. e.g., `2.2/V0001_create_table.sql`.
   *
   * @generated from field: string path = 2;
   */
  path: string;

  /**
   * The type of the file.
   *
   * @generated from field: bytebase.v1.Release.File.Type type = 5;
   */
  type: Release_File_Type;

  /**
   * The version identifier for the file.
   *
   * @generated from field: string version = 6;
   */
  version: string;

  /**
   * The migration type of the file.
   * For versioned files, it is the migration type of the file.
   * For declarative files, this field is always DDL, thus meaningless.
   *
   * @generated from field: bytebase.v1.Release.File.MigrationType migration_type = 9;
   */
  migrationType: Release_File_MigrationType;

  /**
   * For inputs, we must either use `sheet` or `statement`.
   * For outputs, we always use `sheet`. `statement` is the preview of the sheet content.
   *
   * The sheet that holds the content.
   * Format: projects/{project}/sheets/{sheet}
   *
   * @generated from field: string sheet = 3;
   */
  sheet: string;

  /**
   * The raw SQL statement content.
   *
   * @generated from field: bytes statement = 7;
   */
  statement: Uint8Array;

  /**
   * The SHA256 hash value of the sheet content or the statement.
   *
   * @generated from field: string sheet_sha256 = 4;
   */
  sheetSha256: string;

  /**
   * The size of the statement in bytes.
   *
   * @generated from field: int64 statement_size = 8;
   */
  statementSize: bigint;
};

/**
 * Describes the message bytebase.v1.Release.File.
 * Use `create(Release_FileSchema)` to create a new message.
 */
export declare const Release_FileSchema: GenMessage<Release_File>;

/**
 * The type of migration file.
 *
 * @generated from enum bytebase.v1.Release.File.Type
 */
export enum Release_File_Type {
  /**
   * Unspecified type.
   *
   * @generated from enum value: TYPE_UNSPECIFIED = 0;
   */
  TYPE_UNSPECIFIED = 0,

  /**
   * Versioned migration file with sequential version numbers.
   *
   * @generated from enum value: VERSIONED = 1;
   */
  VERSIONED = 1,

  /**
   * Declarative schema definition file describing desired state.
   *
   * @generated from enum value: DECLARATIVE = 2;
   */
  DECLARATIVE = 2,
}

/**
 * Describes the enum bytebase.v1.Release.File.Type.
 */
export declare const Release_File_TypeSchema: GenEnum<Release_File_Type>;

/**
 * The migration type for versioned files.
 *
 * @generated from enum bytebase.v1.Release.File.MigrationType
 */
export enum Release_File_MigrationType {
  /**
   * Unspecified migration type.
   *
   * @generated from enum value: MIGRATION_TYPE_UNSPECIFIED = 0;
   */
  MIGRATION_TYPE_UNSPECIFIED = 0,

  /**
   * DDL (Data Definition Language) migration.
   *
   * @generated from enum value: DDL = 1;
   */
  DDL = 1,

  /**
   * DDL migration using gh-ost for online schema changes.
   *
   * @generated from enum value: DDL_GHOST = 2;
   */
  DDL_GHOST = 2,

  /**
   * DML (Data Manipulation Language) migration.
   *
   * @generated from enum value: DML = 3;
   */
  DML = 3,
}

/**
 * Describes the enum bytebase.v1.Release.File.MigrationType.
 */
export declare const Release_File_MigrationTypeSchema: GenEnum<Release_File_MigrationType>;

/**
 * Version control system source information.
 *
 * @generated from message bytebase.v1.Release.VCSSource
 */
export declare type Release_VCSSource = Message<"bytebase.v1.Release.VCSSource"> & {
  /**
   * The type of VCS.
   *
   * @generated from field: bytebase.v1.VCSType vcs_type = 1;
   */
  vcsType: VCSType;

  /**
   * The url link to the e.g., GitHub commit or pull request.
   *
   * @generated from field: string url = 2;
   */
  url: string;
};

/**
 * Describes the message bytebase.v1.Release.VCSSource.
 * Use `create(Release_VCSSourceSchema)` to create a new message.
 */
export declare const Release_VCSSourceSchema: GenMessage<Release_VCSSource>;

/**
 * ReleaseService manages releases for coordinating deployments.
 *
 * @generated from service bytebase.v1.ReleaseService
 */
export declare const ReleaseService: GenService<{
  /**
   * Retrieves a release by name.
   * Permissions required: bb.releases.get
   *
   * @generated from rpc bytebase.v1.ReleaseService.GetRelease
   */
  getRelease: {
    methodKind: "unary";
    input: typeof GetReleaseRequestSchema;
    output: typeof ReleaseSchema;
  },
  /**
   * Lists releases in a project.
   * Permissions required: bb.releases.list
   *
   * @generated from rpc bytebase.v1.ReleaseService.ListReleases
   */
  listReleases: {
    methodKind: "unary";
    input: typeof ListReleasesRequestSchema;
    output: typeof ListReleasesResponseSchema;
  },
  /**
   * Searches releases by digest or other criteria.
   * Permissions required: bb.releases.get
   *
   * @generated from rpc bytebase.v1.ReleaseService.SearchReleases
   */
  searchReleases: {
    methodKind: "unary";
    input: typeof SearchReleasesRequestSchema;
    output: typeof SearchReleasesResponseSchema;
  },
  /**
   * Creates a new release with SQL files.
   * Permissions required: bb.releases.create
   *
   * @generated from rpc bytebase.v1.ReleaseService.CreateRelease
   */
  createRelease: {
    methodKind: "unary";
    input: typeof CreateReleaseRequestSchema;
    output: typeof ReleaseSchema;
  },
  /**
   * Updates an existing release.
   * Permissions required: bb.releases.update
   *
   * @generated from rpc bytebase.v1.ReleaseService.UpdateRelease
   */
  updateRelease: {
    methodKind: "unary";
    input: typeof UpdateReleaseRequestSchema;
    output: typeof ReleaseSchema;
  },
  /**
   * Deletes a release.
   * Permissions required: bb.releases.delete
   *
   * @generated from rpc bytebase.v1.ReleaseService.DeleteRelease
   */
  deleteRelease: {
    methodKind: "unary";
    input: typeof DeleteReleaseRequestSchema;
    output: typeof EmptySchema;
  },
  /**
   * Restores a deleted release.
   * Permissions required: bb.releases.undelete
   *
   * @generated from rpc bytebase.v1.ReleaseService.UndeleteRelease
   */
  undeleteRelease: {
    methodKind: "unary";
    input: typeof UndeleteReleaseRequestSchema;
    output: typeof ReleaseSchema;
  },
  /**
   * Validates a release by dry-running checks on target databases.
   * Permissions required: bb.releases.check
   *
   * @generated from rpc bytebase.v1.ReleaseService.CheckRelease
   */
  checkRelease: {
    methodKind: "unary";
    input: typeof CheckReleaseRequestSchema;
    output: typeof CheckReleaseResponseSchema;
  },
}>;

