// @generated by protoc-gen-es v2.5.2
// @generated from file v1/risk_service.proto (package bytebase.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";
import type { EmptySchema, FieldMask } from "@bufbuild/protobuf/wkt";
import type { RiskLevel } from "./common_pb";
import type { Expr } from "../google/type/expr_pb";

/**
 * Describes the file v1/risk_service.proto.
 */
export declare const file_v1_risk_service: GenFile;

/**
 * @generated from message bytebase.v1.ListRisksRequest
 */
export declare type ListRisksRequest = Message<"bytebase.v1.ListRisksRequest"> & {
  /**
   * Pagination is not currently implemented. This field is reserved for future use.
   * The maximum number of risks to return. The service may return fewer than
   * this value.
   * If unspecified, at most 10 risks will be returned.
   * The maximum value is 1000; values above 1000 will be coerced to 1000.
   *
   * @generated from field: int32 page_size = 1;
   */
  pageSize: number;

  /**
   * Pagination is not currently implemented. This field is reserved for future use.
   * A page token, received from a previous `ListRisks` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListRisks` must match
   * the call that provided the page token.
   *
   * @generated from field: string page_token = 2;
   */
  pageToken: string;
};

/**
 * Describes the message bytebase.v1.ListRisksRequest.
 * Use `create(ListRisksRequestSchema)` to create a new message.
 */
export declare const ListRisksRequestSchema: GenMessage<ListRisksRequest>;

/**
 * @generated from message bytebase.v1.ListRisksResponse
 */
export declare type ListRisksResponse = Message<"bytebase.v1.ListRisksResponse"> & {
  /**
   * @generated from field: repeated bytebase.v1.Risk risks = 1;
   */
  risks: Risk[];

  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message bytebase.v1.ListRisksResponse.
 * Use `create(ListRisksResponseSchema)` to create a new message.
 */
export declare const ListRisksResponseSchema: GenMessage<ListRisksResponse>;

/**
 * @generated from message bytebase.v1.CreateRiskRequest
 */
export declare type CreateRiskRequest = Message<"bytebase.v1.CreateRiskRequest"> & {
  /**
   * The risk to create.
   *
   * @generated from field: bytebase.v1.Risk risk = 1;
   */
  risk?: Risk;
};

/**
 * Describes the message bytebase.v1.CreateRiskRequest.
 * Use `create(CreateRiskRequestSchema)` to create a new message.
 */
export declare const CreateRiskRequestSchema: GenMessage<CreateRiskRequest>;

/**
 * @generated from message bytebase.v1.GetRiskRequest
 */
export declare type GetRiskRequest = Message<"bytebase.v1.GetRiskRequest"> & {
  /**
   * The name of the risk to retrieve.
   * Format: risks/{risk}
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message bytebase.v1.GetRiskRequest.
 * Use `create(GetRiskRequestSchema)` to create a new message.
 */
export declare const GetRiskRequestSchema: GenMessage<GetRiskRequest>;

/**
 * @generated from message bytebase.v1.UpdateRiskRequest
 */
export declare type UpdateRiskRequest = Message<"bytebase.v1.UpdateRiskRequest"> & {
  /**
   * The risk to update.
   *
   * The risk's `name` field is used to identify the risk to update.
   * Format: risks/{risk}
   *
   * @generated from field: bytebase.v1.Risk risk = 1;
   */
  risk?: Risk;

  /**
   * The list of fields to update.
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 2;
   */
  updateMask?: FieldMask;

  /**
   * If set to true, and the risk is not found, a new risk will be created.
   * In this situation, `update_mask` is ignored.
   *
   * @generated from field: bool allow_missing = 3;
   */
  allowMissing: boolean;
};

/**
 * Describes the message bytebase.v1.UpdateRiskRequest.
 * Use `create(UpdateRiskRequestSchema)` to create a new message.
 */
export declare const UpdateRiskRequestSchema: GenMessage<UpdateRiskRequest>;

/**
 * @generated from message bytebase.v1.DeleteRiskRequest
 */
export declare type DeleteRiskRequest = Message<"bytebase.v1.DeleteRiskRequest"> & {
  /**
   * The name of the risk to delete.
   * Format: risks/{risk}
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message bytebase.v1.DeleteRiskRequest.
 * Use `create(DeleteRiskRequestSchema)` to create a new message.
 */
export declare const DeleteRiskRequestSchema: GenMessage<DeleteRiskRequest>;

/**
 * @generated from message bytebase.v1.Risk
 */
export declare type Risk = Message<"bytebase.v1.Risk"> & {
  /**
   * Format: risks/{risk}
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: bytebase.v1.Risk.Source source = 3;
   */
  source: Risk_Source;

  /**
   * The title of the risk rule.
   *
   * @generated from field: string title = 4;
   */
  title: string;

  /**
   * The risk level assigned when this rule matches.
   *
   * @generated from field: bytebase.v1.RiskLevel level = 5;
   */
  level: RiskLevel;

  /**
   * Whether the risk rule is active.
   *
   * @generated from field: bool active = 7;
   */
  active: boolean;

  /**
   * The condition that is associated with the risk.
   * The syntax and semantics of CEL are documented at https://github.com/google/cel-spec
   *
   * All supported variables:
   * statement.affected_rows: affected row count in the DDL/DML, support "==", "!=", "<", "<=", ">", ">=" operations.
   * statement.table_rows: table row count number, support "==", "!=", "<", "<=", ">", ">=" operations.
   * resource.environment_id: the environment resource id, support "==", "!=", "in [xx]", "!(in [xx])" operations.
   * resource.project_id: the project resource id, support "==", "!=", "in [xx]", "!(in [xx])", "contains()", "matches()", "startsWith()", "endsWith()" operations.
   * resource.db_engine: the database engine type, support "==", "!=", "in [xx]", "!(in [xx])" operations. Check the Engine enum for the values.
   * statement.sql_type: the SQL type, support "==", "!=", "in [xx]", "!(in [xx])" operations.
   *  when the risk source is DDL, check https://github.com/bytebase/bytebase/blob/main/frontend/src/plugins/cel/types/values.ts#L70 for supported values.
   *  when the risk source is DML, check https://github.com/bytebase/bytebase/blob/main/frontend/src/plugins/cel/types/values.ts#L71 for supported values.
   * resource.database_name: the database name, support "==", "!=", "in [xx]", "!(in [xx])", "contains()", "matches()", "startsWith()", "endsWith()" operations.
   * resource.schema_name: the schema name, support "==", "!=", "in [xx]", "!(in [xx])", "contains()", "matches()", "startsWith()", "endsWith()" operations.
   * resource.table_name: the table name, support "==", "!=", "in [xx]", "!(in [xx])", "contains()", "matches()", "startsWith()", "endsWith()" operations.
   * statement.text: the SQL statement, support "contains()", "matches()", "startsWith()", "endsWith()" operations.
   * request.expiration_days: the role expiration days for the request, support "==", "!=", "<", "<=", ">", ">=" operations.
   * request.role: the request role full name, support "==", "!=", "in [xx]", "!(in [xx])", "contains()", "matches()", "startsWith()", "endsWith()" operations.
   *
   * When the risk source is DDL/DML, support following variables:
   * statement.affected_rows
   * statement.table_rows
   * resource.environment_id
   * resource.project_id
   * resource.db_engine
   * statement.sql_type
   * resource.database_name
   * resource.schema_name
   * resource.table_name
   * statement.text
   *
   * When the risk source is CREATE_DATABASE, support following variables:
   * resource.environment_id
   * resource.project_id
   * resource.db_engine
   * resource.database_name
   *
   * When the risk source is DATA_EXPORT, support following variables:
   * resource.environment_id
   * resource.project_id
   * resource.db_engine
   * resource.database_name
   * resource.schema_name
   * resource.table_name
   *
   * When the risk source is REQUEST_ROLE, support following variables:
   * resource.project_id
   * request.expiration_days
   * request.role
   *
   * @generated from field: google.type.Expr condition = 8;
   */
  condition?: Expr;
};

/**
 * Describes the message bytebase.v1.Risk.
 * Use `create(RiskSchema)` to create a new message.
 */
export declare const RiskSchema: GenMessage<Risk>;

/**
 * @generated from enum bytebase.v1.Risk.Source
 */
export enum Risk_Source {
  /**
   * @generated from enum value: SOURCE_UNSPECIFIED = 0;
   */
  SOURCE_UNSPECIFIED = 0,

  /**
   * @generated from enum value: DDL = 1;
   */
  DDL = 1,

  /**
   * @generated from enum value: DML = 2;
   */
  DML = 2,

  /**
   * @generated from enum value: CREATE_DATABASE = 3;
   */
  CREATE_DATABASE = 3,

  /**
   * @generated from enum value: DATA_EXPORT = 6;
   */
  DATA_EXPORT = 6,

  /**
   * @generated from enum value: REQUEST_ROLE = 7;
   */
  REQUEST_ROLE = 7,
}

/**
 * Describes the enum bytebase.v1.Risk.Source.
 */
export declare const Risk_SourceSchema: GenEnum<Risk_Source>;

/**
 * RiskService manages risk assessment rules for database changes.
 *
 * @generated from service bytebase.v1.RiskService
 */
export declare const RiskService: GenService<{
  /**
   * Lists all risk assessment rules.
   * Permissions required: bb.risks.list
   *
   * @generated from rpc bytebase.v1.RiskService.ListRisks
   */
  listRisks: {
    methodKind: "unary";
    input: typeof ListRisksRequestSchema;
    output: typeof ListRisksResponseSchema;
  },
  /**
   * Creates a new risk assessment rule.
   * Permissions required: bb.risks.create
   *
   * @generated from rpc bytebase.v1.RiskService.CreateRisk
   */
  createRisk: {
    methodKind: "unary";
    input: typeof CreateRiskRequestSchema;
    output: typeof RiskSchema;
  },
  /**
   * Retrieves a risk assessment rule by name.
   * Permissions required: bb.risks.list
   *
   * @generated from rpc bytebase.v1.RiskService.GetRisk
   */
  getRisk: {
    methodKind: "unary";
    input: typeof GetRiskRequestSchema;
    output: typeof RiskSchema;
  },
  /**
   * Updates an existing risk assessment rule.
   * Permissions required: bb.risks.update
   *
   * @generated from rpc bytebase.v1.RiskService.UpdateRisk
   */
  updateRisk: {
    methodKind: "unary";
    input: typeof UpdateRiskRequestSchema;
    output: typeof RiskSchema;
  },
  /**
   * Deletes a risk assessment rule.
   * Permissions required: bb.risks.delete
   *
   * @generated from rpc bytebase.v1.RiskService.DeleteRisk
   */
  deleteRisk: {
    methodKind: "unary";
    input: typeof DeleteRiskRequestSchema;
    output: typeof EmptySchema;
  },
}>;

