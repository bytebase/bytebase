// @generated by protoc-gen-es v2.5.2
// @generated from file v1/group_service.proto (package bytebase.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";
import type { EmptySchema, FieldMask } from "@bufbuild/protobuf/wkt";

/**
 * Describes the file v1/group_service.proto.
 */
export declare const file_v1_group_service: GenFile;

/**
 * Request message for getting a group.
 *
 * @generated from message bytebase.v1.GetGroupRequest
 */
export declare type GetGroupRequest = Message<"bytebase.v1.GetGroupRequest"> & {
  /**
   * The name of the group to retrieve.
   * Format: groups/{email}
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message bytebase.v1.GetGroupRequest.
 * Use `create(GetGroupRequestSchema)` to create a new message.
 */
export declare const GetGroupRequestSchema: GenMessage<GetGroupRequest>;

/**
 * Request message for batch getting groups.
 *
 * @generated from message bytebase.v1.BatchGetGroupsRequest
 */
export declare type BatchGetGroupsRequest = Message<"bytebase.v1.BatchGetGroupsRequest"> & {
  /**
   * The group names to retrieve.
   * Format: groups/{email}
   *
   * @generated from field: repeated string names = 1;
   */
  names: string[];
};

/**
 * Describes the message bytebase.v1.BatchGetGroupsRequest.
 * Use `create(BatchGetGroupsRequestSchema)` to create a new message.
 */
export declare const BatchGetGroupsRequestSchema: GenMessage<BatchGetGroupsRequest>;

/**
 * Response message for batch getting groups.
 *
 * @generated from message bytebase.v1.BatchGetGroupsResponse
 */
export declare type BatchGetGroupsResponse = Message<"bytebase.v1.BatchGetGroupsResponse"> & {
  /**
   * The groups from the specified request.
   *
   * @generated from field: repeated bytebase.v1.Group groups = 1;
   */
  groups: Group[];
};

/**
 * Describes the message bytebase.v1.BatchGetGroupsResponse.
 * Use `create(BatchGetGroupsResponseSchema)` to create a new message.
 */
export declare const BatchGetGroupsResponseSchema: GenMessage<BatchGetGroupsResponse>;

/**
 * Request message for listing groups.
 *
 * @generated from message bytebase.v1.ListGroupsRequest
 */
export declare type ListGroupsRequest = Message<"bytebase.v1.ListGroupsRequest"> & {
  /**
   * The maximum number of groups to return. The service may return fewer than
   * this value.
   * If unspecified, at most 10 groups will be returned.
   * The maximum value is 1000; values above 1000 will be coerced to 1000.
   *
   * @generated from field: int32 page_size = 1;
   */
  pageSize: number;

  /**
   * A page token, received from a previous `ListGroups` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListGroups` must match
   * the call that provided the page token.
   *
   * @generated from field: string page_token = 2;
   */
  pageToken: string;

  /**
   * Filter is used to filter groups returned in the list.
   * The syntax and semantics of CEL are documented at https://github.com/google/cel-spec
   *
   * Supported filter:
   * - title: the group title, support "==" and ".matches()" operator.
   * - email: the group email, support "==" and ".matches()" operator.
   * - project: the project full name in "projects/{id}" format, support "==" operator.
   *
   * For example:
   * title == "dba"
   * email == "dba@bytebase.com"
   * title.matches("dba")
   * email.matches("dba")
   * project == "projects/sample-project"
   * You can combine filter conditions like:
   * title.matches("dba") || email.matches("dba")
   *
   * @generated from field: string filter = 3;
   */
  filter: string;
};

/**
 * Describes the message bytebase.v1.ListGroupsRequest.
 * Use `create(ListGroupsRequestSchema)` to create a new message.
 */
export declare const ListGroupsRequestSchema: GenMessage<ListGroupsRequest>;

/**
 * Response message for listing groups.
 *
 * @generated from message bytebase.v1.ListGroupsResponse
 */
export declare type ListGroupsResponse = Message<"bytebase.v1.ListGroupsResponse"> & {
  /**
   * The groups from the specified request.
   *
   * @generated from field: repeated bytebase.v1.Group groups = 1;
   */
  groups: Group[];

  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message bytebase.v1.ListGroupsResponse.
 * Use `create(ListGroupsResponseSchema)` to create a new message.
 */
export declare const ListGroupsResponseSchema: GenMessage<ListGroupsResponse>;

/**
 * Request message for creating a group.
 *
 * @generated from message bytebase.v1.CreateGroupRequest
 */
export declare type CreateGroupRequest = Message<"bytebase.v1.CreateGroupRequest"> & {
  /**
   * The group to create.
   *
   * @generated from field: bytebase.v1.Group group = 1;
   */
  group?: Group;

  /**
   * The email to use for the group, which will become the final component
   * of the group's resource name.
   *
   * @generated from field: string group_email = 2;
   */
  groupEmail: string;
};

/**
 * Describes the message bytebase.v1.CreateGroupRequest.
 * Use `create(CreateGroupRequestSchema)` to create a new message.
 */
export declare const CreateGroupRequestSchema: GenMessage<CreateGroupRequest>;

/**
 * Request message for updating a group.
 *
 * @generated from message bytebase.v1.UpdateGroupRequest
 */
export declare type UpdateGroupRequest = Message<"bytebase.v1.UpdateGroupRequest"> & {
  /**
   * The group to update.
   *
   * The group's `name` field is used to identify the group to update.
   * Format: groups/{email}
   *
   * @generated from field: bytebase.v1.Group group = 1;
   */
  group?: Group;

  /**
   * The list of fields to update.
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 2;
   */
  updateMask?: FieldMask;

  /**
   * If set to true, and the group is not found, a new group will be created.
   * In this situation, `update_mask` is ignored.
   *
   * @generated from field: bool allow_missing = 3;
   */
  allowMissing: boolean;
};

/**
 * Describes the message bytebase.v1.UpdateGroupRequest.
 * Use `create(UpdateGroupRequestSchema)` to create a new message.
 */
export declare const UpdateGroupRequestSchema: GenMessage<UpdateGroupRequest>;

/**
 * Request message for deleting a group.
 *
 * @generated from message bytebase.v1.DeleteGroupRequest
 */
export declare type DeleteGroupRequest = Message<"bytebase.v1.DeleteGroupRequest"> & {
  /**
   * The name of the group to delete.
   * Format: groups/{email}
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message bytebase.v1.DeleteGroupRequest.
 * Use `create(DeleteGroupRequestSchema)` to create a new message.
 */
export declare const DeleteGroupRequestSchema: GenMessage<DeleteGroupRequest>;

/**
 * A member of a group with a role.
 *
 * @generated from message bytebase.v1.GroupMember
 */
export declare type GroupMember = Message<"bytebase.v1.GroupMember"> & {
  /**
   * Member is the principal who belong to this group.
   *
   * Format: users/hello@world.com
   *
   * @generated from field: string member = 1;
   */
  member: string;

  /**
   * The member's role in the group.
   *
   * @generated from field: bytebase.v1.GroupMember.Role role = 2;
   */
  role: GroupMember_Role;
};

/**
 * Describes the message bytebase.v1.GroupMember.
 * Use `create(GroupMemberSchema)` to create a new message.
 */
export declare const GroupMemberSchema: GenMessage<GroupMember>;

/**
 * The role of a group member.
 *
 * @generated from enum bytebase.v1.GroupMember.Role
 */
export enum GroupMember_Role {
  /**
   * Unspecified role.
   *
   * @generated from enum value: ROLE_UNSPECIFIED = 0;
   */
  ROLE_UNSPECIFIED = 0,

  /**
   * Group owner.
   *
   * @generated from enum value: OWNER = 1;
   */
  OWNER = 1,

  /**
   * Group member.
   *
   * @generated from enum value: MEMBER = 2;
   */
  MEMBER = 2,
}

/**
 * Describes the enum bytebase.v1.GroupMember.Role.
 */
export declare const GroupMember_RoleSchema: GenEnum<GroupMember_Role>;

/**
 * A group of users within the workspace.
 *
 * @generated from message bytebase.v1.Group
 */
export declare type Group = Message<"bytebase.v1.Group"> & {
  /**
   * The name of the group to retrieve.
   * Format: groups/{group}, the group should be email or uuid.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The display title of the group.
   *
   * @generated from field: string title = 2;
   */
  title: string;

  /**
   * The description of the group.
   *
   * @generated from field: string description = 3;
   */
  description: string;

  /**
   * The members of the group.
   *
   * @generated from field: repeated bytebase.v1.GroupMember members = 4;
   */
  members: GroupMember[];

  /**
   * The source system where the group originated (e.g., Entra ID for SCIM sync).
   *
   * @generated from field: string source = 5;
   */
  source: string;

  /**
   * The unique email for the group.
   *
   * @generated from field: string email = 6;
   */
  email: string;
};

/**
 * Describes the message bytebase.v1.Group.
 * Use `create(GroupSchema)` to create a new message.
 */
export declare const GroupSchema: GenMessage<Group>;

/**
 * GroupService manages user groups for organizing users and permissions.
 *
 * @generated from service bytebase.v1.GroupService
 */
export declare const GroupService: GenService<{
  /**
   * Gets a group by name.
   * Permissions required: bb.groups.get
   *
   * @generated from rpc bytebase.v1.GroupService.GetGroup
   */
  getGroup: {
    methodKind: "unary";
    input: typeof GetGroupRequestSchema;
    output: typeof GroupSchema;
  },
  /**
   * Gets multiple groups in a single request.
   * Permissions required: bb.groups.get
   *
   * @generated from rpc bytebase.v1.GroupService.BatchGetGroups
   */
  batchGetGroups: {
    methodKind: "unary";
    input: typeof BatchGetGroupsRequestSchema;
    output: typeof BatchGetGroupsResponseSchema;
  },
  /**
   * Lists all groups in the workspace.
   * Permissions required: bb.groups.list
   *
   * @generated from rpc bytebase.v1.GroupService.ListGroups
   */
  listGroups: {
    methodKind: "unary";
    input: typeof ListGroupsRequestSchema;
    output: typeof ListGroupsResponseSchema;
  },
  /**
   * Creates a new group.
   * Permissions required: bb.groups.create
   *
   * @generated from rpc bytebase.v1.GroupService.CreateGroup
   */
  createGroup: {
    methodKind: "unary";
    input: typeof CreateGroupRequestSchema;
    output: typeof GroupSchema;
  },
  /**
   * Updates a group. Group owners or users with bb.groups.update permission can update.
   * Permissions required: bb.groups.update OR caller is group owner
   * When allow_missing=true, also requires: bb.groups.create
   *
   * @generated from rpc bytebase.v1.GroupService.UpdateGroup
   */
  updateGroup: {
    methodKind: "unary";
    input: typeof UpdateGroupRequestSchema;
    output: typeof GroupSchema;
  },
  /**
   * Deletes a group. Group owners or users with bb.groups.delete permission can delete.
   * Permissions required: bb.groups.delete OR caller is group owner
   *
   * @generated from rpc bytebase.v1.GroupService.DeleteGroup
   */
  deleteGroup: {
    methodKind: "unary";
    input: typeof DeleteGroupRequestSchema;
    output: typeof EmptySchema;
  },
}>;

