// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.3.0
//   protoc               unknown
// source: v1/iam_policy.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Expr as Expr1 } from "../google/api/expr/v1alpha1/syntax";
import { Expr } from "../google/type/expr";

export const protobufPackage = "bytebase.v1";

export interface GetIamPolicyRequest {
  /**
   * The name of the resource to get the IAM policy.
   * Format: projects/{project}
   * Format: workspaces/{workspace}
   */
  resource: string;
}

export interface SetIamPolicyRequest {
  /**
   * The name of the resource to set the IAM policy.
   * Format: projects/{project}
   * Format: workspaces/{workspace}
   */
  resource: string;
  policy:
    | IamPolicy
    | undefined;
  /** The current etag of the policy. */
  etag: string;
}

export interface IamPolicy {
  /**
   * Collection of binding.
   * A binding binds one or more project members to a single project role.
   */
  bindings: Binding[];
  /**
   * The current etag of the policy.
   * If an etag is provided and does not match the current etag of the poliy,
   * the call will be blocked and an ABORTED error will be returned.
   */
  etag: string;
}

export interface Binding {
  /**
   * The role that is assigned to the members.
   * Format: roles/{role}
   */
  role: string;
  /**
   * Specifies the principals requesting access for a Bytebase resource.
   * For users, the member should be: user:{email}
   * For groups, the member should be: group:{email}
   */
  members: string[];
  /**
   * The condition that is associated with this binding, only used in the project IAM policy.
   * If the condition evaluates to true, then this binding applies to the current request.
   * If the condition evaluates to false, then this binding does not apply to the current request. However, a different role binding might grant the same role to one or more of the principals in this binding.
   * The syntax and semantics of CEL are documented at https://github.com/google/cel-spec
   *
   * Support variables:
   * resource.database: the database full name in "instances/{instance}/databases/{database}" format, used by the "roles/sqlEditorUser" and "roles/projectExporter" role, support "==" operator.
   * resource.schema: the schema name, used by the "roles/sqlEditorUser" and "roles/projectExporter" role, support "==" operator.
   * resource.table: the table name, used by the "roles/sqlEditorUser" and "roles/projectExporter" role, support "==" operator.
   * request.time: the expiration. Only support "<" operation in `request.time < timestamp("{ISO datetime string format}")`.
   * request.row_limit: the maximum export rows, used by the "roles/projectExporter" role. Only support "<=" operation.
   *
   * For example:
   * resource.database == "instances/local-pg/databases/postgres" && resource.schema in ["public","another_schema"]
   * resource.database == "instances/local-pg/databases/bytebase" && resource.schema == "public" && resource.table in ["audit_log"]
   * request.time < timestamp("2025-04-26T11:24:48.655Z") && request.row_limit <= 1000
   */
  condition:
    | Expr
    | undefined;
  /** The parsed expression of the condition. */
  parsedExpr: Expr1 | undefined;
}

/** The difference delta between two policies. */
export interface PolicyDelta {
  /** The delta for Bindings between two policies. */
  bindingDeltas: BindingDelta[];
}

/**
 * One delta entry for Binding. Each individual change (only one member in each
 * entry) to a binding will be a separate entry.
 */
export interface BindingDelta {
  /** The action that was performed on a Binding. */
  action: BindingDelta_Action;
  /**
   * Role that is assigned to `members`.
   * For example, `roles/projectOwner`.
   */
  role: string;
  /** Follows the same format of Binding.members. */
  member: string;
  /** The condition that is associated with this binding. */
  condition: Expr | undefined;
}

/** The type of action performed on a Binding in a policy. */
export enum BindingDelta_Action {
  ACTION_UNSPECIFIED = "ACTION_UNSPECIFIED",
  ADD = "ADD",
  REMOVE = "REMOVE",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function bindingDelta_ActionFromJSON(object: any): BindingDelta_Action {
  switch (object) {
    case 0:
    case "ACTION_UNSPECIFIED":
      return BindingDelta_Action.ACTION_UNSPECIFIED;
    case 1:
    case "ADD":
      return BindingDelta_Action.ADD;
    case 2:
    case "REMOVE":
      return BindingDelta_Action.REMOVE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BindingDelta_Action.UNRECOGNIZED;
  }
}

export function bindingDelta_ActionToJSON(object: BindingDelta_Action): string {
  switch (object) {
    case BindingDelta_Action.ACTION_UNSPECIFIED:
      return "ACTION_UNSPECIFIED";
    case BindingDelta_Action.ADD:
      return "ADD";
    case BindingDelta_Action.REMOVE:
      return "REMOVE";
    case BindingDelta_Action.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function bindingDelta_ActionToNumber(object: BindingDelta_Action): number {
  switch (object) {
    case BindingDelta_Action.ACTION_UNSPECIFIED:
      return 0;
    case BindingDelta_Action.ADD:
      return 1;
    case BindingDelta_Action.REMOVE:
      return 2;
    case BindingDelta_Action.UNRECOGNIZED:
    default:
      return -1;
  }
}

function createBaseGetIamPolicyRequest(): GetIamPolicyRequest {
  return { resource: "" };
}

export const GetIamPolicyRequest: MessageFns<GetIamPolicyRequest> = {
  encode(message: GetIamPolicyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resource !== "") {
      writer.uint32(10).string(message.resource);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetIamPolicyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetIamPolicyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.resource = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  toJSON(message: GetIamPolicyRequest): unknown {
    const obj: any = {};
    if (message.resource !== "") {
      obj.resource = message.resource;
    }
    return obj;
  },

  create(base?: DeepPartial<GetIamPolicyRequest>): GetIamPolicyRequest {
    return GetIamPolicyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetIamPolicyRequest>): GetIamPolicyRequest {
    const message = createBaseGetIamPolicyRequest();
    message.resource = object.resource ?? "";
    return message;
  },
};

function createBaseSetIamPolicyRequest(): SetIamPolicyRequest {
  return { resource: "", policy: undefined, etag: "" };
}

export const SetIamPolicyRequest: MessageFns<SetIamPolicyRequest> = {
  encode(message: SetIamPolicyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resource !== "") {
      writer.uint32(10).string(message.resource);
    }
    if (message.policy !== undefined) {
      IamPolicy.encode(message.policy, writer.uint32(18).fork()).join();
    }
    if (message.etag !== "") {
      writer.uint32(26).string(message.etag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetIamPolicyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetIamPolicyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.resource = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.policy = IamPolicy.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.etag = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  toJSON(message: SetIamPolicyRequest): unknown {
    const obj: any = {};
    if (message.resource !== "") {
      obj.resource = message.resource;
    }
    if (message.policy !== undefined) {
      obj.policy = IamPolicy.toJSON(message.policy);
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    return obj;
  },

  create(base?: DeepPartial<SetIamPolicyRequest>): SetIamPolicyRequest {
    return SetIamPolicyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SetIamPolicyRequest>): SetIamPolicyRequest {
    const message = createBaseSetIamPolicyRequest();
    message.resource = object.resource ?? "";
    message.policy = (object.policy !== undefined && object.policy !== null)
      ? IamPolicy.fromPartial(object.policy)
      : undefined;
    message.etag = object.etag ?? "";
    return message;
  },
};

function createBaseIamPolicy(): IamPolicy {
  return { bindings: [], etag: "" };
}

export const IamPolicy: MessageFns<IamPolicy> = {
  encode(message: IamPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.bindings) {
      Binding.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.etag !== "") {
      writer.uint32(18).string(message.etag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IamPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIamPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bindings.push(Binding.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.etag = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  toJSON(message: IamPolicy): unknown {
    const obj: any = {};
    if (message.bindings?.length) {
      obj.bindings = message.bindings.map((e) => Binding.toJSON(e));
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    return obj;
  },

  create(base?: DeepPartial<IamPolicy>): IamPolicy {
    return IamPolicy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IamPolicy>): IamPolicy {
    const message = createBaseIamPolicy();
    message.bindings = object.bindings?.map((e) => Binding.fromPartial(e)) || [];
    message.etag = object.etag ?? "";
    return message;
  },
};

function createBaseBinding(): Binding {
  return { role: "", members: [], condition: undefined, parsedExpr: undefined };
}

export const Binding: MessageFns<Binding> = {
  encode(message: Binding, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.role !== "") {
      writer.uint32(10).string(message.role);
    }
    for (const v of message.members) {
      writer.uint32(18).string(v!);
    }
    if (message.condition !== undefined) {
      Expr.encode(message.condition, writer.uint32(26).fork()).join();
    }
    if (message.parsedExpr !== undefined) {
      Expr1.encode(message.parsedExpr, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Binding {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBinding();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.role = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.members.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.condition = Expr.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.parsedExpr = Expr1.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  toJSON(message: Binding): unknown {
    const obj: any = {};
    if (message.role !== "") {
      obj.role = message.role;
    }
    if (message.members?.length) {
      obj.members = message.members;
    }
    if (message.condition !== undefined) {
      obj.condition = Expr.toJSON(message.condition);
    }
    if (message.parsedExpr !== undefined) {
      obj.parsedExpr = Expr1.toJSON(message.parsedExpr);
    }
    return obj;
  },

  create(base?: DeepPartial<Binding>): Binding {
    return Binding.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Binding>): Binding {
    const message = createBaseBinding();
    message.role = object.role ?? "";
    message.members = object.members?.map((e) => e) || [];
    message.condition = (object.condition !== undefined && object.condition !== null)
      ? Expr.fromPartial(object.condition)
      : undefined;
    message.parsedExpr = (object.parsedExpr !== undefined && object.parsedExpr !== null)
      ? Expr1.fromPartial(object.parsedExpr)
      : undefined;
    return message;
  },
};

function createBasePolicyDelta(): PolicyDelta {
  return { bindingDeltas: [] };
}

export const PolicyDelta: MessageFns<PolicyDelta> = {
  encode(message: PolicyDelta, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.bindingDeltas) {
      BindingDelta.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PolicyDelta {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolicyDelta();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bindingDeltas.push(BindingDelta.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  toJSON(message: PolicyDelta): unknown {
    const obj: any = {};
    if (message.bindingDeltas?.length) {
      obj.bindingDeltas = message.bindingDeltas.map((e) => BindingDelta.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<PolicyDelta>): PolicyDelta {
    return PolicyDelta.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PolicyDelta>): PolicyDelta {
    const message = createBasePolicyDelta();
    message.bindingDeltas = object.bindingDeltas?.map((e) => BindingDelta.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBindingDelta(): BindingDelta {
  return { action: BindingDelta_Action.ACTION_UNSPECIFIED, role: "", member: "", condition: undefined };
}

export const BindingDelta: MessageFns<BindingDelta> = {
  encode(message: BindingDelta, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.action !== BindingDelta_Action.ACTION_UNSPECIFIED) {
      writer.uint32(8).int32(bindingDelta_ActionToNumber(message.action));
    }
    if (message.role !== "") {
      writer.uint32(18).string(message.role);
    }
    if (message.member !== "") {
      writer.uint32(26).string(message.member);
    }
    if (message.condition !== undefined) {
      Expr.encode(message.condition, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BindingDelta {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBindingDelta();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.action = bindingDelta_ActionFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.role = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.member = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.condition = Expr.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  toJSON(message: BindingDelta): unknown {
    const obj: any = {};
    if (message.action !== BindingDelta_Action.ACTION_UNSPECIFIED) {
      obj.action = bindingDelta_ActionToJSON(message.action);
    }
    if (message.role !== "") {
      obj.role = message.role;
    }
    if (message.member !== "") {
      obj.member = message.member;
    }
    if (message.condition !== undefined) {
      obj.condition = Expr.toJSON(message.condition);
    }
    return obj;
  },

  create(base?: DeepPartial<BindingDelta>): BindingDelta {
    return BindingDelta.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BindingDelta>): BindingDelta {
    const message = createBaseBindingDelta();
    message.action = object.action ?? BindingDelta_Action.ACTION_UNSPECIFIED;
    message.role = object.role ?? "";
    message.member = object.member ?? "";
    message.condition = (object.condition !== undefined && object.condition !== null)
      ? Expr.fromPartial(object.condition)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
