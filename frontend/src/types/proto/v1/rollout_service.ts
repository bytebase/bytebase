// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.3.0
//   protoc               unknown
// source: v1/rollout_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../google/protobuf/timestamp";
import { ExportFormat, exportFormatFromJSON, exportFormatToJSON, exportFormatToNumber, Position } from "./common";
import { Plan } from "./plan_service";

export const protobufPackage = "bytebase.v1";

export interface BatchRunTasksRequest {
  /**
   * The name of the parent of the tasks.
   * Format: projects/{project}/rollouts/{rollout}/stages/{stage}
   */
  parent: string;
  /**
   * The tasks to run.
   * Format: projects/{project}/rollouts/{rollout}/stages/{stage}/tasks/{task}
   */
  tasks: string[];
  reason: string;
}

export interface BatchRunTasksResponse {
}

export interface BatchSkipTasksRequest {
  /**
   * The name of the parent of the tasks.
   * Format: projects/{project}/rollouts/{rollout}/stages/{stage}
   */
  parent: string;
  /**
   * The tasks to skip.
   * Format: projects/{project}/rollouts/{rollout}/stages/{stage}/tasks/{task}
   */
  tasks: string[];
  reason: string;
}

export interface BatchSkipTasksResponse {
}

export interface BatchCancelTaskRunsRequest {
  /**
   * The name of the parent of the taskRuns.
   * Format: projects/{project}/rollouts/{rollout}/stages/{stage}/tasks/{task}
   * Use `projects/{project}/rollouts/{rollout}/stages/{stage}/tasks/-` to cancel task runs under the same stage.
   */
  parent: string;
  /**
   * The taskRuns to cancel.
   * Format: projects/{project}/rollouts/{rollout}/stages/{stage}/tasks/{task}/taskRuns/{taskRun}
   */
  taskRuns: string[];
  reason: string;
}

export interface BatchCancelTaskRunsResponse {
}

export interface GetRolloutRequest {
  /**
   * The name of the rollout to retrieve.
   * Format: projects/{project}/rollouts/{rollout}
   */
  name: string;
}

export interface ListRolloutsRequest {
  /**
   * The parent, which owns this collection of rollouts.
   * Format: projects/{project}
   * Use "projects/-" to list all rollouts from all projects.
   */
  parent: string;
  /**
   * The maximum number of rollouts to return. The service may return fewer than
   * this value.
   * If unspecified, at most 10 rollouts will be returned.
   * The maximum value is 1000; values above 1000 will be coerced to 1000.
   */
  pageSize: number;
  /**
   * A page token, received from a previous `ListRollouts` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListRollouts` must match
   * the call that provided the page token.
   */
  pageToken: string;
}

export interface ListRolloutsResponse {
  /** The rollouts from the specified request. */
  rollouts: Rollout[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
}

export interface CreateRolloutRequest {
  /**
   * The parent project where this rollout will be created.
   * Format: projects/{project}
   */
  parent: string;
  /** The rollout to create. */
  rollout:
    | Rollout
    | undefined;
  /**
   * stage_id is the id in the plan deployment_config_snapshot.
   * The rollout is created according to the plan and the
   * stages are created up to the stage_id.
   * If unspecified, all stages are created.
   */
  stageId: string;
  /**
   * If set, validate the request and preview the rollout, but
   * do not actually create it.
   */
  validateOnly: boolean;
}

export interface PreviewRolloutRequest {
  /**
   * The name of the project.
   * Format: projects/{project}
   */
  project: string;
  /** The plan used to preview rollout. */
  plan: Plan | undefined;
}

export interface ListTaskRunsRequest {
  /**
   * The parent, which owns this collection of plans.
   * Format: projects/{project}/rollouts/{rollout}/stages/{stage}/tasks/{task}
   * Use "projects/{project}/rollouts/{rollout}/stages/-/tasks/-" to list all taskRuns from a rollout.
   */
  parent: string;
  /**
   * Not used.
   * The maximum number of taskRuns to return. The service may return fewer than
   * this value.
   * If unspecified, at most 10 taskRuns will be returned.
   * The maximum value is 1000; values above 1000 will be coerced to 1000.
   */
  pageSize: number;
  /**
   * Not used.
   * A page token, received from a previous `ListTaskRuns` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListTaskRuns` must match
   * the call that provided the page token.
   */
  pageToken: string;
}

export interface ListTaskRunsResponse {
  /** The taskRuns from the specified request. */
  taskRuns: TaskRun[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
}

export interface GetTaskRunRequest {
  /** Format: projects/{project}/rollouts/{rollout}/stages/{stage}/tasks/{task}/taskRuns/{taskRun} */
  name: string;
}

export interface GetTaskRunLogRequest {
  /**
   * Format: projects/{project}/rollouts/{rollout}/stages/{stage}/tasks/{task}/taskRuns/{taskRun}
   * TODO(d): check the resource_reference.
   */
  parent: string;
}

export interface Rollout {
  /**
   * The resource name of the rollout.
   * Format: projects/{project}/rollouts/{rollout}
   */
  name: string;
  /**
   * The plan that this rollout is based on.
   * Format: projects/{project}/plans/{plan}
   */
  plan: string;
  title: string;
  /** stages and thus tasks of the rollout. */
  stages: Stage[];
  /** Format: users/hello@world.com */
  creator: string;
  createTime: Timestamp | undefined;
  updateTime:
    | Timestamp
    | undefined;
  /**
   * The issue associated with the rollout. Could be empty.
   * Format: projects/{project}/issues/{issue}
   */
  issue: string;
}

export interface Stage {
  /** Format: projects/{project}/rollouts/{rollout}/stages/{stage} */
  name: string;
  /**
   * The id comes from the deployment config.
   * Format: UUID
   * Empty for legacy stages.
   */
  id: string;
  title: string;
  tasks: Task[];
}

export interface Task {
  /** Format: projects/{project}/rollouts/{rollout}/stages/{stage}/tasks/{task} */
  name: string;
  title: string;
  /**
   * A UUID4 string that uniquely identifies the Spec.
   * Could be empty if the rollout of the task does not have an associating plan.
   */
  specId: string;
  /** Status is the status of the task. */
  status: Task_Status;
  skippedReason: string;
  type: Task_Type;
  /** Format: projects/{project}/rollouts/{rollout}/stages/{stage}/tasks/{task} */
  dependsOnTasks: string[];
  /**
   * Format: instances/{instance} if the task is DatabaseCreate.
   * Format: instances/{instance}/databases/{database}
   */
  target: string;
  databaseCreate?: Task_DatabaseCreate | undefined;
  databaseSchemaBaseline?: Task_DatabaseSchemaBaseline | undefined;
  databaseSchemaUpdate?: Task_DatabaseSchemaUpdate | undefined;
  databaseDataUpdate?: Task_DatabaseDataUpdate | undefined;
  databaseDataExport?: Task_DatabaseDataExport | undefined;
}

export enum Task_Status {
  STATUS_UNSPECIFIED = "STATUS_UNSPECIFIED",
  NOT_STARTED = "NOT_STARTED",
  PENDING = "PENDING",
  RUNNING = "RUNNING",
  DONE = "DONE",
  FAILED = "FAILED",
  CANCELED = "CANCELED",
  SKIPPED = "SKIPPED",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function task_StatusFromJSON(object: any): Task_Status {
  switch (object) {
    case 0:
    case "STATUS_UNSPECIFIED":
      return Task_Status.STATUS_UNSPECIFIED;
    case 1:
    case "NOT_STARTED":
      return Task_Status.NOT_STARTED;
    case 2:
    case "PENDING":
      return Task_Status.PENDING;
    case 3:
    case "RUNNING":
      return Task_Status.RUNNING;
    case 4:
    case "DONE":
      return Task_Status.DONE;
    case 5:
    case "FAILED":
      return Task_Status.FAILED;
    case 6:
    case "CANCELED":
      return Task_Status.CANCELED;
    case 7:
    case "SKIPPED":
      return Task_Status.SKIPPED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Task_Status.UNRECOGNIZED;
  }
}

export function task_StatusToJSON(object: Task_Status): string {
  switch (object) {
    case Task_Status.STATUS_UNSPECIFIED:
      return "STATUS_UNSPECIFIED";
    case Task_Status.NOT_STARTED:
      return "NOT_STARTED";
    case Task_Status.PENDING:
      return "PENDING";
    case Task_Status.RUNNING:
      return "RUNNING";
    case Task_Status.DONE:
      return "DONE";
    case Task_Status.FAILED:
      return "FAILED";
    case Task_Status.CANCELED:
      return "CANCELED";
    case Task_Status.SKIPPED:
      return "SKIPPED";
    case Task_Status.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function task_StatusToNumber(object: Task_Status): number {
  switch (object) {
    case Task_Status.STATUS_UNSPECIFIED:
      return 0;
    case Task_Status.NOT_STARTED:
      return 1;
    case Task_Status.PENDING:
      return 2;
    case Task_Status.RUNNING:
      return 3;
    case Task_Status.DONE:
      return 4;
    case Task_Status.FAILED:
      return 5;
    case Task_Status.CANCELED:
      return 6;
    case Task_Status.SKIPPED:
      return 7;
    case Task_Status.UNRECOGNIZED:
    default:
      return -1;
  }
}

export enum Task_Type {
  TYPE_UNSPECIFIED = "TYPE_UNSPECIFIED",
  GENERAL = "GENERAL",
  /** DATABASE_CREATE - use payload DatabaseCreate */
  DATABASE_CREATE = "DATABASE_CREATE",
  /** DATABASE_SCHEMA_BASELINE - use payload DatabaseSchemaBaseline */
  DATABASE_SCHEMA_BASELINE = "DATABASE_SCHEMA_BASELINE",
  /** DATABASE_SCHEMA_UPDATE - use payload DatabaseSchemaUpdate */
  DATABASE_SCHEMA_UPDATE = "DATABASE_SCHEMA_UPDATE",
  /** DATABASE_SCHEMA_UPDATE_SDL - use payload DatabaseSchemaUpdate */
  DATABASE_SCHEMA_UPDATE_SDL = "DATABASE_SCHEMA_UPDATE_SDL",
  /** DATABASE_SCHEMA_UPDATE_GHOST_SYNC - use payload DatabaseSchemaUpdate */
  DATABASE_SCHEMA_UPDATE_GHOST_SYNC = "DATABASE_SCHEMA_UPDATE_GHOST_SYNC",
  /** DATABASE_SCHEMA_UPDATE_GHOST_CUTOVER - use payload nil */
  DATABASE_SCHEMA_UPDATE_GHOST_CUTOVER = "DATABASE_SCHEMA_UPDATE_GHOST_CUTOVER",
  /** DATABASE_DATA_UPDATE - use payload DatabaseDataUpdate */
  DATABASE_DATA_UPDATE = "DATABASE_DATA_UPDATE",
  /** DATABASE_DATA_EXPORT - use payload DatabaseDataExport */
  DATABASE_DATA_EXPORT = "DATABASE_DATA_EXPORT",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function task_TypeFromJSON(object: any): Task_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return Task_Type.TYPE_UNSPECIFIED;
    case 1:
    case "GENERAL":
      return Task_Type.GENERAL;
    case 2:
    case "DATABASE_CREATE":
      return Task_Type.DATABASE_CREATE;
    case 3:
    case "DATABASE_SCHEMA_BASELINE":
      return Task_Type.DATABASE_SCHEMA_BASELINE;
    case 4:
    case "DATABASE_SCHEMA_UPDATE":
      return Task_Type.DATABASE_SCHEMA_UPDATE;
    case 5:
    case "DATABASE_SCHEMA_UPDATE_SDL":
      return Task_Type.DATABASE_SCHEMA_UPDATE_SDL;
    case 6:
    case "DATABASE_SCHEMA_UPDATE_GHOST_SYNC":
      return Task_Type.DATABASE_SCHEMA_UPDATE_GHOST_SYNC;
    case 7:
    case "DATABASE_SCHEMA_UPDATE_GHOST_CUTOVER":
      return Task_Type.DATABASE_SCHEMA_UPDATE_GHOST_CUTOVER;
    case 8:
    case "DATABASE_DATA_UPDATE":
      return Task_Type.DATABASE_DATA_UPDATE;
    case 12:
    case "DATABASE_DATA_EXPORT":
      return Task_Type.DATABASE_DATA_EXPORT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Task_Type.UNRECOGNIZED;
  }
}

export function task_TypeToJSON(object: Task_Type): string {
  switch (object) {
    case Task_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case Task_Type.GENERAL:
      return "GENERAL";
    case Task_Type.DATABASE_CREATE:
      return "DATABASE_CREATE";
    case Task_Type.DATABASE_SCHEMA_BASELINE:
      return "DATABASE_SCHEMA_BASELINE";
    case Task_Type.DATABASE_SCHEMA_UPDATE:
      return "DATABASE_SCHEMA_UPDATE";
    case Task_Type.DATABASE_SCHEMA_UPDATE_SDL:
      return "DATABASE_SCHEMA_UPDATE_SDL";
    case Task_Type.DATABASE_SCHEMA_UPDATE_GHOST_SYNC:
      return "DATABASE_SCHEMA_UPDATE_GHOST_SYNC";
    case Task_Type.DATABASE_SCHEMA_UPDATE_GHOST_CUTOVER:
      return "DATABASE_SCHEMA_UPDATE_GHOST_CUTOVER";
    case Task_Type.DATABASE_DATA_UPDATE:
      return "DATABASE_DATA_UPDATE";
    case Task_Type.DATABASE_DATA_EXPORT:
      return "DATABASE_DATA_EXPORT";
    case Task_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function task_TypeToNumber(object: Task_Type): number {
  switch (object) {
    case Task_Type.TYPE_UNSPECIFIED:
      return 0;
    case Task_Type.GENERAL:
      return 1;
    case Task_Type.DATABASE_CREATE:
      return 2;
    case Task_Type.DATABASE_SCHEMA_BASELINE:
      return 3;
    case Task_Type.DATABASE_SCHEMA_UPDATE:
      return 4;
    case Task_Type.DATABASE_SCHEMA_UPDATE_SDL:
      return 5;
    case Task_Type.DATABASE_SCHEMA_UPDATE_GHOST_SYNC:
      return 6;
    case Task_Type.DATABASE_SCHEMA_UPDATE_GHOST_CUTOVER:
      return 7;
    case Task_Type.DATABASE_DATA_UPDATE:
      return 8;
    case Task_Type.DATABASE_DATA_EXPORT:
      return 12;
    case Task_Type.UNRECOGNIZED:
    default:
      return -1;
  }
}

export interface Task_DatabaseCreate {
  /**
   * The project owning the database.
   * Format: projects/{project}
   */
  project: string;
  /** database name */
  database: string;
  /** table name */
  table: string;
  /** Format: projects/{project}/sheets/{sheet} */
  sheet: string;
  characterSet: string;
  collation: string;
  environment: string;
  labels: { [key: string]: string };
}

export interface Task_DatabaseCreate_LabelsEntry {
  key: string;
  value: string;
}

export interface Task_DatabaseSchemaBaseline {
  schemaVersion: string;
}

export interface Task_DatabaseSchemaUpdate {
  /** Format: projects/{project}/sheets/{sheet} */
  sheet: string;
  schemaVersion: string;
}

export interface Task_DatabaseDataUpdate {
  /** Format: projects/{project}/sheets/{sheet} */
  sheet: string;
  schemaVersion: string;
}

export interface Task_DatabaseDataExport {
  /**
   * The resource name of the target.
   * Format: instances/{instance-id}/databases/{database-name}
   */
  target: string;
  /**
   * The resource name of the sheet.
   * Format: projects/{project}/sheets/{sheet}
   */
  sheet: string;
  /** The format of the exported file. */
  format: ExportFormat;
  /**
   * The zip password provide by users.
   * Leave it empty if no needs to encrypt the zip file.
   */
  password?: string | undefined;
}

export interface TaskRun {
  /** Format: projects/{project}/rollouts/{rollout}/stages/{stage}/tasks/{task}/taskRuns/{taskRun} */
  name: string;
  /** Format: user/hello@world.com */
  creator: string;
  /** Format: user/hello@world.com */
  updater: string;
  createTime: Timestamp | undefined;
  updateTime: Timestamp | undefined;
  title: string;
  status: TaskRun_Status;
  /** Below are the results of a task run. */
  detail: string;
  /**
   * The resource name of the change history
   * Format: instances/{instance}/databases/{database}/changeHistories/{changeHistory}
   */
  changeHistory: string;
  schemaVersion: string;
  startTime: Timestamp | undefined;
  exportArchiveStatus: TaskRun_ExportArchiveStatus;
  /** The prior backup detail that will be used to rollback the task run. */
  priorBackupDetail: TaskRun_PriorBackupDetail | undefined;
  schedulerInfo:
    | TaskRun_SchedulerInfo
    | undefined;
  /** Format: projects/{project}/sheets/{sheet} */
  sheet: string;
}

export enum TaskRun_Status {
  STATUS_UNSPECIFIED = "STATUS_UNSPECIFIED",
  PENDING = "PENDING",
  RUNNING = "RUNNING",
  DONE = "DONE",
  FAILED = "FAILED",
  CANCELED = "CANCELED",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function taskRun_StatusFromJSON(object: any): TaskRun_Status {
  switch (object) {
    case 0:
    case "STATUS_UNSPECIFIED":
      return TaskRun_Status.STATUS_UNSPECIFIED;
    case 1:
    case "PENDING":
      return TaskRun_Status.PENDING;
    case 2:
    case "RUNNING":
      return TaskRun_Status.RUNNING;
    case 3:
    case "DONE":
      return TaskRun_Status.DONE;
    case 4:
    case "FAILED":
      return TaskRun_Status.FAILED;
    case 5:
    case "CANCELED":
      return TaskRun_Status.CANCELED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TaskRun_Status.UNRECOGNIZED;
  }
}

export function taskRun_StatusToJSON(object: TaskRun_Status): string {
  switch (object) {
    case TaskRun_Status.STATUS_UNSPECIFIED:
      return "STATUS_UNSPECIFIED";
    case TaskRun_Status.PENDING:
      return "PENDING";
    case TaskRun_Status.RUNNING:
      return "RUNNING";
    case TaskRun_Status.DONE:
      return "DONE";
    case TaskRun_Status.FAILED:
      return "FAILED";
    case TaskRun_Status.CANCELED:
      return "CANCELED";
    case TaskRun_Status.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function taskRun_StatusToNumber(object: TaskRun_Status): number {
  switch (object) {
    case TaskRun_Status.STATUS_UNSPECIFIED:
      return 0;
    case TaskRun_Status.PENDING:
      return 1;
    case TaskRun_Status.RUNNING:
      return 2;
    case TaskRun_Status.DONE:
      return 3;
    case TaskRun_Status.FAILED:
      return 4;
    case TaskRun_Status.CANCELED:
      return 5;
    case TaskRun_Status.UNRECOGNIZED:
    default:
      return -1;
  }
}

export enum TaskRun_ExportArchiveStatus {
  EXPORT_ARCHIVE_STATUS_UNSPECIFIED = "EXPORT_ARCHIVE_STATUS_UNSPECIFIED",
  READY = "READY",
  EXPORTED = "EXPORTED",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function taskRun_ExportArchiveStatusFromJSON(object: any): TaskRun_ExportArchiveStatus {
  switch (object) {
    case 0:
    case "EXPORT_ARCHIVE_STATUS_UNSPECIFIED":
      return TaskRun_ExportArchiveStatus.EXPORT_ARCHIVE_STATUS_UNSPECIFIED;
    case 1:
    case "READY":
      return TaskRun_ExportArchiveStatus.READY;
    case 2:
    case "EXPORTED":
      return TaskRun_ExportArchiveStatus.EXPORTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TaskRun_ExportArchiveStatus.UNRECOGNIZED;
  }
}

export function taskRun_ExportArchiveStatusToJSON(object: TaskRun_ExportArchiveStatus): string {
  switch (object) {
    case TaskRun_ExportArchiveStatus.EXPORT_ARCHIVE_STATUS_UNSPECIFIED:
      return "EXPORT_ARCHIVE_STATUS_UNSPECIFIED";
    case TaskRun_ExportArchiveStatus.READY:
      return "READY";
    case TaskRun_ExportArchiveStatus.EXPORTED:
      return "EXPORTED";
    case TaskRun_ExportArchiveStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function taskRun_ExportArchiveStatusToNumber(object: TaskRun_ExportArchiveStatus): number {
  switch (object) {
    case TaskRun_ExportArchiveStatus.EXPORT_ARCHIVE_STATUS_UNSPECIFIED:
      return 0;
    case TaskRun_ExportArchiveStatus.READY:
      return 1;
    case TaskRun_ExportArchiveStatus.EXPORTED:
      return 2;
    case TaskRun_ExportArchiveStatus.UNRECOGNIZED:
    default:
      return -1;
  }
}

export interface TaskRun_PriorBackupDetail {
  items: TaskRun_PriorBackupDetail_Item[];
}

export interface TaskRun_PriorBackupDetail_Item {
  /** The original table information. */
  sourceTable:
    | TaskRun_PriorBackupDetail_Item_Table
    | undefined;
  /** The target backup table information. */
  targetTable: TaskRun_PriorBackupDetail_Item_Table | undefined;
  startPosition: Position | undefined;
  endPosition: Position | undefined;
}

export interface TaskRun_PriorBackupDetail_Item_Table {
  /**
   * The database information.
   * Format: instances/{instance}/databases/{database}
   */
  database: string;
  schema: string;
  table: string;
}

export interface TaskRun_SchedulerInfo {
  reportTime: Timestamp | undefined;
  waitingCause: TaskRun_SchedulerInfo_WaitingCause | undefined;
}

export interface TaskRun_SchedulerInfo_WaitingCause {
  connectionLimit?: boolean | undefined;
  task?: TaskRun_SchedulerInfo_WaitingCause_Task | undefined;
}

export interface TaskRun_SchedulerInfo_WaitingCause_Task {
  /** Format: projects/{project}/rollouts/{rollout}/stages/{stage}/tasks/{task} */
  task: string;
  /** Format: projects/{project}/issues/{issue} */
  issue: string;
}

export interface TaskRunLog {
  /** Format: projects/{project}/rollouts/{rollout}/stages/{stage}/tasks/{task}/taskRuns/{taskRun}/log */
  name: string;
  entries: TaskRunLogEntry[];
}

export interface TaskRunLogEntry {
  type: TaskRunLogEntry_Type;
  logTime: Timestamp | undefined;
  deployId: string;
  schemaDump: TaskRunLogEntry_SchemaDump | undefined;
  commandExecute: TaskRunLogEntry_CommandExecute | undefined;
  databaseSync: TaskRunLogEntry_DatabaseSync | undefined;
  taskRunStatusUpdate: TaskRunLogEntry_TaskRunStatusUpdate | undefined;
  transactionControl: TaskRunLogEntry_TransactionControl | undefined;
  priorBackup: TaskRunLogEntry_PriorBackup | undefined;
}

export enum TaskRunLogEntry_Type {
  TYPE_UNSPECIFIED = "TYPE_UNSPECIFIED",
  SCHEMA_DUMP = "SCHEMA_DUMP",
  COMMAND_EXECUTE = "COMMAND_EXECUTE",
  DATABASE_SYNC = "DATABASE_SYNC",
  TASK_RUN_STATUS_UPDATE = "TASK_RUN_STATUS_UPDATE",
  TRANSACTION_CONTROL = "TRANSACTION_CONTROL",
  PRIOR_BACKUP = "PRIOR_BACKUP",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function taskRunLogEntry_TypeFromJSON(object: any): TaskRunLogEntry_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return TaskRunLogEntry_Type.TYPE_UNSPECIFIED;
    case 1:
    case "SCHEMA_DUMP":
      return TaskRunLogEntry_Type.SCHEMA_DUMP;
    case 2:
    case "COMMAND_EXECUTE":
      return TaskRunLogEntry_Type.COMMAND_EXECUTE;
    case 3:
    case "DATABASE_SYNC":
      return TaskRunLogEntry_Type.DATABASE_SYNC;
    case 4:
    case "TASK_RUN_STATUS_UPDATE":
      return TaskRunLogEntry_Type.TASK_RUN_STATUS_UPDATE;
    case 5:
    case "TRANSACTION_CONTROL":
      return TaskRunLogEntry_Type.TRANSACTION_CONTROL;
    case 6:
    case "PRIOR_BACKUP":
      return TaskRunLogEntry_Type.PRIOR_BACKUP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TaskRunLogEntry_Type.UNRECOGNIZED;
  }
}

export function taskRunLogEntry_TypeToJSON(object: TaskRunLogEntry_Type): string {
  switch (object) {
    case TaskRunLogEntry_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case TaskRunLogEntry_Type.SCHEMA_DUMP:
      return "SCHEMA_DUMP";
    case TaskRunLogEntry_Type.COMMAND_EXECUTE:
      return "COMMAND_EXECUTE";
    case TaskRunLogEntry_Type.DATABASE_SYNC:
      return "DATABASE_SYNC";
    case TaskRunLogEntry_Type.TASK_RUN_STATUS_UPDATE:
      return "TASK_RUN_STATUS_UPDATE";
    case TaskRunLogEntry_Type.TRANSACTION_CONTROL:
      return "TRANSACTION_CONTROL";
    case TaskRunLogEntry_Type.PRIOR_BACKUP:
      return "PRIOR_BACKUP";
    case TaskRunLogEntry_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function taskRunLogEntry_TypeToNumber(object: TaskRunLogEntry_Type): number {
  switch (object) {
    case TaskRunLogEntry_Type.TYPE_UNSPECIFIED:
      return 0;
    case TaskRunLogEntry_Type.SCHEMA_DUMP:
      return 1;
    case TaskRunLogEntry_Type.COMMAND_EXECUTE:
      return 2;
    case TaskRunLogEntry_Type.DATABASE_SYNC:
      return 3;
    case TaskRunLogEntry_Type.TASK_RUN_STATUS_UPDATE:
      return 4;
    case TaskRunLogEntry_Type.TRANSACTION_CONTROL:
      return 5;
    case TaskRunLogEntry_Type.PRIOR_BACKUP:
      return 6;
    case TaskRunLogEntry_Type.UNRECOGNIZED:
    default:
      return -1;
  }
}

export interface TaskRunLogEntry_SchemaDump {
  startTime: Timestamp | undefined;
  endTime: Timestamp | undefined;
  error: string;
}

export interface TaskRunLogEntry_CommandExecute {
  logTime:
    | Timestamp
    | undefined;
  /** The indexes of the executed commands. */
  commandIndexes: number[];
  response: TaskRunLogEntry_CommandExecute_CommandResponse | undefined;
}

export interface TaskRunLogEntry_CommandExecute_CommandResponse {
  logTime: Timestamp | undefined;
  error: string;
  affectedRows: number;
  /**
   * `all_affected_rows` is the affected rows of each command.
   * `all_affected_rows` may be unavailable if the database driver doesn't support it. Caller should fallback to `affected_rows` in that case.
   */
  allAffectedRows: number[];
}

export interface TaskRunLogEntry_DatabaseSync {
  startTime: Timestamp | undefined;
  endTime: Timestamp | undefined;
  error: string;
}

export interface TaskRunLogEntry_TaskRunStatusUpdate {
  status: TaskRunLogEntry_TaskRunStatusUpdate_Status;
}

export enum TaskRunLogEntry_TaskRunStatusUpdate_Status {
  STATUS_UNSPECIFIED = "STATUS_UNSPECIFIED",
  /** RUNNING_WAITING - the task run is ready to be executed by the scheduler */
  RUNNING_WAITING = "RUNNING_WAITING",
  /** RUNNING_RUNNING - the task run is being executed by the scheduler */
  RUNNING_RUNNING = "RUNNING_RUNNING",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function taskRunLogEntry_TaskRunStatusUpdate_StatusFromJSON(
  object: any,
): TaskRunLogEntry_TaskRunStatusUpdate_Status {
  switch (object) {
    case 0:
    case "STATUS_UNSPECIFIED":
      return TaskRunLogEntry_TaskRunStatusUpdate_Status.STATUS_UNSPECIFIED;
    case 1:
    case "RUNNING_WAITING":
      return TaskRunLogEntry_TaskRunStatusUpdate_Status.RUNNING_WAITING;
    case 2:
    case "RUNNING_RUNNING":
      return TaskRunLogEntry_TaskRunStatusUpdate_Status.RUNNING_RUNNING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TaskRunLogEntry_TaskRunStatusUpdate_Status.UNRECOGNIZED;
  }
}

export function taskRunLogEntry_TaskRunStatusUpdate_StatusToJSON(
  object: TaskRunLogEntry_TaskRunStatusUpdate_Status,
): string {
  switch (object) {
    case TaskRunLogEntry_TaskRunStatusUpdate_Status.STATUS_UNSPECIFIED:
      return "STATUS_UNSPECIFIED";
    case TaskRunLogEntry_TaskRunStatusUpdate_Status.RUNNING_WAITING:
      return "RUNNING_WAITING";
    case TaskRunLogEntry_TaskRunStatusUpdate_Status.RUNNING_RUNNING:
      return "RUNNING_RUNNING";
    case TaskRunLogEntry_TaskRunStatusUpdate_Status.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function taskRunLogEntry_TaskRunStatusUpdate_StatusToNumber(
  object: TaskRunLogEntry_TaskRunStatusUpdate_Status,
): number {
  switch (object) {
    case TaskRunLogEntry_TaskRunStatusUpdate_Status.STATUS_UNSPECIFIED:
      return 0;
    case TaskRunLogEntry_TaskRunStatusUpdate_Status.RUNNING_WAITING:
      return 1;
    case TaskRunLogEntry_TaskRunStatusUpdate_Status.RUNNING_RUNNING:
      return 2;
    case TaskRunLogEntry_TaskRunStatusUpdate_Status.UNRECOGNIZED:
    default:
      return -1;
  }
}

export interface TaskRunLogEntry_TransactionControl {
  type: TaskRunLogEntry_TransactionControl_Type;
  error: string;
}

export enum TaskRunLogEntry_TransactionControl_Type {
  TYPE_UNSPECIFIED = "TYPE_UNSPECIFIED",
  BEGIN = "BEGIN",
  COMMIT = "COMMIT",
  ROLLBACK = "ROLLBACK",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function taskRunLogEntry_TransactionControl_TypeFromJSON(object: any): TaskRunLogEntry_TransactionControl_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return TaskRunLogEntry_TransactionControl_Type.TYPE_UNSPECIFIED;
    case 1:
    case "BEGIN":
      return TaskRunLogEntry_TransactionControl_Type.BEGIN;
    case 2:
    case "COMMIT":
      return TaskRunLogEntry_TransactionControl_Type.COMMIT;
    case 3:
    case "ROLLBACK":
      return TaskRunLogEntry_TransactionControl_Type.ROLLBACK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TaskRunLogEntry_TransactionControl_Type.UNRECOGNIZED;
  }
}

export function taskRunLogEntry_TransactionControl_TypeToJSON(object: TaskRunLogEntry_TransactionControl_Type): string {
  switch (object) {
    case TaskRunLogEntry_TransactionControl_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case TaskRunLogEntry_TransactionControl_Type.BEGIN:
      return "BEGIN";
    case TaskRunLogEntry_TransactionControl_Type.COMMIT:
      return "COMMIT";
    case TaskRunLogEntry_TransactionControl_Type.ROLLBACK:
      return "ROLLBACK";
    case TaskRunLogEntry_TransactionControl_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function taskRunLogEntry_TransactionControl_TypeToNumber(
  object: TaskRunLogEntry_TransactionControl_Type,
): number {
  switch (object) {
    case TaskRunLogEntry_TransactionControl_Type.TYPE_UNSPECIFIED:
      return 0;
    case TaskRunLogEntry_TransactionControl_Type.BEGIN:
      return 1;
    case TaskRunLogEntry_TransactionControl_Type.COMMIT:
      return 2;
    case TaskRunLogEntry_TransactionControl_Type.ROLLBACK:
      return 3;
    case TaskRunLogEntry_TransactionControl_Type.UNRECOGNIZED:
    default:
      return -1;
  }
}

export interface TaskRunLogEntry_PriorBackup {
  startTime: Timestamp | undefined;
  endTime: Timestamp | undefined;
  priorBackupDetail: TaskRun_PriorBackupDetail | undefined;
  error: string;
}

export interface GetTaskRunSessionRequest {
  /** Format: projects/{project}/rollouts/{rollout}/stages/{stage}/tasks/{task}/taskRuns/{taskRun} */
  parent: string;
}

export interface TaskRunSession {
  /** Format: projects/{project}/rollouts/{rollout}/stages/{stage}/tasks/{task}/taskRuns/{taskRun}/session */
  name: string;
  postgres?: TaskRunSession_Postgres | undefined;
}

export interface TaskRunSession_Postgres {
  /** `session` is the session of the task run executing commands. */
  session:
    | TaskRunSession_Postgres_Session
    | undefined;
  /** `blocking_sessions` block `session`. */
  blockingSessions: TaskRunSession_Postgres_Session[];
  /** `blocked_sessions` are blocked by `session`. */
  blockedSessions: TaskRunSession_Postgres_Session[];
}

/** Read from `pg_stat_activity` */
export interface TaskRunSession_Postgres_Session {
  pid: string;
  blockedByPids: string[];
  query: string;
  state?: string | undefined;
  waitEventType?: string | undefined;
  waitEvent?: string | undefined;
  datname?: string | undefined;
  usename?: string | undefined;
  applicationName: string;
  clientAddr?: string | undefined;
  clientPort?: string | undefined;
  backendStart: Timestamp | undefined;
  xactStart?: Timestamp | undefined;
  queryStart?: Timestamp | undefined;
}

export interface PreviewTaskRunRollbackRequest {
  /** Format: projects/{project}/rollouts/{rollout}/stages/{stage}/tasks/{task}/taskRuns/{taskRun} */
  name: string;
}

export interface PreviewTaskRunRollbackResponse {
  statement: string;
}

function createBaseBatchRunTasksRequest(): BatchRunTasksRequest {
  return { parent: "", tasks: [], reason: "" };
}

export const BatchRunTasksRequest: MessageFns<BatchRunTasksRequest> = {
  encode(message: BatchRunTasksRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    for (const v of message.tasks) {
      writer.uint32(18).string(v!);
    }
    if (message.reason !== "") {
      writer.uint32(26).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchRunTasksRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchRunTasksRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tasks.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchRunTasksRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      tasks: globalThis.Array.isArray(object?.tasks) ? object.tasks.map((e: any) => globalThis.String(e)) : [],
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: BatchRunTasksRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.tasks?.length) {
      obj.tasks = message.tasks;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create(base?: DeepPartial<BatchRunTasksRequest>): BatchRunTasksRequest {
    return BatchRunTasksRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchRunTasksRequest>): BatchRunTasksRequest {
    const message = createBaseBatchRunTasksRequest();
    message.parent = object.parent ?? "";
    message.tasks = object.tasks?.map((e) => e) || [];
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseBatchRunTasksResponse(): BatchRunTasksResponse {
  return {};
}

export const BatchRunTasksResponse: MessageFns<BatchRunTasksResponse> = {
  encode(_: BatchRunTasksResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchRunTasksResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchRunTasksResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): BatchRunTasksResponse {
    return {};
  },

  toJSON(_: BatchRunTasksResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<BatchRunTasksResponse>): BatchRunTasksResponse {
    return BatchRunTasksResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<BatchRunTasksResponse>): BatchRunTasksResponse {
    const message = createBaseBatchRunTasksResponse();
    return message;
  },
};

function createBaseBatchSkipTasksRequest(): BatchSkipTasksRequest {
  return { parent: "", tasks: [], reason: "" };
}

export const BatchSkipTasksRequest: MessageFns<BatchSkipTasksRequest> = {
  encode(message: BatchSkipTasksRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    for (const v of message.tasks) {
      writer.uint32(18).string(v!);
    }
    if (message.reason !== "") {
      writer.uint32(26).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchSkipTasksRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchSkipTasksRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tasks.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchSkipTasksRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      tasks: globalThis.Array.isArray(object?.tasks) ? object.tasks.map((e: any) => globalThis.String(e)) : [],
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: BatchSkipTasksRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.tasks?.length) {
      obj.tasks = message.tasks;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create(base?: DeepPartial<BatchSkipTasksRequest>): BatchSkipTasksRequest {
    return BatchSkipTasksRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchSkipTasksRequest>): BatchSkipTasksRequest {
    const message = createBaseBatchSkipTasksRequest();
    message.parent = object.parent ?? "";
    message.tasks = object.tasks?.map((e) => e) || [];
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseBatchSkipTasksResponse(): BatchSkipTasksResponse {
  return {};
}

export const BatchSkipTasksResponse: MessageFns<BatchSkipTasksResponse> = {
  encode(_: BatchSkipTasksResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchSkipTasksResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchSkipTasksResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): BatchSkipTasksResponse {
    return {};
  },

  toJSON(_: BatchSkipTasksResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<BatchSkipTasksResponse>): BatchSkipTasksResponse {
    return BatchSkipTasksResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<BatchSkipTasksResponse>): BatchSkipTasksResponse {
    const message = createBaseBatchSkipTasksResponse();
    return message;
  },
};

function createBaseBatchCancelTaskRunsRequest(): BatchCancelTaskRunsRequest {
  return { parent: "", taskRuns: [], reason: "" };
}

export const BatchCancelTaskRunsRequest: MessageFns<BatchCancelTaskRunsRequest> = {
  encode(message: BatchCancelTaskRunsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    for (const v of message.taskRuns) {
      writer.uint32(18).string(v!);
    }
    if (message.reason !== "") {
      writer.uint32(26).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchCancelTaskRunsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchCancelTaskRunsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.taskRuns.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchCancelTaskRunsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      taskRuns: globalThis.Array.isArray(object?.taskRuns) ? object.taskRuns.map((e: any) => globalThis.String(e)) : [],
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: BatchCancelTaskRunsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.taskRuns?.length) {
      obj.taskRuns = message.taskRuns;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create(base?: DeepPartial<BatchCancelTaskRunsRequest>): BatchCancelTaskRunsRequest {
    return BatchCancelTaskRunsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchCancelTaskRunsRequest>): BatchCancelTaskRunsRequest {
    const message = createBaseBatchCancelTaskRunsRequest();
    message.parent = object.parent ?? "";
    message.taskRuns = object.taskRuns?.map((e) => e) || [];
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseBatchCancelTaskRunsResponse(): BatchCancelTaskRunsResponse {
  return {};
}

export const BatchCancelTaskRunsResponse: MessageFns<BatchCancelTaskRunsResponse> = {
  encode(_: BatchCancelTaskRunsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchCancelTaskRunsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchCancelTaskRunsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): BatchCancelTaskRunsResponse {
    return {};
  },

  toJSON(_: BatchCancelTaskRunsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<BatchCancelTaskRunsResponse>): BatchCancelTaskRunsResponse {
    return BatchCancelTaskRunsResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<BatchCancelTaskRunsResponse>): BatchCancelTaskRunsResponse {
    const message = createBaseBatchCancelTaskRunsResponse();
    return message;
  },
};

function createBaseGetRolloutRequest(): GetRolloutRequest {
  return { name: "" };
}

export const GetRolloutRequest: MessageFns<GetRolloutRequest> = {
  encode(message: GetRolloutRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRolloutRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRolloutRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRolloutRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetRolloutRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetRolloutRequest>): GetRolloutRequest {
    return GetRolloutRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetRolloutRequest>): GetRolloutRequest {
    const message = createBaseGetRolloutRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListRolloutsRequest(): ListRolloutsRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListRolloutsRequest: MessageFns<ListRolloutsRequest> = {
  encode(message: ListRolloutsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRolloutsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRolloutsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRolloutsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListRolloutsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListRolloutsRequest>): ListRolloutsRequest {
    return ListRolloutsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListRolloutsRequest>): ListRolloutsRequest {
    const message = createBaseListRolloutsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListRolloutsResponse(): ListRolloutsResponse {
  return { rollouts: [], nextPageToken: "" };
}

export const ListRolloutsResponse: MessageFns<ListRolloutsResponse> = {
  encode(message: ListRolloutsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.rollouts) {
      Rollout.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRolloutsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRolloutsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rollouts.push(Rollout.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRolloutsResponse {
    return {
      rollouts: globalThis.Array.isArray(object?.rollouts) ? object.rollouts.map((e: any) => Rollout.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListRolloutsResponse): unknown {
    const obj: any = {};
    if (message.rollouts?.length) {
      obj.rollouts = message.rollouts.map((e) => Rollout.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListRolloutsResponse>): ListRolloutsResponse {
    return ListRolloutsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListRolloutsResponse>): ListRolloutsResponse {
    const message = createBaseListRolloutsResponse();
    message.rollouts = object.rollouts?.map((e) => Rollout.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseCreateRolloutRequest(): CreateRolloutRequest {
  return { parent: "", rollout: undefined, stageId: "", validateOnly: false };
}

export const CreateRolloutRequest: MessageFns<CreateRolloutRequest> = {
  encode(message: CreateRolloutRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.rollout !== undefined) {
      Rollout.encode(message.rollout, writer.uint32(18).fork()).join();
    }
    if (message.stageId !== "") {
      writer.uint32(26).string(message.stageId);
    }
    if (message.validateOnly !== false) {
      writer.uint32(32).bool(message.validateOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateRolloutRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateRolloutRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rollout = Rollout.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.stageId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateRolloutRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      rollout: isSet(object.rollout) ? Rollout.fromJSON(object.rollout) : undefined,
      stageId: isSet(object.stageId) ? globalThis.String(object.stageId) : "",
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
    };
  },

  toJSON(message: CreateRolloutRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.rollout !== undefined) {
      obj.rollout = Rollout.toJSON(message.rollout);
    }
    if (message.stageId !== "") {
      obj.stageId = message.stageId;
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateRolloutRequest>): CreateRolloutRequest {
    return CreateRolloutRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateRolloutRequest>): CreateRolloutRequest {
    const message = createBaseCreateRolloutRequest();
    message.parent = object.parent ?? "";
    message.rollout = (object.rollout !== undefined && object.rollout !== null)
      ? Rollout.fromPartial(object.rollout)
      : undefined;
    message.stageId = object.stageId ?? "";
    message.validateOnly = object.validateOnly ?? false;
    return message;
  },
};

function createBasePreviewRolloutRequest(): PreviewRolloutRequest {
  return { project: "", plan: undefined };
}

export const PreviewRolloutRequest: MessageFns<PreviewRolloutRequest> = {
  encode(message: PreviewRolloutRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.project !== "") {
      writer.uint32(10).string(message.project);
    }
    if (message.plan !== undefined) {
      Plan.encode(message.plan, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PreviewRolloutRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePreviewRolloutRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.project = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.plan = Plan.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PreviewRolloutRequest {
    return {
      project: isSet(object.project) ? globalThis.String(object.project) : "",
      plan: isSet(object.plan) ? Plan.fromJSON(object.plan) : undefined,
    };
  },

  toJSON(message: PreviewRolloutRequest): unknown {
    const obj: any = {};
    if (message.project !== "") {
      obj.project = message.project;
    }
    if (message.plan !== undefined) {
      obj.plan = Plan.toJSON(message.plan);
    }
    return obj;
  },

  create(base?: DeepPartial<PreviewRolloutRequest>): PreviewRolloutRequest {
    return PreviewRolloutRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PreviewRolloutRequest>): PreviewRolloutRequest {
    const message = createBasePreviewRolloutRequest();
    message.project = object.project ?? "";
    message.plan = (object.plan !== undefined && object.plan !== null) ? Plan.fromPartial(object.plan) : undefined;
    return message;
  },
};

function createBaseListTaskRunsRequest(): ListTaskRunsRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListTaskRunsRequest: MessageFns<ListTaskRunsRequest> = {
  encode(message: ListTaskRunsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTaskRunsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTaskRunsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTaskRunsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListTaskRunsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListTaskRunsRequest>): ListTaskRunsRequest {
    return ListTaskRunsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTaskRunsRequest>): ListTaskRunsRequest {
    const message = createBaseListTaskRunsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListTaskRunsResponse(): ListTaskRunsResponse {
  return { taskRuns: [], nextPageToken: "" };
}

export const ListTaskRunsResponse: MessageFns<ListTaskRunsResponse> = {
  encode(message: ListTaskRunsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.taskRuns) {
      TaskRun.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTaskRunsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTaskRunsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.taskRuns.push(TaskRun.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTaskRunsResponse {
    return {
      taskRuns: globalThis.Array.isArray(object?.taskRuns) ? object.taskRuns.map((e: any) => TaskRun.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListTaskRunsResponse): unknown {
    const obj: any = {};
    if (message.taskRuns?.length) {
      obj.taskRuns = message.taskRuns.map((e) => TaskRun.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListTaskRunsResponse>): ListTaskRunsResponse {
    return ListTaskRunsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTaskRunsResponse>): ListTaskRunsResponse {
    const message = createBaseListTaskRunsResponse();
    message.taskRuns = object.taskRuns?.map((e) => TaskRun.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetTaskRunRequest(): GetTaskRunRequest {
  return { name: "" };
}

export const GetTaskRunRequest: MessageFns<GetTaskRunRequest> = {
  encode(message: GetTaskRunRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTaskRunRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTaskRunRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTaskRunRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetTaskRunRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetTaskRunRequest>): GetTaskRunRequest {
    return GetTaskRunRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTaskRunRequest>): GetTaskRunRequest {
    const message = createBaseGetTaskRunRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseGetTaskRunLogRequest(): GetTaskRunLogRequest {
  return { parent: "" };
}

export const GetTaskRunLogRequest: MessageFns<GetTaskRunLogRequest> = {
  encode(message: GetTaskRunLogRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTaskRunLogRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTaskRunLogRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTaskRunLogRequest {
    return { parent: isSet(object.parent) ? globalThis.String(object.parent) : "" };
  },

  toJSON(message: GetTaskRunLogRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    return obj;
  },

  create(base?: DeepPartial<GetTaskRunLogRequest>): GetTaskRunLogRequest {
    return GetTaskRunLogRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTaskRunLogRequest>): GetTaskRunLogRequest {
    const message = createBaseGetTaskRunLogRequest();
    message.parent = object.parent ?? "";
    return message;
  },
};

function createBaseRollout(): Rollout {
  return {
    name: "",
    plan: "",
    title: "",
    stages: [],
    creator: "",
    createTime: undefined,
    updateTime: undefined,
    issue: "",
  };
}

export const Rollout: MessageFns<Rollout> = {
  encode(message: Rollout, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.plan !== "") {
      writer.uint32(26).string(message.plan);
    }
    if (message.title !== "") {
      writer.uint32(34).string(message.title);
    }
    for (const v of message.stages) {
      Stage.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.creator !== "") {
      writer.uint32(50).string(message.creator);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(message.createTime, writer.uint32(58).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(message.updateTime, writer.uint32(66).fork()).join();
    }
    if (message.issue !== "") {
      writer.uint32(74).string(message.issue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Rollout {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRollout();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.plan = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.stages.push(Stage.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.createTime = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.updateTime = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.issue = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Rollout {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      plan: isSet(object.plan) ? globalThis.String(object.plan) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      stages: globalThis.Array.isArray(object?.stages) ? object.stages.map((e: any) => Stage.fromJSON(e)) : [],
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      issue: isSet(object.issue) ? globalThis.String(object.issue) : "",
    };
  },

  toJSON(message: Rollout): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.plan !== "") {
      obj.plan = message.plan;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.stages?.length) {
      obj.stages = message.stages.map((e) => Stage.toJSON(e));
    }
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.createTime !== undefined) {
      obj.createTime = fromTimestamp(message.createTime).toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = fromTimestamp(message.updateTime).toISOString();
    }
    if (message.issue !== "") {
      obj.issue = message.issue;
    }
    return obj;
  },

  create(base?: DeepPartial<Rollout>): Rollout {
    return Rollout.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Rollout>): Rollout {
    const message = createBaseRollout();
    message.name = object.name ?? "";
    message.plan = object.plan ?? "";
    message.title = object.title ?? "";
    message.stages = object.stages?.map((e) => Stage.fromPartial(e)) || [];
    message.creator = object.creator ?? "";
    message.createTime = (object.createTime !== undefined && object.createTime !== null)
      ? Timestamp.fromPartial(object.createTime)
      : undefined;
    message.updateTime = (object.updateTime !== undefined && object.updateTime !== null)
      ? Timestamp.fromPartial(object.updateTime)
      : undefined;
    message.issue = object.issue ?? "";
    return message;
  },
};

function createBaseStage(): Stage {
  return { name: "", id: "", title: "", tasks: [] };
}

export const Stage: MessageFns<Stage> = {
  encode(message: Stage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.id !== "") {
      writer.uint32(26).string(message.id);
    }
    if (message.title !== "") {
      writer.uint32(34).string(message.title);
    }
    for (const v of message.tasks) {
      Task.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Stage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.tasks.push(Task.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Stage {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      tasks: globalThis.Array.isArray(object?.tasks) ? object.tasks.map((e: any) => Task.fromJSON(e)) : [],
    };
  },

  toJSON(message: Stage): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.tasks?.length) {
      obj.tasks = message.tasks.map((e) => Task.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Stage>): Stage {
    return Stage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Stage>): Stage {
    const message = createBaseStage();
    message.name = object.name ?? "";
    message.id = object.id ?? "";
    message.title = object.title ?? "";
    message.tasks = object.tasks?.map((e) => Task.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTask(): Task {
  return {
    name: "",
    title: "",
    specId: "",
    status: Task_Status.STATUS_UNSPECIFIED,
    skippedReason: "",
    type: Task_Type.TYPE_UNSPECIFIED,
    dependsOnTasks: [],
    target: "",
    databaseCreate: undefined,
    databaseSchemaBaseline: undefined,
    databaseSchemaUpdate: undefined,
    databaseDataUpdate: undefined,
    databaseDataExport: undefined,
  };
}

export const Task: MessageFns<Task> = {
  encode(message: Task, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.title !== "") {
      writer.uint32(26).string(message.title);
    }
    if (message.specId !== "") {
      writer.uint32(34).string(message.specId);
    }
    if (message.status !== Task_Status.STATUS_UNSPECIFIED) {
      writer.uint32(40).int32(task_StatusToNumber(message.status));
    }
    if (message.skippedReason !== "") {
      writer.uint32(122).string(message.skippedReason);
    }
    if (message.type !== Task_Type.TYPE_UNSPECIFIED) {
      writer.uint32(48).int32(task_TypeToNumber(message.type));
    }
    for (const v of message.dependsOnTasks) {
      writer.uint32(58).string(v!);
    }
    if (message.target !== "") {
      writer.uint32(66).string(message.target);
    }
    if (message.databaseCreate !== undefined) {
      Task_DatabaseCreate.encode(message.databaseCreate, writer.uint32(74).fork()).join();
    }
    if (message.databaseSchemaBaseline !== undefined) {
      Task_DatabaseSchemaBaseline.encode(message.databaseSchemaBaseline, writer.uint32(82).fork()).join();
    }
    if (message.databaseSchemaUpdate !== undefined) {
      Task_DatabaseSchemaUpdate.encode(message.databaseSchemaUpdate, writer.uint32(90).fork()).join();
    }
    if (message.databaseDataUpdate !== undefined) {
      Task_DatabaseDataUpdate.encode(message.databaseDataUpdate, writer.uint32(98).fork()).join();
    }
    if (message.databaseDataExport !== undefined) {
      Task_DatabaseDataExport.encode(message.databaseDataExport, writer.uint32(130).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Task {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTask();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.specId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.status = task_StatusFromJSON(reader.int32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.skippedReason = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.type = task_TypeFromJSON(reader.int32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.dependsOnTasks.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.target = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.databaseCreate = Task_DatabaseCreate.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.databaseSchemaBaseline = Task_DatabaseSchemaBaseline.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.databaseSchemaUpdate = Task_DatabaseSchemaUpdate.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.databaseDataUpdate = Task_DatabaseDataUpdate.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.databaseDataExport = Task_DatabaseDataExport.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Task {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      specId: isSet(object.specId) ? globalThis.String(object.specId) : "",
      status: isSet(object.status) ? task_StatusFromJSON(object.status) : Task_Status.STATUS_UNSPECIFIED,
      skippedReason: isSet(object.skippedReason) ? globalThis.String(object.skippedReason) : "",
      type: isSet(object.type) ? task_TypeFromJSON(object.type) : Task_Type.TYPE_UNSPECIFIED,
      dependsOnTasks: globalThis.Array.isArray(object?.dependsOnTasks)
        ? object.dependsOnTasks.map((e: any) => globalThis.String(e))
        : [],
      target: isSet(object.target) ? globalThis.String(object.target) : "",
      databaseCreate: isSet(object.databaseCreate) ? Task_DatabaseCreate.fromJSON(object.databaseCreate) : undefined,
      databaseSchemaBaseline: isSet(object.databaseSchemaBaseline)
        ? Task_DatabaseSchemaBaseline.fromJSON(object.databaseSchemaBaseline)
        : undefined,
      databaseSchemaUpdate: isSet(object.databaseSchemaUpdate)
        ? Task_DatabaseSchemaUpdate.fromJSON(object.databaseSchemaUpdate)
        : undefined,
      databaseDataUpdate: isSet(object.databaseDataUpdate)
        ? Task_DatabaseDataUpdate.fromJSON(object.databaseDataUpdate)
        : undefined,
      databaseDataExport: isSet(object.databaseDataExport)
        ? Task_DatabaseDataExport.fromJSON(object.databaseDataExport)
        : undefined,
    };
  },

  toJSON(message: Task): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.specId !== "") {
      obj.specId = message.specId;
    }
    if (message.status !== Task_Status.STATUS_UNSPECIFIED) {
      obj.status = task_StatusToJSON(message.status);
    }
    if (message.skippedReason !== "") {
      obj.skippedReason = message.skippedReason;
    }
    if (message.type !== Task_Type.TYPE_UNSPECIFIED) {
      obj.type = task_TypeToJSON(message.type);
    }
    if (message.dependsOnTasks?.length) {
      obj.dependsOnTasks = message.dependsOnTasks;
    }
    if (message.target !== "") {
      obj.target = message.target;
    }
    if (message.databaseCreate !== undefined) {
      obj.databaseCreate = Task_DatabaseCreate.toJSON(message.databaseCreate);
    }
    if (message.databaseSchemaBaseline !== undefined) {
      obj.databaseSchemaBaseline = Task_DatabaseSchemaBaseline.toJSON(message.databaseSchemaBaseline);
    }
    if (message.databaseSchemaUpdate !== undefined) {
      obj.databaseSchemaUpdate = Task_DatabaseSchemaUpdate.toJSON(message.databaseSchemaUpdate);
    }
    if (message.databaseDataUpdate !== undefined) {
      obj.databaseDataUpdate = Task_DatabaseDataUpdate.toJSON(message.databaseDataUpdate);
    }
    if (message.databaseDataExport !== undefined) {
      obj.databaseDataExport = Task_DatabaseDataExport.toJSON(message.databaseDataExport);
    }
    return obj;
  },

  create(base?: DeepPartial<Task>): Task {
    return Task.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Task>): Task {
    const message = createBaseTask();
    message.name = object.name ?? "";
    message.title = object.title ?? "";
    message.specId = object.specId ?? "";
    message.status = object.status ?? Task_Status.STATUS_UNSPECIFIED;
    message.skippedReason = object.skippedReason ?? "";
    message.type = object.type ?? Task_Type.TYPE_UNSPECIFIED;
    message.dependsOnTasks = object.dependsOnTasks?.map((e) => e) || [];
    message.target = object.target ?? "";
    message.databaseCreate = (object.databaseCreate !== undefined && object.databaseCreate !== null)
      ? Task_DatabaseCreate.fromPartial(object.databaseCreate)
      : undefined;
    message.databaseSchemaBaseline =
      (object.databaseSchemaBaseline !== undefined && object.databaseSchemaBaseline !== null)
        ? Task_DatabaseSchemaBaseline.fromPartial(object.databaseSchemaBaseline)
        : undefined;
    message.databaseSchemaUpdate = (object.databaseSchemaUpdate !== undefined && object.databaseSchemaUpdate !== null)
      ? Task_DatabaseSchemaUpdate.fromPartial(object.databaseSchemaUpdate)
      : undefined;
    message.databaseDataUpdate = (object.databaseDataUpdate !== undefined && object.databaseDataUpdate !== null)
      ? Task_DatabaseDataUpdate.fromPartial(object.databaseDataUpdate)
      : undefined;
    message.databaseDataExport = (object.databaseDataExport !== undefined && object.databaseDataExport !== null)
      ? Task_DatabaseDataExport.fromPartial(object.databaseDataExport)
      : undefined;
    return message;
  },
};

function createBaseTask_DatabaseCreate(): Task_DatabaseCreate {
  return {
    project: "",
    database: "",
    table: "",
    sheet: "",
    characterSet: "",
    collation: "",
    environment: "",
    labels: {},
  };
}

export const Task_DatabaseCreate: MessageFns<Task_DatabaseCreate> = {
  encode(message: Task_DatabaseCreate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.project !== "") {
      writer.uint32(10).string(message.project);
    }
    if (message.database !== "") {
      writer.uint32(18).string(message.database);
    }
    if (message.table !== "") {
      writer.uint32(26).string(message.table);
    }
    if (message.sheet !== "") {
      writer.uint32(34).string(message.sheet);
    }
    if (message.characterSet !== "") {
      writer.uint32(42).string(message.characterSet);
    }
    if (message.collation !== "") {
      writer.uint32(50).string(message.collation);
    }
    if (message.environment !== "") {
      writer.uint32(58).string(message.environment);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Task_DatabaseCreate_LabelsEntry.encode({ key: key as any, value }, writer.uint32(66).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Task_DatabaseCreate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTask_DatabaseCreate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.project = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.database = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.table = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sheet = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.characterSet = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.collation = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.environment = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          const entry8 = Task_DatabaseCreate_LabelsEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            message.labels[entry8.key] = entry8.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Task_DatabaseCreate {
    return {
      project: isSet(object.project) ? globalThis.String(object.project) : "",
      database: isSet(object.database) ? globalThis.String(object.database) : "",
      table: isSet(object.table) ? globalThis.String(object.table) : "",
      sheet: isSet(object.sheet) ? globalThis.String(object.sheet) : "",
      characterSet: isSet(object.characterSet) ? globalThis.String(object.characterSet) : "",
      collation: isSet(object.collation) ? globalThis.String(object.collation) : "",
      environment: isSet(object.environment) ? globalThis.String(object.environment) : "",
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Task_DatabaseCreate): unknown {
    const obj: any = {};
    if (message.project !== "") {
      obj.project = message.project;
    }
    if (message.database !== "") {
      obj.database = message.database;
    }
    if (message.table !== "") {
      obj.table = message.table;
    }
    if (message.sheet !== "") {
      obj.sheet = message.sheet;
    }
    if (message.characterSet !== "") {
      obj.characterSet = message.characterSet;
    }
    if (message.collation !== "") {
      obj.collation = message.collation;
    }
    if (message.environment !== "") {
      obj.environment = message.environment;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<Task_DatabaseCreate>): Task_DatabaseCreate {
    return Task_DatabaseCreate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Task_DatabaseCreate>): Task_DatabaseCreate {
    const message = createBaseTask_DatabaseCreate();
    message.project = object.project ?? "";
    message.database = object.database ?? "";
    message.table = object.table ?? "";
    message.sheet = object.sheet ?? "";
    message.characterSet = object.characterSet ?? "";
    message.collation = object.collation ?? "";
    message.environment = object.environment ?? "";
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseTask_DatabaseCreate_LabelsEntry(): Task_DatabaseCreate_LabelsEntry {
  return { key: "", value: "" };
}

export const Task_DatabaseCreate_LabelsEntry: MessageFns<Task_DatabaseCreate_LabelsEntry> = {
  encode(message: Task_DatabaseCreate_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Task_DatabaseCreate_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTask_DatabaseCreate_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Task_DatabaseCreate_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Task_DatabaseCreate_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Task_DatabaseCreate_LabelsEntry>): Task_DatabaseCreate_LabelsEntry {
    return Task_DatabaseCreate_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Task_DatabaseCreate_LabelsEntry>): Task_DatabaseCreate_LabelsEntry {
    const message = createBaseTask_DatabaseCreate_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseTask_DatabaseSchemaBaseline(): Task_DatabaseSchemaBaseline {
  return { schemaVersion: "" };
}

export const Task_DatabaseSchemaBaseline: MessageFns<Task_DatabaseSchemaBaseline> = {
  encode(message: Task_DatabaseSchemaBaseline, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.schemaVersion !== "") {
      writer.uint32(10).string(message.schemaVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Task_DatabaseSchemaBaseline {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTask_DatabaseSchemaBaseline();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.schemaVersion = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Task_DatabaseSchemaBaseline {
    return { schemaVersion: isSet(object.schemaVersion) ? globalThis.String(object.schemaVersion) : "" };
  },

  toJSON(message: Task_DatabaseSchemaBaseline): unknown {
    const obj: any = {};
    if (message.schemaVersion !== "") {
      obj.schemaVersion = message.schemaVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<Task_DatabaseSchemaBaseline>): Task_DatabaseSchemaBaseline {
    return Task_DatabaseSchemaBaseline.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Task_DatabaseSchemaBaseline>): Task_DatabaseSchemaBaseline {
    const message = createBaseTask_DatabaseSchemaBaseline();
    message.schemaVersion = object.schemaVersion ?? "";
    return message;
  },
};

function createBaseTask_DatabaseSchemaUpdate(): Task_DatabaseSchemaUpdate {
  return { sheet: "", schemaVersion: "" };
}

export const Task_DatabaseSchemaUpdate: MessageFns<Task_DatabaseSchemaUpdate> = {
  encode(message: Task_DatabaseSchemaUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sheet !== "") {
      writer.uint32(10).string(message.sheet);
    }
    if (message.schemaVersion !== "") {
      writer.uint32(18).string(message.schemaVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Task_DatabaseSchemaUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTask_DatabaseSchemaUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sheet = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.schemaVersion = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Task_DatabaseSchemaUpdate {
    return {
      sheet: isSet(object.sheet) ? globalThis.String(object.sheet) : "",
      schemaVersion: isSet(object.schemaVersion) ? globalThis.String(object.schemaVersion) : "",
    };
  },

  toJSON(message: Task_DatabaseSchemaUpdate): unknown {
    const obj: any = {};
    if (message.sheet !== "") {
      obj.sheet = message.sheet;
    }
    if (message.schemaVersion !== "") {
      obj.schemaVersion = message.schemaVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<Task_DatabaseSchemaUpdate>): Task_DatabaseSchemaUpdate {
    return Task_DatabaseSchemaUpdate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Task_DatabaseSchemaUpdate>): Task_DatabaseSchemaUpdate {
    const message = createBaseTask_DatabaseSchemaUpdate();
    message.sheet = object.sheet ?? "";
    message.schemaVersion = object.schemaVersion ?? "";
    return message;
  },
};

function createBaseTask_DatabaseDataUpdate(): Task_DatabaseDataUpdate {
  return { sheet: "", schemaVersion: "" };
}

export const Task_DatabaseDataUpdate: MessageFns<Task_DatabaseDataUpdate> = {
  encode(message: Task_DatabaseDataUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sheet !== "") {
      writer.uint32(10).string(message.sheet);
    }
    if (message.schemaVersion !== "") {
      writer.uint32(18).string(message.schemaVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Task_DatabaseDataUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTask_DatabaseDataUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sheet = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.schemaVersion = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Task_DatabaseDataUpdate {
    return {
      sheet: isSet(object.sheet) ? globalThis.String(object.sheet) : "",
      schemaVersion: isSet(object.schemaVersion) ? globalThis.String(object.schemaVersion) : "",
    };
  },

  toJSON(message: Task_DatabaseDataUpdate): unknown {
    const obj: any = {};
    if (message.sheet !== "") {
      obj.sheet = message.sheet;
    }
    if (message.schemaVersion !== "") {
      obj.schemaVersion = message.schemaVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<Task_DatabaseDataUpdate>): Task_DatabaseDataUpdate {
    return Task_DatabaseDataUpdate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Task_DatabaseDataUpdate>): Task_DatabaseDataUpdate {
    const message = createBaseTask_DatabaseDataUpdate();
    message.sheet = object.sheet ?? "";
    message.schemaVersion = object.schemaVersion ?? "";
    return message;
  },
};

function createBaseTask_DatabaseDataExport(): Task_DatabaseDataExport {
  return { target: "", sheet: "", format: ExportFormat.FORMAT_UNSPECIFIED, password: undefined };
}

export const Task_DatabaseDataExport: MessageFns<Task_DatabaseDataExport> = {
  encode(message: Task_DatabaseDataExport, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.target !== "") {
      writer.uint32(10).string(message.target);
    }
    if (message.sheet !== "") {
      writer.uint32(18).string(message.sheet);
    }
    if (message.format !== ExportFormat.FORMAT_UNSPECIFIED) {
      writer.uint32(24).int32(exportFormatToNumber(message.format));
    }
    if (message.password !== undefined) {
      writer.uint32(34).string(message.password);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Task_DatabaseDataExport {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTask_DatabaseDataExport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.target = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sheet = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.format = exportFormatFromJSON(reader.int32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.password = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Task_DatabaseDataExport {
    return {
      target: isSet(object.target) ? globalThis.String(object.target) : "",
      sheet: isSet(object.sheet) ? globalThis.String(object.sheet) : "",
      format: isSet(object.format) ? exportFormatFromJSON(object.format) : ExportFormat.FORMAT_UNSPECIFIED,
      password: isSet(object.password) ? globalThis.String(object.password) : undefined,
    };
  },

  toJSON(message: Task_DatabaseDataExport): unknown {
    const obj: any = {};
    if (message.target !== "") {
      obj.target = message.target;
    }
    if (message.sheet !== "") {
      obj.sheet = message.sheet;
    }
    if (message.format !== ExportFormat.FORMAT_UNSPECIFIED) {
      obj.format = exportFormatToJSON(message.format);
    }
    if (message.password !== undefined) {
      obj.password = message.password;
    }
    return obj;
  },

  create(base?: DeepPartial<Task_DatabaseDataExport>): Task_DatabaseDataExport {
    return Task_DatabaseDataExport.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Task_DatabaseDataExport>): Task_DatabaseDataExport {
    const message = createBaseTask_DatabaseDataExport();
    message.target = object.target ?? "";
    message.sheet = object.sheet ?? "";
    message.format = object.format ?? ExportFormat.FORMAT_UNSPECIFIED;
    message.password = object.password ?? undefined;
    return message;
  },
};

function createBaseTaskRun(): TaskRun {
  return {
    name: "",
    creator: "",
    updater: "",
    createTime: undefined,
    updateTime: undefined,
    title: "",
    status: TaskRun_Status.STATUS_UNSPECIFIED,
    detail: "",
    changeHistory: "",
    schemaVersion: "",
    startTime: undefined,
    exportArchiveStatus: TaskRun_ExportArchiveStatus.EXPORT_ARCHIVE_STATUS_UNSPECIFIED,
    priorBackupDetail: undefined,
    schedulerInfo: undefined,
    sheet: "",
  };
}

export const TaskRun: MessageFns<TaskRun> = {
  encode(message: TaskRun, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.creator !== "") {
      writer.uint32(26).string(message.creator);
    }
    if (message.updater !== "") {
      writer.uint32(34).string(message.updater);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(message.createTime, writer.uint32(42).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(message.updateTime, writer.uint32(50).fork()).join();
    }
    if (message.title !== "") {
      writer.uint32(58).string(message.title);
    }
    if (message.status !== TaskRun_Status.STATUS_UNSPECIFIED) {
      writer.uint32(64).int32(taskRun_StatusToNumber(message.status));
    }
    if (message.detail !== "") {
      writer.uint32(74).string(message.detail);
    }
    if (message.changeHistory !== "") {
      writer.uint32(82).string(message.changeHistory);
    }
    if (message.schemaVersion !== "") {
      writer.uint32(90).string(message.schemaVersion);
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(message.startTime, writer.uint32(114).fork()).join();
    }
    if (message.exportArchiveStatus !== TaskRun_ExportArchiveStatus.EXPORT_ARCHIVE_STATUS_UNSPECIFIED) {
      writer.uint32(128).int32(taskRun_ExportArchiveStatusToNumber(message.exportArchiveStatus));
    }
    if (message.priorBackupDetail !== undefined) {
      TaskRun_PriorBackupDetail.encode(message.priorBackupDetail, writer.uint32(138).fork()).join();
    }
    if (message.schedulerInfo !== undefined) {
      TaskRun_SchedulerInfo.encode(message.schedulerInfo, writer.uint32(146).fork()).join();
    }
    if (message.sheet !== "") {
      writer.uint32(154).string(message.sheet);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskRun {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskRun();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.updater = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createTime = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.updateTime = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.status = taskRun_StatusFromJSON(reader.int32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.detail = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.changeHistory = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.schemaVersion = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.startTime = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.exportArchiveStatus = taskRun_ExportArchiveStatusFromJSON(reader.int32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.priorBackupDetail = TaskRun_PriorBackupDetail.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.schedulerInfo = TaskRun_SchedulerInfo.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.sheet = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskRun {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      updater: isSet(object.updater) ? globalThis.String(object.updater) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      status: isSet(object.status) ? taskRun_StatusFromJSON(object.status) : TaskRun_Status.STATUS_UNSPECIFIED,
      detail: isSet(object.detail) ? globalThis.String(object.detail) : "",
      changeHistory: isSet(object.changeHistory) ? globalThis.String(object.changeHistory) : "",
      schemaVersion: isSet(object.schemaVersion) ? globalThis.String(object.schemaVersion) : "",
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      exportArchiveStatus: isSet(object.exportArchiveStatus)
        ? taskRun_ExportArchiveStatusFromJSON(object.exportArchiveStatus)
        : TaskRun_ExportArchiveStatus.EXPORT_ARCHIVE_STATUS_UNSPECIFIED,
      priorBackupDetail: isSet(object.priorBackupDetail)
        ? TaskRun_PriorBackupDetail.fromJSON(object.priorBackupDetail)
        : undefined,
      schedulerInfo: isSet(object.schedulerInfo) ? TaskRun_SchedulerInfo.fromJSON(object.schedulerInfo) : undefined,
      sheet: isSet(object.sheet) ? globalThis.String(object.sheet) : "",
    };
  },

  toJSON(message: TaskRun): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.updater !== "") {
      obj.updater = message.updater;
    }
    if (message.createTime !== undefined) {
      obj.createTime = fromTimestamp(message.createTime).toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = fromTimestamp(message.updateTime).toISOString();
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.status !== TaskRun_Status.STATUS_UNSPECIFIED) {
      obj.status = taskRun_StatusToJSON(message.status);
    }
    if (message.detail !== "") {
      obj.detail = message.detail;
    }
    if (message.changeHistory !== "") {
      obj.changeHistory = message.changeHistory;
    }
    if (message.schemaVersion !== "") {
      obj.schemaVersion = message.schemaVersion;
    }
    if (message.startTime !== undefined) {
      obj.startTime = fromTimestamp(message.startTime).toISOString();
    }
    if (message.exportArchiveStatus !== TaskRun_ExportArchiveStatus.EXPORT_ARCHIVE_STATUS_UNSPECIFIED) {
      obj.exportArchiveStatus = taskRun_ExportArchiveStatusToJSON(message.exportArchiveStatus);
    }
    if (message.priorBackupDetail !== undefined) {
      obj.priorBackupDetail = TaskRun_PriorBackupDetail.toJSON(message.priorBackupDetail);
    }
    if (message.schedulerInfo !== undefined) {
      obj.schedulerInfo = TaskRun_SchedulerInfo.toJSON(message.schedulerInfo);
    }
    if (message.sheet !== "") {
      obj.sheet = message.sheet;
    }
    return obj;
  },

  create(base?: DeepPartial<TaskRun>): TaskRun {
    return TaskRun.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TaskRun>): TaskRun {
    const message = createBaseTaskRun();
    message.name = object.name ?? "";
    message.creator = object.creator ?? "";
    message.updater = object.updater ?? "";
    message.createTime = (object.createTime !== undefined && object.createTime !== null)
      ? Timestamp.fromPartial(object.createTime)
      : undefined;
    message.updateTime = (object.updateTime !== undefined && object.updateTime !== null)
      ? Timestamp.fromPartial(object.updateTime)
      : undefined;
    message.title = object.title ?? "";
    message.status = object.status ?? TaskRun_Status.STATUS_UNSPECIFIED;
    message.detail = object.detail ?? "";
    message.changeHistory = object.changeHistory ?? "";
    message.schemaVersion = object.schemaVersion ?? "";
    message.startTime = (object.startTime !== undefined && object.startTime !== null)
      ? Timestamp.fromPartial(object.startTime)
      : undefined;
    message.exportArchiveStatus = object.exportArchiveStatus ??
      TaskRun_ExportArchiveStatus.EXPORT_ARCHIVE_STATUS_UNSPECIFIED;
    message.priorBackupDetail = (object.priorBackupDetail !== undefined && object.priorBackupDetail !== null)
      ? TaskRun_PriorBackupDetail.fromPartial(object.priorBackupDetail)
      : undefined;
    message.schedulerInfo = (object.schedulerInfo !== undefined && object.schedulerInfo !== null)
      ? TaskRun_SchedulerInfo.fromPartial(object.schedulerInfo)
      : undefined;
    message.sheet = object.sheet ?? "";
    return message;
  },
};

function createBaseTaskRun_PriorBackupDetail(): TaskRun_PriorBackupDetail {
  return { items: [] };
}

export const TaskRun_PriorBackupDetail: MessageFns<TaskRun_PriorBackupDetail> = {
  encode(message: TaskRun_PriorBackupDetail, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.items) {
      TaskRun_PriorBackupDetail_Item.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskRun_PriorBackupDetail {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskRun_PriorBackupDetail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.items.push(TaskRun_PriorBackupDetail_Item.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskRun_PriorBackupDetail {
    return {
      items: globalThis.Array.isArray(object?.items)
        ? object.items.map((e: any) => TaskRun_PriorBackupDetail_Item.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TaskRun_PriorBackupDetail): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => TaskRun_PriorBackupDetail_Item.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<TaskRun_PriorBackupDetail>): TaskRun_PriorBackupDetail {
    return TaskRun_PriorBackupDetail.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TaskRun_PriorBackupDetail>): TaskRun_PriorBackupDetail {
    const message = createBaseTaskRun_PriorBackupDetail();
    message.items = object.items?.map((e) => TaskRun_PriorBackupDetail_Item.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTaskRun_PriorBackupDetail_Item(): TaskRun_PriorBackupDetail_Item {
  return { sourceTable: undefined, targetTable: undefined, startPosition: undefined, endPosition: undefined };
}

export const TaskRun_PriorBackupDetail_Item: MessageFns<TaskRun_PriorBackupDetail_Item> = {
  encode(message: TaskRun_PriorBackupDetail_Item, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sourceTable !== undefined) {
      TaskRun_PriorBackupDetail_Item_Table.encode(message.sourceTable, writer.uint32(10).fork()).join();
    }
    if (message.targetTable !== undefined) {
      TaskRun_PriorBackupDetail_Item_Table.encode(message.targetTable, writer.uint32(18).fork()).join();
    }
    if (message.startPosition !== undefined) {
      Position.encode(message.startPosition, writer.uint32(26).fork()).join();
    }
    if (message.endPosition !== undefined) {
      Position.encode(message.endPosition, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskRun_PriorBackupDetail_Item {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskRun_PriorBackupDetail_Item();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sourceTable = TaskRun_PriorBackupDetail_Item_Table.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.targetTable = TaskRun_PriorBackupDetail_Item_Table.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.startPosition = Position.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.endPosition = Position.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskRun_PriorBackupDetail_Item {
    return {
      sourceTable: isSet(object.sourceTable)
        ? TaskRun_PriorBackupDetail_Item_Table.fromJSON(object.sourceTable)
        : undefined,
      targetTable: isSet(object.targetTable)
        ? TaskRun_PriorBackupDetail_Item_Table.fromJSON(object.targetTable)
        : undefined,
      startPosition: isSet(object.startPosition) ? Position.fromJSON(object.startPosition) : undefined,
      endPosition: isSet(object.endPosition) ? Position.fromJSON(object.endPosition) : undefined,
    };
  },

  toJSON(message: TaskRun_PriorBackupDetail_Item): unknown {
    const obj: any = {};
    if (message.sourceTable !== undefined) {
      obj.sourceTable = TaskRun_PriorBackupDetail_Item_Table.toJSON(message.sourceTable);
    }
    if (message.targetTable !== undefined) {
      obj.targetTable = TaskRun_PriorBackupDetail_Item_Table.toJSON(message.targetTable);
    }
    if (message.startPosition !== undefined) {
      obj.startPosition = Position.toJSON(message.startPosition);
    }
    if (message.endPosition !== undefined) {
      obj.endPosition = Position.toJSON(message.endPosition);
    }
    return obj;
  },

  create(base?: DeepPartial<TaskRun_PriorBackupDetail_Item>): TaskRun_PriorBackupDetail_Item {
    return TaskRun_PriorBackupDetail_Item.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TaskRun_PriorBackupDetail_Item>): TaskRun_PriorBackupDetail_Item {
    const message = createBaseTaskRun_PriorBackupDetail_Item();
    message.sourceTable = (object.sourceTable !== undefined && object.sourceTable !== null)
      ? TaskRun_PriorBackupDetail_Item_Table.fromPartial(object.sourceTable)
      : undefined;
    message.targetTable = (object.targetTable !== undefined && object.targetTable !== null)
      ? TaskRun_PriorBackupDetail_Item_Table.fromPartial(object.targetTable)
      : undefined;
    message.startPosition = (object.startPosition !== undefined && object.startPosition !== null)
      ? Position.fromPartial(object.startPosition)
      : undefined;
    message.endPosition = (object.endPosition !== undefined && object.endPosition !== null)
      ? Position.fromPartial(object.endPosition)
      : undefined;
    return message;
  },
};

function createBaseTaskRun_PriorBackupDetail_Item_Table(): TaskRun_PriorBackupDetail_Item_Table {
  return { database: "", schema: "", table: "" };
}

export const TaskRun_PriorBackupDetail_Item_Table: MessageFns<TaskRun_PriorBackupDetail_Item_Table> = {
  encode(message: TaskRun_PriorBackupDetail_Item_Table, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.database !== "") {
      writer.uint32(10).string(message.database);
    }
    if (message.schema !== "") {
      writer.uint32(18).string(message.schema);
    }
    if (message.table !== "") {
      writer.uint32(26).string(message.table);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskRun_PriorBackupDetail_Item_Table {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskRun_PriorBackupDetail_Item_Table();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.database = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.schema = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.table = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskRun_PriorBackupDetail_Item_Table {
    return {
      database: isSet(object.database) ? globalThis.String(object.database) : "",
      schema: isSet(object.schema) ? globalThis.String(object.schema) : "",
      table: isSet(object.table) ? globalThis.String(object.table) : "",
    };
  },

  toJSON(message: TaskRun_PriorBackupDetail_Item_Table): unknown {
    const obj: any = {};
    if (message.database !== "") {
      obj.database = message.database;
    }
    if (message.schema !== "") {
      obj.schema = message.schema;
    }
    if (message.table !== "") {
      obj.table = message.table;
    }
    return obj;
  },

  create(base?: DeepPartial<TaskRun_PriorBackupDetail_Item_Table>): TaskRun_PriorBackupDetail_Item_Table {
    return TaskRun_PriorBackupDetail_Item_Table.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TaskRun_PriorBackupDetail_Item_Table>): TaskRun_PriorBackupDetail_Item_Table {
    const message = createBaseTaskRun_PriorBackupDetail_Item_Table();
    message.database = object.database ?? "";
    message.schema = object.schema ?? "";
    message.table = object.table ?? "";
    return message;
  },
};

function createBaseTaskRun_SchedulerInfo(): TaskRun_SchedulerInfo {
  return { reportTime: undefined, waitingCause: undefined };
}

export const TaskRun_SchedulerInfo: MessageFns<TaskRun_SchedulerInfo> = {
  encode(message: TaskRun_SchedulerInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reportTime !== undefined) {
      Timestamp.encode(message.reportTime, writer.uint32(10).fork()).join();
    }
    if (message.waitingCause !== undefined) {
      TaskRun_SchedulerInfo_WaitingCause.encode(message.waitingCause, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskRun_SchedulerInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskRun_SchedulerInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.reportTime = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.waitingCause = TaskRun_SchedulerInfo_WaitingCause.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskRun_SchedulerInfo {
    return {
      reportTime: isSet(object.reportTime) ? fromJsonTimestamp(object.reportTime) : undefined,
      waitingCause: isSet(object.waitingCause)
        ? TaskRun_SchedulerInfo_WaitingCause.fromJSON(object.waitingCause)
        : undefined,
    };
  },

  toJSON(message: TaskRun_SchedulerInfo): unknown {
    const obj: any = {};
    if (message.reportTime !== undefined) {
      obj.reportTime = fromTimestamp(message.reportTime).toISOString();
    }
    if (message.waitingCause !== undefined) {
      obj.waitingCause = TaskRun_SchedulerInfo_WaitingCause.toJSON(message.waitingCause);
    }
    return obj;
  },

  create(base?: DeepPartial<TaskRun_SchedulerInfo>): TaskRun_SchedulerInfo {
    return TaskRun_SchedulerInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TaskRun_SchedulerInfo>): TaskRun_SchedulerInfo {
    const message = createBaseTaskRun_SchedulerInfo();
    message.reportTime = (object.reportTime !== undefined && object.reportTime !== null)
      ? Timestamp.fromPartial(object.reportTime)
      : undefined;
    message.waitingCause = (object.waitingCause !== undefined && object.waitingCause !== null)
      ? TaskRun_SchedulerInfo_WaitingCause.fromPartial(object.waitingCause)
      : undefined;
    return message;
  },
};

function createBaseTaskRun_SchedulerInfo_WaitingCause(): TaskRun_SchedulerInfo_WaitingCause {
  return { connectionLimit: undefined, task: undefined };
}

export const TaskRun_SchedulerInfo_WaitingCause: MessageFns<TaskRun_SchedulerInfo_WaitingCause> = {
  encode(message: TaskRun_SchedulerInfo_WaitingCause, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.connectionLimit !== undefined) {
      writer.uint32(8).bool(message.connectionLimit);
    }
    if (message.task !== undefined) {
      TaskRun_SchedulerInfo_WaitingCause_Task.encode(message.task, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskRun_SchedulerInfo_WaitingCause {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskRun_SchedulerInfo_WaitingCause();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.connectionLimit = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.task = TaskRun_SchedulerInfo_WaitingCause_Task.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskRun_SchedulerInfo_WaitingCause {
    return {
      connectionLimit: isSet(object.connectionLimit) ? globalThis.Boolean(object.connectionLimit) : undefined,
      task: isSet(object.task) ? TaskRun_SchedulerInfo_WaitingCause_Task.fromJSON(object.task) : undefined,
    };
  },

  toJSON(message: TaskRun_SchedulerInfo_WaitingCause): unknown {
    const obj: any = {};
    if (message.connectionLimit !== undefined) {
      obj.connectionLimit = message.connectionLimit;
    }
    if (message.task !== undefined) {
      obj.task = TaskRun_SchedulerInfo_WaitingCause_Task.toJSON(message.task);
    }
    return obj;
  },

  create(base?: DeepPartial<TaskRun_SchedulerInfo_WaitingCause>): TaskRun_SchedulerInfo_WaitingCause {
    return TaskRun_SchedulerInfo_WaitingCause.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TaskRun_SchedulerInfo_WaitingCause>): TaskRun_SchedulerInfo_WaitingCause {
    const message = createBaseTaskRun_SchedulerInfo_WaitingCause();
    message.connectionLimit = object.connectionLimit ?? undefined;
    message.task = (object.task !== undefined && object.task !== null)
      ? TaskRun_SchedulerInfo_WaitingCause_Task.fromPartial(object.task)
      : undefined;
    return message;
  },
};

function createBaseTaskRun_SchedulerInfo_WaitingCause_Task(): TaskRun_SchedulerInfo_WaitingCause_Task {
  return { task: "", issue: "" };
}

export const TaskRun_SchedulerInfo_WaitingCause_Task: MessageFns<TaskRun_SchedulerInfo_WaitingCause_Task> = {
  encode(message: TaskRun_SchedulerInfo_WaitingCause_Task, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.task !== "") {
      writer.uint32(10).string(message.task);
    }
    if (message.issue !== "") {
      writer.uint32(18).string(message.issue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskRun_SchedulerInfo_WaitingCause_Task {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskRun_SchedulerInfo_WaitingCause_Task();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.task = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.issue = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskRun_SchedulerInfo_WaitingCause_Task {
    return {
      task: isSet(object.task) ? globalThis.String(object.task) : "",
      issue: isSet(object.issue) ? globalThis.String(object.issue) : "",
    };
  },

  toJSON(message: TaskRun_SchedulerInfo_WaitingCause_Task): unknown {
    const obj: any = {};
    if (message.task !== "") {
      obj.task = message.task;
    }
    if (message.issue !== "") {
      obj.issue = message.issue;
    }
    return obj;
  },

  create(base?: DeepPartial<TaskRun_SchedulerInfo_WaitingCause_Task>): TaskRun_SchedulerInfo_WaitingCause_Task {
    return TaskRun_SchedulerInfo_WaitingCause_Task.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TaskRun_SchedulerInfo_WaitingCause_Task>): TaskRun_SchedulerInfo_WaitingCause_Task {
    const message = createBaseTaskRun_SchedulerInfo_WaitingCause_Task();
    message.task = object.task ?? "";
    message.issue = object.issue ?? "";
    return message;
  },
};

function createBaseTaskRunLog(): TaskRunLog {
  return { name: "", entries: [] };
}

export const TaskRunLog: MessageFns<TaskRunLog> = {
  encode(message: TaskRunLog, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.entries) {
      TaskRunLogEntry.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskRunLog {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskRunLog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.entries.push(TaskRunLogEntry.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskRunLog {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      entries: globalThis.Array.isArray(object?.entries)
        ? object.entries.map((e: any) => TaskRunLogEntry.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TaskRunLog): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.entries?.length) {
      obj.entries = message.entries.map((e) => TaskRunLogEntry.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<TaskRunLog>): TaskRunLog {
    return TaskRunLog.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TaskRunLog>): TaskRunLog {
    const message = createBaseTaskRunLog();
    message.name = object.name ?? "";
    message.entries = object.entries?.map((e) => TaskRunLogEntry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTaskRunLogEntry(): TaskRunLogEntry {
  return {
    type: TaskRunLogEntry_Type.TYPE_UNSPECIFIED,
    logTime: undefined,
    deployId: "",
    schemaDump: undefined,
    commandExecute: undefined,
    databaseSync: undefined,
    taskRunStatusUpdate: undefined,
    transactionControl: undefined,
    priorBackup: undefined,
  };
}

export const TaskRunLogEntry: MessageFns<TaskRunLogEntry> = {
  encode(message: TaskRunLogEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== TaskRunLogEntry_Type.TYPE_UNSPECIFIED) {
      writer.uint32(8).int32(taskRunLogEntry_TypeToNumber(message.type));
    }
    if (message.logTime !== undefined) {
      Timestamp.encode(message.logTime, writer.uint32(50).fork()).join();
    }
    if (message.deployId !== "") {
      writer.uint32(98).string(message.deployId);
    }
    if (message.schemaDump !== undefined) {
      TaskRunLogEntry_SchemaDump.encode(message.schemaDump, writer.uint32(18).fork()).join();
    }
    if (message.commandExecute !== undefined) {
      TaskRunLogEntry_CommandExecute.encode(message.commandExecute, writer.uint32(26).fork()).join();
    }
    if (message.databaseSync !== undefined) {
      TaskRunLogEntry_DatabaseSync.encode(message.databaseSync, writer.uint32(34).fork()).join();
    }
    if (message.taskRunStatusUpdate !== undefined) {
      TaskRunLogEntry_TaskRunStatusUpdate.encode(message.taskRunStatusUpdate, writer.uint32(42).fork()).join();
    }
    if (message.transactionControl !== undefined) {
      TaskRunLogEntry_TransactionControl.encode(message.transactionControl, writer.uint32(58).fork()).join();
    }
    if (message.priorBackup !== undefined) {
      TaskRunLogEntry_PriorBackup.encode(message.priorBackup, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskRunLogEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskRunLogEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = taskRunLogEntry_TypeFromJSON(reader.int32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.logTime = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.deployId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.schemaDump = TaskRunLogEntry_SchemaDump.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.commandExecute = TaskRunLogEntry_CommandExecute.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.databaseSync = TaskRunLogEntry_DatabaseSync.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.taskRunStatusUpdate = TaskRunLogEntry_TaskRunStatusUpdate.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.transactionControl = TaskRunLogEntry_TransactionControl.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.priorBackup = TaskRunLogEntry_PriorBackup.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskRunLogEntry {
    return {
      type: isSet(object.type) ? taskRunLogEntry_TypeFromJSON(object.type) : TaskRunLogEntry_Type.TYPE_UNSPECIFIED,
      logTime: isSet(object.logTime) ? fromJsonTimestamp(object.logTime) : undefined,
      deployId: isSet(object.deployId) ? globalThis.String(object.deployId) : "",
      schemaDump: isSet(object.schemaDump) ? TaskRunLogEntry_SchemaDump.fromJSON(object.schemaDump) : undefined,
      commandExecute: isSet(object.commandExecute)
        ? TaskRunLogEntry_CommandExecute.fromJSON(object.commandExecute)
        : undefined,
      databaseSync: isSet(object.databaseSync) ? TaskRunLogEntry_DatabaseSync.fromJSON(object.databaseSync) : undefined,
      taskRunStatusUpdate: isSet(object.taskRunStatusUpdate)
        ? TaskRunLogEntry_TaskRunStatusUpdate.fromJSON(object.taskRunStatusUpdate)
        : undefined,
      transactionControl: isSet(object.transactionControl)
        ? TaskRunLogEntry_TransactionControl.fromJSON(object.transactionControl)
        : undefined,
      priorBackup: isSet(object.priorBackup) ? TaskRunLogEntry_PriorBackup.fromJSON(object.priorBackup) : undefined,
    };
  },

  toJSON(message: TaskRunLogEntry): unknown {
    const obj: any = {};
    if (message.type !== TaskRunLogEntry_Type.TYPE_UNSPECIFIED) {
      obj.type = taskRunLogEntry_TypeToJSON(message.type);
    }
    if (message.logTime !== undefined) {
      obj.logTime = fromTimestamp(message.logTime).toISOString();
    }
    if (message.deployId !== "") {
      obj.deployId = message.deployId;
    }
    if (message.schemaDump !== undefined) {
      obj.schemaDump = TaskRunLogEntry_SchemaDump.toJSON(message.schemaDump);
    }
    if (message.commandExecute !== undefined) {
      obj.commandExecute = TaskRunLogEntry_CommandExecute.toJSON(message.commandExecute);
    }
    if (message.databaseSync !== undefined) {
      obj.databaseSync = TaskRunLogEntry_DatabaseSync.toJSON(message.databaseSync);
    }
    if (message.taskRunStatusUpdate !== undefined) {
      obj.taskRunStatusUpdate = TaskRunLogEntry_TaskRunStatusUpdate.toJSON(message.taskRunStatusUpdate);
    }
    if (message.transactionControl !== undefined) {
      obj.transactionControl = TaskRunLogEntry_TransactionControl.toJSON(message.transactionControl);
    }
    if (message.priorBackup !== undefined) {
      obj.priorBackup = TaskRunLogEntry_PriorBackup.toJSON(message.priorBackup);
    }
    return obj;
  },

  create(base?: DeepPartial<TaskRunLogEntry>): TaskRunLogEntry {
    return TaskRunLogEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TaskRunLogEntry>): TaskRunLogEntry {
    const message = createBaseTaskRunLogEntry();
    message.type = object.type ?? TaskRunLogEntry_Type.TYPE_UNSPECIFIED;
    message.logTime = (object.logTime !== undefined && object.logTime !== null)
      ? Timestamp.fromPartial(object.logTime)
      : undefined;
    message.deployId = object.deployId ?? "";
    message.schemaDump = (object.schemaDump !== undefined && object.schemaDump !== null)
      ? TaskRunLogEntry_SchemaDump.fromPartial(object.schemaDump)
      : undefined;
    message.commandExecute = (object.commandExecute !== undefined && object.commandExecute !== null)
      ? TaskRunLogEntry_CommandExecute.fromPartial(object.commandExecute)
      : undefined;
    message.databaseSync = (object.databaseSync !== undefined && object.databaseSync !== null)
      ? TaskRunLogEntry_DatabaseSync.fromPartial(object.databaseSync)
      : undefined;
    message.taskRunStatusUpdate = (object.taskRunStatusUpdate !== undefined && object.taskRunStatusUpdate !== null)
      ? TaskRunLogEntry_TaskRunStatusUpdate.fromPartial(object.taskRunStatusUpdate)
      : undefined;
    message.transactionControl = (object.transactionControl !== undefined && object.transactionControl !== null)
      ? TaskRunLogEntry_TransactionControl.fromPartial(object.transactionControl)
      : undefined;
    message.priorBackup = (object.priorBackup !== undefined && object.priorBackup !== null)
      ? TaskRunLogEntry_PriorBackup.fromPartial(object.priorBackup)
      : undefined;
    return message;
  },
};

function createBaseTaskRunLogEntry_SchemaDump(): TaskRunLogEntry_SchemaDump {
  return { startTime: undefined, endTime: undefined, error: "" };
}

export const TaskRunLogEntry_SchemaDump: MessageFns<TaskRunLogEntry_SchemaDump> = {
  encode(message: TaskRunLogEntry_SchemaDump, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startTime !== undefined) {
      Timestamp.encode(message.startTime, writer.uint32(10).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(message.endTime, writer.uint32(18).fork()).join();
    }
    if (message.error !== "") {
      writer.uint32(26).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskRunLogEntry_SchemaDump {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskRunLogEntry_SchemaDump();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.startTime = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.endTime = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskRunLogEntry_SchemaDump {
    return {
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: TaskRunLogEntry_SchemaDump): unknown {
    const obj: any = {};
    if (message.startTime !== undefined) {
      obj.startTime = fromTimestamp(message.startTime).toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = fromTimestamp(message.endTime).toISOString();
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create(base?: DeepPartial<TaskRunLogEntry_SchemaDump>): TaskRunLogEntry_SchemaDump {
    return TaskRunLogEntry_SchemaDump.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TaskRunLogEntry_SchemaDump>): TaskRunLogEntry_SchemaDump {
    const message = createBaseTaskRunLogEntry_SchemaDump();
    message.startTime = (object.startTime !== undefined && object.startTime !== null)
      ? Timestamp.fromPartial(object.startTime)
      : undefined;
    message.endTime = (object.endTime !== undefined && object.endTime !== null)
      ? Timestamp.fromPartial(object.endTime)
      : undefined;
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseTaskRunLogEntry_CommandExecute(): TaskRunLogEntry_CommandExecute {
  return { logTime: undefined, commandIndexes: [], response: undefined };
}

export const TaskRunLogEntry_CommandExecute: MessageFns<TaskRunLogEntry_CommandExecute> = {
  encode(message: TaskRunLogEntry_CommandExecute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.logTime !== undefined) {
      Timestamp.encode(message.logTime, writer.uint32(10).fork()).join();
    }
    writer.uint32(18).fork();
    for (const v of message.commandIndexes) {
      writer.int32(v);
    }
    writer.join();
    if (message.response !== undefined) {
      TaskRunLogEntry_CommandExecute_CommandResponse.encode(message.response, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskRunLogEntry_CommandExecute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskRunLogEntry_CommandExecute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.logTime = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.commandIndexes.push(reader.int32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.commandIndexes.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.response = TaskRunLogEntry_CommandExecute_CommandResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskRunLogEntry_CommandExecute {
    return {
      logTime: isSet(object.logTime) ? fromJsonTimestamp(object.logTime) : undefined,
      commandIndexes: globalThis.Array.isArray(object?.commandIndexes)
        ? object.commandIndexes.map((e: any) => globalThis.Number(e))
        : [],
      response: isSet(object.response)
        ? TaskRunLogEntry_CommandExecute_CommandResponse.fromJSON(object.response)
        : undefined,
    };
  },

  toJSON(message: TaskRunLogEntry_CommandExecute): unknown {
    const obj: any = {};
    if (message.logTime !== undefined) {
      obj.logTime = fromTimestamp(message.logTime).toISOString();
    }
    if (message.commandIndexes?.length) {
      obj.commandIndexes = message.commandIndexes.map((e) => Math.round(e));
    }
    if (message.response !== undefined) {
      obj.response = TaskRunLogEntry_CommandExecute_CommandResponse.toJSON(message.response);
    }
    return obj;
  },

  create(base?: DeepPartial<TaskRunLogEntry_CommandExecute>): TaskRunLogEntry_CommandExecute {
    return TaskRunLogEntry_CommandExecute.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TaskRunLogEntry_CommandExecute>): TaskRunLogEntry_CommandExecute {
    const message = createBaseTaskRunLogEntry_CommandExecute();
    message.logTime = (object.logTime !== undefined && object.logTime !== null)
      ? Timestamp.fromPartial(object.logTime)
      : undefined;
    message.commandIndexes = object.commandIndexes?.map((e) => e) || [];
    message.response = (object.response !== undefined && object.response !== null)
      ? TaskRunLogEntry_CommandExecute_CommandResponse.fromPartial(object.response)
      : undefined;
    return message;
  },
};

function createBaseTaskRunLogEntry_CommandExecute_CommandResponse(): TaskRunLogEntry_CommandExecute_CommandResponse {
  return { logTime: undefined, error: "", affectedRows: 0, allAffectedRows: [] };
}

export const TaskRunLogEntry_CommandExecute_CommandResponse: MessageFns<
  TaskRunLogEntry_CommandExecute_CommandResponse
> = {
  encode(
    message: TaskRunLogEntry_CommandExecute_CommandResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.logTime !== undefined) {
      Timestamp.encode(message.logTime, writer.uint32(10).fork()).join();
    }
    if (message.error !== "") {
      writer.uint32(18).string(message.error);
    }
    if (message.affectedRows !== 0) {
      writer.uint32(24).int32(message.affectedRows);
    }
    writer.uint32(34).fork();
    for (const v of message.allAffectedRows) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskRunLogEntry_CommandExecute_CommandResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskRunLogEntry_CommandExecute_CommandResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.logTime = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.affectedRows = reader.int32();
          continue;
        }
        case 4: {
          if (tag === 32) {
            message.allAffectedRows.push(reader.int32());

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.allAffectedRows.push(reader.int32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskRunLogEntry_CommandExecute_CommandResponse {
    return {
      logTime: isSet(object.logTime) ? fromJsonTimestamp(object.logTime) : undefined,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
      affectedRows: isSet(object.affectedRows) ? globalThis.Number(object.affectedRows) : 0,
      allAffectedRows: globalThis.Array.isArray(object?.allAffectedRows)
        ? object.allAffectedRows.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: TaskRunLogEntry_CommandExecute_CommandResponse): unknown {
    const obj: any = {};
    if (message.logTime !== undefined) {
      obj.logTime = fromTimestamp(message.logTime).toISOString();
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    if (message.affectedRows !== 0) {
      obj.affectedRows = Math.round(message.affectedRows);
    }
    if (message.allAffectedRows?.length) {
      obj.allAffectedRows = message.allAffectedRows.map((e) => Math.round(e));
    }
    return obj;
  },

  create(
    base?: DeepPartial<TaskRunLogEntry_CommandExecute_CommandResponse>,
  ): TaskRunLogEntry_CommandExecute_CommandResponse {
    return TaskRunLogEntry_CommandExecute_CommandResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<TaskRunLogEntry_CommandExecute_CommandResponse>,
  ): TaskRunLogEntry_CommandExecute_CommandResponse {
    const message = createBaseTaskRunLogEntry_CommandExecute_CommandResponse();
    message.logTime = (object.logTime !== undefined && object.logTime !== null)
      ? Timestamp.fromPartial(object.logTime)
      : undefined;
    message.error = object.error ?? "";
    message.affectedRows = object.affectedRows ?? 0;
    message.allAffectedRows = object.allAffectedRows?.map((e) => e) || [];
    return message;
  },
};

function createBaseTaskRunLogEntry_DatabaseSync(): TaskRunLogEntry_DatabaseSync {
  return { startTime: undefined, endTime: undefined, error: "" };
}

export const TaskRunLogEntry_DatabaseSync: MessageFns<TaskRunLogEntry_DatabaseSync> = {
  encode(message: TaskRunLogEntry_DatabaseSync, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startTime !== undefined) {
      Timestamp.encode(message.startTime, writer.uint32(10).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(message.endTime, writer.uint32(18).fork()).join();
    }
    if (message.error !== "") {
      writer.uint32(26).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskRunLogEntry_DatabaseSync {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskRunLogEntry_DatabaseSync();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.startTime = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.endTime = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskRunLogEntry_DatabaseSync {
    return {
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: TaskRunLogEntry_DatabaseSync): unknown {
    const obj: any = {};
    if (message.startTime !== undefined) {
      obj.startTime = fromTimestamp(message.startTime).toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = fromTimestamp(message.endTime).toISOString();
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create(base?: DeepPartial<TaskRunLogEntry_DatabaseSync>): TaskRunLogEntry_DatabaseSync {
    return TaskRunLogEntry_DatabaseSync.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TaskRunLogEntry_DatabaseSync>): TaskRunLogEntry_DatabaseSync {
    const message = createBaseTaskRunLogEntry_DatabaseSync();
    message.startTime = (object.startTime !== undefined && object.startTime !== null)
      ? Timestamp.fromPartial(object.startTime)
      : undefined;
    message.endTime = (object.endTime !== undefined && object.endTime !== null)
      ? Timestamp.fromPartial(object.endTime)
      : undefined;
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseTaskRunLogEntry_TaskRunStatusUpdate(): TaskRunLogEntry_TaskRunStatusUpdate {
  return { status: TaskRunLogEntry_TaskRunStatusUpdate_Status.STATUS_UNSPECIFIED };
}

export const TaskRunLogEntry_TaskRunStatusUpdate: MessageFns<TaskRunLogEntry_TaskRunStatusUpdate> = {
  encode(message: TaskRunLogEntry_TaskRunStatusUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== TaskRunLogEntry_TaskRunStatusUpdate_Status.STATUS_UNSPECIFIED) {
      writer.uint32(8).int32(taskRunLogEntry_TaskRunStatusUpdate_StatusToNumber(message.status));
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskRunLogEntry_TaskRunStatusUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskRunLogEntry_TaskRunStatusUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = taskRunLogEntry_TaskRunStatusUpdate_StatusFromJSON(reader.int32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskRunLogEntry_TaskRunStatusUpdate {
    return {
      status: isSet(object.status)
        ? taskRunLogEntry_TaskRunStatusUpdate_StatusFromJSON(object.status)
        : TaskRunLogEntry_TaskRunStatusUpdate_Status.STATUS_UNSPECIFIED,
    };
  },

  toJSON(message: TaskRunLogEntry_TaskRunStatusUpdate): unknown {
    const obj: any = {};
    if (message.status !== TaskRunLogEntry_TaskRunStatusUpdate_Status.STATUS_UNSPECIFIED) {
      obj.status = taskRunLogEntry_TaskRunStatusUpdate_StatusToJSON(message.status);
    }
    return obj;
  },

  create(base?: DeepPartial<TaskRunLogEntry_TaskRunStatusUpdate>): TaskRunLogEntry_TaskRunStatusUpdate {
    return TaskRunLogEntry_TaskRunStatusUpdate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TaskRunLogEntry_TaskRunStatusUpdate>): TaskRunLogEntry_TaskRunStatusUpdate {
    const message = createBaseTaskRunLogEntry_TaskRunStatusUpdate();
    message.status = object.status ?? TaskRunLogEntry_TaskRunStatusUpdate_Status.STATUS_UNSPECIFIED;
    return message;
  },
};

function createBaseTaskRunLogEntry_TransactionControl(): TaskRunLogEntry_TransactionControl {
  return { type: TaskRunLogEntry_TransactionControl_Type.TYPE_UNSPECIFIED, error: "" };
}

export const TaskRunLogEntry_TransactionControl: MessageFns<TaskRunLogEntry_TransactionControl> = {
  encode(message: TaskRunLogEntry_TransactionControl, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== TaskRunLogEntry_TransactionControl_Type.TYPE_UNSPECIFIED) {
      writer.uint32(8).int32(taskRunLogEntry_TransactionControl_TypeToNumber(message.type));
    }
    if (message.error !== "") {
      writer.uint32(18).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskRunLogEntry_TransactionControl {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskRunLogEntry_TransactionControl();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = taskRunLogEntry_TransactionControl_TypeFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskRunLogEntry_TransactionControl {
    return {
      type: isSet(object.type)
        ? taskRunLogEntry_TransactionControl_TypeFromJSON(object.type)
        : TaskRunLogEntry_TransactionControl_Type.TYPE_UNSPECIFIED,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: TaskRunLogEntry_TransactionControl): unknown {
    const obj: any = {};
    if (message.type !== TaskRunLogEntry_TransactionControl_Type.TYPE_UNSPECIFIED) {
      obj.type = taskRunLogEntry_TransactionControl_TypeToJSON(message.type);
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create(base?: DeepPartial<TaskRunLogEntry_TransactionControl>): TaskRunLogEntry_TransactionControl {
    return TaskRunLogEntry_TransactionControl.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TaskRunLogEntry_TransactionControl>): TaskRunLogEntry_TransactionControl {
    const message = createBaseTaskRunLogEntry_TransactionControl();
    message.type = object.type ?? TaskRunLogEntry_TransactionControl_Type.TYPE_UNSPECIFIED;
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseTaskRunLogEntry_PriorBackup(): TaskRunLogEntry_PriorBackup {
  return { startTime: undefined, endTime: undefined, priorBackupDetail: undefined, error: "" };
}

export const TaskRunLogEntry_PriorBackup: MessageFns<TaskRunLogEntry_PriorBackup> = {
  encode(message: TaskRunLogEntry_PriorBackup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startTime !== undefined) {
      Timestamp.encode(message.startTime, writer.uint32(10).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(message.endTime, writer.uint32(18).fork()).join();
    }
    if (message.priorBackupDetail !== undefined) {
      TaskRun_PriorBackupDetail.encode(message.priorBackupDetail, writer.uint32(26).fork()).join();
    }
    if (message.error !== "") {
      writer.uint32(34).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskRunLogEntry_PriorBackup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskRunLogEntry_PriorBackup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.startTime = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.endTime = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.priorBackupDetail = TaskRun_PriorBackupDetail.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskRunLogEntry_PriorBackup {
    return {
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      priorBackupDetail: isSet(object.priorBackupDetail)
        ? TaskRun_PriorBackupDetail.fromJSON(object.priorBackupDetail)
        : undefined,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: TaskRunLogEntry_PriorBackup): unknown {
    const obj: any = {};
    if (message.startTime !== undefined) {
      obj.startTime = fromTimestamp(message.startTime).toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = fromTimestamp(message.endTime).toISOString();
    }
    if (message.priorBackupDetail !== undefined) {
      obj.priorBackupDetail = TaskRun_PriorBackupDetail.toJSON(message.priorBackupDetail);
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create(base?: DeepPartial<TaskRunLogEntry_PriorBackup>): TaskRunLogEntry_PriorBackup {
    return TaskRunLogEntry_PriorBackup.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TaskRunLogEntry_PriorBackup>): TaskRunLogEntry_PriorBackup {
    const message = createBaseTaskRunLogEntry_PriorBackup();
    message.startTime = (object.startTime !== undefined && object.startTime !== null)
      ? Timestamp.fromPartial(object.startTime)
      : undefined;
    message.endTime = (object.endTime !== undefined && object.endTime !== null)
      ? Timestamp.fromPartial(object.endTime)
      : undefined;
    message.priorBackupDetail = (object.priorBackupDetail !== undefined && object.priorBackupDetail !== null)
      ? TaskRun_PriorBackupDetail.fromPartial(object.priorBackupDetail)
      : undefined;
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseGetTaskRunSessionRequest(): GetTaskRunSessionRequest {
  return { parent: "" };
}

export const GetTaskRunSessionRequest: MessageFns<GetTaskRunSessionRequest> = {
  encode(message: GetTaskRunSessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTaskRunSessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTaskRunSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTaskRunSessionRequest {
    return { parent: isSet(object.parent) ? globalThis.String(object.parent) : "" };
  },

  toJSON(message: GetTaskRunSessionRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    return obj;
  },

  create(base?: DeepPartial<GetTaskRunSessionRequest>): GetTaskRunSessionRequest {
    return GetTaskRunSessionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTaskRunSessionRequest>): GetTaskRunSessionRequest {
    const message = createBaseGetTaskRunSessionRequest();
    message.parent = object.parent ?? "";
    return message;
  },
};

function createBaseTaskRunSession(): TaskRunSession {
  return { name: "", postgres: undefined };
}

export const TaskRunSession: MessageFns<TaskRunSession> = {
  encode(message: TaskRunSession, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.postgres !== undefined) {
      TaskRunSession_Postgres.encode(message.postgres, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskRunSession {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskRunSession();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.postgres = TaskRunSession_Postgres.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskRunSession {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      postgres: isSet(object.postgres) ? TaskRunSession_Postgres.fromJSON(object.postgres) : undefined,
    };
  },

  toJSON(message: TaskRunSession): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.postgres !== undefined) {
      obj.postgres = TaskRunSession_Postgres.toJSON(message.postgres);
    }
    return obj;
  },

  create(base?: DeepPartial<TaskRunSession>): TaskRunSession {
    return TaskRunSession.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TaskRunSession>): TaskRunSession {
    const message = createBaseTaskRunSession();
    message.name = object.name ?? "";
    message.postgres = (object.postgres !== undefined && object.postgres !== null)
      ? TaskRunSession_Postgres.fromPartial(object.postgres)
      : undefined;
    return message;
  },
};

function createBaseTaskRunSession_Postgres(): TaskRunSession_Postgres {
  return { session: undefined, blockingSessions: [], blockedSessions: [] };
}

export const TaskRunSession_Postgres: MessageFns<TaskRunSession_Postgres> = {
  encode(message: TaskRunSession_Postgres, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.session !== undefined) {
      TaskRunSession_Postgres_Session.encode(message.session, writer.uint32(10).fork()).join();
    }
    for (const v of message.blockingSessions) {
      TaskRunSession_Postgres_Session.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.blockedSessions) {
      TaskRunSession_Postgres_Session.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskRunSession_Postgres {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskRunSession_Postgres();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.session = TaskRunSession_Postgres_Session.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blockingSessions.push(TaskRunSession_Postgres_Session.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.blockedSessions.push(TaskRunSession_Postgres_Session.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskRunSession_Postgres {
    return {
      session: isSet(object.session) ? TaskRunSession_Postgres_Session.fromJSON(object.session) : undefined,
      blockingSessions: globalThis.Array.isArray(object?.blockingSessions)
        ? object.blockingSessions.map((e: any) => TaskRunSession_Postgres_Session.fromJSON(e))
        : [],
      blockedSessions: globalThis.Array.isArray(object?.blockedSessions)
        ? object.blockedSessions.map((e: any) => TaskRunSession_Postgres_Session.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TaskRunSession_Postgres): unknown {
    const obj: any = {};
    if (message.session !== undefined) {
      obj.session = TaskRunSession_Postgres_Session.toJSON(message.session);
    }
    if (message.blockingSessions?.length) {
      obj.blockingSessions = message.blockingSessions.map((e) => TaskRunSession_Postgres_Session.toJSON(e));
    }
    if (message.blockedSessions?.length) {
      obj.blockedSessions = message.blockedSessions.map((e) => TaskRunSession_Postgres_Session.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<TaskRunSession_Postgres>): TaskRunSession_Postgres {
    return TaskRunSession_Postgres.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TaskRunSession_Postgres>): TaskRunSession_Postgres {
    const message = createBaseTaskRunSession_Postgres();
    message.session = (object.session !== undefined && object.session !== null)
      ? TaskRunSession_Postgres_Session.fromPartial(object.session)
      : undefined;
    message.blockingSessions = object.blockingSessions?.map((e) => TaskRunSession_Postgres_Session.fromPartial(e)) ||
      [];
    message.blockedSessions = object.blockedSessions?.map((e) => TaskRunSession_Postgres_Session.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTaskRunSession_Postgres_Session(): TaskRunSession_Postgres_Session {
  return {
    pid: "",
    blockedByPids: [],
    query: "",
    state: undefined,
    waitEventType: undefined,
    waitEvent: undefined,
    datname: undefined,
    usename: undefined,
    applicationName: "",
    clientAddr: undefined,
    clientPort: undefined,
    backendStart: undefined,
    xactStart: undefined,
    queryStart: undefined,
  };
}

export const TaskRunSession_Postgres_Session: MessageFns<TaskRunSession_Postgres_Session> = {
  encode(message: TaskRunSession_Postgres_Session, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pid !== "") {
      writer.uint32(10).string(message.pid);
    }
    for (const v of message.blockedByPids) {
      writer.uint32(18).string(v!);
    }
    if (message.query !== "") {
      writer.uint32(26).string(message.query);
    }
    if (message.state !== undefined) {
      writer.uint32(34).string(message.state);
    }
    if (message.waitEventType !== undefined) {
      writer.uint32(42).string(message.waitEventType);
    }
    if (message.waitEvent !== undefined) {
      writer.uint32(50).string(message.waitEvent);
    }
    if (message.datname !== undefined) {
      writer.uint32(58).string(message.datname);
    }
    if (message.usename !== undefined) {
      writer.uint32(66).string(message.usename);
    }
    if (message.applicationName !== "") {
      writer.uint32(74).string(message.applicationName);
    }
    if (message.clientAddr !== undefined) {
      writer.uint32(82).string(message.clientAddr);
    }
    if (message.clientPort !== undefined) {
      writer.uint32(90).string(message.clientPort);
    }
    if (message.backendStart !== undefined) {
      Timestamp.encode(message.backendStart, writer.uint32(98).fork()).join();
    }
    if (message.xactStart !== undefined) {
      Timestamp.encode(message.xactStart, writer.uint32(106).fork()).join();
    }
    if (message.queryStart !== undefined) {
      Timestamp.encode(message.queryStart, writer.uint32(114).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskRunSession_Postgres_Session {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskRunSession_Postgres_Session();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blockedByPids.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.query = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.state = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.waitEventType = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.waitEvent = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.datname = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.usename = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.applicationName = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.clientAddr = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.clientPort = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.backendStart = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.xactStart = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.queryStart = Timestamp.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskRunSession_Postgres_Session {
    return {
      pid: isSet(object.pid) ? globalThis.String(object.pid) : "",
      blockedByPids: globalThis.Array.isArray(object?.blockedByPids)
        ? object.blockedByPids.map((e: any) => globalThis.String(e))
        : [],
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      state: isSet(object.state) ? globalThis.String(object.state) : undefined,
      waitEventType: isSet(object.waitEventType) ? globalThis.String(object.waitEventType) : undefined,
      waitEvent: isSet(object.waitEvent) ? globalThis.String(object.waitEvent) : undefined,
      datname: isSet(object.datname) ? globalThis.String(object.datname) : undefined,
      usename: isSet(object.usename) ? globalThis.String(object.usename) : undefined,
      applicationName: isSet(object.applicationName) ? globalThis.String(object.applicationName) : "",
      clientAddr: isSet(object.clientAddr) ? globalThis.String(object.clientAddr) : undefined,
      clientPort: isSet(object.clientPort) ? globalThis.String(object.clientPort) : undefined,
      backendStart: isSet(object.backendStart) ? fromJsonTimestamp(object.backendStart) : undefined,
      xactStart: isSet(object.xactStart) ? fromJsonTimestamp(object.xactStart) : undefined,
      queryStart: isSet(object.queryStart) ? fromJsonTimestamp(object.queryStart) : undefined,
    };
  },

  toJSON(message: TaskRunSession_Postgres_Session): unknown {
    const obj: any = {};
    if (message.pid !== "") {
      obj.pid = message.pid;
    }
    if (message.blockedByPids?.length) {
      obj.blockedByPids = message.blockedByPids;
    }
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.state !== undefined) {
      obj.state = message.state;
    }
    if (message.waitEventType !== undefined) {
      obj.waitEventType = message.waitEventType;
    }
    if (message.waitEvent !== undefined) {
      obj.waitEvent = message.waitEvent;
    }
    if (message.datname !== undefined) {
      obj.datname = message.datname;
    }
    if (message.usename !== undefined) {
      obj.usename = message.usename;
    }
    if (message.applicationName !== "") {
      obj.applicationName = message.applicationName;
    }
    if (message.clientAddr !== undefined) {
      obj.clientAddr = message.clientAddr;
    }
    if (message.clientPort !== undefined) {
      obj.clientPort = message.clientPort;
    }
    if (message.backendStart !== undefined) {
      obj.backendStart = fromTimestamp(message.backendStart).toISOString();
    }
    if (message.xactStart !== undefined) {
      obj.xactStart = fromTimestamp(message.xactStart).toISOString();
    }
    if (message.queryStart !== undefined) {
      obj.queryStart = fromTimestamp(message.queryStart).toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<TaskRunSession_Postgres_Session>): TaskRunSession_Postgres_Session {
    return TaskRunSession_Postgres_Session.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TaskRunSession_Postgres_Session>): TaskRunSession_Postgres_Session {
    const message = createBaseTaskRunSession_Postgres_Session();
    message.pid = object.pid ?? "";
    message.blockedByPids = object.blockedByPids?.map((e) => e) || [];
    message.query = object.query ?? "";
    message.state = object.state ?? undefined;
    message.waitEventType = object.waitEventType ?? undefined;
    message.waitEvent = object.waitEvent ?? undefined;
    message.datname = object.datname ?? undefined;
    message.usename = object.usename ?? undefined;
    message.applicationName = object.applicationName ?? "";
    message.clientAddr = object.clientAddr ?? undefined;
    message.clientPort = object.clientPort ?? undefined;
    message.backendStart = (object.backendStart !== undefined && object.backendStart !== null)
      ? Timestamp.fromPartial(object.backendStart)
      : undefined;
    message.xactStart = (object.xactStart !== undefined && object.xactStart !== null)
      ? Timestamp.fromPartial(object.xactStart)
      : undefined;
    message.queryStart = (object.queryStart !== undefined && object.queryStart !== null)
      ? Timestamp.fromPartial(object.queryStart)
      : undefined;
    return message;
  },
};

function createBasePreviewTaskRunRollbackRequest(): PreviewTaskRunRollbackRequest {
  return { name: "" };
}

export const PreviewTaskRunRollbackRequest: MessageFns<PreviewTaskRunRollbackRequest> = {
  encode(message: PreviewTaskRunRollbackRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PreviewTaskRunRollbackRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePreviewTaskRunRollbackRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PreviewTaskRunRollbackRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: PreviewTaskRunRollbackRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<PreviewTaskRunRollbackRequest>): PreviewTaskRunRollbackRequest {
    return PreviewTaskRunRollbackRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PreviewTaskRunRollbackRequest>): PreviewTaskRunRollbackRequest {
    const message = createBasePreviewTaskRunRollbackRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBasePreviewTaskRunRollbackResponse(): PreviewTaskRunRollbackResponse {
  return { statement: "" };
}

export const PreviewTaskRunRollbackResponse: MessageFns<PreviewTaskRunRollbackResponse> = {
  encode(message: PreviewTaskRunRollbackResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.statement !== "") {
      writer.uint32(10).string(message.statement);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PreviewTaskRunRollbackResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePreviewTaskRunRollbackResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.statement = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PreviewTaskRunRollbackResponse {
    return { statement: isSet(object.statement) ? globalThis.String(object.statement) : "" };
  },

  toJSON(message: PreviewTaskRunRollbackResponse): unknown {
    const obj: any = {};
    if (message.statement !== "") {
      obj.statement = message.statement;
    }
    return obj;
  },

  create(base?: DeepPartial<PreviewTaskRunRollbackResponse>): PreviewTaskRunRollbackResponse {
    return PreviewTaskRunRollbackResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PreviewTaskRunRollbackResponse>): PreviewTaskRunRollbackResponse {
    const message = createBasePreviewTaskRunRollbackResponse();
    message.statement = object.statement ?? "";
    return message;
  },
};

export type RolloutServiceDefinition = typeof RolloutServiceDefinition;
export const RolloutServiceDefinition = {
  name: "RolloutService",
  fullName: "bytebase.v1.RolloutService",
  methods: {
    getRollout: {
      name: "GetRollout",
      requestType: GetRolloutRequest,
      requestStream: false,
      responseType: Rollout,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [new Uint8Array([4, 110, 97, 109, 101])],
          800010: [new Uint8Array([15, 98, 98, 46, 114, 111, 108, 108, 111, 117, 116, 115, 46, 103, 101, 116])],
          800016: [new Uint8Array([1])],
          578365826: [
            new Uint8Array([
              34,
              18,
              32,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              114,
              111,
              108,
              108,
              111,
              117,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    listRollouts: {
      name: "ListRollouts",
      requestType: ListRolloutsRequest,
      requestStream: false,
      responseType: ListRolloutsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [new Uint8Array([6, 112, 97, 114, 101, 110, 116])],
          800010: [new Uint8Array([16, 98, 98, 46, 114, 111, 108, 108, 111, 117, 116, 115, 46, 108, 105, 115, 116])],
          800016: [new Uint8Array([1])],
          578365826: [
            new Uint8Array([
              34,
              18,
              32,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              114,
              111,
              108,
              108,
              111,
              117,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** CreateRollout can be called multiple times with the same rollout.plan but different stage_id to promote rollout stages. */
    createRollout: {
      name: "CreateRollout",
      requestType: CreateRolloutRequest,
      requestStream: false,
      responseType: Rollout,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [new Uint8Array([14, 112, 97, 114, 101, 110, 116, 44, 114, 111, 108, 108, 111, 117, 116])],
          800010: [
            new Uint8Array([18, 98, 98, 46, 114, 111, 108, 108, 111, 117, 116, 115, 46, 99, 114, 101, 97, 116, 101]),
          ],
          800016: [new Uint8Array([1])],
          800024: [new Uint8Array([1])],
          578365826: [
            new Uint8Array([
              43,
              58,
              7,
              114,
              111,
              108,
              108,
              111,
              117,
              116,
              34,
              32,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              114,
              111,
              108,
              108,
              111,
              117,
              116,
              115,
            ]),
          ],
        },
      },
    },
    previewRollout: {
      name: "PreviewRollout",
      requestType: PreviewRolloutRequest,
      requestStream: false,
      responseType: Rollout,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [new Uint8Array([4, 110, 97, 109, 101])],
          800010: [
            new Uint8Array([
              19,
              98,
              98,
              46,
              114,
              111,
              108,
              108,
              111,
              117,
              116,
              115,
              46,
              112,
              114,
              101,
              118,
              105,
              101,
              119,
            ]),
          ],
          800016: [new Uint8Array([1])],
          578365826: [
            new Uint8Array([
              44,
              58,
              1,
              42,
              34,
              39,
              47,
              118,
              49,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              58,
              112,
              114,
              101,
              118,
              105,
              101,
              119,
              82,
              111,
              108,
              108,
              111,
              117,
              116,
            ]),
          ],
        },
      },
    },
    listTaskRuns: {
      name: "ListTaskRuns",
      requestType: ListTaskRunsRequest,
      requestStream: false,
      responseType: ListTaskRunsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [new Uint8Array([6, 112, 97, 114, 101, 110, 116])],
          800010: [new Uint8Array([16, 98, 98, 46, 116, 97, 115, 107, 82, 117, 110, 115, 46, 108, 105, 115, 116])],
          800016: [new Uint8Array([1])],
          578365826: [
            new Uint8Array([
              62,
              18,
              60,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              114,
              111,
              108,
              108,
              111,
              117,
              116,
              115,
              47,
              42,
              47,
              115,
              116,
              97,
              103,
              101,
              115,
              47,
              42,
              47,
              116,
              97,
              115,
              107,
              115,
              47,
              42,
              125,
              47,
              116,
              97,
              115,
              107,
              82,
              117,
              110,
              115,
            ]),
          ],
        },
      },
    },
    getTaskRun: {
      name: "GetTaskRun",
      requestType: GetTaskRunRequest,
      requestStream: false,
      responseType: TaskRun,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [new Uint8Array([4, 110, 97, 109, 101])],
          800010: [new Uint8Array([16, 98, 98, 46, 116, 97, 115, 107, 82, 117, 110, 115, 46, 108, 105, 115, 116])],
          800016: [new Uint8Array([1])],
          578365826: [
            new Uint8Array([
              62,
              18,
              60,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              114,
              111,
              108,
              108,
              111,
              117,
              116,
              115,
              47,
              42,
              47,
              115,
              116,
              97,
              103,
              101,
              115,
              47,
              42,
              47,
              116,
              97,
              115,
              107,
              115,
              47,
              42,
              47,
              116,
              97,
              115,
              107,
              82,
              117,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    getTaskRunLog: {
      name: "GetTaskRunLog",
      requestType: GetTaskRunLogRequest,
      requestStream: false,
      responseType: TaskRunLog,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [new Uint8Array([6, 112, 97, 114, 101, 110, 116])],
          800010: [new Uint8Array([16, 98, 98, 46, 116, 97, 115, 107, 82, 117, 110, 115, 46, 108, 105, 115, 116])],
          800016: [new Uint8Array([1])],
          578365826: [
            new Uint8Array([
              68,
              18,
              66,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              114,
              111,
              108,
              108,
              111,
              117,
              116,
              115,
              47,
              42,
              47,
              115,
              116,
              97,
              103,
              101,
              115,
              47,
              42,
              47,
              116,
              97,
              115,
              107,
              115,
              47,
              42,
              47,
              116,
              97,
              115,
              107,
              82,
              117,
              110,
              115,
              47,
              42,
              125,
              47,
              108,
              111,
              103,
            ]),
          ],
        },
      },
    },
    getTaskRunSession: {
      name: "GetTaskRunSession",
      requestType: GetTaskRunSessionRequest,
      requestStream: false,
      responseType: TaskRunSession,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [new Uint8Array([6, 112, 97, 114, 101, 110, 116])],
          800010: [new Uint8Array([16, 98, 98, 46, 116, 97, 115, 107, 82, 117, 110, 115, 46, 108, 105, 115, 116])],
          800016: [new Uint8Array([1])],
          578365826: [
            new Uint8Array([
              72,
              18,
              70,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              114,
              111,
              108,
              108,
              111,
              117,
              116,
              115,
              47,
              42,
              47,
              115,
              116,
              97,
              103,
              101,
              115,
              47,
              42,
              47,
              116,
              97,
              115,
              107,
              115,
              47,
              42,
              47,
              116,
              97,
              115,
              107,
              82,
              117,
              110,
              115,
              47,
              42,
              125,
              47,
              115,
              101,
              115,
              115,
              105,
              111,
              110,
            ]),
          ],
        },
      },
    },
    /**
     * BatchRunTasks creates task runs for the specified tasks.
     * DataExport issue only allows the creator to run the task.
     * Users with "bb.taskRuns.create" permission can run the task, e.g. Workspace Admin and DBA.
     * Follow role-based rollout policy for the environment.
     */
    batchRunTasks: {
      name: "BatchRunTasks",
      requestType: BatchRunTasksRequest,
      requestStream: false,
      responseType: BatchRunTasksResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [new Uint8Array([6, 112, 97, 114, 101, 110, 116])],
          800016: [new Uint8Array([2])],
          578365826: [
            new Uint8Array([
              63,
              58,
              1,
              42,
              34,
              58,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              114,
              111,
              108,
              108,
              111,
              117,
              116,
              115,
              47,
              42,
              47,
              115,
              116,
              97,
              103,
              101,
              115,
              47,
              42,
              125,
              47,
              116,
              97,
              115,
              107,
              115,
              58,
              98,
              97,
              116,
              99,
              104,
              82,
              117,
              110,
            ]),
          ],
        },
      },
    },
    /**
     * BatchSkipTasks skips the specified tasks.
     * The access is the same as BatchRunTasks().
     */
    batchSkipTasks: {
      name: "BatchSkipTasks",
      requestType: BatchSkipTasksRequest,
      requestStream: false,
      responseType: BatchSkipTasksResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [new Uint8Array([6, 112, 97, 114, 101, 110, 116])],
          800016: [new Uint8Array([2])],
          578365826: [
            new Uint8Array([
              64,
              58,
              1,
              42,
              34,
              59,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              114,
              111,
              108,
              108,
              111,
              117,
              116,
              115,
              47,
              42,
              47,
              115,
              116,
              97,
              103,
              101,
              115,
              47,
              42,
              125,
              47,
              116,
              97,
              115,
              107,
              115,
              58,
              98,
              97,
              116,
              99,
              104,
              83,
              107,
              105,
              112,
            ]),
          ],
        },
      },
    },
    /**
     * BatchSkipTasks cancels the specified task runs in batch.
     * The access is the same as BatchRunTasks().
     */
    batchCancelTaskRuns: {
      name: "BatchCancelTaskRuns",
      requestType: BatchCancelTaskRunsRequest,
      requestStream: false,
      responseType: BatchCancelTaskRunsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [new Uint8Array([6, 112, 97, 114, 101, 110, 116])],
          800016: [new Uint8Array([2])],
          578365826: [
            new Uint8Array([
              77,
              58,
              1,
              42,
              34,
              72,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              114,
              111,
              108,
              108,
              111,
              117,
              116,
              115,
              47,
              42,
              47,
              115,
              116,
              97,
              103,
              101,
              115,
              47,
              42,
              47,
              116,
              97,
              115,
              107,
              115,
              47,
              42,
              125,
              47,
              116,
              97,
              115,
              107,
              82,
              117,
              110,
              115,
              58,
              98,
              97,
              116,
              99,
              104,
              67,
              97,
              110,
              99,
              101,
              108,
            ]),
          ],
        },
      },
    },
    previewTaskRunRollback: {
      name: "PreviewTaskRunRollback",
      requestType: PreviewTaskRunRollbackRequest,
      requestStream: false,
      responseType: PreviewTaskRunRollbackResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [new Uint8Array([4, 110, 97, 109, 101])],
          800010: [new Uint8Array([16, 98, 98, 46, 116, 97, 115, 107, 82, 117, 110, 115, 46, 108, 105, 115, 116])],
          800016: [new Uint8Array([1])],
          578365826: [
            new Uint8Array([
              81,
              58,
              1,
              42,
              34,
              76,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              114,
              111,
              108,
              108,
              111,
              117,
              116,
              115,
              47,
              42,
              47,
              115,
              116,
              97,
              103,
              101,
              115,
              47,
              42,
              47,
              116,
              97,
              115,
              107,
              115,
              47,
              42,
              47,
              116,
              97,
              115,
              107,
              82,
              117,
              110,
              115,
              47,
              42,
              125,
              58,
              112,
              114,
              101,
              118,
              105,
              101,
              119,
              82,
              111,
              108,
              108,
              98,
              97,
              99,
              107,
            ]),
          ],
        },
      },
    },
  },
} as const;

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Timestamp {
  if (o instanceof globalThis.Date) {
    return toTimestamp(o);
  } else if (typeof o === "string") {
    return toTimestamp(new globalThis.Date(o));
  } else {
    return Timestamp.fromJSON(o);
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
