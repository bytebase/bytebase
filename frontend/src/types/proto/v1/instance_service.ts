// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.3.0
//   protoc               unknown
// source: v1/instance_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../google/protobuf/duration";
import { Empty } from "../google/protobuf/empty";
import { FieldMask } from "../google/protobuf/field_mask";
import { Timestamp } from "../google/protobuf/timestamp";
import {
  Engine,
  engineFromJSON,
  engineToJSON,
  engineToNumber,
  State,
  stateFromJSON,
  stateToJSON,
  stateToNumber,
} from "./common";
import { InstanceRole } from "./instance_role_service";

export const protobufPackage = "bytebase.v1";

export enum DataSourceType {
  DATA_SOURCE_UNSPECIFIED = "DATA_SOURCE_UNSPECIFIED",
  ADMIN = "ADMIN",
  READ_ONLY = "READ_ONLY",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function dataSourceTypeFromJSON(object: any): DataSourceType {
  switch (object) {
    case 0:
    case "DATA_SOURCE_UNSPECIFIED":
      return DataSourceType.DATA_SOURCE_UNSPECIFIED;
    case 1:
    case "ADMIN":
      return DataSourceType.ADMIN;
    case 2:
    case "READ_ONLY":
      return DataSourceType.READ_ONLY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DataSourceType.UNRECOGNIZED;
  }
}

export function dataSourceTypeToJSON(object: DataSourceType): string {
  switch (object) {
    case DataSourceType.DATA_SOURCE_UNSPECIFIED:
      return "DATA_SOURCE_UNSPECIFIED";
    case DataSourceType.ADMIN:
      return "ADMIN";
    case DataSourceType.READ_ONLY:
      return "READ_ONLY";
    case DataSourceType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function dataSourceTypeToNumber(object: DataSourceType): number {
  switch (object) {
    case DataSourceType.DATA_SOURCE_UNSPECIFIED:
      return 0;
    case DataSourceType.ADMIN:
      return 1;
    case DataSourceType.READ_ONLY:
      return 2;
    case DataSourceType.UNRECOGNIZED:
    default:
      return -1;
  }
}

export interface GetInstanceRequest {
  /**
   * The name of the instance to retrieve.
   * Format: instances/{instance}
   */
  name: string;
}

export interface ListInstancesRequest {
  /**
   * The maximum number of instances to return. The service may return fewer than
   * this value.
   * If unspecified, at most 10 instances will be returned.
   * The maximum value is 1000; values above 1000 will be coerced to 1000.
   */
  pageSize: number;
  /**
   * A page token, received from a previous `ListInstances` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListInstances` must match
   * the call that provided the page token.
   */
  pageToken: string;
  /** Show deleted instances if specified. */
  showDeleted: boolean;
  /**
   * Filter the instance.
   * The syntax and semantics of CEL are documented at https://github.com/google/cel-spec
   *
   * Supported filters:
   * - name: the instance name, support "==" and ".matches()" operator.
   * - resource_id: the instance id, support "==" and ".matches()" operator.
   * - environment: the environment full name in "environments/{id}" format, support "==" operator.
   * - state: the instance state, check State enum for values, support "==" operator.
   * - engine: the instance engine, check Engine enum for values. Support "==", "in [xx]", "!(in [xx])" operator.
   * - host: the instance host, support "==" and ".matches()" operator.
   * - port: the instance port, support "==" and ".matches()" operator.
   * - project: the project full name in "projects/{id}" format, support "==" operator.
   *
   * For example:
   * name == "sample instance"
   * name.matches("sample")
   * resource_id = "sample-instance"
   * resource_id.matches("sample")
   * state == "DELETED"
   * environment == "environments/test"
   * engine == "MYSQL"
   * engine in ["MYSQL", "POSTGRES"]
   * !(engine in ["MYSQL", "POSTGRES"])
   * host == "127.0.0.1"
   * host.matches("127.0")
   * port == "54321"
   * port.matches("543")
   * project == "projects/sample-project"
   * You can combine filter conditions like:
   * name.matches("sample") && environment == "environments/test"
   * host == "127.0.0.1" && port == "54321"
   */
  filter: string;
}

export interface ListInstancesResponse {
  /** The instances from the specified request. */
  instances: Instance[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
}

export interface CreateInstanceRequest {
  /** The instance to create. */
  instance:
    | Instance
    | undefined;
  /**
   * The ID to use for the instance, which will become the final component of
   * the instance's resource name.
   *
   * This value should be 4-63 characters, and valid characters
   * are /[a-z][0-9]-/.
   */
  instanceId: string;
  /** Validate only also tests the data source connection. */
  validateOnly: boolean;
}

export interface UpdateInstanceRequest {
  /**
   * The instance to update.
   *
   * The instance's `name` field is used to identify the instance to update.
   * Format: instances/{instance}
   */
  instance:
    | Instance
    | undefined;
  /** The list of fields to update. */
  updateMask: string[] | undefined;
}

export interface DeleteInstanceRequest {
  /**
   * The name of the instance to delete.
   * Format: instances/{instance}
   */
  name: string;
  /** If set to true, any databases and sheets from this project will also be moved to default project, and all open issues will be closed. */
  force: boolean;
}

export interface UndeleteInstanceRequest {
  /**
   * The name of the deleted instance.
   * Format: instances/{instance}
   */
  name: string;
}

export interface SyncInstanceRequest {
  /**
   * The name of instance.
   * Format: instances/{instance}
   */
  name: string;
  /**
   * When full sync is enabled, all databases in the instance will be synchronized. Otherwise, only
   * the instance metadata (such as the database list) and any newly discovered instances will be synced.
   */
  enableFullSync: boolean;
}

export interface ListInstanceDatabaseRequest {
  /**
   * The name of the instance.
   * Format: instances/{instance}
   */
  name: string;
  /** The target instance. We need to set this field if the target instance is not created yet. */
  instance?: Instance | undefined;
}

export interface ListInstanceDatabaseResponse {
  /** All database name list in the instance. */
  databases: string[];
}

export interface SyncInstanceResponse {
  /** All database name list in the instance. */
  databases: string[];
}

export interface BatchSyncInstancesRequest {
  /**
   * The request message specifying the instances to sync.
   * A maximum of 1000 instances can be synced in a batch.
   */
  requests: SyncInstanceRequest[];
}

export interface BatchSyncInstancesResponse {
}

export interface BatchUpdateInstancesRequest {
  /** The request message specifying the resources to update. */
  requests: UpdateInstanceRequest[];
}

export interface BatchUpdateInstancesResponse {
  instances: Instance[];
}

export interface AddDataSourceRequest {
  /**
   * The name of the instance to add a data source to.
   * Format: instances/{instance}
   */
  name: string;
  /**
   * Identified by data source ID.
   * Only READ_ONLY data source can be added.
   */
  dataSource:
    | DataSource
    | undefined;
  /** Validate only also tests the data source connection. */
  validateOnly: boolean;
}

export interface RemoveDataSourceRequest {
  /**
   * The name of the instance to remove a data source from.
   * Format: instances/{instance}
   */
  name: string;
  /**
   * Identified by data source ID.
   * Only READ_ONLY data source can be removed.
   */
  dataSource: DataSource | undefined;
}

export interface UpdateDataSourceRequest {
  /**
   * The name of the instance to update a data source.
   * Format: instances/{instance}
   */
  name: string;
  /** Identified by data source ID. */
  dataSource:
    | DataSource
    | undefined;
  /** The list of fields to update. */
  updateMask:
    | string[]
    | undefined;
  /** Validate only also tests the data source connection. */
  validateOnly: boolean;
}

export interface Instance {
  /**
   * The name of the instance.
   * Format: instances/{instance}
   */
  name: string;
  state: State;
  title: string;
  engine: Engine;
  engineVersion: string;
  externalLink: string;
  dataSources: DataSource[];
  /**
   * The environment resource.
   * Format: environments/prod where prod is the environment resource ID.
   */
  environment: string;
  activation: boolean;
  roles: InstanceRole[];
  /** How often the instance is synced. */
  syncInterval:
    | Duration
    | undefined;
  /**
   * The maximum number of connections.
   * The default is 10 if the value is unset or zero.
   */
  maximumConnections: number;
  /**
   * Enable sync for following databases.
   * Default empty, means sync all schemas & databases.
   */
  syncDatabases: string[];
  /** The last time the instance was synced. */
  lastSyncTime: Timestamp | undefined;
}

export interface DataSourceExternalSecret {
  secretType: DataSourceExternalSecret_SecretType;
  url: string;
  authType: DataSourceExternalSecret_AuthType;
  appRole?: DataSourceExternalSecret_AppRoleAuthOption | undefined;
  token?:
    | string
    | undefined;
  /** engine name is the name for secret engine. */
  engineName: string;
  /** the secret name in the engine to store the password. */
  secretName: string;
  /** the key name for the password. */
  passwordKeyName: string;
}

export enum DataSourceExternalSecret_SecretType {
  SAECRET_TYPE_UNSPECIFIED = "SAECRET_TYPE_UNSPECIFIED",
  /** VAULT_KV_V2 - ref: https://developer.hashicorp.com/vault/api-docs/secret/kv/kv-v2 */
  VAULT_KV_V2 = "VAULT_KV_V2",
  /** AWS_SECRETS_MANAGER - ref: https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html */
  AWS_SECRETS_MANAGER = "AWS_SECRETS_MANAGER",
  /** GCP_SECRET_MANAGER - ref: https://cloud.google.com/secret-manager/docs */
  GCP_SECRET_MANAGER = "GCP_SECRET_MANAGER",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function dataSourceExternalSecret_SecretTypeFromJSON(object: any): DataSourceExternalSecret_SecretType {
  switch (object) {
    case 0:
    case "SAECRET_TYPE_UNSPECIFIED":
      return DataSourceExternalSecret_SecretType.SAECRET_TYPE_UNSPECIFIED;
    case 1:
    case "VAULT_KV_V2":
      return DataSourceExternalSecret_SecretType.VAULT_KV_V2;
    case 2:
    case "AWS_SECRETS_MANAGER":
      return DataSourceExternalSecret_SecretType.AWS_SECRETS_MANAGER;
    case 3:
    case "GCP_SECRET_MANAGER":
      return DataSourceExternalSecret_SecretType.GCP_SECRET_MANAGER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DataSourceExternalSecret_SecretType.UNRECOGNIZED;
  }
}

export function dataSourceExternalSecret_SecretTypeToJSON(object: DataSourceExternalSecret_SecretType): string {
  switch (object) {
    case DataSourceExternalSecret_SecretType.SAECRET_TYPE_UNSPECIFIED:
      return "SAECRET_TYPE_UNSPECIFIED";
    case DataSourceExternalSecret_SecretType.VAULT_KV_V2:
      return "VAULT_KV_V2";
    case DataSourceExternalSecret_SecretType.AWS_SECRETS_MANAGER:
      return "AWS_SECRETS_MANAGER";
    case DataSourceExternalSecret_SecretType.GCP_SECRET_MANAGER:
      return "GCP_SECRET_MANAGER";
    case DataSourceExternalSecret_SecretType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function dataSourceExternalSecret_SecretTypeToNumber(object: DataSourceExternalSecret_SecretType): number {
  switch (object) {
    case DataSourceExternalSecret_SecretType.SAECRET_TYPE_UNSPECIFIED:
      return 0;
    case DataSourceExternalSecret_SecretType.VAULT_KV_V2:
      return 1;
    case DataSourceExternalSecret_SecretType.AWS_SECRETS_MANAGER:
      return 2;
    case DataSourceExternalSecret_SecretType.GCP_SECRET_MANAGER:
      return 3;
    case DataSourceExternalSecret_SecretType.UNRECOGNIZED:
    default:
      return -1;
  }
}

export enum DataSourceExternalSecret_AuthType {
  AUTH_TYPE_UNSPECIFIED = "AUTH_TYPE_UNSPECIFIED",
  /** TOKEN - ref: https://developer.hashicorp.com/vault/docs/auth/token */
  TOKEN = "TOKEN",
  /** VAULT_APP_ROLE - ref: https://developer.hashicorp.com/vault/docs/auth/approle */
  VAULT_APP_ROLE = "VAULT_APP_ROLE",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function dataSourceExternalSecret_AuthTypeFromJSON(object: any): DataSourceExternalSecret_AuthType {
  switch (object) {
    case 0:
    case "AUTH_TYPE_UNSPECIFIED":
      return DataSourceExternalSecret_AuthType.AUTH_TYPE_UNSPECIFIED;
    case 1:
    case "TOKEN":
      return DataSourceExternalSecret_AuthType.TOKEN;
    case 2:
    case "VAULT_APP_ROLE":
      return DataSourceExternalSecret_AuthType.VAULT_APP_ROLE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DataSourceExternalSecret_AuthType.UNRECOGNIZED;
  }
}

export function dataSourceExternalSecret_AuthTypeToJSON(object: DataSourceExternalSecret_AuthType): string {
  switch (object) {
    case DataSourceExternalSecret_AuthType.AUTH_TYPE_UNSPECIFIED:
      return "AUTH_TYPE_UNSPECIFIED";
    case DataSourceExternalSecret_AuthType.TOKEN:
      return "TOKEN";
    case DataSourceExternalSecret_AuthType.VAULT_APP_ROLE:
      return "VAULT_APP_ROLE";
    case DataSourceExternalSecret_AuthType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function dataSourceExternalSecret_AuthTypeToNumber(object: DataSourceExternalSecret_AuthType): number {
  switch (object) {
    case DataSourceExternalSecret_AuthType.AUTH_TYPE_UNSPECIFIED:
      return 0;
    case DataSourceExternalSecret_AuthType.TOKEN:
      return 1;
    case DataSourceExternalSecret_AuthType.VAULT_APP_ROLE:
      return 2;
    case DataSourceExternalSecret_AuthType.UNRECOGNIZED:
    default:
      return -1;
  }
}

export interface DataSourceExternalSecret_AppRoleAuthOption {
  roleId: string;
  /** the secret id for the role without ttl. */
  secretId: string;
  type: DataSourceExternalSecret_AppRoleAuthOption_SecretType;
  /** The path where the approle auth method is mounted. */
  mountPath: string;
}

export enum DataSourceExternalSecret_AppRoleAuthOption_SecretType {
  SECRET_TYPE_UNSPECIFIED = "SECRET_TYPE_UNSPECIFIED",
  PLAIN = "PLAIN",
  ENVIRONMENT = "ENVIRONMENT",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function dataSourceExternalSecret_AppRoleAuthOption_SecretTypeFromJSON(
  object: any,
): DataSourceExternalSecret_AppRoleAuthOption_SecretType {
  switch (object) {
    case 0:
    case "SECRET_TYPE_UNSPECIFIED":
      return DataSourceExternalSecret_AppRoleAuthOption_SecretType.SECRET_TYPE_UNSPECIFIED;
    case 1:
    case "PLAIN":
      return DataSourceExternalSecret_AppRoleAuthOption_SecretType.PLAIN;
    case 2:
    case "ENVIRONMENT":
      return DataSourceExternalSecret_AppRoleAuthOption_SecretType.ENVIRONMENT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DataSourceExternalSecret_AppRoleAuthOption_SecretType.UNRECOGNIZED;
  }
}

export function dataSourceExternalSecret_AppRoleAuthOption_SecretTypeToJSON(
  object: DataSourceExternalSecret_AppRoleAuthOption_SecretType,
): string {
  switch (object) {
    case DataSourceExternalSecret_AppRoleAuthOption_SecretType.SECRET_TYPE_UNSPECIFIED:
      return "SECRET_TYPE_UNSPECIFIED";
    case DataSourceExternalSecret_AppRoleAuthOption_SecretType.PLAIN:
      return "PLAIN";
    case DataSourceExternalSecret_AppRoleAuthOption_SecretType.ENVIRONMENT:
      return "ENVIRONMENT";
    case DataSourceExternalSecret_AppRoleAuthOption_SecretType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function dataSourceExternalSecret_AppRoleAuthOption_SecretTypeToNumber(
  object: DataSourceExternalSecret_AppRoleAuthOption_SecretType,
): number {
  switch (object) {
    case DataSourceExternalSecret_AppRoleAuthOption_SecretType.SECRET_TYPE_UNSPECIFIED:
      return 0;
    case DataSourceExternalSecret_AppRoleAuthOption_SecretType.PLAIN:
      return 1;
    case DataSourceExternalSecret_AppRoleAuthOption_SecretType.ENVIRONMENT:
      return 2;
    case DataSourceExternalSecret_AppRoleAuthOption_SecretType.UNRECOGNIZED:
    default:
      return -1;
  }
}

export interface DataSource {
  id: string;
  type: DataSourceType;
  username: string;
  password: string;
  /** Use SSL to connect to the data source. By default, we use system default SSL configuration. */
  useSsl: boolean;
  sslCa: string;
  sslCert: string;
  sslKey: string;
  host: string;
  port: string;
  database: string;
  /**
   * srv, authentication_database and replica_set are used for MongoDB.
   * srv is a boolean flag that indicates whether the host is a DNS SRV record.
   */
  srv: boolean;
  /** authentication_database is the database name to authenticate against, which stores the user credentials. */
  authenticationDatabase: string;
  /** replica_set is used for MongoDB replica set. */
  replicaSet: string;
  /** sid and service_name are used for Oracle. */
  sid: string;
  serviceName: string;
  /**
   * Connection over SSH.
   * The hostname of the SSH server agent.
   * Required.
   */
  sshHost: string;
  /**
   * The port of the SSH server agent. It's 22 typically.
   * Required.
   */
  sshPort: string;
  /**
   * The user to login the server.
   * Required.
   */
  sshUser: string;
  /** The password to login the server. If it's empty string, no password is required. */
  sshPassword: string;
  /** The private key to login the server. If it's empty string, we will use the system default private key from os.Getenv("SSH_AUTH_SOCK"). */
  sshPrivateKey: string;
  /**
   * PKCS#8 private key in PEM format. If it's empty string, no private key is required.
   * Used for authentication when connecting to the data source.
   */
  authenticationPrivateKey: string;
  externalSecret: DataSourceExternalSecret | undefined;
  authenticationType: DataSource_AuthenticationType;
  clientSecretCredential?: DataSource_ClientSecretCredential | undefined;
  saslConfig:
    | SASLConfig
    | undefined;
  /** additional_addresses is used for MongoDB replica set. */
  additionalAddresses: DataSource_Address[];
  /** direct_connection is used for MongoDB to dispatch all the operations to the node specified in the connection string. */
  directConnection: boolean;
  /** region is the location of where the DB is, works for AWS RDS. For example, us-east-1. */
  region: string;
  /** warehouse_id is used by Databricks. */
  warehouseId: string;
  /** master_name is the master name used by connecting redis-master via redis sentinel. */
  masterName: string;
  /** master_username and master_password are master credentials used by redis sentinel mode. */
  masterUsername: string;
  masterPassword: string;
  redisType: DataSource_RedisType;
  /** Cluster is the cluster name for the data source. Used by CockroachDB. */
  cluster: string;
  /**
   * Extra connection parameters for the database connection.
   * For PostgreSQL HA, this can be used to set target_session_attrs=read-write
   */
  extraConnectionParameters: { [key: string]: string };
}

export enum DataSource_AuthenticationType {
  AUTHENTICATION_UNSPECIFIED = "AUTHENTICATION_UNSPECIFIED",
  PASSWORD = "PASSWORD",
  GOOGLE_CLOUD_SQL_IAM = "GOOGLE_CLOUD_SQL_IAM",
  AWS_RDS_IAM = "AWS_RDS_IAM",
  AZURE_IAM = "AZURE_IAM",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function dataSource_AuthenticationTypeFromJSON(object: any): DataSource_AuthenticationType {
  switch (object) {
    case 0:
    case "AUTHENTICATION_UNSPECIFIED":
      return DataSource_AuthenticationType.AUTHENTICATION_UNSPECIFIED;
    case 1:
    case "PASSWORD":
      return DataSource_AuthenticationType.PASSWORD;
    case 2:
    case "GOOGLE_CLOUD_SQL_IAM":
      return DataSource_AuthenticationType.GOOGLE_CLOUD_SQL_IAM;
    case 3:
    case "AWS_RDS_IAM":
      return DataSource_AuthenticationType.AWS_RDS_IAM;
    case 4:
    case "AZURE_IAM":
      return DataSource_AuthenticationType.AZURE_IAM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DataSource_AuthenticationType.UNRECOGNIZED;
  }
}

export function dataSource_AuthenticationTypeToJSON(object: DataSource_AuthenticationType): string {
  switch (object) {
    case DataSource_AuthenticationType.AUTHENTICATION_UNSPECIFIED:
      return "AUTHENTICATION_UNSPECIFIED";
    case DataSource_AuthenticationType.PASSWORD:
      return "PASSWORD";
    case DataSource_AuthenticationType.GOOGLE_CLOUD_SQL_IAM:
      return "GOOGLE_CLOUD_SQL_IAM";
    case DataSource_AuthenticationType.AWS_RDS_IAM:
      return "AWS_RDS_IAM";
    case DataSource_AuthenticationType.AZURE_IAM:
      return "AZURE_IAM";
    case DataSource_AuthenticationType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function dataSource_AuthenticationTypeToNumber(object: DataSource_AuthenticationType): number {
  switch (object) {
    case DataSource_AuthenticationType.AUTHENTICATION_UNSPECIFIED:
      return 0;
    case DataSource_AuthenticationType.PASSWORD:
      return 1;
    case DataSource_AuthenticationType.GOOGLE_CLOUD_SQL_IAM:
      return 2;
    case DataSource_AuthenticationType.AWS_RDS_IAM:
      return 3;
    case DataSource_AuthenticationType.AZURE_IAM:
      return 4;
    case DataSource_AuthenticationType.UNRECOGNIZED:
    default:
      return -1;
  }
}

export enum DataSource_RedisType {
  REDIS_TYPE_UNSPECIFIED = "REDIS_TYPE_UNSPECIFIED",
  STANDALONE = "STANDALONE",
  SENTINEL = "SENTINEL",
  CLUSTER = "CLUSTER",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function dataSource_RedisTypeFromJSON(object: any): DataSource_RedisType {
  switch (object) {
    case 0:
    case "REDIS_TYPE_UNSPECIFIED":
      return DataSource_RedisType.REDIS_TYPE_UNSPECIFIED;
    case 1:
    case "STANDALONE":
      return DataSource_RedisType.STANDALONE;
    case 2:
    case "SENTINEL":
      return DataSource_RedisType.SENTINEL;
    case 3:
    case "CLUSTER":
      return DataSource_RedisType.CLUSTER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DataSource_RedisType.UNRECOGNIZED;
  }
}

export function dataSource_RedisTypeToJSON(object: DataSource_RedisType): string {
  switch (object) {
    case DataSource_RedisType.REDIS_TYPE_UNSPECIFIED:
      return "REDIS_TYPE_UNSPECIFIED";
    case DataSource_RedisType.STANDALONE:
      return "STANDALONE";
    case DataSource_RedisType.SENTINEL:
      return "SENTINEL";
    case DataSource_RedisType.CLUSTER:
      return "CLUSTER";
    case DataSource_RedisType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function dataSource_RedisTypeToNumber(object: DataSource_RedisType): number {
  switch (object) {
    case DataSource_RedisType.REDIS_TYPE_UNSPECIFIED:
      return 0;
    case DataSource_RedisType.STANDALONE:
      return 1;
    case DataSource_RedisType.SENTINEL:
      return 2;
    case DataSource_RedisType.CLUSTER:
      return 3;
    case DataSource_RedisType.UNRECOGNIZED:
    default:
      return -1;
  }
}

export interface DataSource_ClientSecretCredential {
  tenantId: string;
  clientId: string;
  clientSecret: string;
}

export interface DataSource_Address {
  host: string;
  port: string;
}

export interface DataSource_ExtraConnectionParametersEntry {
  key: string;
  value: string;
}

export interface InstanceResource {
  title: string;
  engine: Engine;
  engineVersion: string;
  dataSources: DataSource[];
  activation: boolean;
  /**
   * The name of the instance.
   * Format: instances/{instance}
   */
  name: string;
  /**
   * The environment resource.
   * Format: environments/prod where prod is the environment resource ID.
   */
  environment: string;
}

export interface SASLConfig {
  krbConfig?: KerberosConfig | undefined;
}

export interface KerberosConfig {
  primary: string;
  instance: string;
  realm: string;
  keytab: Uint8Array;
  kdcHost: string;
  kdcPort: string;
  kdcTransportProtocol: string;
}

function createBaseGetInstanceRequest(): GetInstanceRequest {
  return { name: "" };
}

export const GetInstanceRequest: MessageFns<GetInstanceRequest> = {
  encode(message: GetInstanceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetInstanceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetInstanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetInstanceRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetInstanceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetInstanceRequest>): GetInstanceRequest {
    return GetInstanceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetInstanceRequest>): GetInstanceRequest {
    const message = createBaseGetInstanceRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListInstancesRequest(): ListInstancesRequest {
  return { pageSize: 0, pageToken: "", showDeleted: false, filter: "" };
}

export const ListInstancesRequest: MessageFns<ListInstancesRequest> = {
  encode(message: ListInstancesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pageSize !== 0) {
      writer.uint32(8).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(18).string(message.pageToken);
    }
    if (message.showDeleted !== false) {
      writer.uint32(24).bool(message.showDeleted);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListInstancesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListInstancesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.showDeleted = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListInstancesRequest {
    return {
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      showDeleted: isSet(object.showDeleted) ? globalThis.Boolean(object.showDeleted) : false,
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListInstancesRequest): unknown {
    const obj: any = {};
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.showDeleted !== false) {
      obj.showDeleted = message.showDeleted;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListInstancesRequest>): ListInstancesRequest {
    return ListInstancesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListInstancesRequest>): ListInstancesRequest {
    const message = createBaseListInstancesRequest();
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.showDeleted = object.showDeleted ?? false;
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListInstancesResponse(): ListInstancesResponse {
  return { instances: [], nextPageToken: "" };
}

export const ListInstancesResponse: MessageFns<ListInstancesResponse> = {
  encode(message: ListInstancesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.instances) {
      Instance.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListInstancesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListInstancesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.instances.push(Instance.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListInstancesResponse {
    return {
      instances: globalThis.Array.isArray(object?.instances)
        ? object.instances.map((e: any) => Instance.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListInstancesResponse): unknown {
    const obj: any = {};
    if (message.instances?.length) {
      obj.instances = message.instances.map((e) => Instance.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListInstancesResponse>): ListInstancesResponse {
    return ListInstancesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListInstancesResponse>): ListInstancesResponse {
    const message = createBaseListInstancesResponse();
    message.instances = object.instances?.map((e) => Instance.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseCreateInstanceRequest(): CreateInstanceRequest {
  return { instance: undefined, instanceId: "", validateOnly: false };
}

export const CreateInstanceRequest: MessageFns<CreateInstanceRequest> = {
  encode(message: CreateInstanceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.instance !== undefined) {
      Instance.encode(message.instance, writer.uint32(10).fork()).join();
    }
    if (message.instanceId !== "") {
      writer.uint32(18).string(message.instanceId);
    }
    if (message.validateOnly !== false) {
      writer.uint32(24).bool(message.validateOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateInstanceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateInstanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.instance = Instance.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.instanceId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateInstanceRequest {
    return {
      instance: isSet(object.instance) ? Instance.fromJSON(object.instance) : undefined,
      instanceId: isSet(object.instanceId) ? globalThis.String(object.instanceId) : "",
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
    };
  },

  toJSON(message: CreateInstanceRequest): unknown {
    const obj: any = {};
    if (message.instance !== undefined) {
      obj.instance = Instance.toJSON(message.instance);
    }
    if (message.instanceId !== "") {
      obj.instanceId = message.instanceId;
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateInstanceRequest>): CreateInstanceRequest {
    return CreateInstanceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateInstanceRequest>): CreateInstanceRequest {
    const message = createBaseCreateInstanceRequest();
    message.instance = (object.instance !== undefined && object.instance !== null)
      ? Instance.fromPartial(object.instance)
      : undefined;
    message.instanceId = object.instanceId ?? "";
    message.validateOnly = object.validateOnly ?? false;
    return message;
  },
};

function createBaseUpdateInstanceRequest(): UpdateInstanceRequest {
  return { instance: undefined, updateMask: undefined };
}

export const UpdateInstanceRequest: MessageFns<UpdateInstanceRequest> = {
  encode(message: UpdateInstanceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.instance !== undefined) {
      Instance.encode(message.instance, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateInstanceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateInstanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.instance = Instance.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateInstanceRequest {
    return {
      instance: isSet(object.instance) ? Instance.fromJSON(object.instance) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateInstanceRequest): unknown {
    const obj: any = {};
    if (message.instance !== undefined) {
      obj.instance = Instance.toJSON(message.instance);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateInstanceRequest>): UpdateInstanceRequest {
    return UpdateInstanceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateInstanceRequest>): UpdateInstanceRequest {
    const message = createBaseUpdateInstanceRequest();
    message.instance = (object.instance !== undefined && object.instance !== null)
      ? Instance.fromPartial(object.instance)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseDeleteInstanceRequest(): DeleteInstanceRequest {
  return { name: "", force: false };
}

export const DeleteInstanceRequest: MessageFns<DeleteInstanceRequest> = {
  encode(message: DeleteInstanceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.force !== false) {
      writer.uint32(16).bool(message.force);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteInstanceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteInstanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.force = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteInstanceRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      force: isSet(object.force) ? globalThis.Boolean(object.force) : false,
    };
  },

  toJSON(message: DeleteInstanceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.force !== false) {
      obj.force = message.force;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteInstanceRequest>): DeleteInstanceRequest {
    return DeleteInstanceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteInstanceRequest>): DeleteInstanceRequest {
    const message = createBaseDeleteInstanceRequest();
    message.name = object.name ?? "";
    message.force = object.force ?? false;
    return message;
  },
};

function createBaseUndeleteInstanceRequest(): UndeleteInstanceRequest {
  return { name: "" };
}

export const UndeleteInstanceRequest: MessageFns<UndeleteInstanceRequest> = {
  encode(message: UndeleteInstanceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UndeleteInstanceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUndeleteInstanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UndeleteInstanceRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: UndeleteInstanceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<UndeleteInstanceRequest>): UndeleteInstanceRequest {
    return UndeleteInstanceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UndeleteInstanceRequest>): UndeleteInstanceRequest {
    const message = createBaseUndeleteInstanceRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseSyncInstanceRequest(): SyncInstanceRequest {
  return { name: "", enableFullSync: false };
}

export const SyncInstanceRequest: MessageFns<SyncInstanceRequest> = {
  encode(message: SyncInstanceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.enableFullSync !== false) {
      writer.uint32(16).bool(message.enableFullSync);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SyncInstanceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncInstanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.enableFullSync = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SyncInstanceRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      enableFullSync: isSet(object.enableFullSync) ? globalThis.Boolean(object.enableFullSync) : false,
    };
  },

  toJSON(message: SyncInstanceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.enableFullSync !== false) {
      obj.enableFullSync = message.enableFullSync;
    }
    return obj;
  },

  create(base?: DeepPartial<SyncInstanceRequest>): SyncInstanceRequest {
    return SyncInstanceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SyncInstanceRequest>): SyncInstanceRequest {
    const message = createBaseSyncInstanceRequest();
    message.name = object.name ?? "";
    message.enableFullSync = object.enableFullSync ?? false;
    return message;
  },
};

function createBaseListInstanceDatabaseRequest(): ListInstanceDatabaseRequest {
  return { name: "", instance: undefined };
}

export const ListInstanceDatabaseRequest: MessageFns<ListInstanceDatabaseRequest> = {
  encode(message: ListInstanceDatabaseRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.instance !== undefined) {
      Instance.encode(message.instance, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListInstanceDatabaseRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListInstanceDatabaseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.instance = Instance.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListInstanceDatabaseRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      instance: isSet(object.instance) ? Instance.fromJSON(object.instance) : undefined,
    };
  },

  toJSON(message: ListInstanceDatabaseRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.instance !== undefined) {
      obj.instance = Instance.toJSON(message.instance);
    }
    return obj;
  },

  create(base?: DeepPartial<ListInstanceDatabaseRequest>): ListInstanceDatabaseRequest {
    return ListInstanceDatabaseRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListInstanceDatabaseRequest>): ListInstanceDatabaseRequest {
    const message = createBaseListInstanceDatabaseRequest();
    message.name = object.name ?? "";
    message.instance = (object.instance !== undefined && object.instance !== null)
      ? Instance.fromPartial(object.instance)
      : undefined;
    return message;
  },
};

function createBaseListInstanceDatabaseResponse(): ListInstanceDatabaseResponse {
  return { databases: [] };
}

export const ListInstanceDatabaseResponse: MessageFns<ListInstanceDatabaseResponse> = {
  encode(message: ListInstanceDatabaseResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.databases) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListInstanceDatabaseResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListInstanceDatabaseResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.databases.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListInstanceDatabaseResponse {
    return {
      databases: globalThis.Array.isArray(object?.databases)
        ? object.databases.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListInstanceDatabaseResponse): unknown {
    const obj: any = {};
    if (message.databases?.length) {
      obj.databases = message.databases;
    }
    return obj;
  },

  create(base?: DeepPartial<ListInstanceDatabaseResponse>): ListInstanceDatabaseResponse {
    return ListInstanceDatabaseResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListInstanceDatabaseResponse>): ListInstanceDatabaseResponse {
    const message = createBaseListInstanceDatabaseResponse();
    message.databases = object.databases?.map((e) => e) || [];
    return message;
  },
};

function createBaseSyncInstanceResponse(): SyncInstanceResponse {
  return { databases: [] };
}

export const SyncInstanceResponse: MessageFns<SyncInstanceResponse> = {
  encode(message: SyncInstanceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.databases) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SyncInstanceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncInstanceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.databases.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SyncInstanceResponse {
    return {
      databases: globalThis.Array.isArray(object?.databases)
        ? object.databases.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: SyncInstanceResponse): unknown {
    const obj: any = {};
    if (message.databases?.length) {
      obj.databases = message.databases;
    }
    return obj;
  },

  create(base?: DeepPartial<SyncInstanceResponse>): SyncInstanceResponse {
    return SyncInstanceResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SyncInstanceResponse>): SyncInstanceResponse {
    const message = createBaseSyncInstanceResponse();
    message.databases = object.databases?.map((e) => e) || [];
    return message;
  },
};

function createBaseBatchSyncInstancesRequest(): BatchSyncInstancesRequest {
  return { requests: [] };
}

export const BatchSyncInstancesRequest: MessageFns<BatchSyncInstancesRequest> = {
  encode(message: BatchSyncInstancesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.requests) {
      SyncInstanceRequest.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchSyncInstancesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchSyncInstancesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requests.push(SyncInstanceRequest.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchSyncInstancesRequest {
    return {
      requests: globalThis.Array.isArray(object?.requests)
        ? object.requests.map((e: any) => SyncInstanceRequest.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BatchSyncInstancesRequest): unknown {
    const obj: any = {};
    if (message.requests?.length) {
      obj.requests = message.requests.map((e) => SyncInstanceRequest.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BatchSyncInstancesRequest>): BatchSyncInstancesRequest {
    return BatchSyncInstancesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchSyncInstancesRequest>): BatchSyncInstancesRequest {
    const message = createBaseBatchSyncInstancesRequest();
    message.requests = object.requests?.map((e) => SyncInstanceRequest.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBatchSyncInstancesResponse(): BatchSyncInstancesResponse {
  return {};
}

export const BatchSyncInstancesResponse: MessageFns<BatchSyncInstancesResponse> = {
  encode(_: BatchSyncInstancesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchSyncInstancesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchSyncInstancesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): BatchSyncInstancesResponse {
    return {};
  },

  toJSON(_: BatchSyncInstancesResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<BatchSyncInstancesResponse>): BatchSyncInstancesResponse {
    return BatchSyncInstancesResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<BatchSyncInstancesResponse>): BatchSyncInstancesResponse {
    const message = createBaseBatchSyncInstancesResponse();
    return message;
  },
};

function createBaseBatchUpdateInstancesRequest(): BatchUpdateInstancesRequest {
  return { requests: [] };
}

export const BatchUpdateInstancesRequest: MessageFns<BatchUpdateInstancesRequest> = {
  encode(message: BatchUpdateInstancesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.requests) {
      UpdateInstanceRequest.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchUpdateInstancesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchUpdateInstancesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requests.push(UpdateInstanceRequest.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchUpdateInstancesRequest {
    return {
      requests: globalThis.Array.isArray(object?.requests)
        ? object.requests.map((e: any) => UpdateInstanceRequest.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BatchUpdateInstancesRequest): unknown {
    const obj: any = {};
    if (message.requests?.length) {
      obj.requests = message.requests.map((e) => UpdateInstanceRequest.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BatchUpdateInstancesRequest>): BatchUpdateInstancesRequest {
    return BatchUpdateInstancesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchUpdateInstancesRequest>): BatchUpdateInstancesRequest {
    const message = createBaseBatchUpdateInstancesRequest();
    message.requests = object.requests?.map((e) => UpdateInstanceRequest.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBatchUpdateInstancesResponse(): BatchUpdateInstancesResponse {
  return { instances: [] };
}

export const BatchUpdateInstancesResponse: MessageFns<BatchUpdateInstancesResponse> = {
  encode(message: BatchUpdateInstancesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.instances) {
      Instance.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchUpdateInstancesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchUpdateInstancesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.instances.push(Instance.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchUpdateInstancesResponse {
    return {
      instances: globalThis.Array.isArray(object?.instances)
        ? object.instances.map((e: any) => Instance.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BatchUpdateInstancesResponse): unknown {
    const obj: any = {};
    if (message.instances?.length) {
      obj.instances = message.instances.map((e) => Instance.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BatchUpdateInstancesResponse>): BatchUpdateInstancesResponse {
    return BatchUpdateInstancesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchUpdateInstancesResponse>): BatchUpdateInstancesResponse {
    const message = createBaseBatchUpdateInstancesResponse();
    message.instances = object.instances?.map((e) => Instance.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAddDataSourceRequest(): AddDataSourceRequest {
  return { name: "", dataSource: undefined, validateOnly: false };
}

export const AddDataSourceRequest: MessageFns<AddDataSourceRequest> = {
  encode(message: AddDataSourceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.dataSource !== undefined) {
      DataSource.encode(message.dataSource, writer.uint32(18).fork()).join();
    }
    if (message.validateOnly !== false) {
      writer.uint32(24).bool(message.validateOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddDataSourceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddDataSourceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.dataSource = DataSource.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddDataSourceRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      dataSource: isSet(object.dataSource) ? DataSource.fromJSON(object.dataSource) : undefined,
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
    };
  },

  toJSON(message: AddDataSourceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.dataSource !== undefined) {
      obj.dataSource = DataSource.toJSON(message.dataSource);
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    return obj;
  },

  create(base?: DeepPartial<AddDataSourceRequest>): AddDataSourceRequest {
    return AddDataSourceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AddDataSourceRequest>): AddDataSourceRequest {
    const message = createBaseAddDataSourceRequest();
    message.name = object.name ?? "";
    message.dataSource = (object.dataSource !== undefined && object.dataSource !== null)
      ? DataSource.fromPartial(object.dataSource)
      : undefined;
    message.validateOnly = object.validateOnly ?? false;
    return message;
  },
};

function createBaseRemoveDataSourceRequest(): RemoveDataSourceRequest {
  return { name: "", dataSource: undefined };
}

export const RemoveDataSourceRequest: MessageFns<RemoveDataSourceRequest> = {
  encode(message: RemoveDataSourceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.dataSource !== undefined) {
      DataSource.encode(message.dataSource, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveDataSourceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveDataSourceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.dataSource = DataSource.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveDataSourceRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      dataSource: isSet(object.dataSource) ? DataSource.fromJSON(object.dataSource) : undefined,
    };
  },

  toJSON(message: RemoveDataSourceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.dataSource !== undefined) {
      obj.dataSource = DataSource.toJSON(message.dataSource);
    }
    return obj;
  },

  create(base?: DeepPartial<RemoveDataSourceRequest>): RemoveDataSourceRequest {
    return RemoveDataSourceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RemoveDataSourceRequest>): RemoveDataSourceRequest {
    const message = createBaseRemoveDataSourceRequest();
    message.name = object.name ?? "";
    message.dataSource = (object.dataSource !== undefined && object.dataSource !== null)
      ? DataSource.fromPartial(object.dataSource)
      : undefined;
    return message;
  },
};

function createBaseUpdateDataSourceRequest(): UpdateDataSourceRequest {
  return { name: "", dataSource: undefined, updateMask: undefined, validateOnly: false };
}

export const UpdateDataSourceRequest: MessageFns<UpdateDataSourceRequest> = {
  encode(message: UpdateDataSourceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.dataSource !== undefined) {
      DataSource.encode(message.dataSource, writer.uint32(18).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(26).fork()).join();
    }
    if (message.validateOnly !== false) {
      writer.uint32(32).bool(message.validateOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateDataSourceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateDataSourceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.dataSource = DataSource.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateDataSourceRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      dataSource: isSet(object.dataSource) ? DataSource.fromJSON(object.dataSource) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
    };
  },

  toJSON(message: UpdateDataSourceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.dataSource !== undefined) {
      obj.dataSource = DataSource.toJSON(message.dataSource);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateDataSourceRequest>): UpdateDataSourceRequest {
    return UpdateDataSourceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateDataSourceRequest>): UpdateDataSourceRequest {
    const message = createBaseUpdateDataSourceRequest();
    message.name = object.name ?? "";
    message.dataSource = (object.dataSource !== undefined && object.dataSource !== null)
      ? DataSource.fromPartial(object.dataSource)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    message.validateOnly = object.validateOnly ?? false;
    return message;
  },
};

function createBaseInstance(): Instance {
  return {
    name: "",
    state: State.STATE_UNSPECIFIED,
    title: "",
    engine: Engine.ENGINE_UNSPECIFIED,
    engineVersion: "",
    externalLink: "",
    dataSources: [],
    environment: "",
    activation: false,
    roles: [],
    syncInterval: undefined,
    maximumConnections: 0,
    syncDatabases: [],
    lastSyncTime: undefined,
  };
}

export const Instance: MessageFns<Instance> = {
  encode(message: Instance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.state !== State.STATE_UNSPECIFIED) {
      writer.uint32(24).int32(stateToNumber(message.state));
    }
    if (message.title !== "") {
      writer.uint32(34).string(message.title);
    }
    if (message.engine !== Engine.ENGINE_UNSPECIFIED) {
      writer.uint32(40).int32(engineToNumber(message.engine));
    }
    if (message.engineVersion !== "") {
      writer.uint32(50).string(message.engineVersion);
    }
    if (message.externalLink !== "") {
      writer.uint32(58).string(message.externalLink);
    }
    for (const v of message.dataSources) {
      DataSource.encode(v!, writer.uint32(66).fork()).join();
    }
    if (message.environment !== "") {
      writer.uint32(74).string(message.environment);
    }
    if (message.activation !== false) {
      writer.uint32(80).bool(message.activation);
    }
    for (const v of message.roles) {
      InstanceRole.encode(v!, writer.uint32(98).fork()).join();
    }
    if (message.syncInterval !== undefined) {
      Duration.encode(message.syncInterval, writer.uint32(106).fork()).join();
    }
    if (message.maximumConnections !== 0) {
      writer.uint32(112).int32(message.maximumConnections);
    }
    for (const v of message.syncDatabases) {
      writer.uint32(122).string(v!);
    }
    if (message.lastSyncTime !== undefined) {
      Timestamp.encode(message.lastSyncTime, writer.uint32(130).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Instance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.state = stateFromJSON(reader.int32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.engine = engineFromJSON(reader.int32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.engineVersion = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.externalLink = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.dataSources.push(DataSource.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.environment = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.activation = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.roles.push(InstanceRole.decode(reader, reader.uint32()));
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.syncInterval = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.maximumConnections = reader.int32();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.syncDatabases.push(reader.string());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.lastSyncTime = Timestamp.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Instance {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      state: isSet(object.state) ? stateFromJSON(object.state) : State.STATE_UNSPECIFIED,
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      engine: isSet(object.engine) ? engineFromJSON(object.engine) : Engine.ENGINE_UNSPECIFIED,
      engineVersion: isSet(object.engineVersion) ? globalThis.String(object.engineVersion) : "",
      externalLink: isSet(object.externalLink) ? globalThis.String(object.externalLink) : "",
      dataSources: globalThis.Array.isArray(object?.dataSources)
        ? object.dataSources.map((e: any) => DataSource.fromJSON(e))
        : [],
      environment: isSet(object.environment) ? globalThis.String(object.environment) : "",
      activation: isSet(object.activation) ? globalThis.Boolean(object.activation) : false,
      roles: globalThis.Array.isArray(object?.roles) ? object.roles.map((e: any) => InstanceRole.fromJSON(e)) : [],
      syncInterval: isSet(object.syncInterval) ? Duration.fromJSON(object.syncInterval) : undefined,
      maximumConnections: isSet(object.maximumConnections) ? globalThis.Number(object.maximumConnections) : 0,
      syncDatabases: globalThis.Array.isArray(object?.syncDatabases)
        ? object.syncDatabases.map((e: any) => globalThis.String(e))
        : [],
      lastSyncTime: isSet(object.lastSyncTime) ? fromJsonTimestamp(object.lastSyncTime) : undefined,
    };
  },

  toJSON(message: Instance): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.state !== State.STATE_UNSPECIFIED) {
      obj.state = stateToJSON(message.state);
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.engine !== Engine.ENGINE_UNSPECIFIED) {
      obj.engine = engineToJSON(message.engine);
    }
    if (message.engineVersion !== "") {
      obj.engineVersion = message.engineVersion;
    }
    if (message.externalLink !== "") {
      obj.externalLink = message.externalLink;
    }
    if (message.dataSources?.length) {
      obj.dataSources = message.dataSources.map((e) => DataSource.toJSON(e));
    }
    if (message.environment !== "") {
      obj.environment = message.environment;
    }
    if (message.activation !== false) {
      obj.activation = message.activation;
    }
    if (message.roles?.length) {
      obj.roles = message.roles.map((e) => InstanceRole.toJSON(e));
    }
    if (message.syncInterval !== undefined) {
      obj.syncInterval = Duration.toJSON(message.syncInterval);
    }
    if (message.maximumConnections !== 0) {
      obj.maximumConnections = Math.round(message.maximumConnections);
    }
    if (message.syncDatabases?.length) {
      obj.syncDatabases = message.syncDatabases;
    }
    if (message.lastSyncTime !== undefined) {
      obj.lastSyncTime = fromTimestamp(message.lastSyncTime).toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<Instance>): Instance {
    return Instance.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Instance>): Instance {
    const message = createBaseInstance();
    message.name = object.name ?? "";
    message.state = object.state ?? State.STATE_UNSPECIFIED;
    message.title = object.title ?? "";
    message.engine = object.engine ?? Engine.ENGINE_UNSPECIFIED;
    message.engineVersion = object.engineVersion ?? "";
    message.externalLink = object.externalLink ?? "";
    message.dataSources = object.dataSources?.map((e) => DataSource.fromPartial(e)) || [];
    message.environment = object.environment ?? "";
    message.activation = object.activation ?? false;
    message.roles = object.roles?.map((e) => InstanceRole.fromPartial(e)) || [];
    message.syncInterval = (object.syncInterval !== undefined && object.syncInterval !== null)
      ? Duration.fromPartial(object.syncInterval)
      : undefined;
    message.maximumConnections = object.maximumConnections ?? 0;
    message.syncDatabases = object.syncDatabases?.map((e) => e) || [];
    message.lastSyncTime = (object.lastSyncTime !== undefined && object.lastSyncTime !== null)
      ? Timestamp.fromPartial(object.lastSyncTime)
      : undefined;
    return message;
  },
};

function createBaseDataSourceExternalSecret(): DataSourceExternalSecret {
  return {
    secretType: DataSourceExternalSecret_SecretType.SAECRET_TYPE_UNSPECIFIED,
    url: "",
    authType: DataSourceExternalSecret_AuthType.AUTH_TYPE_UNSPECIFIED,
    appRole: undefined,
    token: undefined,
    engineName: "",
    secretName: "",
    passwordKeyName: "",
  };
}

export const DataSourceExternalSecret: MessageFns<DataSourceExternalSecret> = {
  encode(message: DataSourceExternalSecret, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.secretType !== DataSourceExternalSecret_SecretType.SAECRET_TYPE_UNSPECIFIED) {
      writer.uint32(8).int32(dataSourceExternalSecret_SecretTypeToNumber(message.secretType));
    }
    if (message.url !== "") {
      writer.uint32(18).string(message.url);
    }
    if (message.authType !== DataSourceExternalSecret_AuthType.AUTH_TYPE_UNSPECIFIED) {
      writer.uint32(24).int32(dataSourceExternalSecret_AuthTypeToNumber(message.authType));
    }
    if (message.appRole !== undefined) {
      DataSourceExternalSecret_AppRoleAuthOption.encode(message.appRole, writer.uint32(34).fork()).join();
    }
    if (message.token !== undefined) {
      writer.uint32(42).string(message.token);
    }
    if (message.engineName !== "") {
      writer.uint32(50).string(message.engineName);
    }
    if (message.secretName !== "") {
      writer.uint32(58).string(message.secretName);
    }
    if (message.passwordKeyName !== "") {
      writer.uint32(66).string(message.passwordKeyName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataSourceExternalSecret {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataSourceExternalSecret();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.secretType = dataSourceExternalSecret_SecretTypeFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.authType = dataSourceExternalSecret_AuthTypeFromJSON(reader.int32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.appRole = DataSourceExternalSecret_AppRoleAuthOption.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.token = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.engineName = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.secretName = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.passwordKeyName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataSourceExternalSecret {
    return {
      secretType: isSet(object.secretType)
        ? dataSourceExternalSecret_SecretTypeFromJSON(object.secretType)
        : DataSourceExternalSecret_SecretType.SAECRET_TYPE_UNSPECIFIED,
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      authType: isSet(object.authType)
        ? dataSourceExternalSecret_AuthTypeFromJSON(object.authType)
        : DataSourceExternalSecret_AuthType.AUTH_TYPE_UNSPECIFIED,
      appRole: isSet(object.appRole) ? DataSourceExternalSecret_AppRoleAuthOption.fromJSON(object.appRole) : undefined,
      token: isSet(object.token) ? globalThis.String(object.token) : undefined,
      engineName: isSet(object.engineName) ? globalThis.String(object.engineName) : "",
      secretName: isSet(object.secretName) ? globalThis.String(object.secretName) : "",
      passwordKeyName: isSet(object.passwordKeyName) ? globalThis.String(object.passwordKeyName) : "",
    };
  },

  toJSON(message: DataSourceExternalSecret): unknown {
    const obj: any = {};
    if (message.secretType !== DataSourceExternalSecret_SecretType.SAECRET_TYPE_UNSPECIFIED) {
      obj.secretType = dataSourceExternalSecret_SecretTypeToJSON(message.secretType);
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.authType !== DataSourceExternalSecret_AuthType.AUTH_TYPE_UNSPECIFIED) {
      obj.authType = dataSourceExternalSecret_AuthTypeToJSON(message.authType);
    }
    if (message.appRole !== undefined) {
      obj.appRole = DataSourceExternalSecret_AppRoleAuthOption.toJSON(message.appRole);
    }
    if (message.token !== undefined) {
      obj.token = message.token;
    }
    if (message.engineName !== "") {
      obj.engineName = message.engineName;
    }
    if (message.secretName !== "") {
      obj.secretName = message.secretName;
    }
    if (message.passwordKeyName !== "") {
      obj.passwordKeyName = message.passwordKeyName;
    }
    return obj;
  },

  create(base?: DeepPartial<DataSourceExternalSecret>): DataSourceExternalSecret {
    return DataSourceExternalSecret.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataSourceExternalSecret>): DataSourceExternalSecret {
    const message = createBaseDataSourceExternalSecret();
    message.secretType = object.secretType ?? DataSourceExternalSecret_SecretType.SAECRET_TYPE_UNSPECIFIED;
    message.url = object.url ?? "";
    message.authType = object.authType ?? DataSourceExternalSecret_AuthType.AUTH_TYPE_UNSPECIFIED;
    message.appRole = (object.appRole !== undefined && object.appRole !== null)
      ? DataSourceExternalSecret_AppRoleAuthOption.fromPartial(object.appRole)
      : undefined;
    message.token = object.token ?? undefined;
    message.engineName = object.engineName ?? "";
    message.secretName = object.secretName ?? "";
    message.passwordKeyName = object.passwordKeyName ?? "";
    return message;
  },
};

function createBaseDataSourceExternalSecret_AppRoleAuthOption(): DataSourceExternalSecret_AppRoleAuthOption {
  return {
    roleId: "",
    secretId: "",
    type: DataSourceExternalSecret_AppRoleAuthOption_SecretType.SECRET_TYPE_UNSPECIFIED,
    mountPath: "",
  };
}

export const DataSourceExternalSecret_AppRoleAuthOption: MessageFns<DataSourceExternalSecret_AppRoleAuthOption> = {
  encode(message: DataSourceExternalSecret_AppRoleAuthOption, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.roleId !== "") {
      writer.uint32(10).string(message.roleId);
    }
    if (message.secretId !== "") {
      writer.uint32(18).string(message.secretId);
    }
    if (message.type !== DataSourceExternalSecret_AppRoleAuthOption_SecretType.SECRET_TYPE_UNSPECIFIED) {
      writer.uint32(24).int32(dataSourceExternalSecret_AppRoleAuthOption_SecretTypeToNumber(message.type));
    }
    if (message.mountPath !== "") {
      writer.uint32(34).string(message.mountPath);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataSourceExternalSecret_AppRoleAuthOption {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataSourceExternalSecret_AppRoleAuthOption();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.roleId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.secretId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.type = dataSourceExternalSecret_AppRoleAuthOption_SecretTypeFromJSON(reader.int32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.mountPath = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataSourceExternalSecret_AppRoleAuthOption {
    return {
      roleId: isSet(object.roleId) ? globalThis.String(object.roleId) : "",
      secretId: isSet(object.secretId) ? globalThis.String(object.secretId) : "",
      type: isSet(object.type)
        ? dataSourceExternalSecret_AppRoleAuthOption_SecretTypeFromJSON(object.type)
        : DataSourceExternalSecret_AppRoleAuthOption_SecretType.SECRET_TYPE_UNSPECIFIED,
      mountPath: isSet(object.mountPath) ? globalThis.String(object.mountPath) : "",
    };
  },

  toJSON(message: DataSourceExternalSecret_AppRoleAuthOption): unknown {
    const obj: any = {};
    if (message.roleId !== "") {
      obj.roleId = message.roleId;
    }
    if (message.secretId !== "") {
      obj.secretId = message.secretId;
    }
    if (message.type !== DataSourceExternalSecret_AppRoleAuthOption_SecretType.SECRET_TYPE_UNSPECIFIED) {
      obj.type = dataSourceExternalSecret_AppRoleAuthOption_SecretTypeToJSON(message.type);
    }
    if (message.mountPath !== "") {
      obj.mountPath = message.mountPath;
    }
    return obj;
  },

  create(base?: DeepPartial<DataSourceExternalSecret_AppRoleAuthOption>): DataSourceExternalSecret_AppRoleAuthOption {
    return DataSourceExternalSecret_AppRoleAuthOption.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<DataSourceExternalSecret_AppRoleAuthOption>,
  ): DataSourceExternalSecret_AppRoleAuthOption {
    const message = createBaseDataSourceExternalSecret_AppRoleAuthOption();
    message.roleId = object.roleId ?? "";
    message.secretId = object.secretId ?? "";
    message.type = object.type ?? DataSourceExternalSecret_AppRoleAuthOption_SecretType.SECRET_TYPE_UNSPECIFIED;
    message.mountPath = object.mountPath ?? "";
    return message;
  },
};

function createBaseDataSource(): DataSource {
  return {
    id: "",
    type: DataSourceType.DATA_SOURCE_UNSPECIFIED,
    username: "",
    password: "",
    useSsl: false,
    sslCa: "",
    sslCert: "",
    sslKey: "",
    host: "",
    port: "",
    database: "",
    srv: false,
    authenticationDatabase: "",
    replicaSet: "",
    sid: "",
    serviceName: "",
    sshHost: "",
    sshPort: "",
    sshUser: "",
    sshPassword: "",
    sshPrivateKey: "",
    authenticationPrivateKey: "",
    externalSecret: undefined,
    authenticationType: DataSource_AuthenticationType.AUTHENTICATION_UNSPECIFIED,
    clientSecretCredential: undefined,
    saslConfig: undefined,
    additionalAddresses: [],
    directConnection: false,
    region: "",
    warehouseId: "",
    masterName: "",
    masterUsername: "",
    masterPassword: "",
    redisType: DataSource_RedisType.REDIS_TYPE_UNSPECIFIED,
    cluster: "",
    extraConnectionParameters: {},
  };
}

export const DataSource: MessageFns<DataSource> = {
  encode(message: DataSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.type !== DataSourceType.DATA_SOURCE_UNSPECIFIED) {
      writer.uint32(16).int32(dataSourceTypeToNumber(message.type));
    }
    if (message.username !== "") {
      writer.uint32(26).string(message.username);
    }
    if (message.password !== "") {
      writer.uint32(34).string(message.password);
    }
    if (message.useSsl !== false) {
      writer.uint32(240).bool(message.useSsl);
    }
    if (message.sslCa !== "") {
      writer.uint32(42).string(message.sslCa);
    }
    if (message.sslCert !== "") {
      writer.uint32(50).string(message.sslCert);
    }
    if (message.sslKey !== "") {
      writer.uint32(58).string(message.sslKey);
    }
    if (message.host !== "") {
      writer.uint32(66).string(message.host);
    }
    if (message.port !== "") {
      writer.uint32(74).string(message.port);
    }
    if (message.database !== "") {
      writer.uint32(82).string(message.database);
    }
    if (message.srv !== false) {
      writer.uint32(88).bool(message.srv);
    }
    if (message.authenticationDatabase !== "") {
      writer.uint32(98).string(message.authenticationDatabase);
    }
    if (message.replicaSet !== "") {
      writer.uint32(202).string(message.replicaSet);
    }
    if (message.sid !== "") {
      writer.uint32(106).string(message.sid);
    }
    if (message.serviceName !== "") {
      writer.uint32(114).string(message.serviceName);
    }
    if (message.sshHost !== "") {
      writer.uint32(122).string(message.sshHost);
    }
    if (message.sshPort !== "") {
      writer.uint32(130).string(message.sshPort);
    }
    if (message.sshUser !== "") {
      writer.uint32(138).string(message.sshUser);
    }
    if (message.sshPassword !== "") {
      writer.uint32(146).string(message.sshPassword);
    }
    if (message.sshPrivateKey !== "") {
      writer.uint32(154).string(message.sshPrivateKey);
    }
    if (message.authenticationPrivateKey !== "") {
      writer.uint32(162).string(message.authenticationPrivateKey);
    }
    if (message.externalSecret !== undefined) {
      DataSourceExternalSecret.encode(message.externalSecret, writer.uint32(170).fork()).join();
    }
    if (message.authenticationType !== DataSource_AuthenticationType.AUTHENTICATION_UNSPECIFIED) {
      writer.uint32(176).int32(dataSource_AuthenticationTypeToNumber(message.authenticationType));
    }
    if (message.clientSecretCredential !== undefined) {
      DataSource_ClientSecretCredential.encode(message.clientSecretCredential, writer.uint32(186).fork()).join();
    }
    if (message.saslConfig !== undefined) {
      SASLConfig.encode(message.saslConfig, writer.uint32(194).fork()).join();
    }
    for (const v of message.additionalAddresses) {
      DataSource_Address.encode(v!, writer.uint32(210).fork()).join();
    }
    if (message.directConnection !== false) {
      writer.uint32(216).bool(message.directConnection);
    }
    if (message.region !== "") {
      writer.uint32(226).string(message.region);
    }
    if (message.warehouseId !== "") {
      writer.uint32(234).string(message.warehouseId);
    }
    if (message.masterName !== "") {
      writer.uint32(250).string(message.masterName);
    }
    if (message.masterUsername !== "") {
      writer.uint32(258).string(message.masterUsername);
    }
    if (message.masterPassword !== "") {
      writer.uint32(266).string(message.masterPassword);
    }
    if (message.redisType !== DataSource_RedisType.REDIS_TYPE_UNSPECIFIED) {
      writer.uint32(272).int32(dataSource_RedisTypeToNumber(message.redisType));
    }
    if (message.cluster !== "") {
      writer.uint32(282).string(message.cluster);
    }
    Object.entries(message.extraConnectionParameters).forEach(([key, value]) => {
      DataSource_ExtraConnectionParametersEntry.encode({ key: key as any, value }, writer.uint32(290).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.type = dataSourceTypeFromJSON(reader.int32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.password = reader.string();
          continue;
        }
        case 30: {
          if (tag !== 240) {
            break;
          }

          message.useSsl = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.sslCa = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.sslCert = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.sslKey = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.host = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.port = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.database = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.srv = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.authenticationDatabase = reader.string();
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.replicaSet = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.sid = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.serviceName = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.sshHost = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.sshPort = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.sshUser = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.sshPassword = reader.string();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.sshPrivateKey = reader.string();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.authenticationPrivateKey = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.externalSecret = DataSourceExternalSecret.decode(reader, reader.uint32());
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }

          message.authenticationType = dataSource_AuthenticationTypeFromJSON(reader.int32());
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.clientSecretCredential = DataSource_ClientSecretCredential.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.saslConfig = SASLConfig.decode(reader, reader.uint32());
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.additionalAddresses.push(DataSource_Address.decode(reader, reader.uint32()));
          continue;
        }
        case 27: {
          if (tag !== 216) {
            break;
          }

          message.directConnection = reader.bool();
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }

          message.region = reader.string();
          continue;
        }
        case 29: {
          if (tag !== 234) {
            break;
          }

          message.warehouseId = reader.string();
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }

          message.masterName = reader.string();
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }

          message.masterUsername = reader.string();
          continue;
        }
        case 33: {
          if (tag !== 266) {
            break;
          }

          message.masterPassword = reader.string();
          continue;
        }
        case 34: {
          if (tag !== 272) {
            break;
          }

          message.redisType = dataSource_RedisTypeFromJSON(reader.int32());
          continue;
        }
        case 35: {
          if (tag !== 282) {
            break;
          }

          message.cluster = reader.string();
          continue;
        }
        case 36: {
          if (tag !== 290) {
            break;
          }

          const entry36 = DataSource_ExtraConnectionParametersEntry.decode(reader, reader.uint32());
          if (entry36.value !== undefined) {
            message.extraConnectionParameters[entry36.key] = entry36.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataSource {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      type: isSet(object.type) ? dataSourceTypeFromJSON(object.type) : DataSourceType.DATA_SOURCE_UNSPECIFIED,
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
      useSsl: isSet(object.useSsl) ? globalThis.Boolean(object.useSsl) : false,
      sslCa: isSet(object.sslCa) ? globalThis.String(object.sslCa) : "",
      sslCert: isSet(object.sslCert) ? globalThis.String(object.sslCert) : "",
      sslKey: isSet(object.sslKey) ? globalThis.String(object.sslKey) : "",
      host: isSet(object.host) ? globalThis.String(object.host) : "",
      port: isSet(object.port) ? globalThis.String(object.port) : "",
      database: isSet(object.database) ? globalThis.String(object.database) : "",
      srv: isSet(object.srv) ? globalThis.Boolean(object.srv) : false,
      authenticationDatabase: isSet(object.authenticationDatabase)
        ? globalThis.String(object.authenticationDatabase)
        : "",
      replicaSet: isSet(object.replicaSet) ? globalThis.String(object.replicaSet) : "",
      sid: isSet(object.sid) ? globalThis.String(object.sid) : "",
      serviceName: isSet(object.serviceName) ? globalThis.String(object.serviceName) : "",
      sshHost: isSet(object.sshHost) ? globalThis.String(object.sshHost) : "",
      sshPort: isSet(object.sshPort) ? globalThis.String(object.sshPort) : "",
      sshUser: isSet(object.sshUser) ? globalThis.String(object.sshUser) : "",
      sshPassword: isSet(object.sshPassword) ? globalThis.String(object.sshPassword) : "",
      sshPrivateKey: isSet(object.sshPrivateKey) ? globalThis.String(object.sshPrivateKey) : "",
      authenticationPrivateKey: isSet(object.authenticationPrivateKey)
        ? globalThis.String(object.authenticationPrivateKey)
        : "",
      externalSecret: isSet(object.externalSecret)
        ? DataSourceExternalSecret.fromJSON(object.externalSecret)
        : undefined,
      authenticationType: isSet(object.authenticationType)
        ? dataSource_AuthenticationTypeFromJSON(object.authenticationType)
        : DataSource_AuthenticationType.AUTHENTICATION_UNSPECIFIED,
      clientSecretCredential: isSet(object.clientSecretCredential)
        ? DataSource_ClientSecretCredential.fromJSON(object.clientSecretCredential)
        : undefined,
      saslConfig: isSet(object.saslConfig) ? SASLConfig.fromJSON(object.saslConfig) : undefined,
      additionalAddresses: globalThis.Array.isArray(object?.additionalAddresses)
        ? object.additionalAddresses.map((e: any) => DataSource_Address.fromJSON(e))
        : [],
      directConnection: isSet(object.directConnection) ? globalThis.Boolean(object.directConnection) : false,
      region: isSet(object.region) ? globalThis.String(object.region) : "",
      warehouseId: isSet(object.warehouseId) ? globalThis.String(object.warehouseId) : "",
      masterName: isSet(object.masterName) ? globalThis.String(object.masterName) : "",
      masterUsername: isSet(object.masterUsername) ? globalThis.String(object.masterUsername) : "",
      masterPassword: isSet(object.masterPassword) ? globalThis.String(object.masterPassword) : "",
      redisType: isSet(object.redisType)
        ? dataSource_RedisTypeFromJSON(object.redisType)
        : DataSource_RedisType.REDIS_TYPE_UNSPECIFIED,
      cluster: isSet(object.cluster) ? globalThis.String(object.cluster) : "",
      extraConnectionParameters: isObject(object.extraConnectionParameters)
        ? Object.entries(object.extraConnectionParameters).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: DataSource): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.type !== DataSourceType.DATA_SOURCE_UNSPECIFIED) {
      obj.type = dataSourceTypeToJSON(message.type);
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    if (message.useSsl !== false) {
      obj.useSsl = message.useSsl;
    }
    if (message.sslCa !== "") {
      obj.sslCa = message.sslCa;
    }
    if (message.sslCert !== "") {
      obj.sslCert = message.sslCert;
    }
    if (message.sslKey !== "") {
      obj.sslKey = message.sslKey;
    }
    if (message.host !== "") {
      obj.host = message.host;
    }
    if (message.port !== "") {
      obj.port = message.port;
    }
    if (message.database !== "") {
      obj.database = message.database;
    }
    if (message.srv !== false) {
      obj.srv = message.srv;
    }
    if (message.authenticationDatabase !== "") {
      obj.authenticationDatabase = message.authenticationDatabase;
    }
    if (message.replicaSet !== "") {
      obj.replicaSet = message.replicaSet;
    }
    if (message.sid !== "") {
      obj.sid = message.sid;
    }
    if (message.serviceName !== "") {
      obj.serviceName = message.serviceName;
    }
    if (message.sshHost !== "") {
      obj.sshHost = message.sshHost;
    }
    if (message.sshPort !== "") {
      obj.sshPort = message.sshPort;
    }
    if (message.sshUser !== "") {
      obj.sshUser = message.sshUser;
    }
    if (message.sshPassword !== "") {
      obj.sshPassword = message.sshPassword;
    }
    if (message.sshPrivateKey !== "") {
      obj.sshPrivateKey = message.sshPrivateKey;
    }
    if (message.authenticationPrivateKey !== "") {
      obj.authenticationPrivateKey = message.authenticationPrivateKey;
    }
    if (message.externalSecret !== undefined) {
      obj.externalSecret = DataSourceExternalSecret.toJSON(message.externalSecret);
    }
    if (message.authenticationType !== DataSource_AuthenticationType.AUTHENTICATION_UNSPECIFIED) {
      obj.authenticationType = dataSource_AuthenticationTypeToJSON(message.authenticationType);
    }
    if (message.clientSecretCredential !== undefined) {
      obj.clientSecretCredential = DataSource_ClientSecretCredential.toJSON(message.clientSecretCredential);
    }
    if (message.saslConfig !== undefined) {
      obj.saslConfig = SASLConfig.toJSON(message.saslConfig);
    }
    if (message.additionalAddresses?.length) {
      obj.additionalAddresses = message.additionalAddresses.map((e) => DataSource_Address.toJSON(e));
    }
    if (message.directConnection !== false) {
      obj.directConnection = message.directConnection;
    }
    if (message.region !== "") {
      obj.region = message.region;
    }
    if (message.warehouseId !== "") {
      obj.warehouseId = message.warehouseId;
    }
    if (message.masterName !== "") {
      obj.masterName = message.masterName;
    }
    if (message.masterUsername !== "") {
      obj.masterUsername = message.masterUsername;
    }
    if (message.masterPassword !== "") {
      obj.masterPassword = message.masterPassword;
    }
    if (message.redisType !== DataSource_RedisType.REDIS_TYPE_UNSPECIFIED) {
      obj.redisType = dataSource_RedisTypeToJSON(message.redisType);
    }
    if (message.cluster !== "") {
      obj.cluster = message.cluster;
    }
    if (message.extraConnectionParameters) {
      const entries = Object.entries(message.extraConnectionParameters);
      if (entries.length > 0) {
        obj.extraConnectionParameters = {};
        entries.forEach(([k, v]) => {
          obj.extraConnectionParameters[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<DataSource>): DataSource {
    return DataSource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataSource>): DataSource {
    const message = createBaseDataSource();
    message.id = object.id ?? "";
    message.type = object.type ?? DataSourceType.DATA_SOURCE_UNSPECIFIED;
    message.username = object.username ?? "";
    message.password = object.password ?? "";
    message.useSsl = object.useSsl ?? false;
    message.sslCa = object.sslCa ?? "";
    message.sslCert = object.sslCert ?? "";
    message.sslKey = object.sslKey ?? "";
    message.host = object.host ?? "";
    message.port = object.port ?? "";
    message.database = object.database ?? "";
    message.srv = object.srv ?? false;
    message.authenticationDatabase = object.authenticationDatabase ?? "";
    message.replicaSet = object.replicaSet ?? "";
    message.sid = object.sid ?? "";
    message.serviceName = object.serviceName ?? "";
    message.sshHost = object.sshHost ?? "";
    message.sshPort = object.sshPort ?? "";
    message.sshUser = object.sshUser ?? "";
    message.sshPassword = object.sshPassword ?? "";
    message.sshPrivateKey = object.sshPrivateKey ?? "";
    message.authenticationPrivateKey = object.authenticationPrivateKey ?? "";
    message.externalSecret = (object.externalSecret !== undefined && object.externalSecret !== null)
      ? DataSourceExternalSecret.fromPartial(object.externalSecret)
      : undefined;
    message.authenticationType = object.authenticationType ?? DataSource_AuthenticationType.AUTHENTICATION_UNSPECIFIED;
    message.clientSecretCredential =
      (object.clientSecretCredential !== undefined && object.clientSecretCredential !== null)
        ? DataSource_ClientSecretCredential.fromPartial(object.clientSecretCredential)
        : undefined;
    message.saslConfig = (object.saslConfig !== undefined && object.saslConfig !== null)
      ? SASLConfig.fromPartial(object.saslConfig)
      : undefined;
    message.additionalAddresses = object.additionalAddresses?.map((e) => DataSource_Address.fromPartial(e)) || [];
    message.directConnection = object.directConnection ?? false;
    message.region = object.region ?? "";
    message.warehouseId = object.warehouseId ?? "";
    message.masterName = object.masterName ?? "";
    message.masterUsername = object.masterUsername ?? "";
    message.masterPassword = object.masterPassword ?? "";
    message.redisType = object.redisType ?? DataSource_RedisType.REDIS_TYPE_UNSPECIFIED;
    message.cluster = object.cluster ?? "";
    message.extraConnectionParameters = Object.entries(object.extraConnectionParameters ?? {}).reduce<
      { [key: string]: string }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseDataSource_ClientSecretCredential(): DataSource_ClientSecretCredential {
  return { tenantId: "", clientId: "", clientSecret: "" };
}

export const DataSource_ClientSecretCredential: MessageFns<DataSource_ClientSecretCredential> = {
  encode(message: DataSource_ClientSecretCredential, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tenantId !== "") {
      writer.uint32(10).string(message.tenantId);
    }
    if (message.clientId !== "") {
      writer.uint32(18).string(message.clientId);
    }
    if (message.clientSecret !== "") {
      writer.uint32(26).string(message.clientSecret);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataSource_ClientSecretCredential {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataSource_ClientSecretCredential();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tenantId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.clientSecret = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataSource_ClientSecretCredential {
    return {
      tenantId: isSet(object.tenantId) ? globalThis.String(object.tenantId) : "",
      clientId: isSet(object.clientId) ? globalThis.String(object.clientId) : "",
      clientSecret: isSet(object.clientSecret) ? globalThis.String(object.clientSecret) : "",
    };
  },

  toJSON(message: DataSource_ClientSecretCredential): unknown {
    const obj: any = {};
    if (message.tenantId !== "") {
      obj.tenantId = message.tenantId;
    }
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.clientSecret !== "") {
      obj.clientSecret = message.clientSecret;
    }
    return obj;
  },

  create(base?: DeepPartial<DataSource_ClientSecretCredential>): DataSource_ClientSecretCredential {
    return DataSource_ClientSecretCredential.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataSource_ClientSecretCredential>): DataSource_ClientSecretCredential {
    const message = createBaseDataSource_ClientSecretCredential();
    message.tenantId = object.tenantId ?? "";
    message.clientId = object.clientId ?? "";
    message.clientSecret = object.clientSecret ?? "";
    return message;
  },
};

function createBaseDataSource_Address(): DataSource_Address {
  return { host: "", port: "" };
}

export const DataSource_Address: MessageFns<DataSource_Address> = {
  encode(message: DataSource_Address, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.host !== "") {
      writer.uint32(10).string(message.host);
    }
    if (message.port !== "") {
      writer.uint32(18).string(message.port);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataSource_Address {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataSource_Address();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.host = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.port = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataSource_Address {
    return {
      host: isSet(object.host) ? globalThis.String(object.host) : "",
      port: isSet(object.port) ? globalThis.String(object.port) : "",
    };
  },

  toJSON(message: DataSource_Address): unknown {
    const obj: any = {};
    if (message.host !== "") {
      obj.host = message.host;
    }
    if (message.port !== "") {
      obj.port = message.port;
    }
    return obj;
  },

  create(base?: DeepPartial<DataSource_Address>): DataSource_Address {
    return DataSource_Address.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataSource_Address>): DataSource_Address {
    const message = createBaseDataSource_Address();
    message.host = object.host ?? "";
    message.port = object.port ?? "";
    return message;
  },
};

function createBaseDataSource_ExtraConnectionParametersEntry(): DataSource_ExtraConnectionParametersEntry {
  return { key: "", value: "" };
}

export const DataSource_ExtraConnectionParametersEntry: MessageFns<DataSource_ExtraConnectionParametersEntry> = {
  encode(message: DataSource_ExtraConnectionParametersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataSource_ExtraConnectionParametersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataSource_ExtraConnectionParametersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataSource_ExtraConnectionParametersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: DataSource_ExtraConnectionParametersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<DataSource_ExtraConnectionParametersEntry>): DataSource_ExtraConnectionParametersEntry {
    return DataSource_ExtraConnectionParametersEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<DataSource_ExtraConnectionParametersEntry>,
  ): DataSource_ExtraConnectionParametersEntry {
    const message = createBaseDataSource_ExtraConnectionParametersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseInstanceResource(): InstanceResource {
  return {
    title: "",
    engine: Engine.ENGINE_UNSPECIFIED,
    engineVersion: "",
    dataSources: [],
    activation: false,
    name: "",
    environment: "",
  };
}

export const InstanceResource: MessageFns<InstanceResource> = {
  encode(message: InstanceResource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.engine !== Engine.ENGINE_UNSPECIFIED) {
      writer.uint32(16).int32(engineToNumber(message.engine));
    }
    if (message.engineVersion !== "") {
      writer.uint32(26).string(message.engineVersion);
    }
    for (const v of message.dataSources) {
      DataSource.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.activation !== false) {
      writer.uint32(40).bool(message.activation);
    }
    if (message.name !== "") {
      writer.uint32(50).string(message.name);
    }
    if (message.environment !== "") {
      writer.uint32(58).string(message.environment);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InstanceResource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstanceResource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.engine = engineFromJSON(reader.int32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.engineVersion = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.dataSources.push(DataSource.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.activation = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.environment = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InstanceResource {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      engine: isSet(object.engine) ? engineFromJSON(object.engine) : Engine.ENGINE_UNSPECIFIED,
      engineVersion: isSet(object.engineVersion) ? globalThis.String(object.engineVersion) : "",
      dataSources: globalThis.Array.isArray(object?.dataSources)
        ? object.dataSources.map((e: any) => DataSource.fromJSON(e))
        : [],
      activation: isSet(object.activation) ? globalThis.Boolean(object.activation) : false,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      environment: isSet(object.environment) ? globalThis.String(object.environment) : "",
    };
  },

  toJSON(message: InstanceResource): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.engine !== Engine.ENGINE_UNSPECIFIED) {
      obj.engine = engineToJSON(message.engine);
    }
    if (message.engineVersion !== "") {
      obj.engineVersion = message.engineVersion;
    }
    if (message.dataSources?.length) {
      obj.dataSources = message.dataSources.map((e) => DataSource.toJSON(e));
    }
    if (message.activation !== false) {
      obj.activation = message.activation;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.environment !== "") {
      obj.environment = message.environment;
    }
    return obj;
  },

  create(base?: DeepPartial<InstanceResource>): InstanceResource {
    return InstanceResource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InstanceResource>): InstanceResource {
    const message = createBaseInstanceResource();
    message.title = object.title ?? "";
    message.engine = object.engine ?? Engine.ENGINE_UNSPECIFIED;
    message.engineVersion = object.engineVersion ?? "";
    message.dataSources = object.dataSources?.map((e) => DataSource.fromPartial(e)) || [];
    message.activation = object.activation ?? false;
    message.name = object.name ?? "";
    message.environment = object.environment ?? "";
    return message;
  },
};

function createBaseSASLConfig(): SASLConfig {
  return { krbConfig: undefined };
}

export const SASLConfig: MessageFns<SASLConfig> = {
  encode(message: SASLConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.krbConfig !== undefined) {
      KerberosConfig.encode(message.krbConfig, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SASLConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSASLConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.krbConfig = KerberosConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SASLConfig {
    return { krbConfig: isSet(object.krbConfig) ? KerberosConfig.fromJSON(object.krbConfig) : undefined };
  },

  toJSON(message: SASLConfig): unknown {
    const obj: any = {};
    if (message.krbConfig !== undefined) {
      obj.krbConfig = KerberosConfig.toJSON(message.krbConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<SASLConfig>): SASLConfig {
    return SASLConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SASLConfig>): SASLConfig {
    const message = createBaseSASLConfig();
    message.krbConfig = (object.krbConfig !== undefined && object.krbConfig !== null)
      ? KerberosConfig.fromPartial(object.krbConfig)
      : undefined;
    return message;
  },
};

function createBaseKerberosConfig(): KerberosConfig {
  return {
    primary: "",
    instance: "",
    realm: "",
    keytab: new Uint8Array(0),
    kdcHost: "",
    kdcPort: "",
    kdcTransportProtocol: "",
  };
}

export const KerberosConfig: MessageFns<KerberosConfig> = {
  encode(message: KerberosConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.primary !== "") {
      writer.uint32(10).string(message.primary);
    }
    if (message.instance !== "") {
      writer.uint32(18).string(message.instance);
    }
    if (message.realm !== "") {
      writer.uint32(26).string(message.realm);
    }
    if (message.keytab.length !== 0) {
      writer.uint32(34).bytes(message.keytab);
    }
    if (message.kdcHost !== "") {
      writer.uint32(42).string(message.kdcHost);
    }
    if (message.kdcPort !== "") {
      writer.uint32(50).string(message.kdcPort);
    }
    if (message.kdcTransportProtocol !== "") {
      writer.uint32(58).string(message.kdcTransportProtocol);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KerberosConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKerberosConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.primary = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.instance = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.realm = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.keytab = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.kdcHost = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.kdcPort = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.kdcTransportProtocol = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KerberosConfig {
    return {
      primary: isSet(object.primary) ? globalThis.String(object.primary) : "",
      instance: isSet(object.instance) ? globalThis.String(object.instance) : "",
      realm: isSet(object.realm) ? globalThis.String(object.realm) : "",
      keytab: isSet(object.keytab) ? bytesFromBase64(object.keytab) : new Uint8Array(0),
      kdcHost: isSet(object.kdcHost) ? globalThis.String(object.kdcHost) : "",
      kdcPort: isSet(object.kdcPort) ? globalThis.String(object.kdcPort) : "",
      kdcTransportProtocol: isSet(object.kdcTransportProtocol) ? globalThis.String(object.kdcTransportProtocol) : "",
    };
  },

  toJSON(message: KerberosConfig): unknown {
    const obj: any = {};
    if (message.primary !== "") {
      obj.primary = message.primary;
    }
    if (message.instance !== "") {
      obj.instance = message.instance;
    }
    if (message.realm !== "") {
      obj.realm = message.realm;
    }
    if (message.keytab.length !== 0) {
      obj.keytab = base64FromBytes(message.keytab);
    }
    if (message.kdcHost !== "") {
      obj.kdcHost = message.kdcHost;
    }
    if (message.kdcPort !== "") {
      obj.kdcPort = message.kdcPort;
    }
    if (message.kdcTransportProtocol !== "") {
      obj.kdcTransportProtocol = message.kdcTransportProtocol;
    }
    return obj;
  },

  create(base?: DeepPartial<KerberosConfig>): KerberosConfig {
    return KerberosConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KerberosConfig>): KerberosConfig {
    const message = createBaseKerberosConfig();
    message.primary = object.primary ?? "";
    message.instance = object.instance ?? "";
    message.realm = object.realm ?? "";
    message.keytab = object.keytab ?? new Uint8Array(0);
    message.kdcHost = object.kdcHost ?? "";
    message.kdcPort = object.kdcPort ?? "";
    message.kdcTransportProtocol = object.kdcTransportProtocol ?? "";
    return message;
  },
};

export type InstanceServiceDefinition = typeof InstanceServiceDefinition;
export const InstanceServiceDefinition = {
  name: "InstanceService",
  fullName: "bytebase.v1.InstanceService",
  methods: {
    getInstance: {
      name: "GetInstance",
      requestType: GetInstanceRequest,
      requestStream: false,
      responseType: Instance,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [new Uint8Array([4, 110, 97, 109, 101])],
          800010: [new Uint8Array([16, 98, 98, 46, 105, 110, 115, 116, 97, 110, 99, 101, 115, 46, 103, 101, 116])],
          800016: [new Uint8Array([1])],
          578365826: [
            new Uint8Array([
              24,
              18,
              22,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    listInstances: {
      name: "ListInstances",
      requestType: ListInstancesRequest,
      requestStream: false,
      responseType: ListInstancesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [new Uint8Array([0])],
          800010: [new Uint8Array([17, 98, 98, 46, 105, 110, 115, 116, 97, 110, 99, 101, 115, 46, 108, 105, 115, 116])],
          800016: [new Uint8Array([1])],
          578365826: [new Uint8Array([15, 18, 13, 47, 118, 49, 47, 105, 110, 115, 116, 97, 110, 99, 101, 115])],
        },
      },
    },
    createInstance: {
      name: "CreateInstance",
      requestType: CreateInstanceRequest,
      requestStream: false,
      responseType: Instance,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [new Uint8Array([8, 105, 110, 115, 116, 97, 110, 99, 101])],
          800010: [
            new Uint8Array([19, 98, 98, 46, 105, 110, 115, 116, 97, 110, 99, 101, 115, 46, 99, 114, 101, 97, 116, 101]),
          ],
          800016: [new Uint8Array([1])],
          800024: [new Uint8Array([1])],
          578365826: [
            new Uint8Array([
              25,
              58,
              8,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              34,
              13,
              47,
              118,
              49,
              47,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
            ]),
          ],
        },
      },
    },
    updateInstance: {
      name: "UpdateInstance",
      requestType: UpdateInstanceRequest,
      requestStream: false,
      responseType: Instance,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            new Uint8Array([
              20,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          800010: [
            new Uint8Array([
              19,
              98,
              98,
              46,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              46,
              117,
              112,
              100,
              97,
              116,
              101,
            ]),
          ],
          800016: [new Uint8Array([1])],
          800024: [new Uint8Array([1])],
          578365826: [
            new Uint8Array([
              43,
              58,
              8,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              50,
              31,
              47,
              118,
              49,
              47,
              123,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              46,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    deleteInstance: {
      name: "DeleteInstance",
      requestType: DeleteInstanceRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [new Uint8Array([4, 110, 97, 109, 101])],
          800010: [
            new Uint8Array([
              19,
              98,
              98,
              46,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              46,
              100,
              101,
              108,
              101,
              116,
              101,
            ]),
          ],
          800016: [new Uint8Array([1])],
          800024: [new Uint8Array([1])],
          578365826: [
            new Uint8Array([
              24,
              42,
              22,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    undeleteInstance: {
      name: "UndeleteInstance",
      requestType: UndeleteInstanceRequest,
      requestStream: false,
      responseType: Instance,
      responseStream: false,
      options: {
        _unknownFields: {
          800010: [
            new Uint8Array([
              21,
              98,
              98,
              46,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              46,
              117,
              110,
              100,
              101,
              108,
              101,
              116,
              101,
            ]),
          ],
          800016: [new Uint8Array([1])],
          800024: [new Uint8Array([1])],
          578365826: [
            new Uint8Array([
              36,
              58,
              1,
              42,
              34,
              31,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              125,
              58,
              117,
              110,
              100,
              101,
              108,
              101,
              116,
              101,
            ]),
          ],
        },
      },
    },
    syncInstance: {
      name: "SyncInstance",
      requestType: SyncInstanceRequest,
      requestStream: false,
      responseType: SyncInstanceResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          800010: [new Uint8Array([17, 98, 98, 46, 105, 110, 115, 116, 97, 110, 99, 101, 115, 46, 115, 121, 110, 99])],
          800016: [new Uint8Array([1])],
          578365826: [
            new Uint8Array([
              32,
              58,
              1,
              42,
              34,
              27,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              125,
              58,
              115,
              121,
              110,
              99,
            ]),
          ],
        },
      },
    },
    listInstanceDatabase: {
      name: "ListInstanceDatabase",
      requestType: ListInstanceDatabaseRequest,
      requestStream: false,
      responseType: ListInstanceDatabaseResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          800010: [new Uint8Array([16, 98, 98, 46, 105, 110, 115, 116, 97, 110, 99, 101, 115, 46, 103, 101, 116])],
          800016: [new Uint8Array([1])],
          578365826: [
            new Uint8Array([
              37,
              58,
              1,
              42,
              34,
              32,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              125,
              58,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
            ]),
          ],
        },
      },
    },
    batchSyncInstances: {
      name: "BatchSyncInstances",
      requestType: BatchSyncInstancesRequest,
      requestStream: false,
      responseType: BatchSyncInstancesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          800010: [new Uint8Array([17, 98, 98, 46, 105, 110, 115, 116, 97, 110, 99, 101, 115, 46, 115, 121, 110, 99])],
          800016: [new Uint8Array([1])],
          578365826: [
            new Uint8Array([
              28,
              58,
              1,
              42,
              34,
              23,
              47,
              118,
              49,
              47,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              58,
              98,
              97,
              116,
              99,
              104,
              83,
              121,
              110,
              99,
            ]),
          ],
        },
      },
    },
    batchUpdateInstances: {
      name: "BatchUpdateInstances",
      requestType: BatchUpdateInstancesRequest,
      requestStream: false,
      responseType: BatchUpdateInstancesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          800010: [
            new Uint8Array([
              19,
              98,
              98,
              46,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              46,
              117,
              112,
              100,
              97,
              116,
              101,
            ]),
          ],
          800016: [new Uint8Array([1])],
          800024: [new Uint8Array([1])],
          578365826: [
            new Uint8Array([
              30,
              58,
              1,
              42,
              34,
              25,
              47,
              118,
              49,
              47,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              58,
              98,
              97,
              116,
              99,
              104,
              85,
              112,
              100,
              97,
              116,
              101,
            ]),
          ],
        },
      },
    },
    addDataSource: {
      name: "AddDataSource",
      requestType: AddDataSourceRequest,
      requestStream: false,
      responseType: Instance,
      responseStream: false,
      options: {
        _unknownFields: {
          800010: [
            new Uint8Array([
              19,
              98,
              98,
              46,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              46,
              117,
              112,
              100,
              97,
              116,
              101,
            ]),
          ],
          800016: [new Uint8Array([1])],
          800024: [new Uint8Array([1])],
          578365826: [
            new Uint8Array([
              41,
              58,
              1,
              42,
              34,
              36,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              125,
              58,
              97,
              100,
              100,
              68,
              97,
              116,
              97,
              83,
              111,
              117,
              114,
              99,
              101,
            ]),
          ],
        },
      },
    },
    removeDataSource: {
      name: "RemoveDataSource",
      requestType: RemoveDataSourceRequest,
      requestStream: false,
      responseType: Instance,
      responseStream: false,
      options: {
        _unknownFields: {
          800010: [
            new Uint8Array([
              19,
              98,
              98,
              46,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              46,
              117,
              112,
              100,
              97,
              116,
              101,
            ]),
          ],
          800016: [new Uint8Array([1])],
          800024: [new Uint8Array([1])],
          578365826: [
            new Uint8Array([
              44,
              58,
              1,
              42,
              34,
              39,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              125,
              58,
              114,
              101,
              109,
              111,
              118,
              101,
              68,
              97,
              116,
              97,
              83,
              111,
              117,
              114,
              99,
              101,
            ]),
          ],
        },
      },
    },
    updateDataSource: {
      name: "UpdateDataSource",
      requestType: UpdateDataSourceRequest,
      requestStream: false,
      responseType: Instance,
      responseStream: false,
      options: {
        _unknownFields: {
          800010: [
            new Uint8Array([
              19,
              98,
              98,
              46,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              46,
              117,
              112,
              100,
              97,
              116,
              101,
            ]),
          ],
          800016: [new Uint8Array([1])],
          800024: [new Uint8Array([1])],
          578365826: [
            new Uint8Array([
              44,
              58,
              1,
              42,
              50,
              39,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              125,
              58,
              117,
              112,
              100,
              97,
              116,
              101,
              68,
              97,
              116,
              97,
              83,
              111,
              117,
              114,
              99,
              101,
            ]),
          ],
        },
      },
    },
  },
} as const;

function bytesFromBase64(b64: string): Uint8Array {
  const bin = globalThis.atob(b64);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; ++i) {
    arr[i] = bin.charCodeAt(i);
  }
  return arr;
}

function base64FromBytes(arr: Uint8Array): string {
  const bin: string[] = [];
  arr.forEach((byte) => {
    bin.push(globalThis.String.fromCharCode(byte));
  });
  return globalThis.btoa(bin.join(""));
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Timestamp {
  if (o instanceof globalThis.Date) {
    return toTimestamp(o);
  } else if (typeof o === "string") {
    return toTimestamp(new globalThis.Date(o));
  } else {
    return Timestamp.fromJSON(o);
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
