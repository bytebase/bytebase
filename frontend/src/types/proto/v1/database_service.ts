// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: v1/database_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../google/protobuf/duration";
import { Empty } from "../google/protobuf/empty";
import { FieldMask } from "../google/protobuf/field_mask";
import { Timestamp } from "../google/protobuf/timestamp";
import {
  MaskingLevel,
  maskingLevelFromJSON,
  maskingLevelToJSON,
  maskingLevelToNumber,
  Range,
  State,
  stateFromJSON,
  stateToJSON,
  stateToNumber,
} from "./common";
import { InstanceResource } from "./instance_service";

export const protobufPackage = "bytebase.v1";

export enum DatabaseMetadataView {
  /**
   * DATABASE_METADATA_VIEW_UNSPECIFIED - The default and unset value.
   * The API will default to the BASIC view.
   */
  DATABASE_METADATA_VIEW_UNSPECIFIED = "DATABASE_METADATA_VIEW_UNSPECIFIED",
  /**
   * DATABASE_METADATA_VIEW_BASIC - Include basic information of schema object names such as schema, table,
   * view, function names.
   */
  DATABASE_METADATA_VIEW_BASIC = "DATABASE_METADATA_VIEW_BASIC",
  /** DATABASE_METADATA_VIEW_FULL - Include everything such as columns and column masking level. */
  DATABASE_METADATA_VIEW_FULL = "DATABASE_METADATA_VIEW_FULL",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function databaseMetadataViewFromJSON(object: any): DatabaseMetadataView {
  switch (object) {
    case 0:
    case "DATABASE_METADATA_VIEW_UNSPECIFIED":
      return DatabaseMetadataView.DATABASE_METADATA_VIEW_UNSPECIFIED;
    case 1:
    case "DATABASE_METADATA_VIEW_BASIC":
      return DatabaseMetadataView.DATABASE_METADATA_VIEW_BASIC;
    case 2:
    case "DATABASE_METADATA_VIEW_FULL":
      return DatabaseMetadataView.DATABASE_METADATA_VIEW_FULL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DatabaseMetadataView.UNRECOGNIZED;
  }
}

export function databaseMetadataViewToJSON(object: DatabaseMetadataView): string {
  switch (object) {
    case DatabaseMetadataView.DATABASE_METADATA_VIEW_UNSPECIFIED:
      return "DATABASE_METADATA_VIEW_UNSPECIFIED";
    case DatabaseMetadataView.DATABASE_METADATA_VIEW_BASIC:
      return "DATABASE_METADATA_VIEW_BASIC";
    case DatabaseMetadataView.DATABASE_METADATA_VIEW_FULL:
      return "DATABASE_METADATA_VIEW_FULL";
    case DatabaseMetadataView.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function databaseMetadataViewToNumber(object: DatabaseMetadataView): number {
  switch (object) {
    case DatabaseMetadataView.DATABASE_METADATA_VIEW_UNSPECIFIED:
      return 0;
    case DatabaseMetadataView.DATABASE_METADATA_VIEW_BASIC:
      return 1;
    case DatabaseMetadataView.DATABASE_METADATA_VIEW_FULL:
      return 2;
    case DatabaseMetadataView.UNRECOGNIZED:
    default:
      return -1;
  }
}

export enum ChangeHistoryView {
  /**
   * CHANGE_HISTORY_VIEW_UNSPECIFIED - The default / unset value.
   * The API will default to the BASIC view.
   */
  CHANGE_HISTORY_VIEW_UNSPECIFIED = "CHANGE_HISTORY_VIEW_UNSPECIFIED",
  CHANGE_HISTORY_VIEW_BASIC = "CHANGE_HISTORY_VIEW_BASIC",
  CHANGE_HISTORY_VIEW_FULL = "CHANGE_HISTORY_VIEW_FULL",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function changeHistoryViewFromJSON(object: any): ChangeHistoryView {
  switch (object) {
    case 0:
    case "CHANGE_HISTORY_VIEW_UNSPECIFIED":
      return ChangeHistoryView.CHANGE_HISTORY_VIEW_UNSPECIFIED;
    case 1:
    case "CHANGE_HISTORY_VIEW_BASIC":
      return ChangeHistoryView.CHANGE_HISTORY_VIEW_BASIC;
    case 2:
    case "CHANGE_HISTORY_VIEW_FULL":
      return ChangeHistoryView.CHANGE_HISTORY_VIEW_FULL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ChangeHistoryView.UNRECOGNIZED;
  }
}

export function changeHistoryViewToJSON(object: ChangeHistoryView): string {
  switch (object) {
    case ChangeHistoryView.CHANGE_HISTORY_VIEW_UNSPECIFIED:
      return "CHANGE_HISTORY_VIEW_UNSPECIFIED";
    case ChangeHistoryView.CHANGE_HISTORY_VIEW_BASIC:
      return "CHANGE_HISTORY_VIEW_BASIC";
    case ChangeHistoryView.CHANGE_HISTORY_VIEW_FULL:
      return "CHANGE_HISTORY_VIEW_FULL";
    case ChangeHistoryView.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function changeHistoryViewToNumber(object: ChangeHistoryView): number {
  switch (object) {
    case ChangeHistoryView.CHANGE_HISTORY_VIEW_UNSPECIFIED:
      return 0;
    case ChangeHistoryView.CHANGE_HISTORY_VIEW_BASIC:
      return 1;
    case ChangeHistoryView.CHANGE_HISTORY_VIEW_FULL:
      return 2;
    case ChangeHistoryView.UNRECOGNIZED:
    default:
      return -1;
  }
}

export enum ChangelogView {
  /**
   * CHANGELOG_VIEW_UNSPECIFIED - The default / unset value.
   * The API will default to the BASIC view.
   */
  CHANGELOG_VIEW_UNSPECIFIED = "CHANGELOG_VIEW_UNSPECIFIED",
  CHANGELOG_VIEW_BASIC = "CHANGELOG_VIEW_BASIC",
  CHANGELOG_VIEW_FULL = "CHANGELOG_VIEW_FULL",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function changelogViewFromJSON(object: any): ChangelogView {
  switch (object) {
    case 0:
    case "CHANGELOG_VIEW_UNSPECIFIED":
      return ChangelogView.CHANGELOG_VIEW_UNSPECIFIED;
    case 1:
    case "CHANGELOG_VIEW_BASIC":
      return ChangelogView.CHANGELOG_VIEW_BASIC;
    case 2:
    case "CHANGELOG_VIEW_FULL":
      return ChangelogView.CHANGELOG_VIEW_FULL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ChangelogView.UNRECOGNIZED;
  }
}

export function changelogViewToJSON(object: ChangelogView): string {
  switch (object) {
    case ChangelogView.CHANGELOG_VIEW_UNSPECIFIED:
      return "CHANGELOG_VIEW_UNSPECIFIED";
    case ChangelogView.CHANGELOG_VIEW_BASIC:
      return "CHANGELOG_VIEW_BASIC";
    case ChangelogView.CHANGELOG_VIEW_FULL:
      return "CHANGELOG_VIEW_FULL";
    case ChangelogView.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function changelogViewToNumber(object: ChangelogView): number {
  switch (object) {
    case ChangelogView.CHANGELOG_VIEW_UNSPECIFIED:
      return 0;
    case ChangelogView.CHANGELOG_VIEW_BASIC:
      return 1;
    case ChangelogView.CHANGELOG_VIEW_FULL:
      return 2;
    case ChangelogView.UNRECOGNIZED:
    default:
      return -1;
  }
}

export interface GetDatabaseRequest {
  /**
   * The name of the database to retrieve.
   * Format: instances/{instance}/databases/{database}
   */
  name: string;
}

export interface ListInstanceDatabasesRequest {
  /**
   * The parent, which owns this collection of databases.
   * - instances/{instance}: list all databases for an instance. Use
   * "instances/-" to list all databases.
   */
  parent: string;
  /**
   * The maximum number of databases to return. The service may return fewer
   * than this value. If unspecified, at most 10 databases will be returned.
   */
  pageSize: number;
  /**
   * A page token, received from a previous `ListInstanceDatabases` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListInstanceDatabases`
   * must match the call that provided the page token.
   */
  pageToken: string;
  /**
   * Deprecated.
   * Filter is used to filter databases returned in the list.
   * For example, `project == "projects/{project}"` can be used to list
   * databases in a project. Note: the project filter will be moved to parent.
   */
  filter: string;
}

export interface ListInstanceDatabasesResponse {
  /** The databases from the specified request. */
  databases: Database[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
}

export interface ListDatabasesRequest {
  /**
   * The parent, which owns this collection of databases.
   * - projects/{project}: list all databases in a project.
   * - workspaces/{workspace}: list all databases in a workspace.
   */
  parent: string;
  /**
   * The maximum number of databases to return. The service may return fewer
   * than this value. If unspecified, at most 10 databases will be returned.
   */
  pageSize: number;
  /**
   * A page token, received from a previous `ListDatabases` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListDatabases` must
   * match the call that provided the page token.
   */
  pageToken: string;
}

export interface ListDatabasesResponse {
  /** The databases from the specified request. */
  databases: Database[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
}

export interface UpdateDatabaseRequest {
  /**
   * The database to update.
   *
   * The database's `name` field is used to identify the database to update.
   * Format: instances/{instance}/databases/{database}
   */
  database:
    | Database
    | undefined;
  /** The list of fields to update. */
  updateMask: string[] | undefined;
}

export interface BatchUpdateDatabasesRequest {
  /**
   * The parent resource shared by all databases being updated.
   * Format: instances/{instance}
   * If the operation spans parents, a dash (-) may be accepted as a wildcard.
   * We only support updating the project of databases for now.
   */
  parent: string;
  /**
   * The request message specifying the resources to update.
   * A maximum of 1000 databases can be modified in a batch.
   */
  requests: UpdateDatabaseRequest[];
}

export interface BatchUpdateDatabasesResponse {
  /** Databases updated. */
  databases: Database[];
}

export interface SyncDatabaseRequest {
  /**
   * The name of the database to sync.
   * Format: instances/{instance}/databases/{database}
   */
  name: string;
}

export interface SyncDatabaseResponse {
}

export interface GetDatabaseMetadataRequest {
  /**
   * The name of the database to retrieve metadata.
   * Format: instances/{instance}/databases/{database}/metadata
   */
  name: string;
  /** The view to return. Defaults to DATABASE_METADATA_VIEW_BASIC. */
  view: DatabaseMetadataView;
  /**
   * The filter used for a specific schema object such as
   * "schemas/schema-a/tables/table-a".
   * The column masking level will only be returned when a table filter is used.
   */
  filter: string;
}

export interface UpdateDatabaseMetadataRequest {
  /**
   * The database metadata to update.
   *
   * The database_metadata's `name` field is used to identify the database
   * metadata to update. Format:
   * instances/{instance}/databases/{database}/metadata
   */
  databaseMetadata:
    | DatabaseMetadata
    | undefined;
  /** The list of fields to update. */
  updateMask: string[] | undefined;
}

export interface GetDatabaseSchemaRequest {
  /**
   * The name of the database to retrieve schema.
   * Format: instances/{instance}/databases/{database}/schema
   */
  name: string;
  /** Format the schema dump into SDL format. */
  sdlFormat: boolean;
  /**
   * When true, the schema dump will be concise.
   * For Oracle, there will be tables and indexes only for Sync Schema.
   * For Postgres, we'll filter the backup schema.
   */
  concise: boolean;
}

export interface DiffSchemaRequest {
  /**
   * The name of the database or change history.
   * Format:
   * database: instances/{instance}/databases/{database}
   * change history:
   * instances/{instance}/databases/{database}/changeHistories/{changeHistory}
   */
  name: string;
  /** The target schema. */
  schema?:
    | string
    | undefined;
  /**
   * The resource name of the change history
   * Format:
   * instances/{instance}/databases/{database}/changeHistories/{changeHistory}
   */
  changeHistory?:
    | string
    | undefined;
  /** Format the schema dump into SDL format. */
  sdlFormat: boolean;
}

export interface DiffSchemaResponse {
  diff: string;
}

export interface Database {
  /**
   * The name of the database.
   * Format: instances/{instance}/databases/{database}
   * {database} is the database name in the instance.
   */
  name: string;
  /** The existence of a database on latest sync. */
  syncState: State;
  /** The latest synchronization time. */
  successfulSyncTime:
    | Timestamp
    | undefined;
  /**
   * The project for a database.
   * Format: projects/{project}
   */
  project: string;
  /** The version of database schema. */
  schemaVersion: string;
  /**
   * The environment resource.
   * Format: environments/prod where prod is the environment resource ID.
   */
  environment: string;
  /**
   * The effective environment based on environment tag above and environment
   * tag on the instance. Inheritance follows
   * https://cloud.google.com/resource-manager/docs/tags/tags-overview.
   */
  effectiveEnvironment: string;
  /** Labels will be used for deployment and policy control. */
  labels: { [key: string]: string };
  /** The instance resource. */
  instanceResource:
    | InstanceResource
    | undefined;
  /** The database is available for DML prior backup. */
  backupAvailable: boolean;
}

export interface Database_LabelsEntry {
  key: string;
  value: string;
}

/** DatabaseMetadata is the metadata for databases. */
export interface DatabaseMetadata {
  /**
   * The database metadata name.
   *
   * Format: instances/{instance}/databases/{database}/metadata
   */
  name: string;
  /** The schemas is the list of schemas in a database. */
  schemas: SchemaMetadata[];
  /** The character_set is the character set of a database. */
  characterSet: string;
  /** The collation is the collation of a database. */
  collation: string;
  /** The extensions is the list of extensions in a database. */
  extensions: ExtensionMetadata[];
  /** The schema_configs is the list of configs for schemas in a database. */
  schemaConfigs: SchemaConfig[];
  owner: string;
}

/**
 * SchemaMetadata is the metadata for schemas.
 * This is the concept of schema in Postgres, but it's a no-op for MySQL.
 */
export interface SchemaMetadata {
  /**
   * The name is the schema name.
   * It is an empty string for databases without such concept such as MySQL.
   */
  name: string;
  /** The tables is the list of tables in a schema. */
  tables: TableMetadata[];
  /** The external_tables is the list of external tables in a schema. */
  externalTables: ExternalTableMetadata[];
  /** The views is the list of views in a schema. */
  views: ViewMetadata[];
  /** The functions is the list of functions in a schema. */
  functions: FunctionMetadata[];
  /** The procedures is the list of procedures in a schema. */
  procedures: ProcedureMetadata[];
  /**
   * The streams is the list of streams in a schema, currently, only used for
   * Snowflake.
   */
  streams: StreamMetadata[];
  /**
   * The routines is the list of routines in a schema, currently, only used for
   * Snowflake.
   */
  tasks: TaskMetadata[];
  /** The materialized_views is the list of materialized views in a schema. */
  materializedViews: MaterializedViewMetadata[];
  /** The packages is the list of packages in a schema. */
  packages: PackageMetadata[];
  owner: string;
  /**
   * The triggers is the list of triggers in a schema, triggers are sorted by
   * table_name, name, event, timing, action_order.
   */
  triggers: TriggerMetadata[];
  /** The sequences is the list of sequences in a schema, sorted by name. */
  sequences: SequenceMetadata[];
  events: EventMetadata[];
}

export interface EventMetadata {
  /** The name of the event. */
  name: string;
  /** The schedule of the event. */
  definition: string;
  /** The time zone of the event. */
  timeZone: string;
  sqlMode: string;
  characterSetClient: string;
  collationConnection: string;
}

export interface SequenceMetadata {
  /** The name of a sequence. */
  name: string;
  /** The data type of a sequence. */
  dataType: string;
  /** The start value of a sequence. */
  start: string;
  /** The minimum value of a sequence. */
  minValue: string;
  /** The maximum value of a sequence. */
  maxValue: string;
  /** Increment value of a sequence. */
  increment: string;
  /** Cycle is whether the sequence cycles. */
  cycle: boolean;
  /** Cache size of a sequence. */
  cacheSize: string;
  /** Last value of a sequence. */
  lastValue: string;
}

export interface TriggerMetadata {
  /** The name is the name of the trigger. */
  name: string;
  /**
   * The table_name is the name of the table/view that the trigger is created
   * on.
   */
  tableName: string;
  /**
   * The event is the event of the trigger, such as INSERT, UPDATE, DELETE,
   * TRUNCATE.
   */
  event: string;
  /** The timing is the timing of the trigger, such as BEFORE, AFTER. */
  timing: string;
  /** The body is the body of the trigger. */
  body: string;
  sqlMode: string;
  characterSetClient: string;
  collationConnection: string;
}

export interface ExternalTableMetadata {
  /** The name is the name of a external table. */
  name: string;
  /** The external_server_name is the name of the external server. */
  externalServerName: string;
  /** The external_database_name is the name of the external database. */
  externalDatabaseName: string;
  /** The columns is the ordered list of columns in a foreign table. */
  columns: ColumnMetadata[];
}

/** TableMetadata is the metadata for tables. */
export interface TableMetadata {
  /** The name is the name of a table. */
  name: string;
  /** The columns is the ordered list of columns in a table. */
  columns: ColumnMetadata[];
  /** The indexes is the list of indexes in a table. */
  indexes: IndexMetadata[];
  /** The engine is the engine of a table. */
  engine: string;
  /** The collation is the collation of a table. */
  collation: string;
  /** The character set of table. */
  charset: string;
  /** The row_count is the estimated number of rows of a table. */
  rowCount: Long;
  /** The data_size is the estimated data size of a table. */
  dataSize: Long;
  /** The index_size is the estimated index size of a table. */
  indexSize: Long;
  /** The data_free is the estimated free data size of a table. */
  dataFree: Long;
  /** The create_options is the create option of a table. */
  createOptions: string;
  /**
   * The comment is the comment of a table.
   * classification and user_comment is parsed from the comment.
   */
  comment: string;
  /** The user_comment is the user comment of a table parsed from the comment. */
  userComment: string;
  /** The foreign_keys is the list of foreign keys in a table. */
  foreignKeys: ForeignKeyMetadata[];
  /** The partitions is the list of partitions in a table. */
  partitions: TablePartitionMetadata[];
  /** The check_constraints is the list of check constraints in a table. */
  checkConstraints: CheckConstraintMetadata[];
  owner: string;
}

/** CheckConstraintMetadata is the metadata for check constraints. */
export interface CheckConstraintMetadata {
  /** The name is the name of a check constraint. */
  name: string;
  /** The expression is the expression of a check constraint. */
  expression: string;
}

/** TablePartitionMetadata is the metadata for table partitions. */
export interface TablePartitionMetadata {
  /** The name is the name of a table partition. */
  name: string;
  /** The type of a table partition. */
  type: TablePartitionMetadata_Type;
  /**
   * The expression is the expression of a table partition.
   * For PostgreSQL, the expression is the text of {FOR VALUES
   * partition_bound_spec}, see
   * https://www.postgresql.org/docs/current/sql-createtable.html. For MySQL,
   * the expression is the `expr` or `column_list` of the following syntax.
   * PARTITION BY
   *    { [LINEAR] HASH(expr)
   *    | [LINEAR] KEY [ALGORITHM={1 | 2}] (column_list)
   *    | RANGE{(expr) | COLUMNS(column_list)}
   *    | LIST{(expr) | COLUMNS(column_list)} }.
   */
  expression: string;
  /**
   * The value is the value of a table partition.
   * For MySQL, the value is for RANGE and LIST partition types,
   * - For a RANGE partition, it contains the value set in the partition's
   * VALUES LESS THAN clause, which can be either an integer or MAXVALUE.
   * - For a LIST partition, this column contains the values defined in the
   * partition's VALUES IN clause, which is a list of comma-separated integer
   * values.
   * - For others, it's an empty string.
   */
  value: string;
  /**
   * The use_default is whether the users use the default partition, it stores
   * the different value for different database engines. For MySQL, it's [INT]
   * type, 0 means not use default partition, otherwise, it's equals to number
   * in syntax [SUB]PARTITION {number}.
   */
  useDefault: string;
  /** The subpartitions is the list of subpartitions in a table partition. */
  subpartitions: TablePartitionMetadata[];
}

/**
 * Type is the type of a table partition, some database engines may not
 * support all types. Only avilable for the following database engines now:
 * MySQL: RANGE, RANGE COLUMNS, LIST, LIST COLUMNS, HASH, LINEAR HASH, KEY,
 * LINEAR_KEY
 * (https://dev.mysql.com/doc/refman/8.0/en/partitioning-types.html) TiDB:
 * RANGE, RANGE COLUMNS, LIST, LIST COLUMNS, HASH, KEY PostgreSQL: RANGE,
 * LIST, HASH (https://www.postgresql.org/docs/current/ddl-partitioning.html)
 */
export enum TablePartitionMetadata_Type {
  TYPE_UNSPECIFIED = "TYPE_UNSPECIFIED",
  RANGE = "RANGE",
  RANGE_COLUMNS = "RANGE_COLUMNS",
  LIST = "LIST",
  LIST_COLUMNS = "LIST_COLUMNS",
  HASH = "HASH",
  LINEAR_HASH = "LINEAR_HASH",
  KEY = "KEY",
  LINEAR_KEY = "LINEAR_KEY",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function tablePartitionMetadata_TypeFromJSON(object: any): TablePartitionMetadata_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return TablePartitionMetadata_Type.TYPE_UNSPECIFIED;
    case 1:
    case "RANGE":
      return TablePartitionMetadata_Type.RANGE;
    case 2:
    case "RANGE_COLUMNS":
      return TablePartitionMetadata_Type.RANGE_COLUMNS;
    case 3:
    case "LIST":
      return TablePartitionMetadata_Type.LIST;
    case 4:
    case "LIST_COLUMNS":
      return TablePartitionMetadata_Type.LIST_COLUMNS;
    case 5:
    case "HASH":
      return TablePartitionMetadata_Type.HASH;
    case 6:
    case "LINEAR_HASH":
      return TablePartitionMetadata_Type.LINEAR_HASH;
    case 7:
    case "KEY":
      return TablePartitionMetadata_Type.KEY;
    case 8:
    case "LINEAR_KEY":
      return TablePartitionMetadata_Type.LINEAR_KEY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TablePartitionMetadata_Type.UNRECOGNIZED;
  }
}

export function tablePartitionMetadata_TypeToJSON(object: TablePartitionMetadata_Type): string {
  switch (object) {
    case TablePartitionMetadata_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case TablePartitionMetadata_Type.RANGE:
      return "RANGE";
    case TablePartitionMetadata_Type.RANGE_COLUMNS:
      return "RANGE_COLUMNS";
    case TablePartitionMetadata_Type.LIST:
      return "LIST";
    case TablePartitionMetadata_Type.LIST_COLUMNS:
      return "LIST_COLUMNS";
    case TablePartitionMetadata_Type.HASH:
      return "HASH";
    case TablePartitionMetadata_Type.LINEAR_HASH:
      return "LINEAR_HASH";
    case TablePartitionMetadata_Type.KEY:
      return "KEY";
    case TablePartitionMetadata_Type.LINEAR_KEY:
      return "LINEAR_KEY";
    case TablePartitionMetadata_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function tablePartitionMetadata_TypeToNumber(object: TablePartitionMetadata_Type): number {
  switch (object) {
    case TablePartitionMetadata_Type.TYPE_UNSPECIFIED:
      return 0;
    case TablePartitionMetadata_Type.RANGE:
      return 1;
    case TablePartitionMetadata_Type.RANGE_COLUMNS:
      return 2;
    case TablePartitionMetadata_Type.LIST:
      return 3;
    case TablePartitionMetadata_Type.LIST_COLUMNS:
      return 4;
    case TablePartitionMetadata_Type.HASH:
      return 5;
    case TablePartitionMetadata_Type.LINEAR_HASH:
      return 6;
    case TablePartitionMetadata_Type.KEY:
      return 7;
    case TablePartitionMetadata_Type.LINEAR_KEY:
      return 8;
    case TablePartitionMetadata_Type.UNRECOGNIZED:
    default:
      return -1;
  }
}

/** ColumnMetadata is the metadata for columns. */
export interface ColumnMetadata {
  /** The name is the name of a column. */
  name: string;
  /** The position is the position in columns. */
  position: number;
  hasDefault: boolean;
  defaultNull?: boolean | undefined;
  defaultString?: string | undefined;
  defaultExpression?:
    | string
    | undefined;
  /**
   * The on_update is the on update action of a column.
   * For MySQL like databases, it's only supported for TIMESTAMP columns with
   * CURRENT_TIMESTAMP as on update value.
   */
  onUpdate: string;
  /** The nullable is the nullable of a column. */
  nullable: boolean;
  /** The type is the type of a column. */
  type: string;
  /** The character_set is the character_set of a column. */
  characterSet: string;
  /** The collation is the collation of a column. */
  collation: string;
  /**
   * The comment is the comment of a column.
   * classification and user_comment is parsed from the comment.
   */
  comment: string;
  /** The user_comment is the user comment of a column parsed from the comment. */
  userComment: string;
  /**
   * The effective_masking_level is the effective masking level of the column,
   * evaluate from the column masking data and global masking rules.
   */
  effectiveMaskingLevel: MaskingLevel;
  /** The generation is the generation of a column. */
  generation: GenerationMetadata | undefined;
}

export interface GenerationMetadata {
  type: GenerationMetadata_Type;
  expression: string;
}

export enum GenerationMetadata_Type {
  TYPE_UNSPECIFIED = "TYPE_UNSPECIFIED",
  TYPE_VIRTUAL = "TYPE_VIRTUAL",
  TYPE_STORED = "TYPE_STORED",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function generationMetadata_TypeFromJSON(object: any): GenerationMetadata_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return GenerationMetadata_Type.TYPE_UNSPECIFIED;
    case 1:
    case "TYPE_VIRTUAL":
      return GenerationMetadata_Type.TYPE_VIRTUAL;
    case 2:
    case "TYPE_STORED":
      return GenerationMetadata_Type.TYPE_STORED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GenerationMetadata_Type.UNRECOGNIZED;
  }
}

export function generationMetadata_TypeToJSON(object: GenerationMetadata_Type): string {
  switch (object) {
    case GenerationMetadata_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case GenerationMetadata_Type.TYPE_VIRTUAL:
      return "TYPE_VIRTUAL";
    case GenerationMetadata_Type.TYPE_STORED:
      return "TYPE_STORED";
    case GenerationMetadata_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function generationMetadata_TypeToNumber(object: GenerationMetadata_Type): number {
  switch (object) {
    case GenerationMetadata_Type.TYPE_UNSPECIFIED:
      return 0;
    case GenerationMetadata_Type.TYPE_VIRTUAL:
      return 1;
    case GenerationMetadata_Type.TYPE_STORED:
      return 2;
    case GenerationMetadata_Type.UNRECOGNIZED:
    default:
      return -1;
  }
}

/** ViewMetadata is the metadata for views. */
export interface ViewMetadata {
  /** The name is the name of a view. */
  name: string;
  /** The definition is the definition of a view. */
  definition: string;
  /** The comment is the comment of a view. */
  comment: string;
  /** The dependent_columns is the list of dependent columns of a view. */
  dependentColumns: DependentColumn[];
  /** The columns is the ordered list of columns in a table. */
  columns: ColumnMetadata[];
}

/** DependentColumn is the metadata for dependent columns. */
export interface DependentColumn {
  /** The schema is the schema of a reference column. */
  schema: string;
  /** The table is the table of a reference column. */
  table: string;
  /** The column is the name of a reference column. */
  column: string;
}

/** MaterializedViewMetadata is the metadata for materialized views. */
export interface MaterializedViewMetadata {
  /** The name is the name of a materialized view. */
  name: string;
  /** The definition is the definition of a materialized view. */
  definition: string;
  /** The comment is the comment of a materialized view. */
  comment: string;
  /**
   * The dependent_columns is the list of dependent columns of a materialized
   * view.
   */
  dependentColumns: DependentColumn[];
}

/** FunctionMetadata is the metadata for functions. */
export interface FunctionMetadata {
  /** The name is the name of a function. */
  name: string;
  /** The definition is the definition of a function. */
  definition: string;
  /**
   * The signature is the name with the number and type of input arguments the
   * function takes.
   */
  signature: string;
  /** MySQL specific metadata. */
  characterSetClient: string;
  collationConnection: string;
  databaseCollation: string;
  sqlMode: string;
}

/** ProcedureMetadata is the metadata for procedures. */
export interface ProcedureMetadata {
  /** The name is the name of a procedure. */
  name: string;
  /** The definition is the definition of a procedure. */
  definition: string;
  /**
   * The signature is the name with the number and type of input arguments the
   * function takes.
   */
  signature: string;
  /** MySQL specific metadata. */
  characterSetClient: string;
  collationConnection: string;
  databaseCollation: string;
  sqlMode: string;
}

/** PackageMetadata is the metadata for packages. */
export interface PackageMetadata {
  /** The name is the name of a package. */
  name: string;
  /** The definition is the definition of a package. */
  definition: string;
}

export interface TaskMetadata {
  /** The name is the name of a task. */
  name: string;
  /**
   * The id is the snowflake-generated id of a task.
   * Example: 01ad32a0-1bb6-5e93-0000-000000000001
   */
  id: string;
  /** The owner of the task. */
  owner: string;
  /** The comment of the task. */
  comment: string;
  /** The warehouse of the task. */
  warehouse: string;
  /** The schedule interval of the task. */
  schedule: string;
  /** The predecessor tasks of the task. */
  predecessors: string[];
  /** The state of the task. */
  state: TaskMetadata_State;
  /** The condition of the task. */
  condition: string;
  /** The definition of the task. */
  definition: string;
}

export enum TaskMetadata_State {
  STATE_UNSPECIFIED = "STATE_UNSPECIFIED",
  STATE_STARTED = "STATE_STARTED",
  STATE_SUSPENDED = "STATE_SUSPENDED",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function taskMetadata_StateFromJSON(object: any): TaskMetadata_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return TaskMetadata_State.STATE_UNSPECIFIED;
    case 1:
    case "STATE_STARTED":
      return TaskMetadata_State.STATE_STARTED;
    case 2:
    case "STATE_SUSPENDED":
      return TaskMetadata_State.STATE_SUSPENDED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TaskMetadata_State.UNRECOGNIZED;
  }
}

export function taskMetadata_StateToJSON(object: TaskMetadata_State): string {
  switch (object) {
    case TaskMetadata_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case TaskMetadata_State.STATE_STARTED:
      return "STATE_STARTED";
    case TaskMetadata_State.STATE_SUSPENDED:
      return "STATE_SUSPENDED";
    case TaskMetadata_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function taskMetadata_StateToNumber(object: TaskMetadata_State): number {
  switch (object) {
    case TaskMetadata_State.STATE_UNSPECIFIED:
      return 0;
    case TaskMetadata_State.STATE_STARTED:
      return 1;
    case TaskMetadata_State.STATE_SUSPENDED:
      return 2;
    case TaskMetadata_State.UNRECOGNIZED:
    default:
      return -1;
  }
}

export interface StreamMetadata {
  /** The name is the name of a stream. */
  name: string;
  /** The table_name is the name of the table/view that the stream is created on. */
  tableName: string;
  /** The owner of the stream. */
  owner: string;
  /** The comment of the stream. */
  comment: string;
  /** The type of the stream. */
  type: StreamMetadata_Type;
  /** Indicates whether the stream was last read before the `stale_after` time. */
  stale: boolean;
  /** The mode of the stream. */
  mode: StreamMetadata_Mode;
  /** The definition of the stream. */
  definition: string;
}

export enum StreamMetadata_Type {
  TYPE_UNSPECIFIED = "TYPE_UNSPECIFIED",
  TYPE_DELTA = "TYPE_DELTA",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function streamMetadata_TypeFromJSON(object: any): StreamMetadata_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return StreamMetadata_Type.TYPE_UNSPECIFIED;
    case 1:
    case "TYPE_DELTA":
      return StreamMetadata_Type.TYPE_DELTA;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StreamMetadata_Type.UNRECOGNIZED;
  }
}

export function streamMetadata_TypeToJSON(object: StreamMetadata_Type): string {
  switch (object) {
    case StreamMetadata_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case StreamMetadata_Type.TYPE_DELTA:
      return "TYPE_DELTA";
    case StreamMetadata_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function streamMetadata_TypeToNumber(object: StreamMetadata_Type): number {
  switch (object) {
    case StreamMetadata_Type.TYPE_UNSPECIFIED:
      return 0;
    case StreamMetadata_Type.TYPE_DELTA:
      return 1;
    case StreamMetadata_Type.UNRECOGNIZED:
    default:
      return -1;
  }
}

export enum StreamMetadata_Mode {
  MODE_UNSPECIFIED = "MODE_UNSPECIFIED",
  MODE_DEFAULT = "MODE_DEFAULT",
  MODE_APPEND_ONLY = "MODE_APPEND_ONLY",
  MODE_INSERT_ONLY = "MODE_INSERT_ONLY",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function streamMetadata_ModeFromJSON(object: any): StreamMetadata_Mode {
  switch (object) {
    case 0:
    case "MODE_UNSPECIFIED":
      return StreamMetadata_Mode.MODE_UNSPECIFIED;
    case 1:
    case "MODE_DEFAULT":
      return StreamMetadata_Mode.MODE_DEFAULT;
    case 2:
    case "MODE_APPEND_ONLY":
      return StreamMetadata_Mode.MODE_APPEND_ONLY;
    case 3:
    case "MODE_INSERT_ONLY":
      return StreamMetadata_Mode.MODE_INSERT_ONLY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StreamMetadata_Mode.UNRECOGNIZED;
  }
}

export function streamMetadata_ModeToJSON(object: StreamMetadata_Mode): string {
  switch (object) {
    case StreamMetadata_Mode.MODE_UNSPECIFIED:
      return "MODE_UNSPECIFIED";
    case StreamMetadata_Mode.MODE_DEFAULT:
      return "MODE_DEFAULT";
    case StreamMetadata_Mode.MODE_APPEND_ONLY:
      return "MODE_APPEND_ONLY";
    case StreamMetadata_Mode.MODE_INSERT_ONLY:
      return "MODE_INSERT_ONLY";
    case StreamMetadata_Mode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function streamMetadata_ModeToNumber(object: StreamMetadata_Mode): number {
  switch (object) {
    case StreamMetadata_Mode.MODE_UNSPECIFIED:
      return 0;
    case StreamMetadata_Mode.MODE_DEFAULT:
      return 1;
    case StreamMetadata_Mode.MODE_APPEND_ONLY:
      return 2;
    case StreamMetadata_Mode.MODE_INSERT_ONLY:
      return 3;
    case StreamMetadata_Mode.UNRECOGNIZED:
    default:
      return -1;
  }
}

/** IndexMetadata is the metadata for indexes. */
export interface IndexMetadata {
  /** The name is the name of an index. */
  name: string;
  /**
   * The expressions are the ordered columns or expressions of an index.
   * This could refer to a column or an expression.
   */
  expressions: string[];
  /**
   * The key_lengths are the ordered key lengths of an index.
   * If the key length is not specified, it's -1.
   */
  keyLength: Long[];
  /** The descending is the ordered descending of an index. */
  descending: boolean[];
  /** The type is the type of an index. */
  type: string;
  /** The unique is whether the index is unique. */
  unique: boolean;
  /** The primary is whether the index is a primary key index. */
  primary: boolean;
  /** The visible is whether the index is visible. */
  visible: boolean;
  /** The comment is the comment of an index. */
  comment: string;
  /** The definition of an index. */
  definition: string;
}

/** ExtensionMetadata is the metadata for extensions. */
export interface ExtensionMetadata {
  /** The name is the name of an extension. */
  name: string;
  /**
   * The schema is the extension that is installed to. But the extension usage
   * is not limited to the schema.
   */
  schema: string;
  /** The version is the version of an extension. */
  version: string;
  /** The description is the description of an extension. */
  description: string;
}

/** ForeignKeyMetadata is the metadata for foreign keys. */
export interface ForeignKeyMetadata {
  /** The name is the name of a foreign key. */
  name: string;
  /** The columns are the ordered referencing columns of a foreign key. */
  columns: string[];
  /**
   * The referenced_schema is the referenced schema name of a foreign key.
   * It is an empty string for databases without such concept such as MySQL.
   */
  referencedSchema: string;
  /** The referenced_table is the referenced table name of a foreign key. */
  referencedTable: string;
  /** The referenced_columns are the ordered referenced columns of a foreign key. */
  referencedColumns: string[];
  /** The on_delete is the on delete action of a foreign key. */
  onDelete: string;
  /** The on_update is the on update action of a foreign key. */
  onUpdate: string;
  /**
   * The match_type is the match type of a foreign key.
   * The match_type is the PostgreSQL specific field.
   * It's empty string for other databases.
   */
  matchType: string;
}

export interface DatabaseConfig {
  name: string;
  /** The schema_configs is the list of configs for schemas in a database. */
  schemaConfigs: SchemaConfig[];
}

export interface SchemaConfig {
  /**
   * The name is the schema name.
   * It is an empty string for databases without such concept such as MySQL.
   */
  name: string;
  /** The table_configs is the list of configs for tables in a schema. */
  tableConfigs: TableConfig[];
  functionConfigs: FunctionConfig[];
  procedureConfigs: ProcedureConfig[];
  viewConfigs: ViewConfig[];
}

export interface TableConfig {
  /** The name is the name of a table. */
  name: string;
  /** The column_configs is the ordered list of configs for columns in a table. */
  columnConfigs: ColumnConfig[];
  classificationId: string;
  /**
   * The last updater of the table in branch.
   * Format: users/{email}
   */
  updater: string;
  /**
   * The last change come from branch.
   * Format: projcets/{project}/branches/{branch}
   */
  sourceBranch: string;
  /** The timestamp when the table is updated in branch. */
  updateTime: Timestamp | undefined;
}

export interface FunctionConfig {
  /** The name is the name of a function. */
  name: string;
  /**
   * The last updater of the function in branch.
   * Format: users/{email}
   */
  updater: string;
  /**
   * The last change come from branch.
   * Format: projcets/{project}/branches/{branch}
   */
  sourceBranch: string;
  /** The timestamp when the function is updated in branch. */
  updateTime: Timestamp | undefined;
}

export interface ProcedureConfig {
  /** The name is the name of a procedure. */
  name: string;
  /**
   * The last updater of the procedure in branch.
   * Format: users/{email}
   */
  updater: string;
  /**
   * The last change come from branch.
   * Format: projcets/{project}/branches/{branch}
   */
  sourceBranch: string;
  /** The timestamp when the procedure is updated in branch. */
  updateTime: Timestamp | undefined;
}

export interface ViewConfig {
  /** The name is the name of a view. */
  name: string;
  /**
   * The last updater of the view in branch.
   * Format: users/{email}
   */
  updater: string;
  /**
   * The last change come from branch.
   * Format: projcets/{project}/branches/{branch}
   */
  sourceBranch: string;
  /** The timestamp when the view is updated in branch. */
  updateTime: Timestamp | undefined;
}

export interface ColumnConfig {
  /** The name is the name of a column. */
  name: string;
  semanticTypeId: string;
  /** The user labels for a column. */
  labels: { [key: string]: string };
  classificationId: string;
}

export interface ColumnConfig_LabelsEntry {
  key: string;
  value: string;
}

/** DatabaseSchema is the metadata for databases. */
export interface DatabaseSchema {
  /** The schema dump from database. */
  schema: string;
}

/** ListSlowQueriesRequest is the request of listing slow query. */
export interface ListSlowQueriesRequest {
  /** Format: projects/{project} */
  parent: string;
  /**
   * The filter of the slow query log.
   * follow the
   * [ebnf](https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form)
   * syntax. Support filter by database and start_time in SlowQueryDetails for
   * now. For example: Search the slow query log of the specific database:
   *   - the specific database: database =
   *   "instances/{instance}/databases/{database}"
   * Search the slow query log that start_time after 2022-01-01T12:00:00.000Z:
   *   - start_time > "2022-01-01T12:00:00.000Z"
   *   - Should use [RFC-3339 format](https://www.rfc-editor.org/rfc/rfc3339).
   *   - Currently we only support filtering down to date granularity.
   */
  filter: string;
  /**
   * The order by of the slow query log.
   * Support order by count, latest_log_time, average_query_time,
   * maximum_query_time, average_rows_sent, maximum_rows_sent,
   * average_rows_examined, maximum_rows_examined for now. For example:
   *  - order by count: order_by = "count"
   *  - order by latest_log_time desc: order_by = "latest_log_time desc"
   * Default: order by average_query_time desc.
   */
  orderBy: string;
}

/** ListSlowQueriesResponse is the response of listing slow query. */
export interface ListSlowQueriesResponse {
  /** The slow query logs. */
  slowQueryLogs: SlowQueryLog[];
}

/** SlowQueryLog is the slow query log. */
export interface SlowQueryLog {
  /**
   * The resource of the slow query log.
   * The format is "instances/{instance}/databases/{database}".
   */
  resource: string;
  /**
   * The project of the slow query log.
   * The format is "projects/{project}".
   */
  project: string;
  /** The statistics of the slow query log. */
  statistics: SlowQueryStatistics | undefined;
}

/** SlowQueryStatistics is the statistics of the slow query log. */
export interface SlowQueryStatistics {
  /** The fingerprint of the slow query log. */
  sqlFingerprint: string;
  /** The count of the slow query log. */
  count: number;
  /** The latest log time of the slow query log. */
  latestLogTime:
    | Timestamp
    | undefined;
  /** The average query time of the slow query log. */
  averageQueryTime:
    | Duration
    | undefined;
  /** The maximum query time of the slow query log. */
  maximumQueryTime:
    | Duration
    | undefined;
  /** The average rows sent of the slow query log. */
  averageRowsSent: number;
  /** The maximum rows sent of the slow query log. */
  maximumRowsSent: number;
  /** The average rows examined of the slow query log. */
  averageRowsExamined: number;
  /** The maximum rows examined of the slow query log. */
  maximumRowsExamined: number;
  /** The percentage of the query time. */
  queryTimePercent: number;
  /** The percentage of the count. */
  countPercent: number;
  /**
   * Samples are details of the sample slow query logs with the same
   * fingerprint.
   */
  samples: SlowQueryDetails[];
}

/** SlowQueryDetails is the details of the slow query log. */
export interface SlowQueryDetails {
  /** The start time of the slow query log. */
  startTime:
    | Timestamp
    | undefined;
  /** The query time of the slow query log. */
  queryTime:
    | Duration
    | undefined;
  /** The lock time of the slow query log. */
  lockTime:
    | Duration
    | undefined;
  /** The rows sent of the slow query log. */
  rowsSent: number;
  /** The rows examined of the slow query log. */
  rowsExamined: number;
  /** The sql text of the slow query log. */
  sqlText: string;
}

export interface ListSecretsRequest {
  /**
   * The parent of the secret.
   * Format: instances/{instance}/databases/{database}
   */
  parent: string;
  /**
   * Not used.
   * The maximum number of secrets to return. The service may return fewer than
   * this value.
   * If unspecified, at most 10 secrets will be returned.
   * The maximum value is 1000; values above 1000 will be coerced to 1000.
   */
  pageSize: number;
  /**
   * Not used.
   * A page token, received from a previous `ListSecrets` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListSecrets` must match
   * the call that provided the page token.
   */
  pageToken: string;
}

export interface ListSecretsResponse {
  /** The list of secrets. */
  secrets: Secret[];
  /**
   * Not used. A token, which can be sent as `page_token` to retrieve the next
   * page. If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
}

export interface UpdateSecretRequest {
  /** The secret to be created or updated. */
  secret:
    | Secret
    | undefined;
  /** The mask of the fields to be updated. */
  updateMask:
    | string[]
    | undefined;
  /** If true, the secret will be created if it does not exist. */
  allowMissing: boolean;
}

export interface DeleteSecretRequest {
  /**
   * The name of the secret to be deleted.
   * Format:
   * instances/{instance}/databases/{database}/secrets/{secret}
   */
  name: string;
}

/** Secret is the secret of the database now. */
export interface Secret {
  /**
   * name is the unique name of the secret, which is specified by the client.
   * Format:
   * instances/{instance}/databases/{database}/secrets/{secret}
   */
  name: string;
  /** Not used. The timestamp when the secret resource was created initially. */
  createdTime:
    | Timestamp
    | undefined;
  /** Not used. The timestamp when the secret resource was updated. */
  updatedTime:
    | Timestamp
    | undefined;
  /** The value of the secret. */
  value: string;
  /** The description of the secret. */
  description: string;
}

/** AdviseIndexRequest is the request of advising index. */
export interface AdviseIndexRequest {
  /** Format: instances/{instance}/databases/{database} */
  parent: string;
  /** The statement to be advised. */
  statement: string;
}

/** AdviseIndexResponse is the response of advising index. */
export interface AdviseIndexResponse {
  /** The current index of the statement used. */
  currentIndex: string;
  /** The suggested index of the statement. */
  suggestion: string;
  /** The create index statement of the suggested index. */
  createIndexStatement: string;
}

export interface ChangeHistory {
  /**
   * Format:
   * instances/{instance}/databases/{database}/changeHistories/{changeHistory}
   */
  name: string;
  /** Format: users/hello@world.com */
  creator: string;
  /** Format: users/hello@world.com */
  updater: string;
  createTime: Timestamp | undefined;
  updateTime:
    | Timestamp
    | undefined;
  /** release version of Bytebase */
  releaseVersion: string;
  source: ChangeHistory_Source;
  type: ChangeHistory_Type;
  status: ChangeHistory_Status;
  version: string;
  description: string;
  /** The statement is used for preview purpose. */
  statement: string;
  statementSize: Long;
  /**
   * The name of the sheet resource.
   * Format: projects/{project}/sheets/{sheet}
   */
  statementSheet: string;
  schema: string;
  schemaSize: Long;
  prevSchema: string;
  prevSchemaSize: Long;
  executionDuration:
    | Duration
    | undefined;
  /** Format: projects/{project}/issues/{issue} */
  issue: string;
  changedResources: ChangedResources | undefined;
}

export enum ChangeHistory_Source {
  SOURCE_UNSPECIFIED = "SOURCE_UNSPECIFIED",
  UI = "UI",
  VCS = "VCS",
  LIBRARY = "LIBRARY",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function changeHistory_SourceFromJSON(object: any): ChangeHistory_Source {
  switch (object) {
    case 0:
    case "SOURCE_UNSPECIFIED":
      return ChangeHistory_Source.SOURCE_UNSPECIFIED;
    case 1:
    case "UI":
      return ChangeHistory_Source.UI;
    case 2:
    case "VCS":
      return ChangeHistory_Source.VCS;
    case 3:
    case "LIBRARY":
      return ChangeHistory_Source.LIBRARY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ChangeHistory_Source.UNRECOGNIZED;
  }
}

export function changeHistory_SourceToJSON(object: ChangeHistory_Source): string {
  switch (object) {
    case ChangeHistory_Source.SOURCE_UNSPECIFIED:
      return "SOURCE_UNSPECIFIED";
    case ChangeHistory_Source.UI:
      return "UI";
    case ChangeHistory_Source.VCS:
      return "VCS";
    case ChangeHistory_Source.LIBRARY:
      return "LIBRARY";
    case ChangeHistory_Source.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function changeHistory_SourceToNumber(object: ChangeHistory_Source): number {
  switch (object) {
    case ChangeHistory_Source.SOURCE_UNSPECIFIED:
      return 0;
    case ChangeHistory_Source.UI:
      return 1;
    case ChangeHistory_Source.VCS:
      return 2;
    case ChangeHistory_Source.LIBRARY:
      return 3;
    case ChangeHistory_Source.UNRECOGNIZED:
    default:
      return -1;
  }
}

export enum ChangeHistory_Type {
  TYPE_UNSPECIFIED = "TYPE_UNSPECIFIED",
  BASELINE = "BASELINE",
  MIGRATE = "MIGRATE",
  MIGRATE_SDL = "MIGRATE_SDL",
  MIGRATE_GHOST = "MIGRATE_GHOST",
  DATA = "DATA",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function changeHistory_TypeFromJSON(object: any): ChangeHistory_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return ChangeHistory_Type.TYPE_UNSPECIFIED;
    case 1:
    case "BASELINE":
      return ChangeHistory_Type.BASELINE;
    case 2:
    case "MIGRATE":
      return ChangeHistory_Type.MIGRATE;
    case 3:
    case "MIGRATE_SDL":
      return ChangeHistory_Type.MIGRATE_SDL;
    case 4:
    case "MIGRATE_GHOST":
      return ChangeHistory_Type.MIGRATE_GHOST;
    case 6:
    case "DATA":
      return ChangeHistory_Type.DATA;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ChangeHistory_Type.UNRECOGNIZED;
  }
}

export function changeHistory_TypeToJSON(object: ChangeHistory_Type): string {
  switch (object) {
    case ChangeHistory_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case ChangeHistory_Type.BASELINE:
      return "BASELINE";
    case ChangeHistory_Type.MIGRATE:
      return "MIGRATE";
    case ChangeHistory_Type.MIGRATE_SDL:
      return "MIGRATE_SDL";
    case ChangeHistory_Type.MIGRATE_GHOST:
      return "MIGRATE_GHOST";
    case ChangeHistory_Type.DATA:
      return "DATA";
    case ChangeHistory_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function changeHistory_TypeToNumber(object: ChangeHistory_Type): number {
  switch (object) {
    case ChangeHistory_Type.TYPE_UNSPECIFIED:
      return 0;
    case ChangeHistory_Type.BASELINE:
      return 1;
    case ChangeHistory_Type.MIGRATE:
      return 2;
    case ChangeHistory_Type.MIGRATE_SDL:
      return 3;
    case ChangeHistory_Type.MIGRATE_GHOST:
      return 4;
    case ChangeHistory_Type.DATA:
      return 6;
    case ChangeHistory_Type.UNRECOGNIZED:
    default:
      return -1;
  }
}

export enum ChangeHistory_Status {
  STATUS_UNSPECIFIED = "STATUS_UNSPECIFIED",
  PENDING = "PENDING",
  DONE = "DONE",
  FAILED = "FAILED",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function changeHistory_StatusFromJSON(object: any): ChangeHistory_Status {
  switch (object) {
    case 0:
    case "STATUS_UNSPECIFIED":
      return ChangeHistory_Status.STATUS_UNSPECIFIED;
    case 1:
    case "PENDING":
      return ChangeHistory_Status.PENDING;
    case 2:
    case "DONE":
      return ChangeHistory_Status.DONE;
    case 3:
    case "FAILED":
      return ChangeHistory_Status.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ChangeHistory_Status.UNRECOGNIZED;
  }
}

export function changeHistory_StatusToJSON(object: ChangeHistory_Status): string {
  switch (object) {
    case ChangeHistory_Status.STATUS_UNSPECIFIED:
      return "STATUS_UNSPECIFIED";
    case ChangeHistory_Status.PENDING:
      return "PENDING";
    case ChangeHistory_Status.DONE:
      return "DONE";
    case ChangeHistory_Status.FAILED:
      return "FAILED";
    case ChangeHistory_Status.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function changeHistory_StatusToNumber(object: ChangeHistory_Status): number {
  switch (object) {
    case ChangeHistory_Status.STATUS_UNSPECIFIED:
      return 0;
    case ChangeHistory_Status.PENDING:
      return 1;
    case ChangeHistory_Status.DONE:
      return 2;
    case ChangeHistory_Status.FAILED:
      return 3;
    case ChangeHistory_Status.UNRECOGNIZED:
    default:
      return -1;
  }
}

export interface ChangedResources {
  databases: ChangedResourceDatabase[];
}

export interface ChangedResourceDatabase {
  name: string;
  schemas: ChangedResourceSchema[];
}

export interface ChangedResourceSchema {
  name: string;
  tables: ChangedResourceTable[];
  views: ChangedResourceView[];
  functions: ChangedResourceFunction[];
  procedures: ChangedResourceProcedure[];
}

export interface ChangedResourceTable {
  name: string;
  /** The ranges of sub-strings correspond to the statements on the sheet. */
  ranges: Range[];
}

export interface ChangedResourceView {
  name: string;
  /** The ranges of sub-strings correspond to the statements on the sheet. */
  ranges: Range[];
}

export interface ChangedResourceFunction {
  name: string;
  /** The ranges of sub-strings correspond to the statements on the sheet. */
  ranges: Range[];
}

export interface ChangedResourceProcedure {
  name: string;
  /** The ranges of sub-strings correspond to the statements on the sheet. */
  ranges: Range[];
}

export interface ListChangeHistoriesRequest {
  /**
   * The parent of the change histories.
   * Format: instances/{instance}/databases/{database}
   */
  parent: string;
  /**
   * The maximum number of change histories to return. The service may return
   * fewer than this value. If unspecified, at most 10 change histories will be
   * returned. The maximum value is 1000; values above 1000 will be coerced to
   * 1000.
   */
  pageSize: number;
  /**
   * A page token, received from a previous `ListChangeHistories` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListChangeHistories`
   * must match the call that provided the page token.
   */
  pageToken: string;
  view: ChangeHistoryView;
  /**
   * The filter of the change histories.
   * follow the
   * [ebnf](https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form)
   * syntax. Support filter by type, source or table. For example: table =
   * "tableExists('{database}', '{schema}', '{table}')" table =
   * "tableExists('db', 'public', 'table1') || tableExists('db', 'public',
   * 'table2')" type = "MIGRATE | DATA" source = "UI" source = "VCS"
   *
   * The table filter follow the CEL syntax.
   * currently, we have one function for CEL:
   * - tableExists(database, schema, table): return true if the table exists in
   * changed resources.
   *
   * examples:
   * Use
   *   tableExists("db", "public", "table1")
   * to filter the change histories which have the table "table1" in the schema
   * "public" of the database "db". For MySQL, the schema is always "", such as
   * tableExists("db", "", "table1").
   *
   * Combine multiple functions with "&&" and "||", we MUST use the Disjunctive
   * Normal Form(DNF). In other words, the CEL expression consists of several
   * parts connected by OR operators. For example, the following expression is
   * valid:
   * (
   *  tableExists("db", "public", "table1") &&
   *  tableExists("db", "public", "table2")
   * ) || (
   *  tableExists("db", "public", "table3")
   * )
   */
  filter: string;
}

export interface ListChangeHistoriesResponse {
  /** The list of change histories. */
  changeHistories: ChangeHistory[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
}

export interface GetChangeHistoryRequest {
  /**
   * The name of the change history to retrieve.
   * Format:
   * instances/{instance}/databases/{database}/changeHistories/{changeHistory}
   */
  name: string;
  view: ChangeHistoryView;
  /** Format the schema dump into SDL format. */
  sdlFormat: boolean;
  /**
   * When true, the schema dump will be concise.
   * For Oracle, there will be tables and indexes only for Sync Schema.
   * For Postgres, we'll filter the backup schema.
   */
  concise: boolean;
}

export interface ListRevisionsRequest {
  /**
   * The parent of the revisions.
   * Format: instances/{instance}/databases/{database}
   */
  parent: string;
  /**
   * The maximum number of revisions to return. The service may return fewer
   * than this value. If unspecified, at most 10 revisions will be returned. The
   * maximum value is 1000; values above 1000 will be coerced to 1000.
   */
  pageSize: number;
  /**
   * A page token, received from a previous `ListRevisions` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListRevisions` must
   * match the call that provided the page token.
   */
  pageToken: string;
  showDeleted: boolean;
}

export interface ListRevisionsResponse {
  revisions: Revision[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
}

export interface CreateRevisionRequest {
  /** Format: instances/{instance}/databases/{database} */
  parent: string;
  /** The revision to create. */
  revision: Revision | undefined;
}

export interface GetRevisionRequest {
  /**
   * The name of the revision.
   * Format: instances/{instance}/databases/{database}/revisions/{revision}
   */
  name: string;
}

export interface DeleteRevisionRequest {
  /**
   * The name of the revision to delete.
   * Format: instances/{instance}/databases/{database}/revisions/{revision}
   */
  name: string;
}

export interface Revision {
  /** Format: instances/{instance}/databases/{database}/revisions/{revision} */
  name: string;
  /**
   * Format: projects/{project}/releases/{release}
   * Can be empty.
   */
  release: string;
  /** Format: users/hello@world.com */
  creator: string;
  createTime:
    | Timestamp
    | undefined;
  /**
   * Format: users/hello@world.com
   * Can be empty.
   */
  deleter: string;
  /** Can be empty. */
  deleteTime:
    | Timestamp
    | undefined;
  /**
   * Format: projects/{project}/releases/{release}/files/{id}
   * Can be empty.
   */
  file: string;
  version: string;
  /**
   * The sheet that holds the content.
   * Format: projects/{project}/sheets/{sheet}
   */
  sheet: string;
  /** The SHA256 hash value of the sheet. */
  sheetSha256: string;
  /** The statement is used for preview purpose. */
  statement: string;
  statementSize: Long;
  /**
   * The issue associated with the revision.
   * Can be empty.
   * Format: projects/{project}/issues/{issue}
   */
  issue: string;
  /**
   * The task run associated with the revision.
   * Can be empty.
   * Format:
   * projects/{project}/rollouts/{rollout}/stages/{stage}/tasks/{task}/taskRuns/{taskRun}
   */
  taskRun: string;
}

export interface ListChangelogsRequest {
  /**
   * The parent of the changelogs.
   * Format: instances/{instance}/databases/{database}
   */
  parent: string;
  /**
   * The maximum number of changelogs to return. The service may return fewer
   * than this value. If unspecified, at most 10 changelogs will be returned.
   * The maximum value is 1000; values above 1000 will be coerced to 1000.
   */
  pageSize: number;
  /**
   * A page token, received from the previous call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided must match
   * the call that provided the page token.
   */
  pageToken: string;
  view: ChangelogView;
  /**
   * The filter of the changelogs.
   * follow the
   * [ebnf](https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form)
   * syntax. Support filter by type, source or table. For example: table =
   * "tableExists('{database}', '{schema}', '{table}')" table =
   * "tableExists('db', 'public', 'table1') || tableExists('db', 'public',
   * 'table2')" type = "MIGRATE | DATA" source = "UI" source = "VCS"
   *
   * The table filter follow the CEL syntax.
   * currently, we have one function for CEL:
   * - tableExists(database, schema, table): return true if the table exists in
   * changed resources.
   *
   * examples:
   * Use
   *   tableExists("db", "public", "table1")
   * to filter the changelogs which have the table "table1" in the schema
   * "public" of the database "db". For MySQL, the schema is always "", such as
   * tableExists("db", "", "table1").
   *
   * Combine multiple functions with "&&" and "||", we MUST use the Disjunctive
   * Normal Form(DNF). In other words, the CEL expression consists of several
   * parts connected by OR operators. For example, the following expression is
   * valid:
   * (
   *  tableExists("db", "public", "table1") &&
   *  tableExists("db", "public", "table2")
   * ) || (
   *  tableExists("db", "public", "table3")
   * )
   */
  filter: string;
}

export interface ListChangelogsResponse {
  /** The list of changelogs. */
  changelogs: Changelog[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
}

export interface GetChangelogRequest {
  /**
   * The name of the changelog to retrieve.
   * Format: instances/{instance}/databases/{database}/changelogs/{changelog}
   */
  name: string;
  view: ChangelogView;
  /** Format the schema dump into SDL format. */
  sdlFormat: boolean;
  /**
   * When true, the schema dump will be concise.
   * For Oracle, there will be tables and indexes only for Sync Schema.
   * For Postgres, we'll filter the backup schema.
   */
  concise: boolean;
}

export interface Changelog {
  /** Format: instances/{instance}/databases/{database}/changelogs/{changelog} */
  name: string;
  /** Format: users/hello@world.com */
  creator: string;
  createTime: Timestamp | undefined;
  status: Changelog_Status;
  /** The statement is used for preview purpose. */
  statement: string;
  statementSize: Long;
  /**
   * The name of the sheet resource.
   * Format: projects/{project}/sheets/{sheet}
   */
  statementSheet: string;
  schema: string;
  schemaSize: Long;
  prevSchema: string;
  prevSchemaSize: Long;
  /** Format: projects/{project}/issues/{issue} */
  issue: string;
  /**
   * Could be empty
   * TODO(p0ny): We will migrate ChangeHistory to Changelog, and they won't have
   * task_run.
   */
  taskRun: string;
  /** Could be empty */
  version: string;
  /**
   * Could be empty
   * Or present but not found if deleted
   */
  revision: string;
  changedResources: ChangedResources | undefined;
}

export enum Changelog_Status {
  STATUS_UNSPECIFIED = "STATUS_UNSPECIFIED",
  PENDING = "PENDING",
  DONE = "DONE",
  FAILED = "FAILED",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function changelog_StatusFromJSON(object: any): Changelog_Status {
  switch (object) {
    case 0:
    case "STATUS_UNSPECIFIED":
      return Changelog_Status.STATUS_UNSPECIFIED;
    case 1:
    case "PENDING":
      return Changelog_Status.PENDING;
    case 2:
    case "DONE":
      return Changelog_Status.DONE;
    case 3:
    case "FAILED":
      return Changelog_Status.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Changelog_Status.UNRECOGNIZED;
  }
}

export function changelog_StatusToJSON(object: Changelog_Status): string {
  switch (object) {
    case Changelog_Status.STATUS_UNSPECIFIED:
      return "STATUS_UNSPECIFIED";
    case Changelog_Status.PENDING:
      return "PENDING";
    case Changelog_Status.DONE:
      return "DONE";
    case Changelog_Status.FAILED:
      return "FAILED";
    case Changelog_Status.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function changelog_StatusToNumber(object: Changelog_Status): number {
  switch (object) {
    case Changelog_Status.STATUS_UNSPECIFIED:
      return 0;
    case Changelog_Status.PENDING:
      return 1;
    case Changelog_Status.DONE:
      return 2;
    case Changelog_Status.FAILED:
      return 3;
    case Changelog_Status.UNRECOGNIZED:
    default:
      return -1;
  }
}

function createBaseGetDatabaseRequest(): GetDatabaseRequest {
  return { name: "" };
}

export const GetDatabaseRequest: MessageFns<GetDatabaseRequest> = {
  encode(message: GetDatabaseRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDatabaseRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDatabaseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDatabaseRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetDatabaseRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetDatabaseRequest>): GetDatabaseRequest {
    return GetDatabaseRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetDatabaseRequest>): GetDatabaseRequest {
    const message = createBaseGetDatabaseRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListInstanceDatabasesRequest(): ListInstanceDatabasesRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "" };
}

export const ListInstanceDatabasesRequest: MessageFns<ListInstanceDatabasesRequest> = {
  encode(message: ListInstanceDatabasesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListInstanceDatabasesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListInstanceDatabasesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListInstanceDatabasesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListInstanceDatabasesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListInstanceDatabasesRequest>): ListInstanceDatabasesRequest {
    return ListInstanceDatabasesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListInstanceDatabasesRequest>): ListInstanceDatabasesRequest {
    const message = createBaseListInstanceDatabasesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListInstanceDatabasesResponse(): ListInstanceDatabasesResponse {
  return { databases: [], nextPageToken: "" };
}

export const ListInstanceDatabasesResponse: MessageFns<ListInstanceDatabasesResponse> = {
  encode(message: ListInstanceDatabasesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.databases) {
      Database.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListInstanceDatabasesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListInstanceDatabasesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.databases.push(Database.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListInstanceDatabasesResponse {
    return {
      databases: globalThis.Array.isArray(object?.databases)
        ? object.databases.map((e: any) => Database.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListInstanceDatabasesResponse): unknown {
    const obj: any = {};
    if (message.databases?.length) {
      obj.databases = message.databases.map((e) => Database.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListInstanceDatabasesResponse>): ListInstanceDatabasesResponse {
    return ListInstanceDatabasesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListInstanceDatabasesResponse>): ListInstanceDatabasesResponse {
    const message = createBaseListInstanceDatabasesResponse();
    message.databases = object.databases?.map((e) => Database.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseListDatabasesRequest(): ListDatabasesRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListDatabasesRequest: MessageFns<ListDatabasesRequest> = {
  encode(message: ListDatabasesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListDatabasesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDatabasesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDatabasesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListDatabasesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListDatabasesRequest>): ListDatabasesRequest {
    return ListDatabasesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListDatabasesRequest>): ListDatabasesRequest {
    const message = createBaseListDatabasesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListDatabasesResponse(): ListDatabasesResponse {
  return { databases: [], nextPageToken: "" };
}

export const ListDatabasesResponse: MessageFns<ListDatabasesResponse> = {
  encode(message: ListDatabasesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.databases) {
      Database.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListDatabasesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDatabasesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.databases.push(Database.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDatabasesResponse {
    return {
      databases: globalThis.Array.isArray(object?.databases)
        ? object.databases.map((e: any) => Database.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListDatabasesResponse): unknown {
    const obj: any = {};
    if (message.databases?.length) {
      obj.databases = message.databases.map((e) => Database.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListDatabasesResponse>): ListDatabasesResponse {
    return ListDatabasesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListDatabasesResponse>): ListDatabasesResponse {
    const message = createBaseListDatabasesResponse();
    message.databases = object.databases?.map((e) => Database.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseUpdateDatabaseRequest(): UpdateDatabaseRequest {
  return { database: undefined, updateMask: undefined };
}

export const UpdateDatabaseRequest: MessageFns<UpdateDatabaseRequest> = {
  encode(message: UpdateDatabaseRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.database !== undefined) {
      Database.encode(message.database, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateDatabaseRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateDatabaseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.database = Database.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateDatabaseRequest {
    return {
      database: isSet(object.database) ? Database.fromJSON(object.database) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateDatabaseRequest): unknown {
    const obj: any = {};
    if (message.database !== undefined) {
      obj.database = Database.toJSON(message.database);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateDatabaseRequest>): UpdateDatabaseRequest {
    return UpdateDatabaseRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateDatabaseRequest>): UpdateDatabaseRequest {
    const message = createBaseUpdateDatabaseRequest();
    message.database = (object.database !== undefined && object.database !== null)
      ? Database.fromPartial(object.database)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseBatchUpdateDatabasesRequest(): BatchUpdateDatabasesRequest {
  return { parent: "", requests: [] };
}

export const BatchUpdateDatabasesRequest: MessageFns<BatchUpdateDatabasesRequest> = {
  encode(message: BatchUpdateDatabasesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    for (const v of message.requests) {
      UpdateDatabaseRequest.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchUpdateDatabasesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchUpdateDatabasesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requests.push(UpdateDatabaseRequest.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchUpdateDatabasesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      requests: globalThis.Array.isArray(object?.requests)
        ? object.requests.map((e: any) => UpdateDatabaseRequest.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BatchUpdateDatabasesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.requests?.length) {
      obj.requests = message.requests.map((e) => UpdateDatabaseRequest.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BatchUpdateDatabasesRequest>): BatchUpdateDatabasesRequest {
    return BatchUpdateDatabasesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchUpdateDatabasesRequest>): BatchUpdateDatabasesRequest {
    const message = createBaseBatchUpdateDatabasesRequest();
    message.parent = object.parent ?? "";
    message.requests = object.requests?.map((e) => UpdateDatabaseRequest.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBatchUpdateDatabasesResponse(): BatchUpdateDatabasesResponse {
  return { databases: [] };
}

export const BatchUpdateDatabasesResponse: MessageFns<BatchUpdateDatabasesResponse> = {
  encode(message: BatchUpdateDatabasesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.databases) {
      Database.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchUpdateDatabasesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchUpdateDatabasesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.databases.push(Database.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchUpdateDatabasesResponse {
    return {
      databases: globalThis.Array.isArray(object?.databases)
        ? object.databases.map((e: any) => Database.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BatchUpdateDatabasesResponse): unknown {
    const obj: any = {};
    if (message.databases?.length) {
      obj.databases = message.databases.map((e) => Database.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BatchUpdateDatabasesResponse>): BatchUpdateDatabasesResponse {
    return BatchUpdateDatabasesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchUpdateDatabasesResponse>): BatchUpdateDatabasesResponse {
    const message = createBaseBatchUpdateDatabasesResponse();
    message.databases = object.databases?.map((e) => Database.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSyncDatabaseRequest(): SyncDatabaseRequest {
  return { name: "" };
}

export const SyncDatabaseRequest: MessageFns<SyncDatabaseRequest> = {
  encode(message: SyncDatabaseRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SyncDatabaseRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncDatabaseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SyncDatabaseRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: SyncDatabaseRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<SyncDatabaseRequest>): SyncDatabaseRequest {
    return SyncDatabaseRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SyncDatabaseRequest>): SyncDatabaseRequest {
    const message = createBaseSyncDatabaseRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseSyncDatabaseResponse(): SyncDatabaseResponse {
  return {};
}

export const SyncDatabaseResponse: MessageFns<SyncDatabaseResponse> = {
  encode(_: SyncDatabaseResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SyncDatabaseResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncDatabaseResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): SyncDatabaseResponse {
    return {};
  },

  toJSON(_: SyncDatabaseResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<SyncDatabaseResponse>): SyncDatabaseResponse {
    return SyncDatabaseResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<SyncDatabaseResponse>): SyncDatabaseResponse {
    const message = createBaseSyncDatabaseResponse();
    return message;
  },
};

function createBaseGetDatabaseMetadataRequest(): GetDatabaseMetadataRequest {
  return { name: "", view: DatabaseMetadataView.DATABASE_METADATA_VIEW_UNSPECIFIED, filter: "" };
}

export const GetDatabaseMetadataRequest: MessageFns<GetDatabaseMetadataRequest> = {
  encode(message: GetDatabaseMetadataRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.view !== DatabaseMetadataView.DATABASE_METADATA_VIEW_UNSPECIFIED) {
      writer.uint32(16).int32(databaseMetadataViewToNumber(message.view));
    }
    if (message.filter !== "") {
      writer.uint32(26).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDatabaseMetadataRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDatabaseMetadataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.view = databaseMetadataViewFromJSON(reader.int32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDatabaseMetadataRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      view: isSet(object.view)
        ? databaseMetadataViewFromJSON(object.view)
        : DatabaseMetadataView.DATABASE_METADATA_VIEW_UNSPECIFIED,
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: GetDatabaseMetadataRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.view !== DatabaseMetadataView.DATABASE_METADATA_VIEW_UNSPECIFIED) {
      obj.view = databaseMetadataViewToJSON(message.view);
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<GetDatabaseMetadataRequest>): GetDatabaseMetadataRequest {
    return GetDatabaseMetadataRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetDatabaseMetadataRequest>): GetDatabaseMetadataRequest {
    const message = createBaseGetDatabaseMetadataRequest();
    message.name = object.name ?? "";
    message.view = object.view ?? DatabaseMetadataView.DATABASE_METADATA_VIEW_UNSPECIFIED;
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseUpdateDatabaseMetadataRequest(): UpdateDatabaseMetadataRequest {
  return { databaseMetadata: undefined, updateMask: undefined };
}

export const UpdateDatabaseMetadataRequest: MessageFns<UpdateDatabaseMetadataRequest> = {
  encode(message: UpdateDatabaseMetadataRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.databaseMetadata !== undefined) {
      DatabaseMetadata.encode(message.databaseMetadata, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateDatabaseMetadataRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateDatabaseMetadataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.databaseMetadata = DatabaseMetadata.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateDatabaseMetadataRequest {
    return {
      databaseMetadata: isSet(object.databaseMetadata) ? DatabaseMetadata.fromJSON(object.databaseMetadata) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateDatabaseMetadataRequest): unknown {
    const obj: any = {};
    if (message.databaseMetadata !== undefined) {
      obj.databaseMetadata = DatabaseMetadata.toJSON(message.databaseMetadata);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateDatabaseMetadataRequest>): UpdateDatabaseMetadataRequest {
    return UpdateDatabaseMetadataRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateDatabaseMetadataRequest>): UpdateDatabaseMetadataRequest {
    const message = createBaseUpdateDatabaseMetadataRequest();
    message.databaseMetadata = (object.databaseMetadata !== undefined && object.databaseMetadata !== null)
      ? DatabaseMetadata.fromPartial(object.databaseMetadata)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseGetDatabaseSchemaRequest(): GetDatabaseSchemaRequest {
  return { name: "", sdlFormat: false, concise: false };
}

export const GetDatabaseSchemaRequest: MessageFns<GetDatabaseSchemaRequest> = {
  encode(message: GetDatabaseSchemaRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.sdlFormat !== false) {
      writer.uint32(16).bool(message.sdlFormat);
    }
    if (message.concise !== false) {
      writer.uint32(24).bool(message.concise);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDatabaseSchemaRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDatabaseSchemaRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.sdlFormat = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.concise = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDatabaseSchemaRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      sdlFormat: isSet(object.sdlFormat) ? globalThis.Boolean(object.sdlFormat) : false,
      concise: isSet(object.concise) ? globalThis.Boolean(object.concise) : false,
    };
  },

  toJSON(message: GetDatabaseSchemaRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.sdlFormat !== false) {
      obj.sdlFormat = message.sdlFormat;
    }
    if (message.concise !== false) {
      obj.concise = message.concise;
    }
    return obj;
  },

  create(base?: DeepPartial<GetDatabaseSchemaRequest>): GetDatabaseSchemaRequest {
    return GetDatabaseSchemaRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetDatabaseSchemaRequest>): GetDatabaseSchemaRequest {
    const message = createBaseGetDatabaseSchemaRequest();
    message.name = object.name ?? "";
    message.sdlFormat = object.sdlFormat ?? false;
    message.concise = object.concise ?? false;
    return message;
  },
};

function createBaseDiffSchemaRequest(): DiffSchemaRequest {
  return { name: "", schema: undefined, changeHistory: undefined, sdlFormat: false };
}

export const DiffSchemaRequest: MessageFns<DiffSchemaRequest> = {
  encode(message: DiffSchemaRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.schema !== undefined) {
      writer.uint32(18).string(message.schema);
    }
    if (message.changeHistory !== undefined) {
      writer.uint32(26).string(message.changeHistory);
    }
    if (message.sdlFormat !== false) {
      writer.uint32(32).bool(message.sdlFormat);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DiffSchemaRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiffSchemaRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.schema = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.changeHistory = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.sdlFormat = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DiffSchemaRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      schema: isSet(object.schema) ? globalThis.String(object.schema) : undefined,
      changeHistory: isSet(object.changeHistory) ? globalThis.String(object.changeHistory) : undefined,
      sdlFormat: isSet(object.sdlFormat) ? globalThis.Boolean(object.sdlFormat) : false,
    };
  },

  toJSON(message: DiffSchemaRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.schema !== undefined) {
      obj.schema = message.schema;
    }
    if (message.changeHistory !== undefined) {
      obj.changeHistory = message.changeHistory;
    }
    if (message.sdlFormat !== false) {
      obj.sdlFormat = message.sdlFormat;
    }
    return obj;
  },

  create(base?: DeepPartial<DiffSchemaRequest>): DiffSchemaRequest {
    return DiffSchemaRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DiffSchemaRequest>): DiffSchemaRequest {
    const message = createBaseDiffSchemaRequest();
    message.name = object.name ?? "";
    message.schema = object.schema ?? undefined;
    message.changeHistory = object.changeHistory ?? undefined;
    message.sdlFormat = object.sdlFormat ?? false;
    return message;
  },
};

function createBaseDiffSchemaResponse(): DiffSchemaResponse {
  return { diff: "" };
}

export const DiffSchemaResponse: MessageFns<DiffSchemaResponse> = {
  encode(message: DiffSchemaResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.diff !== "") {
      writer.uint32(10).string(message.diff);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DiffSchemaResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiffSchemaResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.diff = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DiffSchemaResponse {
    return { diff: isSet(object.diff) ? globalThis.String(object.diff) : "" };
  },

  toJSON(message: DiffSchemaResponse): unknown {
    const obj: any = {};
    if (message.diff !== "") {
      obj.diff = message.diff;
    }
    return obj;
  },

  create(base?: DeepPartial<DiffSchemaResponse>): DiffSchemaResponse {
    return DiffSchemaResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DiffSchemaResponse>): DiffSchemaResponse {
    const message = createBaseDiffSchemaResponse();
    message.diff = object.diff ?? "";
    return message;
  },
};

function createBaseDatabase(): Database {
  return {
    name: "",
    syncState: State.STATE_UNSPECIFIED,
    successfulSyncTime: undefined,
    project: "",
    schemaVersion: "",
    environment: "",
    effectiveEnvironment: "",
    labels: {},
    instanceResource: undefined,
    backupAvailable: false,
  };
}

export const Database: MessageFns<Database> = {
  encode(message: Database, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.syncState !== State.STATE_UNSPECIFIED) {
      writer.uint32(24).int32(stateToNumber(message.syncState));
    }
    if (message.successfulSyncTime !== undefined) {
      Timestamp.encode(message.successfulSyncTime, writer.uint32(34).fork()).join();
    }
    if (message.project !== "") {
      writer.uint32(42).string(message.project);
    }
    if (message.schemaVersion !== "") {
      writer.uint32(50).string(message.schemaVersion);
    }
    if (message.environment !== "") {
      writer.uint32(58).string(message.environment);
    }
    if (message.effectiveEnvironment !== "") {
      writer.uint32(66).string(message.effectiveEnvironment);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Database_LabelsEntry.encode({ key: key as any, value }, writer.uint32(74).fork()).join();
    });
    if (message.instanceResource !== undefined) {
      InstanceResource.encode(message.instanceResource, writer.uint32(82).fork()).join();
    }
    if (message.backupAvailable !== false) {
      writer.uint32(88).bool(message.backupAvailable);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Database {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatabase();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.syncState = stateFromJSON(reader.int32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.successfulSyncTime = Timestamp.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.project = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.schemaVersion = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.environment = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.effectiveEnvironment = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          const entry9 = Database_LabelsEntry.decode(reader, reader.uint32());
          if (entry9.value !== undefined) {
            message.labels[entry9.key] = entry9.value;
          }
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.instanceResource = InstanceResource.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.backupAvailable = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Database {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      syncState: isSet(object.syncState) ? stateFromJSON(object.syncState) : State.STATE_UNSPECIFIED,
      successfulSyncTime: isSet(object.successfulSyncTime) ? fromJsonTimestamp(object.successfulSyncTime) : undefined,
      project: isSet(object.project) ? globalThis.String(object.project) : "",
      schemaVersion: isSet(object.schemaVersion) ? globalThis.String(object.schemaVersion) : "",
      environment: isSet(object.environment) ? globalThis.String(object.environment) : "",
      effectiveEnvironment: isSet(object.effectiveEnvironment) ? globalThis.String(object.effectiveEnvironment) : "",
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      instanceResource: isSet(object.instanceResource) ? InstanceResource.fromJSON(object.instanceResource) : undefined,
      backupAvailable: isSet(object.backupAvailable) ? globalThis.Boolean(object.backupAvailable) : false,
    };
  },

  toJSON(message: Database): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.syncState !== State.STATE_UNSPECIFIED) {
      obj.syncState = stateToJSON(message.syncState);
    }
    if (message.successfulSyncTime !== undefined) {
      obj.successfulSyncTime = fromTimestamp(message.successfulSyncTime).toISOString();
    }
    if (message.project !== "") {
      obj.project = message.project;
    }
    if (message.schemaVersion !== "") {
      obj.schemaVersion = message.schemaVersion;
    }
    if (message.environment !== "") {
      obj.environment = message.environment;
    }
    if (message.effectiveEnvironment !== "") {
      obj.effectiveEnvironment = message.effectiveEnvironment;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.instanceResource !== undefined) {
      obj.instanceResource = InstanceResource.toJSON(message.instanceResource);
    }
    if (message.backupAvailable !== false) {
      obj.backupAvailable = message.backupAvailable;
    }
    return obj;
  },

  create(base?: DeepPartial<Database>): Database {
    return Database.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Database>): Database {
    const message = createBaseDatabase();
    message.name = object.name ?? "";
    message.syncState = object.syncState ?? State.STATE_UNSPECIFIED;
    message.successfulSyncTime = (object.successfulSyncTime !== undefined && object.successfulSyncTime !== null)
      ? Timestamp.fromPartial(object.successfulSyncTime)
      : undefined;
    message.project = object.project ?? "";
    message.schemaVersion = object.schemaVersion ?? "";
    message.environment = object.environment ?? "";
    message.effectiveEnvironment = object.effectiveEnvironment ?? "";
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.instanceResource = (object.instanceResource !== undefined && object.instanceResource !== null)
      ? InstanceResource.fromPartial(object.instanceResource)
      : undefined;
    message.backupAvailable = object.backupAvailable ?? false;
    return message;
  },
};

function createBaseDatabase_LabelsEntry(): Database_LabelsEntry {
  return { key: "", value: "" };
}

export const Database_LabelsEntry: MessageFns<Database_LabelsEntry> = {
  encode(message: Database_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Database_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatabase_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Database_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Database_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Database_LabelsEntry>): Database_LabelsEntry {
    return Database_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Database_LabelsEntry>): Database_LabelsEntry {
    const message = createBaseDatabase_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseDatabaseMetadata(): DatabaseMetadata {
  return { name: "", schemas: [], characterSet: "", collation: "", extensions: [], schemaConfigs: [], owner: "" };
}

export const DatabaseMetadata: MessageFns<DatabaseMetadata> = {
  encode(message: DatabaseMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.schemas) {
      SchemaMetadata.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.characterSet !== "") {
      writer.uint32(26).string(message.characterSet);
    }
    if (message.collation !== "") {
      writer.uint32(34).string(message.collation);
    }
    for (const v of message.extensions) {
      ExtensionMetadata.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.schemaConfigs) {
      SchemaConfig.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.owner !== "") {
      writer.uint32(58).string(message.owner);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DatabaseMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatabaseMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.schemas.push(SchemaMetadata.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.characterSet = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.collation = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.extensions.push(ExtensionMetadata.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.schemaConfigs.push(SchemaConfig.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.owner = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DatabaseMetadata {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      schemas: globalThis.Array.isArray(object?.schemas)
        ? object.schemas.map((e: any) => SchemaMetadata.fromJSON(e))
        : [],
      characterSet: isSet(object.characterSet) ? globalThis.String(object.characterSet) : "",
      collation: isSet(object.collation) ? globalThis.String(object.collation) : "",
      extensions: globalThis.Array.isArray(object?.extensions)
        ? object.extensions.map((e: any) => ExtensionMetadata.fromJSON(e))
        : [],
      schemaConfigs: globalThis.Array.isArray(object?.schemaConfigs)
        ? object.schemaConfigs.map((e: any) => SchemaConfig.fromJSON(e))
        : [],
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
    };
  },

  toJSON(message: DatabaseMetadata): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.schemas?.length) {
      obj.schemas = message.schemas.map((e) => SchemaMetadata.toJSON(e));
    }
    if (message.characterSet !== "") {
      obj.characterSet = message.characterSet;
    }
    if (message.collation !== "") {
      obj.collation = message.collation;
    }
    if (message.extensions?.length) {
      obj.extensions = message.extensions.map((e) => ExtensionMetadata.toJSON(e));
    }
    if (message.schemaConfigs?.length) {
      obj.schemaConfigs = message.schemaConfigs.map((e) => SchemaConfig.toJSON(e));
    }
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    return obj;
  },

  create(base?: DeepPartial<DatabaseMetadata>): DatabaseMetadata {
    return DatabaseMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DatabaseMetadata>): DatabaseMetadata {
    const message = createBaseDatabaseMetadata();
    message.name = object.name ?? "";
    message.schemas = object.schemas?.map((e) => SchemaMetadata.fromPartial(e)) || [];
    message.characterSet = object.characterSet ?? "";
    message.collation = object.collation ?? "";
    message.extensions = object.extensions?.map((e) => ExtensionMetadata.fromPartial(e)) || [];
    message.schemaConfigs = object.schemaConfigs?.map((e) => SchemaConfig.fromPartial(e)) || [];
    message.owner = object.owner ?? "";
    return message;
  },
};

function createBaseSchemaMetadata(): SchemaMetadata {
  return {
    name: "",
    tables: [],
    externalTables: [],
    views: [],
    functions: [],
    procedures: [],
    streams: [],
    tasks: [],
    materializedViews: [],
    packages: [],
    owner: "",
    triggers: [],
    sequences: [],
    events: [],
  };
}

export const SchemaMetadata: MessageFns<SchemaMetadata> = {
  encode(message: SchemaMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.tables) {
      TableMetadata.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.externalTables) {
      ExternalTableMetadata.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.views) {
      ViewMetadata.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.functions) {
      FunctionMetadata.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.procedures) {
      ProcedureMetadata.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.streams) {
      StreamMetadata.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.tasks) {
      TaskMetadata.encode(v!, writer.uint32(66).fork()).join();
    }
    for (const v of message.materializedViews) {
      MaterializedViewMetadata.encode(v!, writer.uint32(74).fork()).join();
    }
    for (const v of message.packages) {
      PackageMetadata.encode(v!, writer.uint32(82).fork()).join();
    }
    if (message.owner !== "") {
      writer.uint32(90).string(message.owner);
    }
    for (const v of message.triggers) {
      TriggerMetadata.encode(v!, writer.uint32(98).fork()).join();
    }
    for (const v of message.sequences) {
      SequenceMetadata.encode(v!, writer.uint32(106).fork()).join();
    }
    for (const v of message.events) {
      EventMetadata.encode(v!, writer.uint32(114).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SchemaMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSchemaMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tables.push(TableMetadata.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.externalTables.push(ExternalTableMetadata.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.views.push(ViewMetadata.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.functions.push(FunctionMetadata.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.procedures.push(ProcedureMetadata.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.streams.push(StreamMetadata.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.tasks.push(TaskMetadata.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.materializedViews.push(MaterializedViewMetadata.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.packages.push(PackageMetadata.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.owner = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.triggers.push(TriggerMetadata.decode(reader, reader.uint32()));
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.sequences.push(SequenceMetadata.decode(reader, reader.uint32()));
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.events.push(EventMetadata.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SchemaMetadata {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      tables: globalThis.Array.isArray(object?.tables) ? object.tables.map((e: any) => TableMetadata.fromJSON(e)) : [],
      externalTables: globalThis.Array.isArray(object?.externalTables)
        ? object.externalTables.map((e: any) => ExternalTableMetadata.fromJSON(e))
        : [],
      views: globalThis.Array.isArray(object?.views) ? object.views.map((e: any) => ViewMetadata.fromJSON(e)) : [],
      functions: globalThis.Array.isArray(object?.functions)
        ? object.functions.map((e: any) => FunctionMetadata.fromJSON(e))
        : [],
      procedures: globalThis.Array.isArray(object?.procedures)
        ? object.procedures.map((e: any) => ProcedureMetadata.fromJSON(e))
        : [],
      streams: globalThis.Array.isArray(object?.streams)
        ? object.streams.map((e: any) => StreamMetadata.fromJSON(e))
        : [],
      tasks: globalThis.Array.isArray(object?.tasks) ? object.tasks.map((e: any) => TaskMetadata.fromJSON(e)) : [],
      materializedViews: globalThis.Array.isArray(object?.materializedViews)
        ? object.materializedViews.map((e: any) => MaterializedViewMetadata.fromJSON(e))
        : [],
      packages: globalThis.Array.isArray(object?.packages)
        ? object.packages.map((e: any) => PackageMetadata.fromJSON(e))
        : [],
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      triggers: globalThis.Array.isArray(object?.triggers)
        ? object.triggers.map((e: any) => TriggerMetadata.fromJSON(e))
        : [],
      sequences: globalThis.Array.isArray(object?.sequences)
        ? object.sequences.map((e: any) => SequenceMetadata.fromJSON(e))
        : [],
      events: globalThis.Array.isArray(object?.events)
        ? object.events.map((e: any) => EventMetadata.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SchemaMetadata): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.tables?.length) {
      obj.tables = message.tables.map((e) => TableMetadata.toJSON(e));
    }
    if (message.externalTables?.length) {
      obj.externalTables = message.externalTables.map((e) => ExternalTableMetadata.toJSON(e));
    }
    if (message.views?.length) {
      obj.views = message.views.map((e) => ViewMetadata.toJSON(e));
    }
    if (message.functions?.length) {
      obj.functions = message.functions.map((e) => FunctionMetadata.toJSON(e));
    }
    if (message.procedures?.length) {
      obj.procedures = message.procedures.map((e) => ProcedureMetadata.toJSON(e));
    }
    if (message.streams?.length) {
      obj.streams = message.streams.map((e) => StreamMetadata.toJSON(e));
    }
    if (message.tasks?.length) {
      obj.tasks = message.tasks.map((e) => TaskMetadata.toJSON(e));
    }
    if (message.materializedViews?.length) {
      obj.materializedViews = message.materializedViews.map((e) => MaterializedViewMetadata.toJSON(e));
    }
    if (message.packages?.length) {
      obj.packages = message.packages.map((e) => PackageMetadata.toJSON(e));
    }
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.triggers?.length) {
      obj.triggers = message.triggers.map((e) => TriggerMetadata.toJSON(e));
    }
    if (message.sequences?.length) {
      obj.sequences = message.sequences.map((e) => SequenceMetadata.toJSON(e));
    }
    if (message.events?.length) {
      obj.events = message.events.map((e) => EventMetadata.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SchemaMetadata>): SchemaMetadata {
    return SchemaMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SchemaMetadata>): SchemaMetadata {
    const message = createBaseSchemaMetadata();
    message.name = object.name ?? "";
    message.tables = object.tables?.map((e) => TableMetadata.fromPartial(e)) || [];
    message.externalTables = object.externalTables?.map((e) => ExternalTableMetadata.fromPartial(e)) || [];
    message.views = object.views?.map((e) => ViewMetadata.fromPartial(e)) || [];
    message.functions = object.functions?.map((e) => FunctionMetadata.fromPartial(e)) || [];
    message.procedures = object.procedures?.map((e) => ProcedureMetadata.fromPartial(e)) || [];
    message.streams = object.streams?.map((e) => StreamMetadata.fromPartial(e)) || [];
    message.tasks = object.tasks?.map((e) => TaskMetadata.fromPartial(e)) || [];
    message.materializedViews = object.materializedViews?.map((e) => MaterializedViewMetadata.fromPartial(e)) || [];
    message.packages = object.packages?.map((e) => PackageMetadata.fromPartial(e)) || [];
    message.owner = object.owner ?? "";
    message.triggers = object.triggers?.map((e) => TriggerMetadata.fromPartial(e)) || [];
    message.sequences = object.sequences?.map((e) => SequenceMetadata.fromPartial(e)) || [];
    message.events = object.events?.map((e) => EventMetadata.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEventMetadata(): EventMetadata {
  return { name: "", definition: "", timeZone: "", sqlMode: "", characterSetClient: "", collationConnection: "" };
}

export const EventMetadata: MessageFns<EventMetadata> = {
  encode(message: EventMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.definition !== "") {
      writer.uint32(18).string(message.definition);
    }
    if (message.timeZone !== "") {
      writer.uint32(26).string(message.timeZone);
    }
    if (message.sqlMode !== "") {
      writer.uint32(34).string(message.sqlMode);
    }
    if (message.characterSetClient !== "") {
      writer.uint32(42).string(message.characterSetClient);
    }
    if (message.collationConnection !== "") {
      writer.uint32(50).string(message.collationConnection);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.definition = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.timeZone = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sqlMode = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.characterSetClient = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.collationConnection = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventMetadata {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      definition: isSet(object.definition) ? globalThis.String(object.definition) : "",
      timeZone: isSet(object.timeZone) ? globalThis.String(object.timeZone) : "",
      sqlMode: isSet(object.sqlMode) ? globalThis.String(object.sqlMode) : "",
      characterSetClient: isSet(object.characterSetClient) ? globalThis.String(object.characterSetClient) : "",
      collationConnection: isSet(object.collationConnection) ? globalThis.String(object.collationConnection) : "",
    };
  },

  toJSON(message: EventMetadata): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.definition !== "") {
      obj.definition = message.definition;
    }
    if (message.timeZone !== "") {
      obj.timeZone = message.timeZone;
    }
    if (message.sqlMode !== "") {
      obj.sqlMode = message.sqlMode;
    }
    if (message.characterSetClient !== "") {
      obj.characterSetClient = message.characterSetClient;
    }
    if (message.collationConnection !== "") {
      obj.collationConnection = message.collationConnection;
    }
    return obj;
  },

  create(base?: DeepPartial<EventMetadata>): EventMetadata {
    return EventMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventMetadata>): EventMetadata {
    const message = createBaseEventMetadata();
    message.name = object.name ?? "";
    message.definition = object.definition ?? "";
    message.timeZone = object.timeZone ?? "";
    message.sqlMode = object.sqlMode ?? "";
    message.characterSetClient = object.characterSetClient ?? "";
    message.collationConnection = object.collationConnection ?? "";
    return message;
  },
};

function createBaseSequenceMetadata(): SequenceMetadata {
  return {
    name: "",
    dataType: "",
    start: "",
    minValue: "",
    maxValue: "",
    increment: "",
    cycle: false,
    cacheSize: "",
    lastValue: "",
  };
}

export const SequenceMetadata: MessageFns<SequenceMetadata> = {
  encode(message: SequenceMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.dataType !== "") {
      writer.uint32(18).string(message.dataType);
    }
    if (message.start !== "") {
      writer.uint32(26).string(message.start);
    }
    if (message.minValue !== "") {
      writer.uint32(34).string(message.minValue);
    }
    if (message.maxValue !== "") {
      writer.uint32(42).string(message.maxValue);
    }
    if (message.increment !== "") {
      writer.uint32(50).string(message.increment);
    }
    if (message.cycle !== false) {
      writer.uint32(56).bool(message.cycle);
    }
    if (message.cacheSize !== "") {
      writer.uint32(66).string(message.cacheSize);
    }
    if (message.lastValue !== "") {
      writer.uint32(74).string(message.lastValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SequenceMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSequenceMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.dataType = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.start = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.minValue = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.maxValue = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.increment = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.cycle = reader.bool();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.cacheSize = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.lastValue = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SequenceMetadata {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      dataType: isSet(object.dataType) ? globalThis.String(object.dataType) : "",
      start: isSet(object.start) ? globalThis.String(object.start) : "",
      minValue: isSet(object.minValue) ? globalThis.String(object.minValue) : "",
      maxValue: isSet(object.maxValue) ? globalThis.String(object.maxValue) : "",
      increment: isSet(object.increment) ? globalThis.String(object.increment) : "",
      cycle: isSet(object.cycle) ? globalThis.Boolean(object.cycle) : false,
      cacheSize: isSet(object.cacheSize) ? globalThis.String(object.cacheSize) : "",
      lastValue: isSet(object.lastValue) ? globalThis.String(object.lastValue) : "",
    };
  },

  toJSON(message: SequenceMetadata): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.dataType !== "") {
      obj.dataType = message.dataType;
    }
    if (message.start !== "") {
      obj.start = message.start;
    }
    if (message.minValue !== "") {
      obj.minValue = message.minValue;
    }
    if (message.maxValue !== "") {
      obj.maxValue = message.maxValue;
    }
    if (message.increment !== "") {
      obj.increment = message.increment;
    }
    if (message.cycle !== false) {
      obj.cycle = message.cycle;
    }
    if (message.cacheSize !== "") {
      obj.cacheSize = message.cacheSize;
    }
    if (message.lastValue !== "") {
      obj.lastValue = message.lastValue;
    }
    return obj;
  },

  create(base?: DeepPartial<SequenceMetadata>): SequenceMetadata {
    return SequenceMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SequenceMetadata>): SequenceMetadata {
    const message = createBaseSequenceMetadata();
    message.name = object.name ?? "";
    message.dataType = object.dataType ?? "";
    message.start = object.start ?? "";
    message.minValue = object.minValue ?? "";
    message.maxValue = object.maxValue ?? "";
    message.increment = object.increment ?? "";
    message.cycle = object.cycle ?? false;
    message.cacheSize = object.cacheSize ?? "";
    message.lastValue = object.lastValue ?? "";
    return message;
  },
};

function createBaseTriggerMetadata(): TriggerMetadata {
  return {
    name: "",
    tableName: "",
    event: "",
    timing: "",
    body: "",
    sqlMode: "",
    characterSetClient: "",
    collationConnection: "",
  };
}

export const TriggerMetadata: MessageFns<TriggerMetadata> = {
  encode(message: TriggerMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.tableName !== "") {
      writer.uint32(18).string(message.tableName);
    }
    if (message.event !== "") {
      writer.uint32(26).string(message.event);
    }
    if (message.timing !== "") {
      writer.uint32(34).string(message.timing);
    }
    if (message.body !== "") {
      writer.uint32(42).string(message.body);
    }
    if (message.sqlMode !== "") {
      writer.uint32(50).string(message.sqlMode);
    }
    if (message.characterSetClient !== "") {
      writer.uint32(58).string(message.characterSetClient);
    }
    if (message.collationConnection !== "") {
      writer.uint32(66).string(message.collationConnection);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TriggerMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTriggerMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tableName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.event = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.timing = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.body = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.sqlMode = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.characterSetClient = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.collationConnection = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TriggerMetadata {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      tableName: isSet(object.tableName) ? globalThis.String(object.tableName) : "",
      event: isSet(object.event) ? globalThis.String(object.event) : "",
      timing: isSet(object.timing) ? globalThis.String(object.timing) : "",
      body: isSet(object.body) ? globalThis.String(object.body) : "",
      sqlMode: isSet(object.sqlMode) ? globalThis.String(object.sqlMode) : "",
      characterSetClient: isSet(object.characterSetClient) ? globalThis.String(object.characterSetClient) : "",
      collationConnection: isSet(object.collationConnection) ? globalThis.String(object.collationConnection) : "",
    };
  },

  toJSON(message: TriggerMetadata): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.tableName !== "") {
      obj.tableName = message.tableName;
    }
    if (message.event !== "") {
      obj.event = message.event;
    }
    if (message.timing !== "") {
      obj.timing = message.timing;
    }
    if (message.body !== "") {
      obj.body = message.body;
    }
    if (message.sqlMode !== "") {
      obj.sqlMode = message.sqlMode;
    }
    if (message.characterSetClient !== "") {
      obj.characterSetClient = message.characterSetClient;
    }
    if (message.collationConnection !== "") {
      obj.collationConnection = message.collationConnection;
    }
    return obj;
  },

  create(base?: DeepPartial<TriggerMetadata>): TriggerMetadata {
    return TriggerMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TriggerMetadata>): TriggerMetadata {
    const message = createBaseTriggerMetadata();
    message.name = object.name ?? "";
    message.tableName = object.tableName ?? "";
    message.event = object.event ?? "";
    message.timing = object.timing ?? "";
    message.body = object.body ?? "";
    message.sqlMode = object.sqlMode ?? "";
    message.characterSetClient = object.characterSetClient ?? "";
    message.collationConnection = object.collationConnection ?? "";
    return message;
  },
};

function createBaseExternalTableMetadata(): ExternalTableMetadata {
  return { name: "", externalServerName: "", externalDatabaseName: "", columns: [] };
}

export const ExternalTableMetadata: MessageFns<ExternalTableMetadata> = {
  encode(message: ExternalTableMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.externalServerName !== "") {
      writer.uint32(18).string(message.externalServerName);
    }
    if (message.externalDatabaseName !== "") {
      writer.uint32(26).string(message.externalDatabaseName);
    }
    for (const v of message.columns) {
      ColumnMetadata.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExternalTableMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExternalTableMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.externalServerName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.externalDatabaseName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.columns.push(ColumnMetadata.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExternalTableMetadata {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      externalServerName: isSet(object.externalServerName) ? globalThis.String(object.externalServerName) : "",
      externalDatabaseName: isSet(object.externalDatabaseName) ? globalThis.String(object.externalDatabaseName) : "",
      columns: globalThis.Array.isArray(object?.columns)
        ? object.columns.map((e: any) => ColumnMetadata.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ExternalTableMetadata): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.externalServerName !== "") {
      obj.externalServerName = message.externalServerName;
    }
    if (message.externalDatabaseName !== "") {
      obj.externalDatabaseName = message.externalDatabaseName;
    }
    if (message.columns?.length) {
      obj.columns = message.columns.map((e) => ColumnMetadata.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ExternalTableMetadata>): ExternalTableMetadata {
    return ExternalTableMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExternalTableMetadata>): ExternalTableMetadata {
    const message = createBaseExternalTableMetadata();
    message.name = object.name ?? "";
    message.externalServerName = object.externalServerName ?? "";
    message.externalDatabaseName = object.externalDatabaseName ?? "";
    message.columns = object.columns?.map((e) => ColumnMetadata.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTableMetadata(): TableMetadata {
  return {
    name: "",
    columns: [],
    indexes: [],
    engine: "",
    collation: "",
    charset: "",
    rowCount: Long.ZERO,
    dataSize: Long.ZERO,
    indexSize: Long.ZERO,
    dataFree: Long.ZERO,
    createOptions: "",
    comment: "",
    userComment: "",
    foreignKeys: [],
    partitions: [],
    checkConstraints: [],
    owner: "",
  };
}

export const TableMetadata: MessageFns<TableMetadata> = {
  encode(message: TableMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.columns) {
      ColumnMetadata.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.indexes) {
      IndexMetadata.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.engine !== "") {
      writer.uint32(34).string(message.engine);
    }
    if (message.collation !== "") {
      writer.uint32(42).string(message.collation);
    }
    if (message.charset !== "") {
      writer.uint32(138).string(message.charset);
    }
    if (!message.rowCount.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.rowCount.toString());
    }
    if (!message.dataSize.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.dataSize.toString());
    }
    if (!message.indexSize.equals(Long.ZERO)) {
      writer.uint32(64).int64(message.indexSize.toString());
    }
    if (!message.dataFree.equals(Long.ZERO)) {
      writer.uint32(72).int64(message.dataFree.toString());
    }
    if (message.createOptions !== "") {
      writer.uint32(82).string(message.createOptions);
    }
    if (message.comment !== "") {
      writer.uint32(90).string(message.comment);
    }
    if (message.userComment !== "") {
      writer.uint32(114).string(message.userComment);
    }
    for (const v of message.foreignKeys) {
      ForeignKeyMetadata.encode(v!, writer.uint32(98).fork()).join();
    }
    for (const v of message.partitions) {
      TablePartitionMetadata.encode(v!, writer.uint32(122).fork()).join();
    }
    for (const v of message.checkConstraints) {
      CheckConstraintMetadata.encode(v!, writer.uint32(130).fork()).join();
    }
    if (message.owner !== "") {
      writer.uint32(146).string(message.owner);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TableMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTableMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.columns.push(ColumnMetadata.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.indexes.push(IndexMetadata.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.engine = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.collation = reader.string();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.charset = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.rowCount = Long.fromString(reader.int64().toString());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.dataSize = Long.fromString(reader.int64().toString());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.indexSize = Long.fromString(reader.int64().toString());
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.dataFree = Long.fromString(reader.int64().toString());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.createOptions = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.userComment = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.foreignKeys.push(ForeignKeyMetadata.decode(reader, reader.uint32()));
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.partitions.push(TablePartitionMetadata.decode(reader, reader.uint32()));
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.checkConstraints.push(CheckConstraintMetadata.decode(reader, reader.uint32()));
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.owner = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TableMetadata {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      columns: globalThis.Array.isArray(object?.columns)
        ? object.columns.map((e: any) => ColumnMetadata.fromJSON(e))
        : [],
      indexes: globalThis.Array.isArray(object?.indexes)
        ? object.indexes.map((e: any) => IndexMetadata.fromJSON(e))
        : [],
      engine: isSet(object.engine) ? globalThis.String(object.engine) : "",
      collation: isSet(object.collation) ? globalThis.String(object.collation) : "",
      charset: isSet(object.charset) ? globalThis.String(object.charset) : "",
      rowCount: isSet(object.rowCount) ? Long.fromValue(object.rowCount) : Long.ZERO,
      dataSize: isSet(object.dataSize) ? Long.fromValue(object.dataSize) : Long.ZERO,
      indexSize: isSet(object.indexSize) ? Long.fromValue(object.indexSize) : Long.ZERO,
      dataFree: isSet(object.dataFree) ? Long.fromValue(object.dataFree) : Long.ZERO,
      createOptions: isSet(object.createOptions) ? globalThis.String(object.createOptions) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      userComment: isSet(object.userComment) ? globalThis.String(object.userComment) : "",
      foreignKeys: globalThis.Array.isArray(object?.foreignKeys)
        ? object.foreignKeys.map((e: any) => ForeignKeyMetadata.fromJSON(e))
        : [],
      partitions: globalThis.Array.isArray(object?.partitions)
        ? object.partitions.map((e: any) => TablePartitionMetadata.fromJSON(e))
        : [],
      checkConstraints: globalThis.Array.isArray(object?.checkConstraints)
        ? object.checkConstraints.map((e: any) => CheckConstraintMetadata.fromJSON(e))
        : [],
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
    };
  },

  toJSON(message: TableMetadata): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.columns?.length) {
      obj.columns = message.columns.map((e) => ColumnMetadata.toJSON(e));
    }
    if (message.indexes?.length) {
      obj.indexes = message.indexes.map((e) => IndexMetadata.toJSON(e));
    }
    if (message.engine !== "") {
      obj.engine = message.engine;
    }
    if (message.collation !== "") {
      obj.collation = message.collation;
    }
    if (message.charset !== "") {
      obj.charset = message.charset;
    }
    if (!message.rowCount.equals(Long.ZERO)) {
      obj.rowCount = (message.rowCount || Long.ZERO).toString();
    }
    if (!message.dataSize.equals(Long.ZERO)) {
      obj.dataSize = (message.dataSize || Long.ZERO).toString();
    }
    if (!message.indexSize.equals(Long.ZERO)) {
      obj.indexSize = (message.indexSize || Long.ZERO).toString();
    }
    if (!message.dataFree.equals(Long.ZERO)) {
      obj.dataFree = (message.dataFree || Long.ZERO).toString();
    }
    if (message.createOptions !== "") {
      obj.createOptions = message.createOptions;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.userComment !== "") {
      obj.userComment = message.userComment;
    }
    if (message.foreignKeys?.length) {
      obj.foreignKeys = message.foreignKeys.map((e) => ForeignKeyMetadata.toJSON(e));
    }
    if (message.partitions?.length) {
      obj.partitions = message.partitions.map((e) => TablePartitionMetadata.toJSON(e));
    }
    if (message.checkConstraints?.length) {
      obj.checkConstraints = message.checkConstraints.map((e) => CheckConstraintMetadata.toJSON(e));
    }
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    return obj;
  },

  create(base?: DeepPartial<TableMetadata>): TableMetadata {
    return TableMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TableMetadata>): TableMetadata {
    const message = createBaseTableMetadata();
    message.name = object.name ?? "";
    message.columns = object.columns?.map((e) => ColumnMetadata.fromPartial(e)) || [];
    message.indexes = object.indexes?.map((e) => IndexMetadata.fromPartial(e)) || [];
    message.engine = object.engine ?? "";
    message.collation = object.collation ?? "";
    message.charset = object.charset ?? "";
    message.rowCount = (object.rowCount !== undefined && object.rowCount !== null)
      ? Long.fromValue(object.rowCount)
      : Long.ZERO;
    message.dataSize = (object.dataSize !== undefined && object.dataSize !== null)
      ? Long.fromValue(object.dataSize)
      : Long.ZERO;
    message.indexSize = (object.indexSize !== undefined && object.indexSize !== null)
      ? Long.fromValue(object.indexSize)
      : Long.ZERO;
    message.dataFree = (object.dataFree !== undefined && object.dataFree !== null)
      ? Long.fromValue(object.dataFree)
      : Long.ZERO;
    message.createOptions = object.createOptions ?? "";
    message.comment = object.comment ?? "";
    message.userComment = object.userComment ?? "";
    message.foreignKeys = object.foreignKeys?.map((e) => ForeignKeyMetadata.fromPartial(e)) || [];
    message.partitions = object.partitions?.map((e) => TablePartitionMetadata.fromPartial(e)) || [];
    message.checkConstraints = object.checkConstraints?.map((e) => CheckConstraintMetadata.fromPartial(e)) || [];
    message.owner = object.owner ?? "";
    return message;
  },
};

function createBaseCheckConstraintMetadata(): CheckConstraintMetadata {
  return { name: "", expression: "" };
}

export const CheckConstraintMetadata: MessageFns<CheckConstraintMetadata> = {
  encode(message: CheckConstraintMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.expression !== "") {
      writer.uint32(18).string(message.expression);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckConstraintMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckConstraintMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.expression = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckConstraintMetadata {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      expression: isSet(object.expression) ? globalThis.String(object.expression) : "",
    };
  },

  toJSON(message: CheckConstraintMetadata): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.expression !== "") {
      obj.expression = message.expression;
    }
    return obj;
  },

  create(base?: DeepPartial<CheckConstraintMetadata>): CheckConstraintMetadata {
    return CheckConstraintMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CheckConstraintMetadata>): CheckConstraintMetadata {
    const message = createBaseCheckConstraintMetadata();
    message.name = object.name ?? "";
    message.expression = object.expression ?? "";
    return message;
  },
};

function createBaseTablePartitionMetadata(): TablePartitionMetadata {
  return {
    name: "",
    type: TablePartitionMetadata_Type.TYPE_UNSPECIFIED,
    expression: "",
    value: "",
    useDefault: "",
    subpartitions: [],
  };
}

export const TablePartitionMetadata: MessageFns<TablePartitionMetadata> = {
  encode(message: TablePartitionMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.type !== TablePartitionMetadata_Type.TYPE_UNSPECIFIED) {
      writer.uint32(16).int32(tablePartitionMetadata_TypeToNumber(message.type));
    }
    if (message.expression !== "") {
      writer.uint32(26).string(message.expression);
    }
    if (message.value !== "") {
      writer.uint32(34).string(message.value);
    }
    if (message.useDefault !== "") {
      writer.uint32(42).string(message.useDefault);
    }
    for (const v of message.subpartitions) {
      TablePartitionMetadata.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TablePartitionMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTablePartitionMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.type = tablePartitionMetadata_TypeFromJSON(reader.int32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.expression = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.value = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.useDefault = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.subpartitions.push(TablePartitionMetadata.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TablePartitionMetadata {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type)
        ? tablePartitionMetadata_TypeFromJSON(object.type)
        : TablePartitionMetadata_Type.TYPE_UNSPECIFIED,
      expression: isSet(object.expression) ? globalThis.String(object.expression) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      useDefault: isSet(object.useDefault) ? globalThis.String(object.useDefault) : "",
      subpartitions: globalThis.Array.isArray(object?.subpartitions)
        ? object.subpartitions.map((e: any) => TablePartitionMetadata.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TablePartitionMetadata): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== TablePartitionMetadata_Type.TYPE_UNSPECIFIED) {
      obj.type = tablePartitionMetadata_TypeToJSON(message.type);
    }
    if (message.expression !== "") {
      obj.expression = message.expression;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.useDefault !== "") {
      obj.useDefault = message.useDefault;
    }
    if (message.subpartitions?.length) {
      obj.subpartitions = message.subpartitions.map((e) => TablePartitionMetadata.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<TablePartitionMetadata>): TablePartitionMetadata {
    return TablePartitionMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TablePartitionMetadata>): TablePartitionMetadata {
    const message = createBaseTablePartitionMetadata();
    message.name = object.name ?? "";
    message.type = object.type ?? TablePartitionMetadata_Type.TYPE_UNSPECIFIED;
    message.expression = object.expression ?? "";
    message.value = object.value ?? "";
    message.useDefault = object.useDefault ?? "";
    message.subpartitions = object.subpartitions?.map((e) => TablePartitionMetadata.fromPartial(e)) || [];
    return message;
  },
};

function createBaseColumnMetadata(): ColumnMetadata {
  return {
    name: "",
    position: 0,
    hasDefault: false,
    defaultNull: undefined,
    defaultString: undefined,
    defaultExpression: undefined,
    onUpdate: "",
    nullable: false,
    type: "",
    characterSet: "",
    collation: "",
    comment: "",
    userComment: "",
    effectiveMaskingLevel: MaskingLevel.MASKING_LEVEL_UNSPECIFIED,
    generation: undefined,
  };
}

export const ColumnMetadata: MessageFns<ColumnMetadata> = {
  encode(message: ColumnMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.position !== 0) {
      writer.uint32(16).int32(message.position);
    }
    if (message.hasDefault !== false) {
      writer.uint32(24).bool(message.hasDefault);
    }
    if (message.defaultNull !== undefined) {
      writer.uint32(32).bool(message.defaultNull);
    }
    if (message.defaultString !== undefined) {
      writer.uint32(42).string(message.defaultString);
    }
    if (message.defaultExpression !== undefined) {
      writer.uint32(50).string(message.defaultExpression);
    }
    if (message.onUpdate !== "") {
      writer.uint32(122).string(message.onUpdate);
    }
    if (message.nullable !== false) {
      writer.uint32(56).bool(message.nullable);
    }
    if (message.type !== "") {
      writer.uint32(66).string(message.type);
    }
    if (message.characterSet !== "") {
      writer.uint32(74).string(message.characterSet);
    }
    if (message.collation !== "") {
      writer.uint32(82).string(message.collation);
    }
    if (message.comment !== "") {
      writer.uint32(90).string(message.comment);
    }
    if (message.userComment !== "") {
      writer.uint32(106).string(message.userComment);
    }
    if (message.effectiveMaskingLevel !== MaskingLevel.MASKING_LEVEL_UNSPECIFIED) {
      writer.uint32(112).int32(maskingLevelToNumber(message.effectiveMaskingLevel));
    }
    if (message.generation !== undefined) {
      GenerationMetadata.encode(message.generation, writer.uint32(130).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ColumnMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseColumnMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.position = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.hasDefault = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.defaultNull = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.defaultString = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.defaultExpression = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.onUpdate = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.nullable = reader.bool();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.type = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.characterSet = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.collation = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.userComment = reader.string();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.effectiveMaskingLevel = maskingLevelFromJSON(reader.int32());
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.generation = GenerationMetadata.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ColumnMetadata {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      position: isSet(object.position) ? globalThis.Number(object.position) : 0,
      hasDefault: isSet(object.hasDefault) ? globalThis.Boolean(object.hasDefault) : false,
      defaultNull: isSet(object.defaultNull) ? globalThis.Boolean(object.defaultNull) : undefined,
      defaultString: isSet(object.defaultString) ? globalThis.String(object.defaultString) : undefined,
      defaultExpression: isSet(object.defaultExpression) ? globalThis.String(object.defaultExpression) : undefined,
      onUpdate: isSet(object.onUpdate) ? globalThis.String(object.onUpdate) : "",
      nullable: isSet(object.nullable) ? globalThis.Boolean(object.nullable) : false,
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      characterSet: isSet(object.characterSet) ? globalThis.String(object.characterSet) : "",
      collation: isSet(object.collation) ? globalThis.String(object.collation) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      userComment: isSet(object.userComment) ? globalThis.String(object.userComment) : "",
      effectiveMaskingLevel: isSet(object.effectiveMaskingLevel)
        ? maskingLevelFromJSON(object.effectiveMaskingLevel)
        : MaskingLevel.MASKING_LEVEL_UNSPECIFIED,
      generation: isSet(object.generation) ? GenerationMetadata.fromJSON(object.generation) : undefined,
    };
  },

  toJSON(message: ColumnMetadata): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.position !== 0) {
      obj.position = Math.round(message.position);
    }
    if (message.hasDefault !== false) {
      obj.hasDefault = message.hasDefault;
    }
    if (message.defaultNull !== undefined) {
      obj.defaultNull = message.defaultNull;
    }
    if (message.defaultString !== undefined) {
      obj.defaultString = message.defaultString;
    }
    if (message.defaultExpression !== undefined) {
      obj.defaultExpression = message.defaultExpression;
    }
    if (message.onUpdate !== "") {
      obj.onUpdate = message.onUpdate;
    }
    if (message.nullable !== false) {
      obj.nullable = message.nullable;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.characterSet !== "") {
      obj.characterSet = message.characterSet;
    }
    if (message.collation !== "") {
      obj.collation = message.collation;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.userComment !== "") {
      obj.userComment = message.userComment;
    }
    if (message.effectiveMaskingLevel !== MaskingLevel.MASKING_LEVEL_UNSPECIFIED) {
      obj.effectiveMaskingLevel = maskingLevelToJSON(message.effectiveMaskingLevel);
    }
    if (message.generation !== undefined) {
      obj.generation = GenerationMetadata.toJSON(message.generation);
    }
    return obj;
  },

  create(base?: DeepPartial<ColumnMetadata>): ColumnMetadata {
    return ColumnMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ColumnMetadata>): ColumnMetadata {
    const message = createBaseColumnMetadata();
    message.name = object.name ?? "";
    message.position = object.position ?? 0;
    message.hasDefault = object.hasDefault ?? false;
    message.defaultNull = object.defaultNull ?? undefined;
    message.defaultString = object.defaultString ?? undefined;
    message.defaultExpression = object.defaultExpression ?? undefined;
    message.onUpdate = object.onUpdate ?? "";
    message.nullable = object.nullable ?? false;
    message.type = object.type ?? "";
    message.characterSet = object.characterSet ?? "";
    message.collation = object.collation ?? "";
    message.comment = object.comment ?? "";
    message.userComment = object.userComment ?? "";
    message.effectiveMaskingLevel = object.effectiveMaskingLevel ?? MaskingLevel.MASKING_LEVEL_UNSPECIFIED;
    message.generation = (object.generation !== undefined && object.generation !== null)
      ? GenerationMetadata.fromPartial(object.generation)
      : undefined;
    return message;
  },
};

function createBaseGenerationMetadata(): GenerationMetadata {
  return { type: GenerationMetadata_Type.TYPE_UNSPECIFIED, expression: "" };
}

export const GenerationMetadata: MessageFns<GenerationMetadata> = {
  encode(message: GenerationMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== GenerationMetadata_Type.TYPE_UNSPECIFIED) {
      writer.uint32(8).int32(generationMetadata_TypeToNumber(message.type));
    }
    if (message.expression !== "") {
      writer.uint32(18).string(message.expression);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = generationMetadata_TypeFromJSON(reader.int32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.expression = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerationMetadata {
    return {
      type: isSet(object.type)
        ? generationMetadata_TypeFromJSON(object.type)
        : GenerationMetadata_Type.TYPE_UNSPECIFIED,
      expression: isSet(object.expression) ? globalThis.String(object.expression) : "",
    };
  },

  toJSON(message: GenerationMetadata): unknown {
    const obj: any = {};
    if (message.type !== GenerationMetadata_Type.TYPE_UNSPECIFIED) {
      obj.type = generationMetadata_TypeToJSON(message.type);
    }
    if (message.expression !== "") {
      obj.expression = message.expression;
    }
    return obj;
  },

  create(base?: DeepPartial<GenerationMetadata>): GenerationMetadata {
    return GenerationMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerationMetadata>): GenerationMetadata {
    const message = createBaseGenerationMetadata();
    message.type = object.type ?? GenerationMetadata_Type.TYPE_UNSPECIFIED;
    message.expression = object.expression ?? "";
    return message;
  },
};

function createBaseViewMetadata(): ViewMetadata {
  return { name: "", definition: "", comment: "", dependentColumns: [], columns: [] };
}

export const ViewMetadata: MessageFns<ViewMetadata> = {
  encode(message: ViewMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.definition !== "") {
      writer.uint32(18).string(message.definition);
    }
    if (message.comment !== "") {
      writer.uint32(26).string(message.comment);
    }
    for (const v of message.dependentColumns) {
      DependentColumn.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.columns) {
      ColumnMetadata.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ViewMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseViewMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.definition = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.dependentColumns.push(DependentColumn.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.columns.push(ColumnMetadata.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ViewMetadata {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      definition: isSet(object.definition) ? globalThis.String(object.definition) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      dependentColumns: globalThis.Array.isArray(object?.dependentColumns)
        ? object.dependentColumns.map((e: any) => DependentColumn.fromJSON(e))
        : [],
      columns: globalThis.Array.isArray(object?.columns)
        ? object.columns.map((e: any) => ColumnMetadata.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ViewMetadata): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.definition !== "") {
      obj.definition = message.definition;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.dependentColumns?.length) {
      obj.dependentColumns = message.dependentColumns.map((e) => DependentColumn.toJSON(e));
    }
    if (message.columns?.length) {
      obj.columns = message.columns.map((e) => ColumnMetadata.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ViewMetadata>): ViewMetadata {
    return ViewMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ViewMetadata>): ViewMetadata {
    const message = createBaseViewMetadata();
    message.name = object.name ?? "";
    message.definition = object.definition ?? "";
    message.comment = object.comment ?? "";
    message.dependentColumns = object.dependentColumns?.map((e) => DependentColumn.fromPartial(e)) || [];
    message.columns = object.columns?.map((e) => ColumnMetadata.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDependentColumn(): DependentColumn {
  return { schema: "", table: "", column: "" };
}

export const DependentColumn: MessageFns<DependentColumn> = {
  encode(message: DependentColumn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.schema !== "") {
      writer.uint32(10).string(message.schema);
    }
    if (message.table !== "") {
      writer.uint32(18).string(message.table);
    }
    if (message.column !== "") {
      writer.uint32(26).string(message.column);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DependentColumn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDependentColumn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.schema = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.table = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.column = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DependentColumn {
    return {
      schema: isSet(object.schema) ? globalThis.String(object.schema) : "",
      table: isSet(object.table) ? globalThis.String(object.table) : "",
      column: isSet(object.column) ? globalThis.String(object.column) : "",
    };
  },

  toJSON(message: DependentColumn): unknown {
    const obj: any = {};
    if (message.schema !== "") {
      obj.schema = message.schema;
    }
    if (message.table !== "") {
      obj.table = message.table;
    }
    if (message.column !== "") {
      obj.column = message.column;
    }
    return obj;
  },

  create(base?: DeepPartial<DependentColumn>): DependentColumn {
    return DependentColumn.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DependentColumn>): DependentColumn {
    const message = createBaseDependentColumn();
    message.schema = object.schema ?? "";
    message.table = object.table ?? "";
    message.column = object.column ?? "";
    return message;
  },
};

function createBaseMaterializedViewMetadata(): MaterializedViewMetadata {
  return { name: "", definition: "", comment: "", dependentColumns: [] };
}

export const MaterializedViewMetadata: MessageFns<MaterializedViewMetadata> = {
  encode(message: MaterializedViewMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.definition !== "") {
      writer.uint32(18).string(message.definition);
    }
    if (message.comment !== "") {
      writer.uint32(26).string(message.comment);
    }
    for (const v of message.dependentColumns) {
      DependentColumn.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MaterializedViewMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMaterializedViewMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.definition = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.dependentColumns.push(DependentColumn.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MaterializedViewMetadata {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      definition: isSet(object.definition) ? globalThis.String(object.definition) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      dependentColumns: globalThis.Array.isArray(object?.dependentColumns)
        ? object.dependentColumns.map((e: any) => DependentColumn.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MaterializedViewMetadata): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.definition !== "") {
      obj.definition = message.definition;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.dependentColumns?.length) {
      obj.dependentColumns = message.dependentColumns.map((e) => DependentColumn.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MaterializedViewMetadata>): MaterializedViewMetadata {
    return MaterializedViewMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MaterializedViewMetadata>): MaterializedViewMetadata {
    const message = createBaseMaterializedViewMetadata();
    message.name = object.name ?? "";
    message.definition = object.definition ?? "";
    message.comment = object.comment ?? "";
    message.dependentColumns = object.dependentColumns?.map((e) => DependentColumn.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFunctionMetadata(): FunctionMetadata {
  return {
    name: "",
    definition: "",
    signature: "",
    characterSetClient: "",
    collationConnection: "",
    databaseCollation: "",
    sqlMode: "",
  };
}

export const FunctionMetadata: MessageFns<FunctionMetadata> = {
  encode(message: FunctionMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.definition !== "") {
      writer.uint32(18).string(message.definition);
    }
    if (message.signature !== "") {
      writer.uint32(26).string(message.signature);
    }
    if (message.characterSetClient !== "") {
      writer.uint32(34).string(message.characterSetClient);
    }
    if (message.collationConnection !== "") {
      writer.uint32(42).string(message.collationConnection);
    }
    if (message.databaseCollation !== "") {
      writer.uint32(50).string(message.databaseCollation);
    }
    if (message.sqlMode !== "") {
      writer.uint32(58).string(message.sqlMode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunctionMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.definition = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.signature = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.characterSetClient = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.collationConnection = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.databaseCollation = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.sqlMode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunctionMetadata {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      definition: isSet(object.definition) ? globalThis.String(object.definition) : "",
      signature: isSet(object.signature) ? globalThis.String(object.signature) : "",
      characterSetClient: isSet(object.characterSetClient) ? globalThis.String(object.characterSetClient) : "",
      collationConnection: isSet(object.collationConnection) ? globalThis.String(object.collationConnection) : "",
      databaseCollation: isSet(object.databaseCollation) ? globalThis.String(object.databaseCollation) : "",
      sqlMode: isSet(object.sqlMode) ? globalThis.String(object.sqlMode) : "",
    };
  },

  toJSON(message: FunctionMetadata): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.definition !== "") {
      obj.definition = message.definition;
    }
    if (message.signature !== "") {
      obj.signature = message.signature;
    }
    if (message.characterSetClient !== "") {
      obj.characterSetClient = message.characterSetClient;
    }
    if (message.collationConnection !== "") {
      obj.collationConnection = message.collationConnection;
    }
    if (message.databaseCollation !== "") {
      obj.databaseCollation = message.databaseCollation;
    }
    if (message.sqlMode !== "") {
      obj.sqlMode = message.sqlMode;
    }
    return obj;
  },

  create(base?: DeepPartial<FunctionMetadata>): FunctionMetadata {
    return FunctionMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FunctionMetadata>): FunctionMetadata {
    const message = createBaseFunctionMetadata();
    message.name = object.name ?? "";
    message.definition = object.definition ?? "";
    message.signature = object.signature ?? "";
    message.characterSetClient = object.characterSetClient ?? "";
    message.collationConnection = object.collationConnection ?? "";
    message.databaseCollation = object.databaseCollation ?? "";
    message.sqlMode = object.sqlMode ?? "";
    return message;
  },
};

function createBaseProcedureMetadata(): ProcedureMetadata {
  return {
    name: "",
    definition: "",
    signature: "",
    characterSetClient: "",
    collationConnection: "",
    databaseCollation: "",
    sqlMode: "",
  };
}

export const ProcedureMetadata: MessageFns<ProcedureMetadata> = {
  encode(message: ProcedureMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.definition !== "") {
      writer.uint32(18).string(message.definition);
    }
    if (message.signature !== "") {
      writer.uint32(26).string(message.signature);
    }
    if (message.characterSetClient !== "") {
      writer.uint32(34).string(message.characterSetClient);
    }
    if (message.collationConnection !== "") {
      writer.uint32(42).string(message.collationConnection);
    }
    if (message.databaseCollation !== "") {
      writer.uint32(50).string(message.databaseCollation);
    }
    if (message.sqlMode !== "") {
      writer.uint32(58).string(message.sqlMode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcedureMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcedureMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.definition = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.signature = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.characterSetClient = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.collationConnection = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.databaseCollation = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.sqlMode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcedureMetadata {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      definition: isSet(object.definition) ? globalThis.String(object.definition) : "",
      signature: isSet(object.signature) ? globalThis.String(object.signature) : "",
      characterSetClient: isSet(object.characterSetClient) ? globalThis.String(object.characterSetClient) : "",
      collationConnection: isSet(object.collationConnection) ? globalThis.String(object.collationConnection) : "",
      databaseCollation: isSet(object.databaseCollation) ? globalThis.String(object.databaseCollation) : "",
      sqlMode: isSet(object.sqlMode) ? globalThis.String(object.sqlMode) : "",
    };
  },

  toJSON(message: ProcedureMetadata): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.definition !== "") {
      obj.definition = message.definition;
    }
    if (message.signature !== "") {
      obj.signature = message.signature;
    }
    if (message.characterSetClient !== "") {
      obj.characterSetClient = message.characterSetClient;
    }
    if (message.collationConnection !== "") {
      obj.collationConnection = message.collationConnection;
    }
    if (message.databaseCollation !== "") {
      obj.databaseCollation = message.databaseCollation;
    }
    if (message.sqlMode !== "") {
      obj.sqlMode = message.sqlMode;
    }
    return obj;
  },

  create(base?: DeepPartial<ProcedureMetadata>): ProcedureMetadata {
    return ProcedureMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProcedureMetadata>): ProcedureMetadata {
    const message = createBaseProcedureMetadata();
    message.name = object.name ?? "";
    message.definition = object.definition ?? "";
    message.signature = object.signature ?? "";
    message.characterSetClient = object.characterSetClient ?? "";
    message.collationConnection = object.collationConnection ?? "";
    message.databaseCollation = object.databaseCollation ?? "";
    message.sqlMode = object.sqlMode ?? "";
    return message;
  },
};

function createBasePackageMetadata(): PackageMetadata {
  return { name: "", definition: "" };
}

export const PackageMetadata: MessageFns<PackageMetadata> = {
  encode(message: PackageMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.definition !== "") {
      writer.uint32(18).string(message.definition);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PackageMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePackageMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.definition = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PackageMetadata {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      definition: isSet(object.definition) ? globalThis.String(object.definition) : "",
    };
  },

  toJSON(message: PackageMetadata): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.definition !== "") {
      obj.definition = message.definition;
    }
    return obj;
  },

  create(base?: DeepPartial<PackageMetadata>): PackageMetadata {
    return PackageMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PackageMetadata>): PackageMetadata {
    const message = createBasePackageMetadata();
    message.name = object.name ?? "";
    message.definition = object.definition ?? "";
    return message;
  },
};

function createBaseTaskMetadata(): TaskMetadata {
  return {
    name: "",
    id: "",
    owner: "",
    comment: "",
    warehouse: "",
    schedule: "",
    predecessors: [],
    state: TaskMetadata_State.STATE_UNSPECIFIED,
    condition: "",
    definition: "",
  };
}

export const TaskMetadata: MessageFns<TaskMetadata> = {
  encode(message: TaskMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.owner !== "") {
      writer.uint32(26).string(message.owner);
    }
    if (message.comment !== "") {
      writer.uint32(34).string(message.comment);
    }
    if (message.warehouse !== "") {
      writer.uint32(42).string(message.warehouse);
    }
    if (message.schedule !== "") {
      writer.uint32(50).string(message.schedule);
    }
    for (const v of message.predecessors) {
      writer.uint32(58).string(v!);
    }
    if (message.state !== TaskMetadata_State.STATE_UNSPECIFIED) {
      writer.uint32(64).int32(taskMetadata_StateToNumber(message.state));
    }
    if (message.condition !== "") {
      writer.uint32(74).string(message.condition);
    }
    if (message.definition !== "") {
      writer.uint32(82).string(message.definition);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.owner = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.warehouse = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.schedule = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.predecessors.push(reader.string());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.state = taskMetadata_StateFromJSON(reader.int32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.condition = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.definition = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskMetadata {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      warehouse: isSet(object.warehouse) ? globalThis.String(object.warehouse) : "",
      schedule: isSet(object.schedule) ? globalThis.String(object.schedule) : "",
      predecessors: globalThis.Array.isArray(object?.predecessors)
        ? object.predecessors.map((e: any) => globalThis.String(e))
        : [],
      state: isSet(object.state) ? taskMetadata_StateFromJSON(object.state) : TaskMetadata_State.STATE_UNSPECIFIED,
      condition: isSet(object.condition) ? globalThis.String(object.condition) : "",
      definition: isSet(object.definition) ? globalThis.String(object.definition) : "",
    };
  },

  toJSON(message: TaskMetadata): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.warehouse !== "") {
      obj.warehouse = message.warehouse;
    }
    if (message.schedule !== "") {
      obj.schedule = message.schedule;
    }
    if (message.predecessors?.length) {
      obj.predecessors = message.predecessors;
    }
    if (message.state !== TaskMetadata_State.STATE_UNSPECIFIED) {
      obj.state = taskMetadata_StateToJSON(message.state);
    }
    if (message.condition !== "") {
      obj.condition = message.condition;
    }
    if (message.definition !== "") {
      obj.definition = message.definition;
    }
    return obj;
  },

  create(base?: DeepPartial<TaskMetadata>): TaskMetadata {
    return TaskMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TaskMetadata>): TaskMetadata {
    const message = createBaseTaskMetadata();
    message.name = object.name ?? "";
    message.id = object.id ?? "";
    message.owner = object.owner ?? "";
    message.comment = object.comment ?? "";
    message.warehouse = object.warehouse ?? "";
    message.schedule = object.schedule ?? "";
    message.predecessors = object.predecessors?.map((e) => e) || [];
    message.state = object.state ?? TaskMetadata_State.STATE_UNSPECIFIED;
    message.condition = object.condition ?? "";
    message.definition = object.definition ?? "";
    return message;
  },
};

function createBaseStreamMetadata(): StreamMetadata {
  return {
    name: "",
    tableName: "",
    owner: "",
    comment: "",
    type: StreamMetadata_Type.TYPE_UNSPECIFIED,
    stale: false,
    mode: StreamMetadata_Mode.MODE_UNSPECIFIED,
    definition: "",
  };
}

export const StreamMetadata: MessageFns<StreamMetadata> = {
  encode(message: StreamMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.tableName !== "") {
      writer.uint32(18).string(message.tableName);
    }
    if (message.owner !== "") {
      writer.uint32(26).string(message.owner);
    }
    if (message.comment !== "") {
      writer.uint32(34).string(message.comment);
    }
    if (message.type !== StreamMetadata_Type.TYPE_UNSPECIFIED) {
      writer.uint32(40).int32(streamMetadata_TypeToNumber(message.type));
    }
    if (message.stale !== false) {
      writer.uint32(48).bool(message.stale);
    }
    if (message.mode !== StreamMetadata_Mode.MODE_UNSPECIFIED) {
      writer.uint32(56).int32(streamMetadata_ModeToNumber(message.mode));
    }
    if (message.definition !== "") {
      writer.uint32(66).string(message.definition);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tableName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.owner = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.type = streamMetadata_TypeFromJSON(reader.int32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.stale = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.mode = streamMetadata_ModeFromJSON(reader.int32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.definition = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamMetadata {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      tableName: isSet(object.tableName) ? globalThis.String(object.tableName) : "",
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      type: isSet(object.type) ? streamMetadata_TypeFromJSON(object.type) : StreamMetadata_Type.TYPE_UNSPECIFIED,
      stale: isSet(object.stale) ? globalThis.Boolean(object.stale) : false,
      mode: isSet(object.mode) ? streamMetadata_ModeFromJSON(object.mode) : StreamMetadata_Mode.MODE_UNSPECIFIED,
      definition: isSet(object.definition) ? globalThis.String(object.definition) : "",
    };
  },

  toJSON(message: StreamMetadata): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.tableName !== "") {
      obj.tableName = message.tableName;
    }
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.type !== StreamMetadata_Type.TYPE_UNSPECIFIED) {
      obj.type = streamMetadata_TypeToJSON(message.type);
    }
    if (message.stale !== false) {
      obj.stale = message.stale;
    }
    if (message.mode !== StreamMetadata_Mode.MODE_UNSPECIFIED) {
      obj.mode = streamMetadata_ModeToJSON(message.mode);
    }
    if (message.definition !== "") {
      obj.definition = message.definition;
    }
    return obj;
  },

  create(base?: DeepPartial<StreamMetadata>): StreamMetadata {
    return StreamMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamMetadata>): StreamMetadata {
    const message = createBaseStreamMetadata();
    message.name = object.name ?? "";
    message.tableName = object.tableName ?? "";
    message.owner = object.owner ?? "";
    message.comment = object.comment ?? "";
    message.type = object.type ?? StreamMetadata_Type.TYPE_UNSPECIFIED;
    message.stale = object.stale ?? false;
    message.mode = object.mode ?? StreamMetadata_Mode.MODE_UNSPECIFIED;
    message.definition = object.definition ?? "";
    return message;
  },
};

function createBaseIndexMetadata(): IndexMetadata {
  return {
    name: "",
    expressions: [],
    keyLength: [],
    descending: [],
    type: "",
    unique: false,
    primary: false,
    visible: false,
    comment: "",
    definition: "",
  };
}

export const IndexMetadata: MessageFns<IndexMetadata> = {
  encode(message: IndexMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.expressions) {
      writer.uint32(18).string(v!);
    }
    writer.uint32(74).fork();
    for (const v of message.keyLength) {
      writer.int64(v.toString());
    }
    writer.join();
    writer.uint32(82).fork();
    for (const v of message.descending) {
      writer.bool(v);
    }
    writer.join();
    if (message.type !== "") {
      writer.uint32(26).string(message.type);
    }
    if (message.unique !== false) {
      writer.uint32(32).bool(message.unique);
    }
    if (message.primary !== false) {
      writer.uint32(40).bool(message.primary);
    }
    if (message.visible !== false) {
      writer.uint32(48).bool(message.visible);
    }
    if (message.comment !== "") {
      writer.uint32(58).string(message.comment);
    }
    if (message.definition !== "") {
      writer.uint32(66).string(message.definition);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IndexMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIndexMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.expressions.push(reader.string());
          continue;
        case 9:
          if (tag === 72) {
            message.keyLength.push(Long.fromString(reader.int64().toString()));

            continue;
          }

          if (tag === 74) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.keyLength.push(Long.fromString(reader.int64().toString()));
            }

            continue;
          }

          break;
        case 10:
          if (tag === 80) {
            message.descending.push(reader.bool());

            continue;
          }

          if (tag === 82) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.descending.push(reader.bool());
            }

            continue;
          }

          break;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.type = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.unique = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.primary = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.visible = reader.bool();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.definition = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IndexMetadata {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      expressions: globalThis.Array.isArray(object?.expressions)
        ? object.expressions.map((e: any) => globalThis.String(e))
        : [],
      keyLength: globalThis.Array.isArray(object?.keyLength) ? object.keyLength.map((e: any) => Long.fromValue(e)) : [],
      descending: globalThis.Array.isArray(object?.descending)
        ? object.descending.map((e: any) => globalThis.Boolean(e))
        : [],
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      unique: isSet(object.unique) ? globalThis.Boolean(object.unique) : false,
      primary: isSet(object.primary) ? globalThis.Boolean(object.primary) : false,
      visible: isSet(object.visible) ? globalThis.Boolean(object.visible) : false,
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      definition: isSet(object.definition) ? globalThis.String(object.definition) : "",
    };
  },

  toJSON(message: IndexMetadata): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.expressions?.length) {
      obj.expressions = message.expressions;
    }
    if (message.keyLength?.length) {
      obj.keyLength = message.keyLength.map((e) => (e || Long.ZERO).toString());
    }
    if (message.descending?.length) {
      obj.descending = message.descending;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.unique !== false) {
      obj.unique = message.unique;
    }
    if (message.primary !== false) {
      obj.primary = message.primary;
    }
    if (message.visible !== false) {
      obj.visible = message.visible;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.definition !== "") {
      obj.definition = message.definition;
    }
    return obj;
  },

  create(base?: DeepPartial<IndexMetadata>): IndexMetadata {
    return IndexMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IndexMetadata>): IndexMetadata {
    const message = createBaseIndexMetadata();
    message.name = object.name ?? "";
    message.expressions = object.expressions?.map((e) => e) || [];
    message.keyLength = object.keyLength?.map((e) => Long.fromValue(e)) || [];
    message.descending = object.descending?.map((e) => e) || [];
    message.type = object.type ?? "";
    message.unique = object.unique ?? false;
    message.primary = object.primary ?? false;
    message.visible = object.visible ?? false;
    message.comment = object.comment ?? "";
    message.definition = object.definition ?? "";
    return message;
  },
};

function createBaseExtensionMetadata(): ExtensionMetadata {
  return { name: "", schema: "", version: "", description: "" };
}

export const ExtensionMetadata: MessageFns<ExtensionMetadata> = {
  encode(message: ExtensionMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.schema !== "") {
      writer.uint32(18).string(message.schema);
    }
    if (message.version !== "") {
      writer.uint32(26).string(message.version);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExtensionMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExtensionMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.schema = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.version = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExtensionMetadata {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      schema: isSet(object.schema) ? globalThis.String(object.schema) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: ExtensionMetadata): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.schema !== "") {
      obj.schema = message.schema;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create(base?: DeepPartial<ExtensionMetadata>): ExtensionMetadata {
    return ExtensionMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExtensionMetadata>): ExtensionMetadata {
    const message = createBaseExtensionMetadata();
    message.name = object.name ?? "";
    message.schema = object.schema ?? "";
    message.version = object.version ?? "";
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseForeignKeyMetadata(): ForeignKeyMetadata {
  return {
    name: "",
    columns: [],
    referencedSchema: "",
    referencedTable: "",
    referencedColumns: [],
    onDelete: "",
    onUpdate: "",
    matchType: "",
  };
}

export const ForeignKeyMetadata: MessageFns<ForeignKeyMetadata> = {
  encode(message: ForeignKeyMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.columns) {
      writer.uint32(18).string(v!);
    }
    if (message.referencedSchema !== "") {
      writer.uint32(26).string(message.referencedSchema);
    }
    if (message.referencedTable !== "") {
      writer.uint32(34).string(message.referencedTable);
    }
    for (const v of message.referencedColumns) {
      writer.uint32(42).string(v!);
    }
    if (message.onDelete !== "") {
      writer.uint32(50).string(message.onDelete);
    }
    if (message.onUpdate !== "") {
      writer.uint32(58).string(message.onUpdate);
    }
    if (message.matchType !== "") {
      writer.uint32(66).string(message.matchType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ForeignKeyMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForeignKeyMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.columns.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.referencedSchema = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.referencedTable = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.referencedColumns.push(reader.string());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.onDelete = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.onUpdate = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.matchType = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ForeignKeyMetadata {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      columns: globalThis.Array.isArray(object?.columns) ? object.columns.map((e: any) => globalThis.String(e)) : [],
      referencedSchema: isSet(object.referencedSchema) ? globalThis.String(object.referencedSchema) : "",
      referencedTable: isSet(object.referencedTable) ? globalThis.String(object.referencedTable) : "",
      referencedColumns: globalThis.Array.isArray(object?.referencedColumns)
        ? object.referencedColumns.map((e: any) => globalThis.String(e))
        : [],
      onDelete: isSet(object.onDelete) ? globalThis.String(object.onDelete) : "",
      onUpdate: isSet(object.onUpdate) ? globalThis.String(object.onUpdate) : "",
      matchType: isSet(object.matchType) ? globalThis.String(object.matchType) : "",
    };
  },

  toJSON(message: ForeignKeyMetadata): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.columns?.length) {
      obj.columns = message.columns;
    }
    if (message.referencedSchema !== "") {
      obj.referencedSchema = message.referencedSchema;
    }
    if (message.referencedTable !== "") {
      obj.referencedTable = message.referencedTable;
    }
    if (message.referencedColumns?.length) {
      obj.referencedColumns = message.referencedColumns;
    }
    if (message.onDelete !== "") {
      obj.onDelete = message.onDelete;
    }
    if (message.onUpdate !== "") {
      obj.onUpdate = message.onUpdate;
    }
    if (message.matchType !== "") {
      obj.matchType = message.matchType;
    }
    return obj;
  },

  create(base?: DeepPartial<ForeignKeyMetadata>): ForeignKeyMetadata {
    return ForeignKeyMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ForeignKeyMetadata>): ForeignKeyMetadata {
    const message = createBaseForeignKeyMetadata();
    message.name = object.name ?? "";
    message.columns = object.columns?.map((e) => e) || [];
    message.referencedSchema = object.referencedSchema ?? "";
    message.referencedTable = object.referencedTable ?? "";
    message.referencedColumns = object.referencedColumns?.map((e) => e) || [];
    message.onDelete = object.onDelete ?? "";
    message.onUpdate = object.onUpdate ?? "";
    message.matchType = object.matchType ?? "";
    return message;
  },
};

function createBaseDatabaseConfig(): DatabaseConfig {
  return { name: "", schemaConfigs: [] };
}

export const DatabaseConfig: MessageFns<DatabaseConfig> = {
  encode(message: DatabaseConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.schemaConfigs) {
      SchemaConfig.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DatabaseConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatabaseConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.schemaConfigs.push(SchemaConfig.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DatabaseConfig {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      schemaConfigs: globalThis.Array.isArray(object?.schemaConfigs)
        ? object.schemaConfigs.map((e: any) => SchemaConfig.fromJSON(e))
        : [],
    };
  },

  toJSON(message: DatabaseConfig): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.schemaConfigs?.length) {
      obj.schemaConfigs = message.schemaConfigs.map((e) => SchemaConfig.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<DatabaseConfig>): DatabaseConfig {
    return DatabaseConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DatabaseConfig>): DatabaseConfig {
    const message = createBaseDatabaseConfig();
    message.name = object.name ?? "";
    message.schemaConfigs = object.schemaConfigs?.map((e) => SchemaConfig.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSchemaConfig(): SchemaConfig {
  return { name: "", tableConfigs: [], functionConfigs: [], procedureConfigs: [], viewConfigs: [] };
}

export const SchemaConfig: MessageFns<SchemaConfig> = {
  encode(message: SchemaConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.tableConfigs) {
      TableConfig.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.functionConfigs) {
      FunctionConfig.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.procedureConfigs) {
      ProcedureConfig.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.viewConfigs) {
      ViewConfig.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SchemaConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSchemaConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tableConfigs.push(TableConfig.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.functionConfigs.push(FunctionConfig.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.procedureConfigs.push(ProcedureConfig.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.viewConfigs.push(ViewConfig.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SchemaConfig {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      tableConfigs: globalThis.Array.isArray(object?.tableConfigs)
        ? object.tableConfigs.map((e: any) => TableConfig.fromJSON(e))
        : [],
      functionConfigs: globalThis.Array.isArray(object?.functionConfigs)
        ? object.functionConfigs.map((e: any) => FunctionConfig.fromJSON(e))
        : [],
      procedureConfigs: globalThis.Array.isArray(object?.procedureConfigs)
        ? object.procedureConfigs.map((e: any) => ProcedureConfig.fromJSON(e))
        : [],
      viewConfigs: globalThis.Array.isArray(object?.viewConfigs)
        ? object.viewConfigs.map((e: any) => ViewConfig.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SchemaConfig): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.tableConfigs?.length) {
      obj.tableConfigs = message.tableConfigs.map((e) => TableConfig.toJSON(e));
    }
    if (message.functionConfigs?.length) {
      obj.functionConfigs = message.functionConfigs.map((e) => FunctionConfig.toJSON(e));
    }
    if (message.procedureConfigs?.length) {
      obj.procedureConfigs = message.procedureConfigs.map((e) => ProcedureConfig.toJSON(e));
    }
    if (message.viewConfigs?.length) {
      obj.viewConfigs = message.viewConfigs.map((e) => ViewConfig.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SchemaConfig>): SchemaConfig {
    return SchemaConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SchemaConfig>): SchemaConfig {
    const message = createBaseSchemaConfig();
    message.name = object.name ?? "";
    message.tableConfigs = object.tableConfigs?.map((e) => TableConfig.fromPartial(e)) || [];
    message.functionConfigs = object.functionConfigs?.map((e) => FunctionConfig.fromPartial(e)) || [];
    message.procedureConfigs = object.procedureConfigs?.map((e) => ProcedureConfig.fromPartial(e)) || [];
    message.viewConfigs = object.viewConfigs?.map((e) => ViewConfig.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTableConfig(): TableConfig {
  return { name: "", columnConfigs: [], classificationId: "", updater: "", sourceBranch: "", updateTime: undefined };
}

export const TableConfig: MessageFns<TableConfig> = {
  encode(message: TableConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.columnConfigs) {
      ColumnConfig.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.classificationId !== "") {
      writer.uint32(26).string(message.classificationId);
    }
    if (message.updater !== "") {
      writer.uint32(34).string(message.updater);
    }
    if (message.sourceBranch !== "") {
      writer.uint32(50).string(message.sourceBranch);
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(message.updateTime, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TableConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTableConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.columnConfigs.push(ColumnConfig.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.classificationId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.updater = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.sourceBranch = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.updateTime = Timestamp.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TableConfig {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      columnConfigs: globalThis.Array.isArray(object?.columnConfigs)
        ? object.columnConfigs.map((e: any) => ColumnConfig.fromJSON(e))
        : [],
      classificationId: isSet(object.classificationId) ? globalThis.String(object.classificationId) : "",
      updater: isSet(object.updater) ? globalThis.String(object.updater) : "",
      sourceBranch: isSet(object.sourceBranch) ? globalThis.String(object.sourceBranch) : "",
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
    };
  },

  toJSON(message: TableConfig): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.columnConfigs?.length) {
      obj.columnConfigs = message.columnConfigs.map((e) => ColumnConfig.toJSON(e));
    }
    if (message.classificationId !== "") {
      obj.classificationId = message.classificationId;
    }
    if (message.updater !== "") {
      obj.updater = message.updater;
    }
    if (message.sourceBranch !== "") {
      obj.sourceBranch = message.sourceBranch;
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = fromTimestamp(message.updateTime).toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<TableConfig>): TableConfig {
    return TableConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TableConfig>): TableConfig {
    const message = createBaseTableConfig();
    message.name = object.name ?? "";
    message.columnConfigs = object.columnConfigs?.map((e) => ColumnConfig.fromPartial(e)) || [];
    message.classificationId = object.classificationId ?? "";
    message.updater = object.updater ?? "";
    message.sourceBranch = object.sourceBranch ?? "";
    message.updateTime = (object.updateTime !== undefined && object.updateTime !== null)
      ? Timestamp.fromPartial(object.updateTime)
      : undefined;
    return message;
  },
};

function createBaseFunctionConfig(): FunctionConfig {
  return { name: "", updater: "", sourceBranch: "", updateTime: undefined };
}

export const FunctionConfig: MessageFns<FunctionConfig> = {
  encode(message: FunctionConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.updater !== "") {
      writer.uint32(18).string(message.updater);
    }
    if (message.sourceBranch !== "") {
      writer.uint32(34).string(message.sourceBranch);
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(message.updateTime, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunctionConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updater = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sourceBranch = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = Timestamp.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunctionConfig {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      updater: isSet(object.updater) ? globalThis.String(object.updater) : "",
      sourceBranch: isSet(object.sourceBranch) ? globalThis.String(object.sourceBranch) : "",
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
    };
  },

  toJSON(message: FunctionConfig): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.updater !== "") {
      obj.updater = message.updater;
    }
    if (message.sourceBranch !== "") {
      obj.sourceBranch = message.sourceBranch;
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = fromTimestamp(message.updateTime).toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<FunctionConfig>): FunctionConfig {
    return FunctionConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FunctionConfig>): FunctionConfig {
    const message = createBaseFunctionConfig();
    message.name = object.name ?? "";
    message.updater = object.updater ?? "";
    message.sourceBranch = object.sourceBranch ?? "";
    message.updateTime = (object.updateTime !== undefined && object.updateTime !== null)
      ? Timestamp.fromPartial(object.updateTime)
      : undefined;
    return message;
  },
};

function createBaseProcedureConfig(): ProcedureConfig {
  return { name: "", updater: "", sourceBranch: "", updateTime: undefined };
}

export const ProcedureConfig: MessageFns<ProcedureConfig> = {
  encode(message: ProcedureConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.updater !== "") {
      writer.uint32(18).string(message.updater);
    }
    if (message.sourceBranch !== "") {
      writer.uint32(34).string(message.sourceBranch);
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(message.updateTime, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcedureConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcedureConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updater = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sourceBranch = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = Timestamp.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcedureConfig {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      updater: isSet(object.updater) ? globalThis.String(object.updater) : "",
      sourceBranch: isSet(object.sourceBranch) ? globalThis.String(object.sourceBranch) : "",
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
    };
  },

  toJSON(message: ProcedureConfig): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.updater !== "") {
      obj.updater = message.updater;
    }
    if (message.sourceBranch !== "") {
      obj.sourceBranch = message.sourceBranch;
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = fromTimestamp(message.updateTime).toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<ProcedureConfig>): ProcedureConfig {
    return ProcedureConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProcedureConfig>): ProcedureConfig {
    const message = createBaseProcedureConfig();
    message.name = object.name ?? "";
    message.updater = object.updater ?? "";
    message.sourceBranch = object.sourceBranch ?? "";
    message.updateTime = (object.updateTime !== undefined && object.updateTime !== null)
      ? Timestamp.fromPartial(object.updateTime)
      : undefined;
    return message;
  },
};

function createBaseViewConfig(): ViewConfig {
  return { name: "", updater: "", sourceBranch: "", updateTime: undefined };
}

export const ViewConfig: MessageFns<ViewConfig> = {
  encode(message: ViewConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.updater !== "") {
      writer.uint32(18).string(message.updater);
    }
    if (message.sourceBranch !== "") {
      writer.uint32(34).string(message.sourceBranch);
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(message.updateTime, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ViewConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseViewConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updater = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sourceBranch = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = Timestamp.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ViewConfig {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      updater: isSet(object.updater) ? globalThis.String(object.updater) : "",
      sourceBranch: isSet(object.sourceBranch) ? globalThis.String(object.sourceBranch) : "",
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
    };
  },

  toJSON(message: ViewConfig): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.updater !== "") {
      obj.updater = message.updater;
    }
    if (message.sourceBranch !== "") {
      obj.sourceBranch = message.sourceBranch;
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = fromTimestamp(message.updateTime).toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<ViewConfig>): ViewConfig {
    return ViewConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ViewConfig>): ViewConfig {
    const message = createBaseViewConfig();
    message.name = object.name ?? "";
    message.updater = object.updater ?? "";
    message.sourceBranch = object.sourceBranch ?? "";
    message.updateTime = (object.updateTime !== undefined && object.updateTime !== null)
      ? Timestamp.fromPartial(object.updateTime)
      : undefined;
    return message;
  },
};

function createBaseColumnConfig(): ColumnConfig {
  return { name: "", semanticTypeId: "", labels: {}, classificationId: "" };
}

export const ColumnConfig: MessageFns<ColumnConfig> = {
  encode(message: ColumnConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.semanticTypeId !== "") {
      writer.uint32(18).string(message.semanticTypeId);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      ColumnConfig_LabelsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.classificationId !== "") {
      writer.uint32(34).string(message.classificationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ColumnConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseColumnConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.semanticTypeId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = ColumnConfig_LabelsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.labels[entry3.key] = entry3.value;
          }
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.classificationId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ColumnConfig {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      semanticTypeId: isSet(object.semanticTypeId) ? globalThis.String(object.semanticTypeId) : "",
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      classificationId: isSet(object.classificationId) ? globalThis.String(object.classificationId) : "",
    };
  },

  toJSON(message: ColumnConfig): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.semanticTypeId !== "") {
      obj.semanticTypeId = message.semanticTypeId;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.classificationId !== "") {
      obj.classificationId = message.classificationId;
    }
    return obj;
  },

  create(base?: DeepPartial<ColumnConfig>): ColumnConfig {
    return ColumnConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ColumnConfig>): ColumnConfig {
    const message = createBaseColumnConfig();
    message.name = object.name ?? "";
    message.semanticTypeId = object.semanticTypeId ?? "";
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.classificationId = object.classificationId ?? "";
    return message;
  },
};

function createBaseColumnConfig_LabelsEntry(): ColumnConfig_LabelsEntry {
  return { key: "", value: "" };
}

export const ColumnConfig_LabelsEntry: MessageFns<ColumnConfig_LabelsEntry> = {
  encode(message: ColumnConfig_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ColumnConfig_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseColumnConfig_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ColumnConfig_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ColumnConfig_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ColumnConfig_LabelsEntry>): ColumnConfig_LabelsEntry {
    return ColumnConfig_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ColumnConfig_LabelsEntry>): ColumnConfig_LabelsEntry {
    const message = createBaseColumnConfig_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseDatabaseSchema(): DatabaseSchema {
  return { schema: "" };
}

export const DatabaseSchema: MessageFns<DatabaseSchema> = {
  encode(message: DatabaseSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.schema !== "") {
      writer.uint32(10).string(message.schema);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DatabaseSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatabaseSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.schema = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DatabaseSchema {
    return { schema: isSet(object.schema) ? globalThis.String(object.schema) : "" };
  },

  toJSON(message: DatabaseSchema): unknown {
    const obj: any = {};
    if (message.schema !== "") {
      obj.schema = message.schema;
    }
    return obj;
  },

  create(base?: DeepPartial<DatabaseSchema>): DatabaseSchema {
    return DatabaseSchema.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DatabaseSchema>): DatabaseSchema {
    const message = createBaseDatabaseSchema();
    message.schema = object.schema ?? "";
    return message;
  },
};

function createBaseListSlowQueriesRequest(): ListSlowQueriesRequest {
  return { parent: "", filter: "", orderBy: "" };
}

export const ListSlowQueriesRequest: MessageFns<ListSlowQueriesRequest> = {
  encode(message: ListSlowQueriesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.filter !== "") {
      writer.uint32(18).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(26).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSlowQueriesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSlowQueriesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSlowQueriesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListSlowQueriesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListSlowQueriesRequest>): ListSlowQueriesRequest {
    return ListSlowQueriesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSlowQueriesRequest>): ListSlowQueriesRequest {
    const message = createBaseListSlowQueriesRequest();
    message.parent = object.parent ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListSlowQueriesResponse(): ListSlowQueriesResponse {
  return { slowQueryLogs: [] };
}

export const ListSlowQueriesResponse: MessageFns<ListSlowQueriesResponse> = {
  encode(message: ListSlowQueriesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.slowQueryLogs) {
      SlowQueryLog.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSlowQueriesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSlowQueriesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.slowQueryLogs.push(SlowQueryLog.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSlowQueriesResponse {
    return {
      slowQueryLogs: globalThis.Array.isArray(object?.slowQueryLogs)
        ? object.slowQueryLogs.map((e: any) => SlowQueryLog.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListSlowQueriesResponse): unknown {
    const obj: any = {};
    if (message.slowQueryLogs?.length) {
      obj.slowQueryLogs = message.slowQueryLogs.map((e) => SlowQueryLog.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListSlowQueriesResponse>): ListSlowQueriesResponse {
    return ListSlowQueriesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSlowQueriesResponse>): ListSlowQueriesResponse {
    const message = createBaseListSlowQueriesResponse();
    message.slowQueryLogs = object.slowQueryLogs?.map((e) => SlowQueryLog.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSlowQueryLog(): SlowQueryLog {
  return { resource: "", project: "", statistics: undefined };
}

export const SlowQueryLog: MessageFns<SlowQueryLog> = {
  encode(message: SlowQueryLog, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resource !== "") {
      writer.uint32(10).string(message.resource);
    }
    if (message.project !== "") {
      writer.uint32(18).string(message.project);
    }
    if (message.statistics !== undefined) {
      SlowQueryStatistics.encode(message.statistics, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SlowQueryLog {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSlowQueryLog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.resource = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.project = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.statistics = SlowQueryStatistics.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SlowQueryLog {
    return {
      resource: isSet(object.resource) ? globalThis.String(object.resource) : "",
      project: isSet(object.project) ? globalThis.String(object.project) : "",
      statistics: isSet(object.statistics) ? SlowQueryStatistics.fromJSON(object.statistics) : undefined,
    };
  },

  toJSON(message: SlowQueryLog): unknown {
    const obj: any = {};
    if (message.resource !== "") {
      obj.resource = message.resource;
    }
    if (message.project !== "") {
      obj.project = message.project;
    }
    if (message.statistics !== undefined) {
      obj.statistics = SlowQueryStatistics.toJSON(message.statistics);
    }
    return obj;
  },

  create(base?: DeepPartial<SlowQueryLog>): SlowQueryLog {
    return SlowQueryLog.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SlowQueryLog>): SlowQueryLog {
    const message = createBaseSlowQueryLog();
    message.resource = object.resource ?? "";
    message.project = object.project ?? "";
    message.statistics = (object.statistics !== undefined && object.statistics !== null)
      ? SlowQueryStatistics.fromPartial(object.statistics)
      : undefined;
    return message;
  },
};

function createBaseSlowQueryStatistics(): SlowQueryStatistics {
  return {
    sqlFingerprint: "",
    count: 0,
    latestLogTime: undefined,
    averageQueryTime: undefined,
    maximumQueryTime: undefined,
    averageRowsSent: 0,
    maximumRowsSent: 0,
    averageRowsExamined: 0,
    maximumRowsExamined: 0,
    queryTimePercent: 0,
    countPercent: 0,
    samples: [],
  };
}

export const SlowQueryStatistics: MessageFns<SlowQueryStatistics> = {
  encode(message: SlowQueryStatistics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sqlFingerprint !== "") {
      writer.uint32(10).string(message.sqlFingerprint);
    }
    if (message.count !== 0) {
      writer.uint32(16).int32(message.count);
    }
    if (message.latestLogTime !== undefined) {
      Timestamp.encode(message.latestLogTime, writer.uint32(26).fork()).join();
    }
    if (message.averageQueryTime !== undefined) {
      Duration.encode(message.averageQueryTime, writer.uint32(34).fork()).join();
    }
    if (message.maximumQueryTime !== undefined) {
      Duration.encode(message.maximumQueryTime, writer.uint32(42).fork()).join();
    }
    if (message.averageRowsSent !== 0) {
      writer.uint32(48).int32(message.averageRowsSent);
    }
    if (message.maximumRowsSent !== 0) {
      writer.uint32(56).int32(message.maximumRowsSent);
    }
    if (message.averageRowsExamined !== 0) {
      writer.uint32(64).int32(message.averageRowsExamined);
    }
    if (message.maximumRowsExamined !== 0) {
      writer.uint32(72).int32(message.maximumRowsExamined);
    }
    if (message.queryTimePercent !== 0) {
      writer.uint32(81).double(message.queryTimePercent);
    }
    if (message.countPercent !== 0) {
      writer.uint32(89).double(message.countPercent);
    }
    for (const v of message.samples) {
      SlowQueryDetails.encode(v!, writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SlowQueryStatistics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSlowQueryStatistics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sqlFingerprint = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.count = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.latestLogTime = Timestamp.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.averageQueryTime = Duration.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.maximumQueryTime = Duration.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.averageRowsSent = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.maximumRowsSent = reader.int32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.averageRowsExamined = reader.int32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.maximumRowsExamined = reader.int32();
          continue;
        case 10:
          if (tag !== 81) {
            break;
          }

          message.queryTimePercent = reader.double();
          continue;
        case 11:
          if (tag !== 89) {
            break;
          }

          message.countPercent = reader.double();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.samples.push(SlowQueryDetails.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SlowQueryStatistics {
    return {
      sqlFingerprint: isSet(object.sqlFingerprint) ? globalThis.String(object.sqlFingerprint) : "",
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
      latestLogTime: isSet(object.latestLogTime) ? fromJsonTimestamp(object.latestLogTime) : undefined,
      averageQueryTime: isSet(object.averageQueryTime) ? Duration.fromJSON(object.averageQueryTime) : undefined,
      maximumQueryTime: isSet(object.maximumQueryTime) ? Duration.fromJSON(object.maximumQueryTime) : undefined,
      averageRowsSent: isSet(object.averageRowsSent) ? globalThis.Number(object.averageRowsSent) : 0,
      maximumRowsSent: isSet(object.maximumRowsSent) ? globalThis.Number(object.maximumRowsSent) : 0,
      averageRowsExamined: isSet(object.averageRowsExamined) ? globalThis.Number(object.averageRowsExamined) : 0,
      maximumRowsExamined: isSet(object.maximumRowsExamined) ? globalThis.Number(object.maximumRowsExamined) : 0,
      queryTimePercent: isSet(object.queryTimePercent) ? globalThis.Number(object.queryTimePercent) : 0,
      countPercent: isSet(object.countPercent) ? globalThis.Number(object.countPercent) : 0,
      samples: globalThis.Array.isArray(object?.samples)
        ? object.samples.map((e: any) => SlowQueryDetails.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SlowQueryStatistics): unknown {
    const obj: any = {};
    if (message.sqlFingerprint !== "") {
      obj.sqlFingerprint = message.sqlFingerprint;
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    if (message.latestLogTime !== undefined) {
      obj.latestLogTime = fromTimestamp(message.latestLogTime).toISOString();
    }
    if (message.averageQueryTime !== undefined) {
      obj.averageQueryTime = Duration.toJSON(message.averageQueryTime);
    }
    if (message.maximumQueryTime !== undefined) {
      obj.maximumQueryTime = Duration.toJSON(message.maximumQueryTime);
    }
    if (message.averageRowsSent !== 0) {
      obj.averageRowsSent = Math.round(message.averageRowsSent);
    }
    if (message.maximumRowsSent !== 0) {
      obj.maximumRowsSent = Math.round(message.maximumRowsSent);
    }
    if (message.averageRowsExamined !== 0) {
      obj.averageRowsExamined = Math.round(message.averageRowsExamined);
    }
    if (message.maximumRowsExamined !== 0) {
      obj.maximumRowsExamined = Math.round(message.maximumRowsExamined);
    }
    if (message.queryTimePercent !== 0) {
      obj.queryTimePercent = message.queryTimePercent;
    }
    if (message.countPercent !== 0) {
      obj.countPercent = message.countPercent;
    }
    if (message.samples?.length) {
      obj.samples = message.samples.map((e) => SlowQueryDetails.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SlowQueryStatistics>): SlowQueryStatistics {
    return SlowQueryStatistics.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SlowQueryStatistics>): SlowQueryStatistics {
    const message = createBaseSlowQueryStatistics();
    message.sqlFingerprint = object.sqlFingerprint ?? "";
    message.count = object.count ?? 0;
    message.latestLogTime = (object.latestLogTime !== undefined && object.latestLogTime !== null)
      ? Timestamp.fromPartial(object.latestLogTime)
      : undefined;
    message.averageQueryTime = (object.averageQueryTime !== undefined && object.averageQueryTime !== null)
      ? Duration.fromPartial(object.averageQueryTime)
      : undefined;
    message.maximumQueryTime = (object.maximumQueryTime !== undefined && object.maximumQueryTime !== null)
      ? Duration.fromPartial(object.maximumQueryTime)
      : undefined;
    message.averageRowsSent = object.averageRowsSent ?? 0;
    message.maximumRowsSent = object.maximumRowsSent ?? 0;
    message.averageRowsExamined = object.averageRowsExamined ?? 0;
    message.maximumRowsExamined = object.maximumRowsExamined ?? 0;
    message.queryTimePercent = object.queryTimePercent ?? 0;
    message.countPercent = object.countPercent ?? 0;
    message.samples = object.samples?.map((e) => SlowQueryDetails.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSlowQueryDetails(): SlowQueryDetails {
  return { startTime: undefined, queryTime: undefined, lockTime: undefined, rowsSent: 0, rowsExamined: 0, sqlText: "" };
}

export const SlowQueryDetails: MessageFns<SlowQueryDetails> = {
  encode(message: SlowQueryDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startTime !== undefined) {
      Timestamp.encode(message.startTime, writer.uint32(10).fork()).join();
    }
    if (message.queryTime !== undefined) {
      Duration.encode(message.queryTime, writer.uint32(18).fork()).join();
    }
    if (message.lockTime !== undefined) {
      Duration.encode(message.lockTime, writer.uint32(26).fork()).join();
    }
    if (message.rowsSent !== 0) {
      writer.uint32(32).int32(message.rowsSent);
    }
    if (message.rowsExamined !== 0) {
      writer.uint32(40).int32(message.rowsExamined);
    }
    if (message.sqlText !== "") {
      writer.uint32(50).string(message.sqlText);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SlowQueryDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSlowQueryDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.startTime = Timestamp.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.queryTime = Duration.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.lockTime = Duration.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.rowsSent = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.rowsExamined = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.sqlText = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SlowQueryDetails {
    return {
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      queryTime: isSet(object.queryTime) ? Duration.fromJSON(object.queryTime) : undefined,
      lockTime: isSet(object.lockTime) ? Duration.fromJSON(object.lockTime) : undefined,
      rowsSent: isSet(object.rowsSent) ? globalThis.Number(object.rowsSent) : 0,
      rowsExamined: isSet(object.rowsExamined) ? globalThis.Number(object.rowsExamined) : 0,
      sqlText: isSet(object.sqlText) ? globalThis.String(object.sqlText) : "",
    };
  },

  toJSON(message: SlowQueryDetails): unknown {
    const obj: any = {};
    if (message.startTime !== undefined) {
      obj.startTime = fromTimestamp(message.startTime).toISOString();
    }
    if (message.queryTime !== undefined) {
      obj.queryTime = Duration.toJSON(message.queryTime);
    }
    if (message.lockTime !== undefined) {
      obj.lockTime = Duration.toJSON(message.lockTime);
    }
    if (message.rowsSent !== 0) {
      obj.rowsSent = Math.round(message.rowsSent);
    }
    if (message.rowsExamined !== 0) {
      obj.rowsExamined = Math.round(message.rowsExamined);
    }
    if (message.sqlText !== "") {
      obj.sqlText = message.sqlText;
    }
    return obj;
  },

  create(base?: DeepPartial<SlowQueryDetails>): SlowQueryDetails {
    return SlowQueryDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SlowQueryDetails>): SlowQueryDetails {
    const message = createBaseSlowQueryDetails();
    message.startTime = (object.startTime !== undefined && object.startTime !== null)
      ? Timestamp.fromPartial(object.startTime)
      : undefined;
    message.queryTime = (object.queryTime !== undefined && object.queryTime !== null)
      ? Duration.fromPartial(object.queryTime)
      : undefined;
    message.lockTime = (object.lockTime !== undefined && object.lockTime !== null)
      ? Duration.fromPartial(object.lockTime)
      : undefined;
    message.rowsSent = object.rowsSent ?? 0;
    message.rowsExamined = object.rowsExamined ?? 0;
    message.sqlText = object.sqlText ?? "";
    return message;
  },
};

function createBaseListSecretsRequest(): ListSecretsRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListSecretsRequest: MessageFns<ListSecretsRequest> = {
  encode(message: ListSecretsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSecretsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSecretsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSecretsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListSecretsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListSecretsRequest>): ListSecretsRequest {
    return ListSecretsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSecretsRequest>): ListSecretsRequest {
    const message = createBaseListSecretsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListSecretsResponse(): ListSecretsResponse {
  return { secrets: [], nextPageToken: "" };
}

export const ListSecretsResponse: MessageFns<ListSecretsResponse> = {
  encode(message: ListSecretsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.secrets) {
      Secret.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSecretsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSecretsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.secrets.push(Secret.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSecretsResponse {
    return {
      secrets: globalThis.Array.isArray(object?.secrets) ? object.secrets.map((e: any) => Secret.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListSecretsResponse): unknown {
    const obj: any = {};
    if (message.secrets?.length) {
      obj.secrets = message.secrets.map((e) => Secret.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListSecretsResponse>): ListSecretsResponse {
    return ListSecretsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSecretsResponse>): ListSecretsResponse {
    const message = createBaseListSecretsResponse();
    message.secrets = object.secrets?.map((e) => Secret.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseUpdateSecretRequest(): UpdateSecretRequest {
  return { secret: undefined, updateMask: undefined, allowMissing: false };
}

export const UpdateSecretRequest: MessageFns<UpdateSecretRequest> = {
  encode(message: UpdateSecretRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.secret !== undefined) {
      Secret.encode(message.secret, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    if (message.allowMissing !== false) {
      writer.uint32(24).bool(message.allowMissing);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateSecretRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSecretRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.secret = Secret.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.allowMissing = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSecretRequest {
    return {
      secret: isSet(object.secret) ? Secret.fromJSON(object.secret) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      allowMissing: isSet(object.allowMissing) ? globalThis.Boolean(object.allowMissing) : false,
    };
  },

  toJSON(message: UpdateSecretRequest): unknown {
    const obj: any = {};
    if (message.secret !== undefined) {
      obj.secret = Secret.toJSON(message.secret);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.allowMissing !== false) {
      obj.allowMissing = message.allowMissing;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateSecretRequest>): UpdateSecretRequest {
    return UpdateSecretRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateSecretRequest>): UpdateSecretRequest {
    const message = createBaseUpdateSecretRequest();
    message.secret = (object.secret !== undefined && object.secret !== null)
      ? Secret.fromPartial(object.secret)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    message.allowMissing = object.allowMissing ?? false;
    return message;
  },
};

function createBaseDeleteSecretRequest(): DeleteSecretRequest {
  return { name: "" };
}

export const DeleteSecretRequest: MessageFns<DeleteSecretRequest> = {
  encode(message: DeleteSecretRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteSecretRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteSecretRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteSecretRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteSecretRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteSecretRequest>): DeleteSecretRequest {
    return DeleteSecretRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteSecretRequest>): DeleteSecretRequest {
    const message = createBaseDeleteSecretRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseSecret(): Secret {
  return { name: "", createdTime: undefined, updatedTime: undefined, value: "", description: "" };
}

export const Secret: MessageFns<Secret> = {
  encode(message: Secret, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createdTime !== undefined) {
      Timestamp.encode(message.createdTime, writer.uint32(18).fork()).join();
    }
    if (message.updatedTime !== undefined) {
      Timestamp.encode(message.updatedTime, writer.uint32(26).fork()).join();
    }
    if (message.value !== "") {
      writer.uint32(34).string(message.value);
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Secret {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSecret();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createdTime = Timestamp.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updatedTime = Timestamp.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.value = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Secret {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createdTime: isSet(object.createdTime) ? fromJsonTimestamp(object.createdTime) : undefined,
      updatedTime: isSet(object.updatedTime) ? fromJsonTimestamp(object.updatedTime) : undefined,
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: Secret): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createdTime !== undefined) {
      obj.createdTime = fromTimestamp(message.createdTime).toISOString();
    }
    if (message.updatedTime !== undefined) {
      obj.updatedTime = fromTimestamp(message.updatedTime).toISOString();
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create(base?: DeepPartial<Secret>): Secret {
    return Secret.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Secret>): Secret {
    const message = createBaseSecret();
    message.name = object.name ?? "";
    message.createdTime = (object.createdTime !== undefined && object.createdTime !== null)
      ? Timestamp.fromPartial(object.createdTime)
      : undefined;
    message.updatedTime = (object.updatedTime !== undefined && object.updatedTime !== null)
      ? Timestamp.fromPartial(object.updatedTime)
      : undefined;
    message.value = object.value ?? "";
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseAdviseIndexRequest(): AdviseIndexRequest {
  return { parent: "", statement: "" };
}

export const AdviseIndexRequest: MessageFns<AdviseIndexRequest> = {
  encode(message: AdviseIndexRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.statement !== "") {
      writer.uint32(18).string(message.statement);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdviseIndexRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdviseIndexRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.statement = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdviseIndexRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      statement: isSet(object.statement) ? globalThis.String(object.statement) : "",
    };
  },

  toJSON(message: AdviseIndexRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.statement !== "") {
      obj.statement = message.statement;
    }
    return obj;
  },

  create(base?: DeepPartial<AdviseIndexRequest>): AdviseIndexRequest {
    return AdviseIndexRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AdviseIndexRequest>): AdviseIndexRequest {
    const message = createBaseAdviseIndexRequest();
    message.parent = object.parent ?? "";
    message.statement = object.statement ?? "";
    return message;
  },
};

function createBaseAdviseIndexResponse(): AdviseIndexResponse {
  return { currentIndex: "", suggestion: "", createIndexStatement: "" };
}

export const AdviseIndexResponse: MessageFns<AdviseIndexResponse> = {
  encode(message: AdviseIndexResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.currentIndex !== "") {
      writer.uint32(10).string(message.currentIndex);
    }
    if (message.suggestion !== "") {
      writer.uint32(18).string(message.suggestion);
    }
    if (message.createIndexStatement !== "") {
      writer.uint32(26).string(message.createIndexStatement);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdviseIndexResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdviseIndexResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.currentIndex = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.suggestion = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.createIndexStatement = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdviseIndexResponse {
    return {
      currentIndex: isSet(object.currentIndex) ? globalThis.String(object.currentIndex) : "",
      suggestion: isSet(object.suggestion) ? globalThis.String(object.suggestion) : "",
      createIndexStatement: isSet(object.createIndexStatement) ? globalThis.String(object.createIndexStatement) : "",
    };
  },

  toJSON(message: AdviseIndexResponse): unknown {
    const obj: any = {};
    if (message.currentIndex !== "") {
      obj.currentIndex = message.currentIndex;
    }
    if (message.suggestion !== "") {
      obj.suggestion = message.suggestion;
    }
    if (message.createIndexStatement !== "") {
      obj.createIndexStatement = message.createIndexStatement;
    }
    return obj;
  },

  create(base?: DeepPartial<AdviseIndexResponse>): AdviseIndexResponse {
    return AdviseIndexResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AdviseIndexResponse>): AdviseIndexResponse {
    const message = createBaseAdviseIndexResponse();
    message.currentIndex = object.currentIndex ?? "";
    message.suggestion = object.suggestion ?? "";
    message.createIndexStatement = object.createIndexStatement ?? "";
    return message;
  },
};

function createBaseChangeHistory(): ChangeHistory {
  return {
    name: "",
    creator: "",
    updater: "",
    createTime: undefined,
    updateTime: undefined,
    releaseVersion: "",
    source: ChangeHistory_Source.SOURCE_UNSPECIFIED,
    type: ChangeHistory_Type.TYPE_UNSPECIFIED,
    status: ChangeHistory_Status.STATUS_UNSPECIFIED,
    version: "",
    description: "",
    statement: "",
    statementSize: Long.ZERO,
    statementSheet: "",
    schema: "",
    schemaSize: Long.ZERO,
    prevSchema: "",
    prevSchemaSize: Long.ZERO,
    executionDuration: undefined,
    issue: "",
    changedResources: undefined,
  };
}

export const ChangeHistory: MessageFns<ChangeHistory> = {
  encode(message: ChangeHistory, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.creator !== "") {
      writer.uint32(26).string(message.creator);
    }
    if (message.updater !== "") {
      writer.uint32(34).string(message.updater);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(message.createTime, writer.uint32(42).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(message.updateTime, writer.uint32(50).fork()).join();
    }
    if (message.releaseVersion !== "") {
      writer.uint32(58).string(message.releaseVersion);
    }
    if (message.source !== ChangeHistory_Source.SOURCE_UNSPECIFIED) {
      writer.uint32(64).int32(changeHistory_SourceToNumber(message.source));
    }
    if (message.type !== ChangeHistory_Type.TYPE_UNSPECIFIED) {
      writer.uint32(72).int32(changeHistory_TypeToNumber(message.type));
    }
    if (message.status !== ChangeHistory_Status.STATUS_UNSPECIFIED) {
      writer.uint32(80).int32(changeHistory_StatusToNumber(message.status));
    }
    if (message.version !== "") {
      writer.uint32(90).string(message.version);
    }
    if (message.description !== "") {
      writer.uint32(98).string(message.description);
    }
    if (message.statement !== "") {
      writer.uint32(106).string(message.statement);
    }
    if (!message.statementSize.equals(Long.ZERO)) {
      writer.uint32(168).int64(message.statementSize.toString());
    }
    if (message.statementSheet !== "") {
      writer.uint32(162).string(message.statementSheet);
    }
    if (message.schema !== "") {
      writer.uint32(114).string(message.schema);
    }
    if (!message.schemaSize.equals(Long.ZERO)) {
      writer.uint32(176).int64(message.schemaSize.toString());
    }
    if (message.prevSchema !== "") {
      writer.uint32(122).string(message.prevSchema);
    }
    if (!message.prevSchemaSize.equals(Long.ZERO)) {
      writer.uint32(184).int64(message.prevSchemaSize.toString());
    }
    if (message.executionDuration !== undefined) {
      Duration.encode(message.executionDuration, writer.uint32(130).fork()).join();
    }
    if (message.issue !== "") {
      writer.uint32(138).string(message.issue);
    }
    if (message.changedResources !== undefined) {
      ChangedResources.encode(message.changedResources, writer.uint32(154).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChangeHistory {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangeHistory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.creator = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.updater = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.createTime = Timestamp.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.updateTime = Timestamp.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.releaseVersion = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.source = changeHistory_SourceFromJSON(reader.int32());
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.type = changeHistory_TypeFromJSON(reader.int32());
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.status = changeHistory_StatusFromJSON(reader.int32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.version = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.description = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.statement = reader.string();
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.statementSize = Long.fromString(reader.int64().toString());
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.statementSheet = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.schema = reader.string();
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.schemaSize = Long.fromString(reader.int64().toString());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.prevSchema = reader.string();
          continue;
        case 23:
          if (tag !== 184) {
            break;
          }

          message.prevSchemaSize = Long.fromString(reader.int64().toString());
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.executionDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.issue = reader.string();
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.changedResources = ChangedResources.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChangeHistory {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      updater: isSet(object.updater) ? globalThis.String(object.updater) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      releaseVersion: isSet(object.releaseVersion) ? globalThis.String(object.releaseVersion) : "",
      source: isSet(object.source)
        ? changeHistory_SourceFromJSON(object.source)
        : ChangeHistory_Source.SOURCE_UNSPECIFIED,
      type: isSet(object.type) ? changeHistory_TypeFromJSON(object.type) : ChangeHistory_Type.TYPE_UNSPECIFIED,
      status: isSet(object.status)
        ? changeHistory_StatusFromJSON(object.status)
        : ChangeHistory_Status.STATUS_UNSPECIFIED,
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      statement: isSet(object.statement) ? globalThis.String(object.statement) : "",
      statementSize: isSet(object.statementSize) ? Long.fromValue(object.statementSize) : Long.ZERO,
      statementSheet: isSet(object.statementSheet) ? globalThis.String(object.statementSheet) : "",
      schema: isSet(object.schema) ? globalThis.String(object.schema) : "",
      schemaSize: isSet(object.schemaSize) ? Long.fromValue(object.schemaSize) : Long.ZERO,
      prevSchema: isSet(object.prevSchema) ? globalThis.String(object.prevSchema) : "",
      prevSchemaSize: isSet(object.prevSchemaSize) ? Long.fromValue(object.prevSchemaSize) : Long.ZERO,
      executionDuration: isSet(object.executionDuration) ? Duration.fromJSON(object.executionDuration) : undefined,
      issue: isSet(object.issue) ? globalThis.String(object.issue) : "",
      changedResources: isSet(object.changedResources) ? ChangedResources.fromJSON(object.changedResources) : undefined,
    };
  },

  toJSON(message: ChangeHistory): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.updater !== "") {
      obj.updater = message.updater;
    }
    if (message.createTime !== undefined) {
      obj.createTime = fromTimestamp(message.createTime).toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = fromTimestamp(message.updateTime).toISOString();
    }
    if (message.releaseVersion !== "") {
      obj.releaseVersion = message.releaseVersion;
    }
    if (message.source !== ChangeHistory_Source.SOURCE_UNSPECIFIED) {
      obj.source = changeHistory_SourceToJSON(message.source);
    }
    if (message.type !== ChangeHistory_Type.TYPE_UNSPECIFIED) {
      obj.type = changeHistory_TypeToJSON(message.type);
    }
    if (message.status !== ChangeHistory_Status.STATUS_UNSPECIFIED) {
      obj.status = changeHistory_StatusToJSON(message.status);
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.statement !== "") {
      obj.statement = message.statement;
    }
    if (!message.statementSize.equals(Long.ZERO)) {
      obj.statementSize = (message.statementSize || Long.ZERO).toString();
    }
    if (message.statementSheet !== "") {
      obj.statementSheet = message.statementSheet;
    }
    if (message.schema !== "") {
      obj.schema = message.schema;
    }
    if (!message.schemaSize.equals(Long.ZERO)) {
      obj.schemaSize = (message.schemaSize || Long.ZERO).toString();
    }
    if (message.prevSchema !== "") {
      obj.prevSchema = message.prevSchema;
    }
    if (!message.prevSchemaSize.equals(Long.ZERO)) {
      obj.prevSchemaSize = (message.prevSchemaSize || Long.ZERO).toString();
    }
    if (message.executionDuration !== undefined) {
      obj.executionDuration = Duration.toJSON(message.executionDuration);
    }
    if (message.issue !== "") {
      obj.issue = message.issue;
    }
    if (message.changedResources !== undefined) {
      obj.changedResources = ChangedResources.toJSON(message.changedResources);
    }
    return obj;
  },

  create(base?: DeepPartial<ChangeHistory>): ChangeHistory {
    return ChangeHistory.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChangeHistory>): ChangeHistory {
    const message = createBaseChangeHistory();
    message.name = object.name ?? "";
    message.creator = object.creator ?? "";
    message.updater = object.updater ?? "";
    message.createTime = (object.createTime !== undefined && object.createTime !== null)
      ? Timestamp.fromPartial(object.createTime)
      : undefined;
    message.updateTime = (object.updateTime !== undefined && object.updateTime !== null)
      ? Timestamp.fromPartial(object.updateTime)
      : undefined;
    message.releaseVersion = object.releaseVersion ?? "";
    message.source = object.source ?? ChangeHistory_Source.SOURCE_UNSPECIFIED;
    message.type = object.type ?? ChangeHistory_Type.TYPE_UNSPECIFIED;
    message.status = object.status ?? ChangeHistory_Status.STATUS_UNSPECIFIED;
    message.version = object.version ?? "";
    message.description = object.description ?? "";
    message.statement = object.statement ?? "";
    message.statementSize = (object.statementSize !== undefined && object.statementSize !== null)
      ? Long.fromValue(object.statementSize)
      : Long.ZERO;
    message.statementSheet = object.statementSheet ?? "";
    message.schema = object.schema ?? "";
    message.schemaSize = (object.schemaSize !== undefined && object.schemaSize !== null)
      ? Long.fromValue(object.schemaSize)
      : Long.ZERO;
    message.prevSchema = object.prevSchema ?? "";
    message.prevSchemaSize = (object.prevSchemaSize !== undefined && object.prevSchemaSize !== null)
      ? Long.fromValue(object.prevSchemaSize)
      : Long.ZERO;
    message.executionDuration = (object.executionDuration !== undefined && object.executionDuration !== null)
      ? Duration.fromPartial(object.executionDuration)
      : undefined;
    message.issue = object.issue ?? "";
    message.changedResources = (object.changedResources !== undefined && object.changedResources !== null)
      ? ChangedResources.fromPartial(object.changedResources)
      : undefined;
    return message;
  },
};

function createBaseChangedResources(): ChangedResources {
  return { databases: [] };
}

export const ChangedResources: MessageFns<ChangedResources> = {
  encode(message: ChangedResources, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.databases) {
      ChangedResourceDatabase.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChangedResources {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangedResources();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.databases.push(ChangedResourceDatabase.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChangedResources {
    return {
      databases: globalThis.Array.isArray(object?.databases)
        ? object.databases.map((e: any) => ChangedResourceDatabase.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ChangedResources): unknown {
    const obj: any = {};
    if (message.databases?.length) {
      obj.databases = message.databases.map((e) => ChangedResourceDatabase.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ChangedResources>): ChangedResources {
    return ChangedResources.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChangedResources>): ChangedResources {
    const message = createBaseChangedResources();
    message.databases = object.databases?.map((e) => ChangedResourceDatabase.fromPartial(e)) || [];
    return message;
  },
};

function createBaseChangedResourceDatabase(): ChangedResourceDatabase {
  return { name: "", schemas: [] };
}

export const ChangedResourceDatabase: MessageFns<ChangedResourceDatabase> = {
  encode(message: ChangedResourceDatabase, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.schemas) {
      ChangedResourceSchema.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChangedResourceDatabase {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangedResourceDatabase();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.schemas.push(ChangedResourceSchema.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChangedResourceDatabase {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      schemas: globalThis.Array.isArray(object?.schemas)
        ? object.schemas.map((e: any) => ChangedResourceSchema.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ChangedResourceDatabase): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.schemas?.length) {
      obj.schemas = message.schemas.map((e) => ChangedResourceSchema.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ChangedResourceDatabase>): ChangedResourceDatabase {
    return ChangedResourceDatabase.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChangedResourceDatabase>): ChangedResourceDatabase {
    const message = createBaseChangedResourceDatabase();
    message.name = object.name ?? "";
    message.schemas = object.schemas?.map((e) => ChangedResourceSchema.fromPartial(e)) || [];
    return message;
  },
};

function createBaseChangedResourceSchema(): ChangedResourceSchema {
  return { name: "", tables: [], views: [], functions: [], procedures: [] };
}

export const ChangedResourceSchema: MessageFns<ChangedResourceSchema> = {
  encode(message: ChangedResourceSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.tables) {
      ChangedResourceTable.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.views) {
      ChangedResourceView.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.functions) {
      ChangedResourceFunction.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.procedures) {
      ChangedResourceProcedure.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChangedResourceSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangedResourceSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tables.push(ChangedResourceTable.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.views.push(ChangedResourceView.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.functions.push(ChangedResourceFunction.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.procedures.push(ChangedResourceProcedure.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChangedResourceSchema {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      tables: globalThis.Array.isArray(object?.tables)
        ? object.tables.map((e: any) => ChangedResourceTable.fromJSON(e))
        : [],
      views: globalThis.Array.isArray(object?.views)
        ? object.views.map((e: any) => ChangedResourceView.fromJSON(e))
        : [],
      functions: globalThis.Array.isArray(object?.functions)
        ? object.functions.map((e: any) => ChangedResourceFunction.fromJSON(e))
        : [],
      procedures: globalThis.Array.isArray(object?.procedures)
        ? object.procedures.map((e: any) => ChangedResourceProcedure.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ChangedResourceSchema): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.tables?.length) {
      obj.tables = message.tables.map((e) => ChangedResourceTable.toJSON(e));
    }
    if (message.views?.length) {
      obj.views = message.views.map((e) => ChangedResourceView.toJSON(e));
    }
    if (message.functions?.length) {
      obj.functions = message.functions.map((e) => ChangedResourceFunction.toJSON(e));
    }
    if (message.procedures?.length) {
      obj.procedures = message.procedures.map((e) => ChangedResourceProcedure.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ChangedResourceSchema>): ChangedResourceSchema {
    return ChangedResourceSchema.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChangedResourceSchema>): ChangedResourceSchema {
    const message = createBaseChangedResourceSchema();
    message.name = object.name ?? "";
    message.tables = object.tables?.map((e) => ChangedResourceTable.fromPartial(e)) || [];
    message.views = object.views?.map((e) => ChangedResourceView.fromPartial(e)) || [];
    message.functions = object.functions?.map((e) => ChangedResourceFunction.fromPartial(e)) || [];
    message.procedures = object.procedures?.map((e) => ChangedResourceProcedure.fromPartial(e)) || [];
    return message;
  },
};

function createBaseChangedResourceTable(): ChangedResourceTable {
  return { name: "", ranges: [] };
}

export const ChangedResourceTable: MessageFns<ChangedResourceTable> = {
  encode(message: ChangedResourceTable, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.ranges) {
      Range.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChangedResourceTable {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangedResourceTable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.ranges.push(Range.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChangedResourceTable {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      ranges: globalThis.Array.isArray(object?.ranges) ? object.ranges.map((e: any) => Range.fromJSON(e)) : [],
    };
  },

  toJSON(message: ChangedResourceTable): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.ranges?.length) {
      obj.ranges = message.ranges.map((e) => Range.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ChangedResourceTable>): ChangedResourceTable {
    return ChangedResourceTable.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChangedResourceTable>): ChangedResourceTable {
    const message = createBaseChangedResourceTable();
    message.name = object.name ?? "";
    message.ranges = object.ranges?.map((e) => Range.fromPartial(e)) || [];
    return message;
  },
};

function createBaseChangedResourceView(): ChangedResourceView {
  return { name: "", ranges: [] };
}

export const ChangedResourceView: MessageFns<ChangedResourceView> = {
  encode(message: ChangedResourceView, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.ranges) {
      Range.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChangedResourceView {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangedResourceView();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ranges.push(Range.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChangedResourceView {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      ranges: globalThis.Array.isArray(object?.ranges) ? object.ranges.map((e: any) => Range.fromJSON(e)) : [],
    };
  },

  toJSON(message: ChangedResourceView): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.ranges?.length) {
      obj.ranges = message.ranges.map((e) => Range.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ChangedResourceView>): ChangedResourceView {
    return ChangedResourceView.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChangedResourceView>): ChangedResourceView {
    const message = createBaseChangedResourceView();
    message.name = object.name ?? "";
    message.ranges = object.ranges?.map((e) => Range.fromPartial(e)) || [];
    return message;
  },
};

function createBaseChangedResourceFunction(): ChangedResourceFunction {
  return { name: "", ranges: [] };
}

export const ChangedResourceFunction: MessageFns<ChangedResourceFunction> = {
  encode(message: ChangedResourceFunction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.ranges) {
      Range.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChangedResourceFunction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangedResourceFunction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ranges.push(Range.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChangedResourceFunction {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      ranges: globalThis.Array.isArray(object?.ranges) ? object.ranges.map((e: any) => Range.fromJSON(e)) : [],
    };
  },

  toJSON(message: ChangedResourceFunction): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.ranges?.length) {
      obj.ranges = message.ranges.map((e) => Range.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ChangedResourceFunction>): ChangedResourceFunction {
    return ChangedResourceFunction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChangedResourceFunction>): ChangedResourceFunction {
    const message = createBaseChangedResourceFunction();
    message.name = object.name ?? "";
    message.ranges = object.ranges?.map((e) => Range.fromPartial(e)) || [];
    return message;
  },
};

function createBaseChangedResourceProcedure(): ChangedResourceProcedure {
  return { name: "", ranges: [] };
}

export const ChangedResourceProcedure: MessageFns<ChangedResourceProcedure> = {
  encode(message: ChangedResourceProcedure, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.ranges) {
      Range.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChangedResourceProcedure {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangedResourceProcedure();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ranges.push(Range.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChangedResourceProcedure {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      ranges: globalThis.Array.isArray(object?.ranges) ? object.ranges.map((e: any) => Range.fromJSON(e)) : [],
    };
  },

  toJSON(message: ChangedResourceProcedure): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.ranges?.length) {
      obj.ranges = message.ranges.map((e) => Range.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ChangedResourceProcedure>): ChangedResourceProcedure {
    return ChangedResourceProcedure.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChangedResourceProcedure>): ChangedResourceProcedure {
    const message = createBaseChangedResourceProcedure();
    message.name = object.name ?? "";
    message.ranges = object.ranges?.map((e) => Range.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListChangeHistoriesRequest(): ListChangeHistoriesRequest {
  return {
    parent: "",
    pageSize: 0,
    pageToken: "",
    view: ChangeHistoryView.CHANGE_HISTORY_VIEW_UNSPECIFIED,
    filter: "",
  };
}

export const ListChangeHistoriesRequest: MessageFns<ListChangeHistoriesRequest> = {
  encode(message: ListChangeHistoriesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.view !== ChangeHistoryView.CHANGE_HISTORY_VIEW_UNSPECIFIED) {
      writer.uint32(32).int32(changeHistoryViewToNumber(message.view));
    }
    if (message.filter !== "") {
      writer.uint32(42).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListChangeHistoriesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListChangeHistoriesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.view = changeHistoryViewFromJSON(reader.int32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListChangeHistoriesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      view: isSet(object.view)
        ? changeHistoryViewFromJSON(object.view)
        : ChangeHistoryView.CHANGE_HISTORY_VIEW_UNSPECIFIED,
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListChangeHistoriesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.view !== ChangeHistoryView.CHANGE_HISTORY_VIEW_UNSPECIFIED) {
      obj.view = changeHistoryViewToJSON(message.view);
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListChangeHistoriesRequest>): ListChangeHistoriesRequest {
    return ListChangeHistoriesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListChangeHistoriesRequest>): ListChangeHistoriesRequest {
    const message = createBaseListChangeHistoriesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.view = object.view ?? ChangeHistoryView.CHANGE_HISTORY_VIEW_UNSPECIFIED;
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListChangeHistoriesResponse(): ListChangeHistoriesResponse {
  return { changeHistories: [], nextPageToken: "" };
}

export const ListChangeHistoriesResponse: MessageFns<ListChangeHistoriesResponse> = {
  encode(message: ListChangeHistoriesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.changeHistories) {
      ChangeHistory.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListChangeHistoriesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListChangeHistoriesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.changeHistories.push(ChangeHistory.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListChangeHistoriesResponse {
    return {
      changeHistories: globalThis.Array.isArray(object?.changeHistories)
        ? object.changeHistories.map((e: any) => ChangeHistory.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListChangeHistoriesResponse): unknown {
    const obj: any = {};
    if (message.changeHistories?.length) {
      obj.changeHistories = message.changeHistories.map((e) => ChangeHistory.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListChangeHistoriesResponse>): ListChangeHistoriesResponse {
    return ListChangeHistoriesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListChangeHistoriesResponse>): ListChangeHistoriesResponse {
    const message = createBaseListChangeHistoriesResponse();
    message.changeHistories = object.changeHistories?.map((e) => ChangeHistory.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetChangeHistoryRequest(): GetChangeHistoryRequest {
  return { name: "", view: ChangeHistoryView.CHANGE_HISTORY_VIEW_UNSPECIFIED, sdlFormat: false, concise: false };
}

export const GetChangeHistoryRequest: MessageFns<GetChangeHistoryRequest> = {
  encode(message: GetChangeHistoryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.view !== ChangeHistoryView.CHANGE_HISTORY_VIEW_UNSPECIFIED) {
      writer.uint32(16).int32(changeHistoryViewToNumber(message.view));
    }
    if (message.sdlFormat !== false) {
      writer.uint32(24).bool(message.sdlFormat);
    }
    if (message.concise !== false) {
      writer.uint32(32).bool(message.concise);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetChangeHistoryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetChangeHistoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.view = changeHistoryViewFromJSON(reader.int32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.sdlFormat = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.concise = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetChangeHistoryRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      view: isSet(object.view)
        ? changeHistoryViewFromJSON(object.view)
        : ChangeHistoryView.CHANGE_HISTORY_VIEW_UNSPECIFIED,
      sdlFormat: isSet(object.sdlFormat) ? globalThis.Boolean(object.sdlFormat) : false,
      concise: isSet(object.concise) ? globalThis.Boolean(object.concise) : false,
    };
  },

  toJSON(message: GetChangeHistoryRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.view !== ChangeHistoryView.CHANGE_HISTORY_VIEW_UNSPECIFIED) {
      obj.view = changeHistoryViewToJSON(message.view);
    }
    if (message.sdlFormat !== false) {
      obj.sdlFormat = message.sdlFormat;
    }
    if (message.concise !== false) {
      obj.concise = message.concise;
    }
    return obj;
  },

  create(base?: DeepPartial<GetChangeHistoryRequest>): GetChangeHistoryRequest {
    return GetChangeHistoryRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetChangeHistoryRequest>): GetChangeHistoryRequest {
    const message = createBaseGetChangeHistoryRequest();
    message.name = object.name ?? "";
    message.view = object.view ?? ChangeHistoryView.CHANGE_HISTORY_VIEW_UNSPECIFIED;
    message.sdlFormat = object.sdlFormat ?? false;
    message.concise = object.concise ?? false;
    return message;
  },
};

function createBaseListRevisionsRequest(): ListRevisionsRequest {
  return { parent: "", pageSize: 0, pageToken: "", showDeleted: false };
}

export const ListRevisionsRequest: MessageFns<ListRevisionsRequest> = {
  encode(message: ListRevisionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.showDeleted !== false) {
      writer.uint32(32).bool(message.showDeleted);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRevisionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRevisionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.showDeleted = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRevisionsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      showDeleted: isSet(object.showDeleted) ? globalThis.Boolean(object.showDeleted) : false,
    };
  },

  toJSON(message: ListRevisionsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.showDeleted !== false) {
      obj.showDeleted = message.showDeleted;
    }
    return obj;
  },

  create(base?: DeepPartial<ListRevisionsRequest>): ListRevisionsRequest {
    return ListRevisionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListRevisionsRequest>): ListRevisionsRequest {
    const message = createBaseListRevisionsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.showDeleted = object.showDeleted ?? false;
    return message;
  },
};

function createBaseListRevisionsResponse(): ListRevisionsResponse {
  return { revisions: [], nextPageToken: "" };
}

export const ListRevisionsResponse: MessageFns<ListRevisionsResponse> = {
  encode(message: ListRevisionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.revisions) {
      Revision.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRevisionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRevisionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.revisions.push(Revision.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRevisionsResponse {
    return {
      revisions: globalThis.Array.isArray(object?.revisions)
        ? object.revisions.map((e: any) => Revision.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListRevisionsResponse): unknown {
    const obj: any = {};
    if (message.revisions?.length) {
      obj.revisions = message.revisions.map((e) => Revision.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListRevisionsResponse>): ListRevisionsResponse {
    return ListRevisionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListRevisionsResponse>): ListRevisionsResponse {
    const message = createBaseListRevisionsResponse();
    message.revisions = object.revisions?.map((e) => Revision.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseCreateRevisionRequest(): CreateRevisionRequest {
  return { parent: "", revision: undefined };
}

export const CreateRevisionRequest: MessageFns<CreateRevisionRequest> = {
  encode(message: CreateRevisionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.revision !== undefined) {
      Revision.encode(message.revision, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateRevisionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateRevisionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.revision = Revision.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateRevisionRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      revision: isSet(object.revision) ? Revision.fromJSON(object.revision) : undefined,
    };
  },

  toJSON(message: CreateRevisionRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.revision !== undefined) {
      obj.revision = Revision.toJSON(message.revision);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateRevisionRequest>): CreateRevisionRequest {
    return CreateRevisionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateRevisionRequest>): CreateRevisionRequest {
    const message = createBaseCreateRevisionRequest();
    message.parent = object.parent ?? "";
    message.revision = (object.revision !== undefined && object.revision !== null)
      ? Revision.fromPartial(object.revision)
      : undefined;
    return message;
  },
};

function createBaseGetRevisionRequest(): GetRevisionRequest {
  return { name: "" };
}

export const GetRevisionRequest: MessageFns<GetRevisionRequest> = {
  encode(message: GetRevisionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRevisionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRevisionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRevisionRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetRevisionRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetRevisionRequest>): GetRevisionRequest {
    return GetRevisionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetRevisionRequest>): GetRevisionRequest {
    const message = createBaseGetRevisionRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDeleteRevisionRequest(): DeleteRevisionRequest {
  return { name: "" };
}

export const DeleteRevisionRequest: MessageFns<DeleteRevisionRequest> = {
  encode(message: DeleteRevisionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteRevisionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteRevisionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteRevisionRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteRevisionRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteRevisionRequest>): DeleteRevisionRequest {
    return DeleteRevisionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteRevisionRequest>): DeleteRevisionRequest {
    const message = createBaseDeleteRevisionRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseRevision(): Revision {
  return {
    name: "",
    release: "",
    creator: "",
    createTime: undefined,
    deleter: "",
    deleteTime: undefined,
    file: "",
    version: "",
    sheet: "",
    sheetSha256: "",
    statement: "",
    statementSize: Long.ZERO,
    issue: "",
    taskRun: "",
  };
}

export const Revision: MessageFns<Revision> = {
  encode(message: Revision, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.release !== "") {
      writer.uint32(18).string(message.release);
    }
    if (message.creator !== "") {
      writer.uint32(26).string(message.creator);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(message.createTime, writer.uint32(34).fork()).join();
    }
    if (message.deleter !== "") {
      writer.uint32(42).string(message.deleter);
    }
    if (message.deleteTime !== undefined) {
      Timestamp.encode(message.deleteTime, writer.uint32(50).fork()).join();
    }
    if (message.file !== "") {
      writer.uint32(58).string(message.file);
    }
    if (message.version !== "") {
      writer.uint32(66).string(message.version);
    }
    if (message.sheet !== "") {
      writer.uint32(74).string(message.sheet);
    }
    if (message.sheetSha256 !== "") {
      writer.uint32(82).string(message.sheetSha256);
    }
    if (message.statement !== "") {
      writer.uint32(90).string(message.statement);
    }
    if (!message.statementSize.equals(Long.ZERO)) {
      writer.uint32(96).int64(message.statementSize.toString());
    }
    if (message.issue !== "") {
      writer.uint32(106).string(message.issue);
    }
    if (message.taskRun !== "") {
      writer.uint32(114).string(message.taskRun);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Revision {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRevision();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.release = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.creator = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.createTime = Timestamp.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.deleter = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.deleteTime = Timestamp.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.file = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.version = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.sheet = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.sheetSha256 = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.statement = reader.string();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.statementSize = Long.fromString(reader.int64().toString());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.issue = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.taskRun = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Revision {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      release: isSet(object.release) ? globalThis.String(object.release) : "",
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      deleter: isSet(object.deleter) ? globalThis.String(object.deleter) : "",
      deleteTime: isSet(object.deleteTime) ? fromJsonTimestamp(object.deleteTime) : undefined,
      file: isSet(object.file) ? globalThis.String(object.file) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      sheet: isSet(object.sheet) ? globalThis.String(object.sheet) : "",
      sheetSha256: isSet(object.sheetSha256) ? globalThis.String(object.sheetSha256) : "",
      statement: isSet(object.statement) ? globalThis.String(object.statement) : "",
      statementSize: isSet(object.statementSize) ? Long.fromValue(object.statementSize) : Long.ZERO,
      issue: isSet(object.issue) ? globalThis.String(object.issue) : "",
      taskRun: isSet(object.taskRun) ? globalThis.String(object.taskRun) : "",
    };
  },

  toJSON(message: Revision): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.release !== "") {
      obj.release = message.release;
    }
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.createTime !== undefined) {
      obj.createTime = fromTimestamp(message.createTime).toISOString();
    }
    if (message.deleter !== "") {
      obj.deleter = message.deleter;
    }
    if (message.deleteTime !== undefined) {
      obj.deleteTime = fromTimestamp(message.deleteTime).toISOString();
    }
    if (message.file !== "") {
      obj.file = message.file;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.sheet !== "") {
      obj.sheet = message.sheet;
    }
    if (message.sheetSha256 !== "") {
      obj.sheetSha256 = message.sheetSha256;
    }
    if (message.statement !== "") {
      obj.statement = message.statement;
    }
    if (!message.statementSize.equals(Long.ZERO)) {
      obj.statementSize = (message.statementSize || Long.ZERO).toString();
    }
    if (message.issue !== "") {
      obj.issue = message.issue;
    }
    if (message.taskRun !== "") {
      obj.taskRun = message.taskRun;
    }
    return obj;
  },

  create(base?: DeepPartial<Revision>): Revision {
    return Revision.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Revision>): Revision {
    const message = createBaseRevision();
    message.name = object.name ?? "";
    message.release = object.release ?? "";
    message.creator = object.creator ?? "";
    message.createTime = (object.createTime !== undefined && object.createTime !== null)
      ? Timestamp.fromPartial(object.createTime)
      : undefined;
    message.deleter = object.deleter ?? "";
    message.deleteTime = (object.deleteTime !== undefined && object.deleteTime !== null)
      ? Timestamp.fromPartial(object.deleteTime)
      : undefined;
    message.file = object.file ?? "";
    message.version = object.version ?? "";
    message.sheet = object.sheet ?? "";
    message.sheetSha256 = object.sheetSha256 ?? "";
    message.statement = object.statement ?? "";
    message.statementSize = (object.statementSize !== undefined && object.statementSize !== null)
      ? Long.fromValue(object.statementSize)
      : Long.ZERO;
    message.issue = object.issue ?? "";
    message.taskRun = object.taskRun ?? "";
    return message;
  },
};

function createBaseListChangelogsRequest(): ListChangelogsRequest {
  return { parent: "", pageSize: 0, pageToken: "", view: ChangelogView.CHANGELOG_VIEW_UNSPECIFIED, filter: "" };
}

export const ListChangelogsRequest: MessageFns<ListChangelogsRequest> = {
  encode(message: ListChangelogsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.view !== ChangelogView.CHANGELOG_VIEW_UNSPECIFIED) {
      writer.uint32(32).int32(changelogViewToNumber(message.view));
    }
    if (message.filter !== "") {
      writer.uint32(42).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListChangelogsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListChangelogsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.view = changelogViewFromJSON(reader.int32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListChangelogsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      view: isSet(object.view) ? changelogViewFromJSON(object.view) : ChangelogView.CHANGELOG_VIEW_UNSPECIFIED,
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListChangelogsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.view !== ChangelogView.CHANGELOG_VIEW_UNSPECIFIED) {
      obj.view = changelogViewToJSON(message.view);
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListChangelogsRequest>): ListChangelogsRequest {
    return ListChangelogsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListChangelogsRequest>): ListChangelogsRequest {
    const message = createBaseListChangelogsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.view = object.view ?? ChangelogView.CHANGELOG_VIEW_UNSPECIFIED;
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListChangelogsResponse(): ListChangelogsResponse {
  return { changelogs: [], nextPageToken: "" };
}

export const ListChangelogsResponse: MessageFns<ListChangelogsResponse> = {
  encode(message: ListChangelogsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.changelogs) {
      Changelog.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListChangelogsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListChangelogsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.changelogs.push(Changelog.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListChangelogsResponse {
    return {
      changelogs: globalThis.Array.isArray(object?.changelogs)
        ? object.changelogs.map((e: any) => Changelog.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListChangelogsResponse): unknown {
    const obj: any = {};
    if (message.changelogs?.length) {
      obj.changelogs = message.changelogs.map((e) => Changelog.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListChangelogsResponse>): ListChangelogsResponse {
    return ListChangelogsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListChangelogsResponse>): ListChangelogsResponse {
    const message = createBaseListChangelogsResponse();
    message.changelogs = object.changelogs?.map((e) => Changelog.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetChangelogRequest(): GetChangelogRequest {
  return { name: "", view: ChangelogView.CHANGELOG_VIEW_UNSPECIFIED, sdlFormat: false, concise: false };
}

export const GetChangelogRequest: MessageFns<GetChangelogRequest> = {
  encode(message: GetChangelogRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.view !== ChangelogView.CHANGELOG_VIEW_UNSPECIFIED) {
      writer.uint32(16).int32(changelogViewToNumber(message.view));
    }
    if (message.sdlFormat !== false) {
      writer.uint32(24).bool(message.sdlFormat);
    }
    if (message.concise !== false) {
      writer.uint32(32).bool(message.concise);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetChangelogRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetChangelogRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.view = changelogViewFromJSON(reader.int32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.sdlFormat = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.concise = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetChangelogRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      view: isSet(object.view) ? changelogViewFromJSON(object.view) : ChangelogView.CHANGELOG_VIEW_UNSPECIFIED,
      sdlFormat: isSet(object.sdlFormat) ? globalThis.Boolean(object.sdlFormat) : false,
      concise: isSet(object.concise) ? globalThis.Boolean(object.concise) : false,
    };
  },

  toJSON(message: GetChangelogRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.view !== ChangelogView.CHANGELOG_VIEW_UNSPECIFIED) {
      obj.view = changelogViewToJSON(message.view);
    }
    if (message.sdlFormat !== false) {
      obj.sdlFormat = message.sdlFormat;
    }
    if (message.concise !== false) {
      obj.concise = message.concise;
    }
    return obj;
  },

  create(base?: DeepPartial<GetChangelogRequest>): GetChangelogRequest {
    return GetChangelogRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetChangelogRequest>): GetChangelogRequest {
    const message = createBaseGetChangelogRequest();
    message.name = object.name ?? "";
    message.view = object.view ?? ChangelogView.CHANGELOG_VIEW_UNSPECIFIED;
    message.sdlFormat = object.sdlFormat ?? false;
    message.concise = object.concise ?? false;
    return message;
  },
};

function createBaseChangelog(): Changelog {
  return {
    name: "",
    creator: "",
    createTime: undefined,
    status: Changelog_Status.STATUS_UNSPECIFIED,
    statement: "",
    statementSize: Long.ZERO,
    statementSheet: "",
    schema: "",
    schemaSize: Long.ZERO,
    prevSchema: "",
    prevSchemaSize: Long.ZERO,
    issue: "",
    taskRun: "",
    version: "",
    revision: "",
    changedResources: undefined,
  };
}

export const Changelog: MessageFns<Changelog> = {
  encode(message: Changelog, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.creator !== "") {
      writer.uint32(18).string(message.creator);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(message.createTime, writer.uint32(26).fork()).join();
    }
    if (message.status !== Changelog_Status.STATUS_UNSPECIFIED) {
      writer.uint32(32).int32(changelog_StatusToNumber(message.status));
    }
    if (message.statement !== "") {
      writer.uint32(42).string(message.statement);
    }
    if (!message.statementSize.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.statementSize.toString());
    }
    if (message.statementSheet !== "") {
      writer.uint32(58).string(message.statementSheet);
    }
    if (message.schema !== "") {
      writer.uint32(66).string(message.schema);
    }
    if (!message.schemaSize.equals(Long.ZERO)) {
      writer.uint32(72).int64(message.schemaSize.toString());
    }
    if (message.prevSchema !== "") {
      writer.uint32(82).string(message.prevSchema);
    }
    if (!message.prevSchemaSize.equals(Long.ZERO)) {
      writer.uint32(88).int64(message.prevSchemaSize.toString());
    }
    if (message.issue !== "") {
      writer.uint32(98).string(message.issue);
    }
    if (message.taskRun !== "") {
      writer.uint32(106).string(message.taskRun);
    }
    if (message.version !== "") {
      writer.uint32(114).string(message.version);
    }
    if (message.revision !== "") {
      writer.uint32(122).string(message.revision);
    }
    if (message.changedResources !== undefined) {
      ChangedResources.encode(message.changedResources, writer.uint32(130).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Changelog {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangelog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.creator = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.createTime = Timestamp.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.status = changelog_StatusFromJSON(reader.int32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.statement = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.statementSize = Long.fromString(reader.int64().toString());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.statementSheet = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.schema = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.schemaSize = Long.fromString(reader.int64().toString());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.prevSchema = reader.string();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.prevSchemaSize = Long.fromString(reader.int64().toString());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.issue = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.taskRun = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.version = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.revision = reader.string();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.changedResources = ChangedResources.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Changelog {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      status: isSet(object.status) ? changelog_StatusFromJSON(object.status) : Changelog_Status.STATUS_UNSPECIFIED,
      statement: isSet(object.statement) ? globalThis.String(object.statement) : "",
      statementSize: isSet(object.statementSize) ? Long.fromValue(object.statementSize) : Long.ZERO,
      statementSheet: isSet(object.statementSheet) ? globalThis.String(object.statementSheet) : "",
      schema: isSet(object.schema) ? globalThis.String(object.schema) : "",
      schemaSize: isSet(object.schemaSize) ? Long.fromValue(object.schemaSize) : Long.ZERO,
      prevSchema: isSet(object.prevSchema) ? globalThis.String(object.prevSchema) : "",
      prevSchemaSize: isSet(object.prevSchemaSize) ? Long.fromValue(object.prevSchemaSize) : Long.ZERO,
      issue: isSet(object.issue) ? globalThis.String(object.issue) : "",
      taskRun: isSet(object.taskRun) ? globalThis.String(object.taskRun) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      revision: isSet(object.revision) ? globalThis.String(object.revision) : "",
      changedResources: isSet(object.changedResources) ? ChangedResources.fromJSON(object.changedResources) : undefined,
    };
  },

  toJSON(message: Changelog): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.createTime !== undefined) {
      obj.createTime = fromTimestamp(message.createTime).toISOString();
    }
    if (message.status !== Changelog_Status.STATUS_UNSPECIFIED) {
      obj.status = changelog_StatusToJSON(message.status);
    }
    if (message.statement !== "") {
      obj.statement = message.statement;
    }
    if (!message.statementSize.equals(Long.ZERO)) {
      obj.statementSize = (message.statementSize || Long.ZERO).toString();
    }
    if (message.statementSheet !== "") {
      obj.statementSheet = message.statementSheet;
    }
    if (message.schema !== "") {
      obj.schema = message.schema;
    }
    if (!message.schemaSize.equals(Long.ZERO)) {
      obj.schemaSize = (message.schemaSize || Long.ZERO).toString();
    }
    if (message.prevSchema !== "") {
      obj.prevSchema = message.prevSchema;
    }
    if (!message.prevSchemaSize.equals(Long.ZERO)) {
      obj.prevSchemaSize = (message.prevSchemaSize || Long.ZERO).toString();
    }
    if (message.issue !== "") {
      obj.issue = message.issue;
    }
    if (message.taskRun !== "") {
      obj.taskRun = message.taskRun;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.revision !== "") {
      obj.revision = message.revision;
    }
    if (message.changedResources !== undefined) {
      obj.changedResources = ChangedResources.toJSON(message.changedResources);
    }
    return obj;
  },

  create(base?: DeepPartial<Changelog>): Changelog {
    return Changelog.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Changelog>): Changelog {
    const message = createBaseChangelog();
    message.name = object.name ?? "";
    message.creator = object.creator ?? "";
    message.createTime = (object.createTime !== undefined && object.createTime !== null)
      ? Timestamp.fromPartial(object.createTime)
      : undefined;
    message.status = object.status ?? Changelog_Status.STATUS_UNSPECIFIED;
    message.statement = object.statement ?? "";
    message.statementSize = (object.statementSize !== undefined && object.statementSize !== null)
      ? Long.fromValue(object.statementSize)
      : Long.ZERO;
    message.statementSheet = object.statementSheet ?? "";
    message.schema = object.schema ?? "";
    message.schemaSize = (object.schemaSize !== undefined && object.schemaSize !== null)
      ? Long.fromValue(object.schemaSize)
      : Long.ZERO;
    message.prevSchema = object.prevSchema ?? "";
    message.prevSchemaSize = (object.prevSchemaSize !== undefined && object.prevSchemaSize !== null)
      ? Long.fromValue(object.prevSchemaSize)
      : Long.ZERO;
    message.issue = object.issue ?? "";
    message.taskRun = object.taskRun ?? "";
    message.version = object.version ?? "";
    message.revision = object.revision ?? "";
    message.changedResources = (object.changedResources !== undefined && object.changedResources !== null)
      ? ChangedResources.fromPartial(object.changedResources)
      : undefined;
    return message;
  },
};

export type DatabaseServiceDefinition = typeof DatabaseServiceDefinition;
export const DatabaseServiceDefinition = {
  name: "DatabaseService",
  fullName: "bytebase.v1.DatabaseService",
  methods: {
    getDatabase: {
      name: "GetDatabase",
      requestType: GetDatabaseRequest,
      requestStream: false,
      responseType: Database,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [new Uint8Array([4, 110, 97, 109, 101])],
          800010: [new Uint8Array([16, 98, 98, 46, 100, 97, 116, 97, 98, 97, 115, 101, 115, 46, 103, 101, 116])],
          800016: [new Uint8Array([1])],
          578365826: [
            new Uint8Array([
              36,
              18,
              34,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              47,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    listInstanceDatabases: {
      name: "ListInstanceDatabases",
      requestType: ListInstanceDatabasesRequest,
      requestStream: false,
      responseType: ListInstanceDatabasesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [new Uint8Array([0])],
          800010: [new Uint8Array([16, 98, 98, 46, 105, 110, 115, 116, 97, 110, 99, 101, 115, 46, 103, 101, 116])],
          800016: [new Uint8Array([1])],
          578365826: [
            new Uint8Array([
              36,
              18,
              34,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              125,
              47,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
            ]),
          ],
        },
      },
    },
    listDatabases: {
      name: "ListDatabases",
      requestType: ListDatabasesRequest,
      requestStream: false,
      responseType: ListDatabasesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [new Uint8Array([0])],
          800010: [new Uint8Array([17, 98, 98, 46, 100, 97, 116, 97, 98, 97, 115, 101, 115, 46, 108, 105, 115, 116])],
          800016: [new Uint8Array([1])],
          578365826: [
            new Uint8Array([
              74,
              90,
              37,
              18,
              35,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              119,
              111,
              114,
              107,
              115,
              112,
              97,
              99,
              101,
              115,
              47,
              42,
              125,
              47,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
              18,
              33,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
            ]),
          ],
        },
      },
    },
    updateDatabase: {
      name: "UpdateDatabase",
      requestType: UpdateDatabaseRequest,
      requestStream: false,
      responseType: Database,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            new Uint8Array([
              20,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          800010: [
            new Uint8Array([19, 98, 98, 46, 100, 97, 116, 97, 98, 97, 115, 101, 115, 46, 117, 112, 100, 97, 116, 101]),
          ],
          800016: [new Uint8Array([1])],
          800024: [new Uint8Array([1])],
          578365826: [
            new Uint8Array([
              55,
              58,
              8,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              50,
              43,
              47,
              118,
              49,
              47,
              123,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              46,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              47,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    batchUpdateDatabases: {
      name: "BatchUpdateDatabases",
      requestType: BatchUpdateDatabasesRequest,
      requestStream: false,
      responseType: BatchUpdateDatabasesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          800010: [
            new Uint8Array([19, 98, 98, 46, 100, 97, 116, 97, 98, 97, 115, 101, 115, 46, 117, 112, 100, 97, 116, 101]),
          ],
          800016: [new Uint8Array([1])],
          800024: [new Uint8Array([1])],
          578365826: [
            new Uint8Array([
              51,
              58,
              1,
              42,
              34,
              46,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              125,
              47,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
              58,
              98,
              97,
              116,
              99,
              104,
              85,
              112,
              100,
              97,
              116,
              101,
            ]),
          ],
        },
      },
    },
    syncDatabase: {
      name: "SyncDatabase",
      requestType: SyncDatabaseRequest,
      requestStream: false,
      responseType: SyncDatabaseResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          800010: [new Uint8Array([17, 98, 98, 46, 100, 97, 116, 97, 98, 97, 115, 101, 115, 46, 115, 121, 110, 99])],
          800016: [new Uint8Array([1])],
          578365826: [
            new Uint8Array([
              44,
              58,
              1,
              42,
              34,
              39,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              47,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
              47,
              42,
              125,
              58,
              115,
              121,
              110,
              99,
            ]),
          ],
        },
      },
    },
    getDatabaseMetadata: {
      name: "GetDatabaseMetadata",
      requestType: GetDatabaseMetadataRequest,
      requestStream: false,
      responseType: DatabaseMetadata,
      responseStream: false,
      options: {
        _unknownFields: {
          800010: [
            new Uint8Array([
              22,
              98,
              98,
              46,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
              46,
              103,
              101,
              116,
              83,
              99,
              104,
              101,
              109,
              97,
            ]),
          ],
          800016: [new Uint8Array([1])],
          578365826: [
            new Uint8Array([
              45,
              18,
              43,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              47,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
              47,
              42,
              47,
              109,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
              125,
            ]),
          ],
        },
      },
    },
    updateDatabaseMetadata: {
      name: "UpdateDatabaseMetadata",
      requestType: UpdateDatabaseMetadataRequest,
      requestStream: false,
      responseType: DatabaseMetadata,
      responseStream: false,
      options: {
        _unknownFields: {
          800010: [
            new Uint8Array([19, 98, 98, 46, 100, 97, 116, 97, 98, 97, 115, 101, 115, 46, 117, 112, 100, 97, 116, 101]),
          ],
          800016: [new Uint8Array([1])],
          800024: [new Uint8Array([1])],
          578365826: [
            new Uint8Array([
              82,
              58,
              17,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              95,
              109,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
              50,
              61,
              47,
              118,
              49,
              47,
              123,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              95,
              109,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
              46,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              47,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
              47,
              42,
              47,
              109,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
              125,
            ]),
          ],
        },
      },
    },
    getDatabaseSchema: {
      name: "GetDatabaseSchema",
      requestType: GetDatabaseSchemaRequest,
      requestStream: false,
      responseType: DatabaseSchema,
      responseStream: false,
      options: {
        _unknownFields: {
          800010: [
            new Uint8Array([
              22,
              98,
              98,
              46,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
              46,
              103,
              101,
              116,
              83,
              99,
              104,
              101,
              109,
              97,
            ]),
          ],
          800016: [new Uint8Array([1])],
          578365826: [
            new Uint8Array([
              43,
              18,
              41,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              47,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
              47,
              42,
              47,
              115,
              99,
              104,
              101,
              109,
              97,
              125,
            ]),
          ],
        },
      },
    },
    diffSchema: {
      name: "DiffSchema",
      requestType: DiffSchemaRequest,
      requestStream: false,
      responseType: DiffSchemaResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          800010: [new Uint8Array([16, 98, 98, 46, 100, 97, 116, 97, 98, 97, 115, 101, 115, 46, 103, 101, 116])],
          800016: [new Uint8Array([1])],
          578365826: [
            new Uint8Array([
              120,
              58,
              1,
              42,
              90,
              68,
              58,
              1,
              42,
              34,
              63,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              47,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
              47,
              42,
              47,
              99,
              104,
              97,
              110,
              103,
              101,
              72,
              105,
              115,
              116,
              111,
              114,
              105,
              101,
              115,
              47,
              42,
              125,
              58,
              100,
              105,
              102,
              102,
              83,
              99,
              104,
              101,
              109,
              97,
              34,
              45,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              47,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
              47,
              42,
              125,
              58,
              100,
              105,
              102,
              102,
              83,
              99,
              104,
              101,
              109,
              97,
            ]),
          ],
        },
      },
    },
    listSlowQueries: {
      name: "ListSlowQueries",
      requestType: ListSlowQueriesRequest,
      requestStream: false,
      responseType: ListSlowQueriesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [new Uint8Array([6, 112, 97, 114, 101, 110, 116])],
          800010: [
            new Uint8Array([
              19,
              98,
              98,
              46,
              115,
              108,
              111,
              119,
              81,
              117,
              101,
              114,
              105,
              101,
              115,
              46,
              108,
              105,
              115,
              116,
            ]),
          ],
          800016: [new Uint8Array([1])],
          578365826: [
            new Uint8Array([
              37,
              18,
              35,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              115,
              108,
              111,
              119,
              81,
              117,
              101,
              114,
              105,
              101,
              115,
            ]),
          ],
        },
      },
    },
    listSecrets: {
      name: "ListSecrets",
      requestType: ListSecretsRequest,
      requestStream: false,
      responseType: ListSecretsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [new Uint8Array([6, 112, 97, 114, 101, 110, 116])],
          800010: [
            new Uint8Array([
              23,
              98,
              98,
              46,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              83,
              101,
              99,
              114,
              101,
              116,
              115,
              46,
              108,
              105,
              115,
              116,
            ]),
          ],
          800016: [new Uint8Array([1])],
          578365826: [
            new Uint8Array([
              46,
              18,
              44,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              47,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
              47,
              42,
              125,
              47,
              115,
              101,
              99,
              114,
              101,
              116,
              115,
            ]),
          ],
        },
      },
    },
    updateSecret: {
      name: "UpdateSecret",
      requestType: UpdateSecretRequest,
      requestStream: false,
      responseType: Secret,
      responseStream: false,
      options: {
        _unknownFields: {
          800010: [
            new Uint8Array([
              25,
              98,
              98,
              46,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              83,
              101,
              99,
              114,
              101,
              116,
              115,
              46,
              117,
              112,
              100,
              97,
              116,
              101,
            ]),
          ],
          800016: [new Uint8Array([1])],
          800024: [new Uint8Array([1])],
          578365826: [
            new Uint8Array([
              61,
              58,
              6,
              115,
              101,
              99,
              114,
              101,
              116,
              50,
              51,
              47,
              118,
              49,
              47,
              123,
              115,
              101,
              99,
              114,
              101,
              116,
              46,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              47,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
              47,
              42,
              47,
              115,
              101,
              99,
              114,
              101,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    deleteSecret: {
      name: "DeleteSecret",
      requestType: DeleteSecretRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          800010: [
            new Uint8Array([
              25,
              98,
              98,
              46,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              83,
              101,
              99,
              114,
              101,
              116,
              115,
              46,
              100,
              101,
              108,
              101,
              116,
              101,
            ]),
          ],
          800016: [new Uint8Array([1])],
          800024: [new Uint8Array([1])],
          578365826: [
            new Uint8Array([
              46,
              42,
              44,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              47,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
              47,
              42,
              47,
              115,
              101,
              99,
              114,
              101,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    adviseIndex: {
      name: "AdviseIndex",
      requestType: AdviseIndexRequest,
      requestStream: false,
      responseType: AdviseIndexResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [new Uint8Array([6, 112, 97, 114, 101, 110, 116])],
          800010: [
            new Uint8Array([
              24,
              98,
              98,
              46,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
              46,
              97,
              100,
              118,
              105,
              115,
              101,
              73,
              110,
              100,
              101,
              120,
            ]),
          ],
          800016: [new Uint8Array([1])],
          578365826: [
            new Uint8Array([
              50,
              34,
              48,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              47,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
              47,
              42,
              125,
              58,
              97,
              100,
              118,
              105,
              115,
              101,
              73,
              110,
              100,
              101,
              120,
            ]),
          ],
        },
      },
    },
    listChangeHistories: {
      name: "ListChangeHistories",
      requestType: ListChangeHistoriesRequest,
      requestStream: false,
      responseType: ListChangeHistoriesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [new Uint8Array([6, 112, 97, 114, 101, 110, 116])],
          800010: [
            new Uint8Array([
              23,
              98,
              98,
              46,
              99,
              104,
              97,
              110,
              103,
              101,
              72,
              105,
              115,
              116,
              111,
              114,
              105,
              101,
              115,
              46,
              108,
              105,
              115,
              116,
            ]),
          ],
          800016: [new Uint8Array([1])],
          578365826: [
            new Uint8Array([
              54,
              18,
              52,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              47,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
              47,
              42,
              125,
              47,
              99,
              104,
              97,
              110,
              103,
              101,
              72,
              105,
              115,
              116,
              111,
              114,
              105,
              101,
              115,
            ]),
          ],
        },
      },
    },
    getChangeHistory: {
      name: "GetChangeHistory",
      requestType: GetChangeHistoryRequest,
      requestStream: false,
      responseType: ChangeHistory,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [new Uint8Array([4, 110, 97, 109, 101])],
          800010: [
            new Uint8Array([
              22,
              98,
              98,
              46,
              99,
              104,
              97,
              110,
              103,
              101,
              72,
              105,
              115,
              116,
              111,
              114,
              105,
              101,
              115,
              46,
              103,
              101,
              116,
            ]),
          ],
          800016: [new Uint8Array([1])],
          578365826: [
            new Uint8Array([
              54,
              18,
              52,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              47,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
              47,
              42,
              47,
              99,
              104,
              97,
              110,
              103,
              101,
              72,
              105,
              115,
              116,
              111,
              114,
              105,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    listRevisions: {
      name: "ListRevisions",
      requestType: ListRevisionsRequest,
      requestStream: false,
      responseType: ListRevisionsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [new Uint8Array([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            new Uint8Array([
              48,
              18,
              46,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              47,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
              47,
              42,
              125,
              47,
              114,
              101,
              118,
              105,
              115,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    getRevision: {
      name: "GetRevision",
      requestType: GetRevisionRequest,
      requestStream: false,
      responseType: Revision,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [new Uint8Array([4, 110, 97, 109, 101])],
          578365826: [
            new Uint8Array([
              48,
              18,
              46,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              47,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
              47,
              42,
              47,
              114,
              101,
              118,
              105,
              115,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    createRevision: {
      name: "CreateRevision",
      requestType: CreateRevisionRequest,
      requestStream: false,
      responseType: Revision,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            new Uint8Array([
              58,
              58,
              8,
              114,
              101,
              118,
              105,
              115,
              105,
              111,
              110,
              34,
              46,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              47,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
              47,
              42,
              125,
              47,
              114,
              101,
              118,
              105,
              115,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    deleteRevision: {
      name: "DeleteRevision",
      requestType: DeleteRevisionRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [new Uint8Array([4, 110, 97, 109, 101])],
          578365826: [
            new Uint8Array([
              48,
              42,
              46,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              47,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
              47,
              42,
              47,
              114,
              101,
              118,
              105,
              115,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    listChangelogs: {
      name: "ListChangelogs",
      requestType: ListChangelogsRequest,
      requestStream: false,
      responseType: ListChangelogsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [new Uint8Array([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            new Uint8Array([
              49,
              18,
              47,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              47,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
              47,
              42,
              125,
              47,
              99,
              104,
              97,
              110,
              103,
              101,
              108,
              111,
              103,
              115,
            ]),
          ],
        },
      },
    },
    getChangelog: {
      name: "GetChangelog",
      requestType: GetChangelogRequest,
      requestStream: false,
      responseType: Changelog,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [new Uint8Array([4, 110, 97, 109, 101])],
          578365826: [
            new Uint8Array([
              49,
              18,
              47,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              47,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
              47,
              42,
              47,
              99,
              104,
              97,
              110,
              103,
              101,
              108,
              111,
              103,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
  },
} as const;

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Timestamp {
  if (o instanceof globalThis.Date) {
    return toTimestamp(o);
  } else if (typeof o === "string") {
    return toTimestamp(new globalThis.Date(o));
  } else {
    return Timestamp.fromJSON(o);
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
