// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.3.0
//   protoc               unknown
// source: v1/database_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Empty } from "../google/protobuf/empty";
import { FieldMask } from "../google/protobuf/field_mask";
import { Timestamp } from "../google/protobuf/timestamp";
import { Range, State, stateFromJSON, stateToJSON, stateToNumber } from "./common";
import { InstanceResource } from "./instance_service";

export const protobufPackage = "bytebase.v1";

export enum ChangelogView {
  /**
   * CHANGELOG_VIEW_UNSPECIFIED - The default / unset value.
   * The API will default to the BASIC view.
   */
  CHANGELOG_VIEW_UNSPECIFIED = "CHANGELOG_VIEW_UNSPECIFIED",
  CHANGELOG_VIEW_BASIC = "CHANGELOG_VIEW_BASIC",
  CHANGELOG_VIEW_FULL = "CHANGELOG_VIEW_FULL",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function changelogViewFromJSON(object: any): ChangelogView {
  switch (object) {
    case 0:
    case "CHANGELOG_VIEW_UNSPECIFIED":
      return ChangelogView.CHANGELOG_VIEW_UNSPECIFIED;
    case 1:
    case "CHANGELOG_VIEW_BASIC":
      return ChangelogView.CHANGELOG_VIEW_BASIC;
    case 2:
    case "CHANGELOG_VIEW_FULL":
      return ChangelogView.CHANGELOG_VIEW_FULL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ChangelogView.UNRECOGNIZED;
  }
}

export function changelogViewToJSON(object: ChangelogView): string {
  switch (object) {
    case ChangelogView.CHANGELOG_VIEW_UNSPECIFIED:
      return "CHANGELOG_VIEW_UNSPECIFIED";
    case ChangelogView.CHANGELOG_VIEW_BASIC:
      return "CHANGELOG_VIEW_BASIC";
    case ChangelogView.CHANGELOG_VIEW_FULL:
      return "CHANGELOG_VIEW_FULL";
    case ChangelogView.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function changelogViewToNumber(object: ChangelogView): number {
  switch (object) {
    case ChangelogView.CHANGELOG_VIEW_UNSPECIFIED:
      return 0;
    case ChangelogView.CHANGELOG_VIEW_BASIC:
      return 1;
    case ChangelogView.CHANGELOG_VIEW_FULL:
      return 2;
    case ChangelogView.UNRECOGNIZED:
    default:
      return -1;
  }
}

export interface GetDatabaseRequest {
  /**
   * The name of the database to retrieve.
   * Format: instances/{instance}/databases/{database}
   */
  name: string;
}

export interface BatchGetDatabasesRequest {
  /**
   * The parent resource shared by all databases being retrieved.
   * - projects/{project}: batch get databases in a project;
   * - instances/{instances}: batch get databases in a instance;
   * Use "-" as wildcard to batch get databases across parent.
   */
  parent: string;
  /** The list of database names to retrieve. */
  names: string[];
}

export interface BatchGetDatabasesResponse {
  /** The databases from the specified request. */
  databases: Database[];
}

export interface ListDatabasesRequest {
  /**
   * - projects/{project}: list databases in a project, require "bb.projects.get" permission.
   * - workspaces/-: list databases in the workspace, require "bb.databases.list" permission.
   * - instances/{instances}: list databases in a instance, require "bb.instances.get" permission
   */
  parent: string;
  /**
   * The maximum number of databases to return. The service may return fewer
   * than this value.
   * If unspecified, at most 10 databases will be returned.
   * The maximum value is 1000; values above 1000 will be coerced to 1000.
   */
  pageSize: number;
  /**
   * A page token, received from a previous `ListDatabases` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListDatabases` must
   * match the call that provided the page token.
   */
  pageToken: string;
  /**
   * Filter is used to filter databases returned in the list.
   * The syntax and semantics of CEL are documented at https://github.com/google/cel-spec
   *
   * Supported filter:
   * - environment: the environment full name in "environments/{id}" format, support "==" operator.
   * - name: the database name, support ".matches()" operator.
   * - project: the project full name in "projects/{id}" format, support "==" operator.
   * - instance: the instance full name in "instances/{id}" format, support "==" operator.
   * - engine: the database engine, check Engine enum for values. Support "==", "in [xx]", "!(in [xx])" operator.
   * - label: the database label in "{key}:{value1},{value2}" format. Support "==" operator.
   * - exclude_unassigned: should be "true" or "false", will not show unassigned databases if it's true, support "==" operator.
   * - drifted: should be "true" or "false", show drifted databases if it's true, support "==" operator.
   *
   * For example:
   * environment == "environments/{environment resource id}"
   * project == "projects/{project resource id}"
   * instance == "instances/{instance resource id}"
   * name.matches("database name")
   * engine == "MYSQL"
   * engine in ["MYSQL", "POSTGRES"]
   * !(engine in ["MYSQL", "POSTGRES"])
   * label == "region:asia"
   * label == "tenant:asia,europe"
   * label == "region:asia" && label == "tenant:bytebase"
   * exclude_unassigned == true
   * drifted == true
   * You can combine filter conditions like:
   * environment == "environments/prod" && name.matches("employee")
   */
  filter: string;
  /** Show deleted database if specified. */
  showDeleted: boolean;
}

export interface ListDatabasesResponse {
  /** The databases from the specified request. */
  databases: Database[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
}

export interface UpdateDatabaseRequest {
  /**
   * The database to update.
   *
   * The database's `name` field is used to identify the database to update.
   * Format: instances/{instance}/databases/{database}
   */
  database:
    | Database
    | undefined;
  /** The list of fields to update. */
  updateMask: string[] | undefined;
}

export interface BatchUpdateDatabasesRequest {
  /**
   * The parent resource shared by all databases being updated.
   * Format: instances/{instance}
   * If the operation spans parents, a dash (-) may be accepted as a wildcard.
   * We only support updating the project of databases for now.
   */
  parent: string;
  /**
   * The request message specifying the resources to update.
   * A maximum of 1000 databases can be modified in a batch.
   */
  requests: UpdateDatabaseRequest[];
}

export interface BatchUpdateDatabasesResponse {
  /** Databases updated. */
  databases: Database[];
}

export interface BatchSyncDatabasesRequest {
  /**
   * The parent resource shared by all databases being updated.
   * Format: instances/{instance}
   * If the operation spans parents, a dash (-) may be accepted as a wildcard.
   */
  parent: string;
  /** The list of database names to sync. */
  names: string[];
}

export interface BatchSyncDatabasesResponse {
}

export interface SyncDatabaseRequest {
  /**
   * The name of the database to sync.
   * Format: instances/{instance}/databases/{database}
   */
  name: string;
}

export interface SyncDatabaseResponse {
}

export interface GetDatabaseMetadataRequest {
  /**
   * The name of the database to retrieve metadata.
   * Format: instances/{instance}/databases/{database}/metadata
   */
  name: string;
  /**
   * Filter is used to filter databases returned in the list.
   * The syntax and semantics of CEL are documented at https://github.com/google/cel-spec
   *
   * Supported filter:
   * - schema: the schema name, support "==" operator.
   * - table: the table name, support "==" operator.
   *
   * For example:
   * schema == "schema-a"
   * table == "table-a"
   * schema == "schema-a" && table == "table-a"
   * The filter used for a specific schema object such as
   * "schemas/schema-a/tables/table-a".
   * The column masking level will only be returned when a table filter is used.
   */
  filter: string;
}

export interface GetDatabaseSchemaRequest {
  /**
   * The name of the database to retrieve schema.
   * Format: instances/{instance}/databases/{database}/schema
   */
  name: string;
  /** Format the schema dump into SDL format. */
  sdlFormat: boolean;
}

export interface DiffSchemaRequest {
  /**
   * The name of the database or changelog.
   * Format:
   * database: instances/{instance}/databases/{database}
   * changelog: instances/{instance}/databases/{database}/changelogs/{changelog}
   */
  name: string;
  /** The target schema. */
  schema?:
    | string
    | undefined;
  /**
   * The resource name of the changelog
   * Format:
   * instances/{instance}/databases/{database}/changelogs/{changelog}
   */
  changelog?:
    | string
    | undefined;
  /** Format the schema dump into SDL format. */
  sdlFormat: boolean;
}

export interface DiffSchemaResponse {
  diff: string;
}

export interface Database {
  /**
   * The name of the database.
   * Format: instances/{instance}/databases/{database}
   * {database} is the database name in the instance.
   */
  name: string;
  /** The existence of a database. */
  state: State;
  /** The latest synchronization time. */
  successfulSyncTime:
    | Timestamp
    | undefined;
  /**
   * The project for a database.
   * Format: projects/{project}
   */
  project: string;
  /** The version of database schema. */
  schemaVersion: string;
  /**
   * The environment resource.
   * Format: environments/prod where prod is the environment resource ID.
   */
  environment: string;
  /**
   * The effective environment based on environment tag above and environment
   * tag on the instance. Inheritance follows
   * https://cloud.google.com/resource-manager/docs/tags/tags-overview.
   */
  effectiveEnvironment: string;
  /** Labels will be used for deployment and policy control. */
  labels: { [key: string]: string };
  /** The instance resource. */
  instanceResource:
    | InstanceResource
    | undefined;
  /** The database is available for DML prior backup. */
  backupAvailable: boolean;
  /** The schema is drifted from the source of truth. */
  drifted: boolean;
}

export interface Database_LabelsEntry {
  key: string;
  value: string;
}

/** DatabaseMetadata is the metadata for databases. */
export interface DatabaseMetadata {
  /**
   * The database metadata name.
   *
   * Format: instances/{instance}/databases/{database}/metadata
   */
  name: string;
  /** The schemas is the list of schemas in a database. */
  schemas: SchemaMetadata[];
  /** The character_set is the character set of a database. */
  characterSet: string;
  /** The collation is the collation of a database. */
  collation: string;
  /** The extensions is the list of extensions in a database. */
  extensions: ExtensionMetadata[];
  owner: string;
}

/**
 * SchemaMetadata is the metadata for schemas.
 * This is the concept of schema in Postgres, but it's a no-op for MySQL.
 */
export interface SchemaMetadata {
  /**
   * The name is the schema name.
   * It is an empty string for databases without such concept such as MySQL.
   */
  name: string;
  /** The tables is the list of tables in a schema. */
  tables: TableMetadata[];
  /** The external_tables is the list of external tables in a schema. */
  externalTables: ExternalTableMetadata[];
  /** The views is the list of views in a schema. */
  views: ViewMetadata[];
  /** The functions is the list of functions in a schema. */
  functions: FunctionMetadata[];
  /** The procedures is the list of procedures in a schema. */
  procedures: ProcedureMetadata[];
  /**
   * The streams is the list of streams in a schema, currently, only used for
   * Snowflake.
   */
  streams: StreamMetadata[];
  /**
   * The routines is the list of routines in a schema, currently, only used for
   * Snowflake.
   */
  tasks: TaskMetadata[];
  /** The materialized_views is the list of materialized views in a schema. */
  materializedViews: MaterializedViewMetadata[];
  /** The packages is the list of packages in a schema. */
  packages: PackageMetadata[];
  owner: string;
  /** The sequences is the list of sequences in a schema, sorted by name. */
  sequences: SequenceMetadata[];
  events: EventMetadata[];
  enumTypes: EnumTypeMetadata[];
  skipDump: boolean;
}

export interface EnumTypeMetadata {
  /** The name of a type. */
  name: string;
  /** The enum values of a type. */
  values: string[];
  comment: string;
  skipDump: boolean;
}

export interface EventMetadata {
  /** The name of the event. */
  name: string;
  /** The schedule of the event. */
  definition: string;
  /** The time zone of the event. */
  timeZone: string;
  sqlMode: string;
  characterSetClient: string;
  collationConnection: string;
}

export interface SequenceMetadata {
  /** The name of a sequence. */
  name: string;
  /** The data type of a sequence. */
  dataType: string;
  /** The start value of a sequence. */
  start: string;
  /** The minimum value of a sequence. */
  minValue: string;
  /** The maximum value of a sequence. */
  maxValue: string;
  /** Increment value of a sequence. */
  increment: string;
  /** Cycle is whether the sequence cycles. */
  cycle: boolean;
  /** Cache size of a sequence. */
  cacheSize: string;
  /** Last value of a sequence. */
  lastValue: string;
  /** The owner table of the sequence. */
  ownerTable: string;
  /** The owner column of the sequence. */
  ownerColumn: string;
  comment: string;
  skipDump: boolean;
}

export interface TriggerMetadata {
  /** The name is the name of the trigger. */
  name: string;
  /**
   * The event is the event of the trigger, such as INSERT, UPDATE, DELETE,
   * TRUNCATE.
   */
  event: string;
  /** The timing is the timing of the trigger, such as BEFORE, AFTER. */
  timing: string;
  /** The body is the body of the trigger. */
  body: string;
  sqlMode: string;
  characterSetClient: string;
  collationConnection: string;
  comment: string;
  skipDump: boolean;
}

export interface ExternalTableMetadata {
  /** The name is the name of a external table. */
  name: string;
  /** The external_server_name is the name of the external server. */
  externalServerName: string;
  /** The external_database_name is the name of the external database. */
  externalDatabaseName: string;
  /** The columns is the ordered list of columns in a foreign table. */
  columns: ColumnMetadata[];
}

/** TableMetadata is the metadata for tables. */
export interface TableMetadata {
  /** The name is the name of a table. */
  name: string;
  /** The columns is the ordered list of columns in a table. */
  columns: ColumnMetadata[];
  /** The indexes is the list of indexes in a table. */
  indexes: IndexMetadata[];
  /** The engine is the engine of a table. */
  engine: string;
  /** The collation is the collation of a table. */
  collation: string;
  /** The character set of table. */
  charset: string;
  /** The row_count is the estimated number of rows of a table. */
  rowCount: Long;
  /** The data_size is the estimated data size of a table. */
  dataSize: Long;
  /** The index_size is the estimated index size of a table. */
  indexSize: Long;
  /** The data_free is the estimated free data size of a table. */
  dataFree: Long;
  /** The create_options is the create option of a table. */
  createOptions: string;
  /**
   * The comment is the comment of a table.
   * classification and user_comment is parsed from the comment.
   */
  comment: string;
  /** The user_comment is the user comment of a table parsed from the comment. */
  userComment: string;
  /** The foreign_keys is the list of foreign keys in a table. */
  foreignKeys: ForeignKeyMetadata[];
  /** The partitions is the list of partitions in a table. */
  partitions: TablePartitionMetadata[];
  /** The check_constraints is the list of check constraints in a table. */
  checkConstraints: CheckConstraintMetadata[];
  owner: string;
  /**
   * The sorting_keys is a tuple of column names or arbitrary expressions. ClickHouse specific field.
   * Reference: https://clickhouse.com/docs/en/engines/table-engines/mergetree-family/mergetree#order_by
   */
  sortingKeys: string[];
  triggers: TriggerMetadata[];
  skipDump: boolean;
  /** https://docs.pingcap.com/tidb/stable/information-schema-tables/ */
  shardingInfo: string;
  /**
   * https://docs.pingcap.com/tidb/stable/clustered-indexes/#clustered-indexes
   * CLUSTERED or NONCLUSTERED.
   */
  primaryKeyType: string;
}

/** CheckConstraintMetadata is the metadata for check constraints. */
export interface CheckConstraintMetadata {
  /** The name is the name of a check constraint. */
  name: string;
  /** The expression is the expression of a check constraint. */
  expression: string;
}

/** TablePartitionMetadata is the metadata for table partitions. */
export interface TablePartitionMetadata {
  /** The name is the name of a table partition. */
  name: string;
  /** The type of a table partition. */
  type: TablePartitionMetadata_Type;
  /**
   * The expression is the expression of a table partition.
   * For PostgreSQL, the expression is the text of {FOR VALUES
   * partition_bound_spec}, see
   * https://www.postgresql.org/docs/current/sql-createtable.html. For MySQL,
   * the expression is the `expr` or `column_list` of the following syntax.
   * PARTITION BY
   *    { [LINEAR] HASH(expr)
   *    | [LINEAR] KEY [ALGORITHM={1 | 2}] (column_list)
   *    | RANGE{(expr) | COLUMNS(column_list)}
   *    | LIST{(expr) | COLUMNS(column_list)} }.
   */
  expression: string;
  /**
   * The value is the value of a table partition.
   * For MySQL, the value is for RANGE and LIST partition types,
   * - For a RANGE partition, it contains the value set in the partition's
   * VALUES LESS THAN clause, which can be either an integer or MAXVALUE.
   * - For a LIST partition, this column contains the values defined in the
   * partition's VALUES IN clause, which is a list of comma-separated integer
   * values.
   * - For others, it's an empty string.
   */
  value: string;
  /**
   * The use_default is whether the users use the default partition, it stores
   * the different value for different database engines. For MySQL, it's [INT]
   * type, 0 means not use default partition, otherwise, it's equals to number
   * in syntax [SUB]PARTITION {number}.
   */
  useDefault: string;
  /** The subpartitions is the list of subpartitions in a table partition. */
  subpartitions: TablePartitionMetadata[];
  indexes: IndexMetadata[];
  checkConstraints: CheckConstraintMetadata[];
}

/**
 * Type is the type of a table partition, some database engines may not
 * support all types. Only avilable for the following database engines now:
 * MySQL: RANGE, RANGE COLUMNS, LIST, LIST COLUMNS, HASH, LINEAR HASH, KEY,
 * LINEAR_KEY
 * (https://dev.mysql.com/doc/refman/8.0/en/partitioning-types.html) TiDB:
 * RANGE, RANGE COLUMNS, LIST, LIST COLUMNS, HASH, KEY PostgreSQL: RANGE,
 * LIST, HASH (https://www.postgresql.org/docs/current/ddl-partitioning.html)
 */
export enum TablePartitionMetadata_Type {
  TYPE_UNSPECIFIED = "TYPE_UNSPECIFIED",
  RANGE = "RANGE",
  RANGE_COLUMNS = "RANGE_COLUMNS",
  LIST = "LIST",
  LIST_COLUMNS = "LIST_COLUMNS",
  HASH = "HASH",
  LINEAR_HASH = "LINEAR_HASH",
  KEY = "KEY",
  LINEAR_KEY = "LINEAR_KEY",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function tablePartitionMetadata_TypeFromJSON(object: any): TablePartitionMetadata_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return TablePartitionMetadata_Type.TYPE_UNSPECIFIED;
    case 1:
    case "RANGE":
      return TablePartitionMetadata_Type.RANGE;
    case 2:
    case "RANGE_COLUMNS":
      return TablePartitionMetadata_Type.RANGE_COLUMNS;
    case 3:
    case "LIST":
      return TablePartitionMetadata_Type.LIST;
    case 4:
    case "LIST_COLUMNS":
      return TablePartitionMetadata_Type.LIST_COLUMNS;
    case 5:
    case "HASH":
      return TablePartitionMetadata_Type.HASH;
    case 6:
    case "LINEAR_HASH":
      return TablePartitionMetadata_Type.LINEAR_HASH;
    case 7:
    case "KEY":
      return TablePartitionMetadata_Type.KEY;
    case 8:
    case "LINEAR_KEY":
      return TablePartitionMetadata_Type.LINEAR_KEY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TablePartitionMetadata_Type.UNRECOGNIZED;
  }
}

export function tablePartitionMetadata_TypeToJSON(object: TablePartitionMetadata_Type): string {
  switch (object) {
    case TablePartitionMetadata_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case TablePartitionMetadata_Type.RANGE:
      return "RANGE";
    case TablePartitionMetadata_Type.RANGE_COLUMNS:
      return "RANGE_COLUMNS";
    case TablePartitionMetadata_Type.LIST:
      return "LIST";
    case TablePartitionMetadata_Type.LIST_COLUMNS:
      return "LIST_COLUMNS";
    case TablePartitionMetadata_Type.HASH:
      return "HASH";
    case TablePartitionMetadata_Type.LINEAR_HASH:
      return "LINEAR_HASH";
    case TablePartitionMetadata_Type.KEY:
      return "KEY";
    case TablePartitionMetadata_Type.LINEAR_KEY:
      return "LINEAR_KEY";
    case TablePartitionMetadata_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function tablePartitionMetadata_TypeToNumber(object: TablePartitionMetadata_Type): number {
  switch (object) {
    case TablePartitionMetadata_Type.TYPE_UNSPECIFIED:
      return 0;
    case TablePartitionMetadata_Type.RANGE:
      return 1;
    case TablePartitionMetadata_Type.RANGE_COLUMNS:
      return 2;
    case TablePartitionMetadata_Type.LIST:
      return 3;
    case TablePartitionMetadata_Type.LIST_COLUMNS:
      return 4;
    case TablePartitionMetadata_Type.HASH:
      return 5;
    case TablePartitionMetadata_Type.LINEAR_HASH:
      return 6;
    case TablePartitionMetadata_Type.KEY:
      return 7;
    case TablePartitionMetadata_Type.LINEAR_KEY:
      return 8;
    case TablePartitionMetadata_Type.UNRECOGNIZED:
    default:
      return -1;
  }
}

/** ColumnMetadata is the metadata for columns. */
export interface ColumnMetadata {
  /** The name is the name of a column. */
  name: string;
  /** The position is the position in columns. */
  position: number;
  hasDefault: boolean;
  defaultNull?: boolean | undefined;
  defaultString?: string | undefined;
  defaultExpression?:
    | string
    | undefined;
  /**
   * Oracle specific metadata.
   * The default_on_null is the default on null of a column.
   */
  defaultOnNull: boolean;
  /**
   * The on_update is the on update action of a column.
   * For MySQL like databases, it's only supported for TIMESTAMP columns with
   * CURRENT_TIMESTAMP as on update value.
   */
  onUpdate: string;
  /** The nullable is the nullable of a column. */
  nullable: boolean;
  /** The type is the type of a column. */
  type: string;
  /** The character_set is the character_set of a column. */
  characterSet: string;
  /** The collation is the collation of a column. */
  collation: string;
  /**
   * The comment is the comment of a column.
   * classification and user_comment is parsed from the comment.
   */
  comment: string;
  /** The user_comment is the user comment of a column parsed from the comment. */
  userComment: string;
  /** The generation is the generation of a column. */
  generation: GenerationMetadata | undefined;
  isIdentity: boolean;
  /** The identity_generation is for identity columns, PG only. */
  identityGeneration: ColumnMetadata_IdentityGeneration;
  /** The identity_seed is for identity columns, MSSQL only. */
  identitySeed: Long;
  /** The identity_increment is for identity columns, MSSQL only. */
  identityIncrement: Long;
}

export enum ColumnMetadata_IdentityGeneration {
  IDENTITY_GENERATION_UNSPECIFIED = "IDENTITY_GENERATION_UNSPECIFIED",
  ALWAYS = "ALWAYS",
  BY_DEFAULT = "BY_DEFAULT",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function columnMetadata_IdentityGenerationFromJSON(object: any): ColumnMetadata_IdentityGeneration {
  switch (object) {
    case 0:
    case "IDENTITY_GENERATION_UNSPECIFIED":
      return ColumnMetadata_IdentityGeneration.IDENTITY_GENERATION_UNSPECIFIED;
    case 1:
    case "ALWAYS":
      return ColumnMetadata_IdentityGeneration.ALWAYS;
    case 2:
    case "BY_DEFAULT":
      return ColumnMetadata_IdentityGeneration.BY_DEFAULT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ColumnMetadata_IdentityGeneration.UNRECOGNIZED;
  }
}

export function columnMetadata_IdentityGenerationToJSON(object: ColumnMetadata_IdentityGeneration): string {
  switch (object) {
    case ColumnMetadata_IdentityGeneration.IDENTITY_GENERATION_UNSPECIFIED:
      return "IDENTITY_GENERATION_UNSPECIFIED";
    case ColumnMetadata_IdentityGeneration.ALWAYS:
      return "ALWAYS";
    case ColumnMetadata_IdentityGeneration.BY_DEFAULT:
      return "BY_DEFAULT";
    case ColumnMetadata_IdentityGeneration.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function columnMetadata_IdentityGenerationToNumber(object: ColumnMetadata_IdentityGeneration): number {
  switch (object) {
    case ColumnMetadata_IdentityGeneration.IDENTITY_GENERATION_UNSPECIFIED:
      return 0;
    case ColumnMetadata_IdentityGeneration.ALWAYS:
      return 1;
    case ColumnMetadata_IdentityGeneration.BY_DEFAULT:
      return 2;
    case ColumnMetadata_IdentityGeneration.UNRECOGNIZED:
    default:
      return -1;
  }
}

export interface GenerationMetadata {
  type: GenerationMetadata_Type;
  expression: string;
}

export enum GenerationMetadata_Type {
  TYPE_UNSPECIFIED = "TYPE_UNSPECIFIED",
  TYPE_VIRTUAL = "TYPE_VIRTUAL",
  TYPE_STORED = "TYPE_STORED",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function generationMetadata_TypeFromJSON(object: any): GenerationMetadata_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return GenerationMetadata_Type.TYPE_UNSPECIFIED;
    case 1:
    case "TYPE_VIRTUAL":
      return GenerationMetadata_Type.TYPE_VIRTUAL;
    case 2:
    case "TYPE_STORED":
      return GenerationMetadata_Type.TYPE_STORED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GenerationMetadata_Type.UNRECOGNIZED;
  }
}

export function generationMetadata_TypeToJSON(object: GenerationMetadata_Type): string {
  switch (object) {
    case GenerationMetadata_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case GenerationMetadata_Type.TYPE_VIRTUAL:
      return "TYPE_VIRTUAL";
    case GenerationMetadata_Type.TYPE_STORED:
      return "TYPE_STORED";
    case GenerationMetadata_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function generationMetadata_TypeToNumber(object: GenerationMetadata_Type): number {
  switch (object) {
    case GenerationMetadata_Type.TYPE_UNSPECIFIED:
      return 0;
    case GenerationMetadata_Type.TYPE_VIRTUAL:
      return 1;
    case GenerationMetadata_Type.TYPE_STORED:
      return 2;
    case GenerationMetadata_Type.UNRECOGNIZED:
    default:
      return -1;
  }
}

/** ViewMetadata is the metadata for views. */
export interface ViewMetadata {
  /** The name is the name of a view. */
  name: string;
  /** The definition is the definition of a view. */
  definition: string;
  /** The comment is the comment of a view. */
  comment: string;
  /** The dependency_columns is the list of dependency columns of a view. */
  dependencyColumns: DependencyColumn[];
  /** The columns is the ordered list of columns in a table. */
  columns: ColumnMetadata[];
  /** The triggers is the list of triggers in a view. */
  triggers: TriggerMetadata[];
  skipDump: boolean;
}

/** DependencyColumn is the metadata for dependency columns. */
export interface DependencyColumn {
  /** The schema is the schema of a reference column. */
  schema: string;
  /** The table is the table of a reference column. */
  table: string;
  /** The column is the name of a reference column. */
  column: string;
}

/** MaterializedViewMetadata is the metadata for materialized views. */
export interface MaterializedViewMetadata {
  /** The name is the name of a materialized view. */
  name: string;
  /** The definition is the definition of a materialized view. */
  definition: string;
  /** The comment is the comment of a materialized view. */
  comment: string;
  /**
   * The dependency_columns is the list of dependency columns of a materialized
   * view.
   */
  dependencyColumns: DependencyColumn[];
  /** The columns is the ordered list of columns in a table. */
  triggers: TriggerMetadata[];
  /** The indexes is the list of indexes in a table. */
  indexes: IndexMetadata[];
  skipDump: boolean;
}

export interface DependencyTable {
  /** The schema is the schema of a reference table. */
  schema: string;
  /** The table is the name of a reference table. */
  table: string;
}

/** FunctionMetadata is the metadata for functions. */
export interface FunctionMetadata {
  /** The name is the name of a function. */
  name: string;
  /** The definition is the definition of a function. */
  definition: string;
  /**
   * The signature is the name with the number and type of input arguments the
   * function takes.
   */
  signature: string;
  /** MySQL specific metadata. */
  characterSetClient: string;
  collationConnection: string;
  databaseCollation: string;
  sqlMode: string;
  comment: string;
  /**
   * The dependency_tables is the list of dependency tables of a function.
   * For PostgreSQL, it's the list of tables that the function depends on the return type definition.
   */
  dependencyTables: DependencyTable[];
  skipDump: boolean;
}

/** ProcedureMetadata is the metadata for procedures. */
export interface ProcedureMetadata {
  /** The name is the name of a procedure. */
  name: string;
  /** The definition is the definition of a procedure. */
  definition: string;
  /**
   * The signature is the name with the number and type of input arguments the
   * function takes.
   */
  signature: string;
  /** MySQL specific metadata. */
  characterSetClient: string;
  collationConnection: string;
  databaseCollation: string;
  sqlMode: string;
  skipDump: boolean;
}

/** PackageMetadata is the metadata for packages. */
export interface PackageMetadata {
  /** The name is the name of a package. */
  name: string;
  /** The definition is the definition of a package. */
  definition: string;
}

export interface TaskMetadata {
  /** The name is the name of a task. */
  name: string;
  /**
   * The id is the snowflake-generated id of a task.
   * Example: 01ad32a0-1bb6-5e93-0000-000000000001
   */
  id: string;
  /** The owner of the task. */
  owner: string;
  /** The comment of the task. */
  comment: string;
  /** The warehouse of the task. */
  warehouse: string;
  /** The schedule interval of the task. */
  schedule: string;
  /** The predecessor tasks of the task. */
  predecessors: string[];
  /** The state of the task. */
  state: TaskMetadata_State;
  /** The condition of the task. */
  condition: string;
  /** The definition of the task. */
  definition: string;
}

export enum TaskMetadata_State {
  STATE_UNSPECIFIED = "STATE_UNSPECIFIED",
  STATE_STARTED = "STATE_STARTED",
  STATE_SUSPENDED = "STATE_SUSPENDED",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function taskMetadata_StateFromJSON(object: any): TaskMetadata_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return TaskMetadata_State.STATE_UNSPECIFIED;
    case 1:
    case "STATE_STARTED":
      return TaskMetadata_State.STATE_STARTED;
    case 2:
    case "STATE_SUSPENDED":
      return TaskMetadata_State.STATE_SUSPENDED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TaskMetadata_State.UNRECOGNIZED;
  }
}

export function taskMetadata_StateToJSON(object: TaskMetadata_State): string {
  switch (object) {
    case TaskMetadata_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case TaskMetadata_State.STATE_STARTED:
      return "STATE_STARTED";
    case TaskMetadata_State.STATE_SUSPENDED:
      return "STATE_SUSPENDED";
    case TaskMetadata_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function taskMetadata_StateToNumber(object: TaskMetadata_State): number {
  switch (object) {
    case TaskMetadata_State.STATE_UNSPECIFIED:
      return 0;
    case TaskMetadata_State.STATE_STARTED:
      return 1;
    case TaskMetadata_State.STATE_SUSPENDED:
      return 2;
    case TaskMetadata_State.UNRECOGNIZED:
    default:
      return -1;
  }
}

export interface StreamMetadata {
  /** The name is the name of a stream. */
  name: string;
  /** The table_name is the name of the table/view that the stream is created on. */
  tableName: string;
  /** The owner of the stream. */
  owner: string;
  /** The comment of the stream. */
  comment: string;
  /** The type of the stream. */
  type: StreamMetadata_Type;
  /** Indicates whether the stream was last read before the `stale_after` time. */
  stale: boolean;
  /** The mode of the stream. */
  mode: StreamMetadata_Mode;
  /** The definition of the stream. */
  definition: string;
}

export enum StreamMetadata_Type {
  TYPE_UNSPECIFIED = "TYPE_UNSPECIFIED",
  TYPE_DELTA = "TYPE_DELTA",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function streamMetadata_TypeFromJSON(object: any): StreamMetadata_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return StreamMetadata_Type.TYPE_UNSPECIFIED;
    case 1:
    case "TYPE_DELTA":
      return StreamMetadata_Type.TYPE_DELTA;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StreamMetadata_Type.UNRECOGNIZED;
  }
}

export function streamMetadata_TypeToJSON(object: StreamMetadata_Type): string {
  switch (object) {
    case StreamMetadata_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case StreamMetadata_Type.TYPE_DELTA:
      return "TYPE_DELTA";
    case StreamMetadata_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function streamMetadata_TypeToNumber(object: StreamMetadata_Type): number {
  switch (object) {
    case StreamMetadata_Type.TYPE_UNSPECIFIED:
      return 0;
    case StreamMetadata_Type.TYPE_DELTA:
      return 1;
    case StreamMetadata_Type.UNRECOGNIZED:
    default:
      return -1;
  }
}

export enum StreamMetadata_Mode {
  MODE_UNSPECIFIED = "MODE_UNSPECIFIED",
  MODE_DEFAULT = "MODE_DEFAULT",
  MODE_APPEND_ONLY = "MODE_APPEND_ONLY",
  MODE_INSERT_ONLY = "MODE_INSERT_ONLY",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function streamMetadata_ModeFromJSON(object: any): StreamMetadata_Mode {
  switch (object) {
    case 0:
    case "MODE_UNSPECIFIED":
      return StreamMetadata_Mode.MODE_UNSPECIFIED;
    case 1:
    case "MODE_DEFAULT":
      return StreamMetadata_Mode.MODE_DEFAULT;
    case 2:
    case "MODE_APPEND_ONLY":
      return StreamMetadata_Mode.MODE_APPEND_ONLY;
    case 3:
    case "MODE_INSERT_ONLY":
      return StreamMetadata_Mode.MODE_INSERT_ONLY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StreamMetadata_Mode.UNRECOGNIZED;
  }
}

export function streamMetadata_ModeToJSON(object: StreamMetadata_Mode): string {
  switch (object) {
    case StreamMetadata_Mode.MODE_UNSPECIFIED:
      return "MODE_UNSPECIFIED";
    case StreamMetadata_Mode.MODE_DEFAULT:
      return "MODE_DEFAULT";
    case StreamMetadata_Mode.MODE_APPEND_ONLY:
      return "MODE_APPEND_ONLY";
    case StreamMetadata_Mode.MODE_INSERT_ONLY:
      return "MODE_INSERT_ONLY";
    case StreamMetadata_Mode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function streamMetadata_ModeToNumber(object: StreamMetadata_Mode): number {
  switch (object) {
    case StreamMetadata_Mode.MODE_UNSPECIFIED:
      return 0;
    case StreamMetadata_Mode.MODE_DEFAULT:
      return 1;
    case StreamMetadata_Mode.MODE_APPEND_ONLY:
      return 2;
    case StreamMetadata_Mode.MODE_INSERT_ONLY:
      return 3;
    case StreamMetadata_Mode.UNRECOGNIZED:
    default:
      return -1;
  }
}

/** IndexMetadata is the metadata for indexes. */
export interface IndexMetadata {
  /** The name is the name of an index. */
  name: string;
  /**
   * The expressions are the ordered columns or expressions of an index.
   * This could refer to a column or an expression.
   */
  expressions: string[];
  /**
   * The key_lengths are the ordered key lengths of an index.
   * If the key length is not specified, it's -1.
   */
  keyLength: Long[];
  /** The descending is the ordered descending of an index. */
  descending: boolean[];
  /** The type is the type of an index. */
  type: string;
  /** The unique is whether the index is unique. */
  unique: boolean;
  /** The primary is whether the index is a primary key index. */
  primary: boolean;
  /** The visible is whether the index is visible. */
  visible: boolean;
  /** The comment is the comment of an index. */
  comment: string;
  /** The definition of an index. */
  definition: string;
  /** The schema name of the parent index. */
  parentIndexSchema: string;
  /** The index name of the parent index. */
  parentIndexName: string;
  /** The number of granules in the block. It's a ClickHouse specific field. */
  granularity: Long;
  /**
   * It's a PostgreSQL specific field.
   * The unique constraint and unique index are not the same thing in PostgreSQL.
   */
  isConstraint: boolean;
}

/** ExtensionMetadata is the metadata for extensions. */
export interface ExtensionMetadata {
  /** The name is the name of an extension. */
  name: string;
  /**
   * The schema is the extension that is installed to. But the extension usage
   * is not limited to the schema.
   */
  schema: string;
  /** The version is the version of an extension. */
  version: string;
  /** The description is the description of an extension. */
  description: string;
}

/** ForeignKeyMetadata is the metadata for foreign keys. */
export interface ForeignKeyMetadata {
  /** The name is the name of a foreign key. */
  name: string;
  /** The columns are the ordered referencing columns of a foreign key. */
  columns: string[];
  /**
   * The referenced_schema is the referenced schema name of a foreign key.
   * It is an empty string for databases without such concept such as MySQL.
   */
  referencedSchema: string;
  /** The referenced_table is the referenced table name of a foreign key. */
  referencedTable: string;
  /** The referenced_columns are the ordered referenced columns of a foreign key. */
  referencedColumns: string[];
  /** The on_delete is the on delete action of a foreign key. */
  onDelete: string;
  /** The on_update is the on update action of a foreign key. */
  onUpdate: string;
  /**
   * The match_type is the match type of a foreign key.
   * The match_type is the PostgreSQL specific field.
   * It's empty string for other databases.
   */
  matchType: string;
}

/** DatabaseSchema is the metadata for databases. */
export interface DatabaseSchema {
  /** The schema dump from database. */
  schema: string;
}

export interface ListSecretsRequest {
  /**
   * The parent of the secret.
   * Format: instances/{instance}/databases/{database}
   */
  parent: string;
  /**
   * Not used.
   * The maximum number of secrets to return. The service may return fewer than
   * this value.
   * If unspecified, at most 10 secrets will be returned.
   * The maximum value is 1000; values above 1000 will be coerced to 1000.
   */
  pageSize: number;
  /**
   * Not used.
   * A page token, received from a previous `ListSecrets` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListSecrets` must match
   * the call that provided the page token.
   */
  pageToken: string;
}

export interface ListSecretsResponse {
  /** The list of secrets. */
  secrets: Secret[];
  /**
   * Not used. A token, which can be sent as `page_token` to retrieve the next
   * page. If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
}

export interface UpdateSecretRequest {
  /** The secret to be created or updated. */
  secret:
    | Secret
    | undefined;
  /** The mask of the fields to be updated. */
  updateMask:
    | string[]
    | undefined;
  /** If true, the secret will be created if it does not exist. */
  allowMissing: boolean;
}

export interface DeleteSecretRequest {
  /**
   * The name of the secret to be deleted.
   * Format:
   * instances/{instance}/databases/{database}/secrets/{secret}
   */
  name: string;
}

/** Secret is the secret of the database now. */
export interface Secret {
  /**
   * name is the unique name of the secret, which is specified by the client.
   * Format:
   * instances/{instance}/databases/{database}/secrets/{secret}
   */
  name: string;
  /** Not used. The timestamp when the secret resource was created initially. */
  createdTime:
    | Timestamp
    | undefined;
  /** Not used. The timestamp when the secret resource was updated. */
  updatedTime:
    | Timestamp
    | undefined;
  /** The value of the secret. */
  value: string;
  /** The description of the secret. */
  description: string;
}

export interface ChangedResources {
  databases: ChangedResourceDatabase[];
}

export interface ChangedResourceDatabase {
  name: string;
  schemas: ChangedResourceSchema[];
}

export interface ChangedResourceSchema {
  name: string;
  tables: ChangedResourceTable[];
  views: ChangedResourceView[];
  functions: ChangedResourceFunction[];
  procedures: ChangedResourceProcedure[];
}

export interface ChangedResourceTable {
  name: string;
  /** The ranges of sub-strings correspond to the statements on the sheet. */
  ranges: Range[];
}

export interface ChangedResourceView {
  name: string;
  /** The ranges of sub-strings correspond to the statements on the sheet. */
  ranges: Range[];
}

export interface ChangedResourceFunction {
  name: string;
  /** The ranges of sub-strings correspond to the statements on the sheet. */
  ranges: Range[];
}

export interface ChangedResourceProcedure {
  name: string;
  /** The ranges of sub-strings correspond to the statements on the sheet. */
  ranges: Range[];
}

export interface ListChangelogsRequest {
  /**
   * The parent of the changelogs.
   * Format: instances/{instance}/databases/{database}
   */
  parent: string;
  /**
   * The maximum number of changelogs to return. The service may return fewer
   * than this value. If unspecified, at most 10 changelogs will be returned.
   * The maximum value is 1000; values above 1000 will be coerced to 1000.
   */
  pageSize: number;
  /**
   * A page token, received from the previous call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided must match
   * the call that provided the page token.
   */
  pageToken: string;
  view: ChangelogView;
  /**
   * The filter of the changelogs.
   * follow the
   * [ebnf](https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form)
   * syntax. Support filter by type, source or table. For example: table =
   * "tableExists('{database}', '{schema}', '{table}')" table =
   * "tableExists('db', 'public', 'table1') || tableExists('db', 'public',
   * 'table2')"
   *
   * The table filter follow the CEL syntax.
   * currently, we have one function for CEL:
   * - tableExists(database, schema, table): return true if the table exists in
   * changed resources.
   *
   * examples:
   * Use
   *   tableExists("db", "public", "table1")
   * to filter the changelogs which have the table "table1" in the schema
   * "public" of the database "db". For MySQL, the schema is always "", such as
   * tableExists("db", "", "table1").
   *
   * Combine multiple functions with "&&" and "||", we MUST use the Disjunctive
   * Normal Form(DNF). In other words, the CEL expression consists of several
   * parts connected by OR operators. For example, the following expression is
   * valid:
   * (
   *  tableExists("db", "public", "table1") &&
   *  tableExists("db", "public", "table2")
   * ) || (
   *  tableExists("db", "public", "table3")
   * )
   */
  filter: string;
}

export interface ListChangelogsResponse {
  /** The list of changelogs. */
  changelogs: Changelog[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
}

export interface GetChangelogRequest {
  /**
   * The name of the changelog to retrieve.
   * Format: instances/{instance}/databases/{database}/changelogs/{changelog}
   */
  name: string;
  view: ChangelogView;
  /** Format the schema dump into SDL format. */
  sdlFormat: boolean;
}

export interface Changelog {
  /** Format: instances/{instance}/databases/{database}/changelogs/{changelog} */
  name: string;
  createTime: Timestamp | undefined;
  status: Changelog_Status;
  /** The statement is used for preview purpose. */
  statement: string;
  statementSize: Long;
  /**
   * The name of the sheet resource.
   * Format: projects/{project}/sheets/{sheet}
   */
  statementSheet: string;
  schema: string;
  schemaSize: Long;
  prevSchema: string;
  prevSchemaSize: Long;
  /** Format: projects/{project}/issues/{issue} */
  issue: string;
  /** Format: projects/{projects}/rollouts/{rollout}/stages/{stage}/tasks/{task}/taskRuns/{taskRun} */
  taskRun: string;
  /** Could be empty */
  version: string;
  /**
   * Could be empty
   * Or present but not found if deleted
   */
  revision: string;
  changedResources: ChangedResources | undefined;
  type: Changelog_Type;
}

export enum Changelog_Status {
  STATUS_UNSPECIFIED = "STATUS_UNSPECIFIED",
  PENDING = "PENDING",
  DONE = "DONE",
  FAILED = "FAILED",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function changelog_StatusFromJSON(object: any): Changelog_Status {
  switch (object) {
    case 0:
    case "STATUS_UNSPECIFIED":
      return Changelog_Status.STATUS_UNSPECIFIED;
    case 1:
    case "PENDING":
      return Changelog_Status.PENDING;
    case 2:
    case "DONE":
      return Changelog_Status.DONE;
    case 3:
    case "FAILED":
      return Changelog_Status.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Changelog_Status.UNRECOGNIZED;
  }
}

export function changelog_StatusToJSON(object: Changelog_Status): string {
  switch (object) {
    case Changelog_Status.STATUS_UNSPECIFIED:
      return "STATUS_UNSPECIFIED";
    case Changelog_Status.PENDING:
      return "PENDING";
    case Changelog_Status.DONE:
      return "DONE";
    case Changelog_Status.FAILED:
      return "FAILED";
    case Changelog_Status.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function changelog_StatusToNumber(object: Changelog_Status): number {
  switch (object) {
    case Changelog_Status.STATUS_UNSPECIFIED:
      return 0;
    case Changelog_Status.PENDING:
      return 1;
    case Changelog_Status.DONE:
      return 2;
    case Changelog_Status.FAILED:
      return 3;
    case Changelog_Status.UNRECOGNIZED:
    default:
      return -1;
  }
}

export enum Changelog_Type {
  TYPE_UNSPECIFIED = "TYPE_UNSPECIFIED",
  BASELINE = "BASELINE",
  MIGRATE = "MIGRATE",
  MIGRATE_SDL = "MIGRATE_SDL",
  MIGRATE_GHOST = "MIGRATE_GHOST",
  DATA = "DATA",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function changelog_TypeFromJSON(object: any): Changelog_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return Changelog_Type.TYPE_UNSPECIFIED;
    case 1:
    case "BASELINE":
      return Changelog_Type.BASELINE;
    case 2:
    case "MIGRATE":
      return Changelog_Type.MIGRATE;
    case 3:
    case "MIGRATE_SDL":
      return Changelog_Type.MIGRATE_SDL;
    case 4:
    case "MIGRATE_GHOST":
      return Changelog_Type.MIGRATE_GHOST;
    case 6:
    case "DATA":
      return Changelog_Type.DATA;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Changelog_Type.UNRECOGNIZED;
  }
}

export function changelog_TypeToJSON(object: Changelog_Type): string {
  switch (object) {
    case Changelog_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case Changelog_Type.BASELINE:
      return "BASELINE";
    case Changelog_Type.MIGRATE:
      return "MIGRATE";
    case Changelog_Type.MIGRATE_SDL:
      return "MIGRATE_SDL";
    case Changelog_Type.MIGRATE_GHOST:
      return "MIGRATE_GHOST";
    case Changelog_Type.DATA:
      return "DATA";
    case Changelog_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function changelog_TypeToNumber(object: Changelog_Type): number {
  switch (object) {
    case Changelog_Type.TYPE_UNSPECIFIED:
      return 0;
    case Changelog_Type.BASELINE:
      return 1;
    case Changelog_Type.MIGRATE:
      return 2;
    case Changelog_Type.MIGRATE_SDL:
      return 3;
    case Changelog_Type.MIGRATE_GHOST:
      return 4;
    case Changelog_Type.DATA:
      return 6;
    case Changelog_Type.UNRECOGNIZED:
    default:
      return -1;
  }
}

export interface GetSchemaStringRequest {
  /**
   * The name of the database.
   * Format: instances/{instance}/databases/{database}
   */
  name: string;
  type: GetSchemaStringRequest_ObjectType;
  /** It's empty for DATABASE. */
  schema: string;
  /** It's empty for DATABASE and SCHEMA. */
  object: string;
  /**
   * If use the metadata to generate the schema string, the type is OBJECT_TYPE_UNSPECIFIED.
   * Also the schema and object are empty.
   */
  metadata: DatabaseMetadata | undefined;
}

export enum GetSchemaStringRequest_ObjectType {
  OBJECT_TYPE_UNSPECIFIED = "OBJECT_TYPE_UNSPECIFIED",
  DATABASE = "DATABASE",
  SCHEMA = "SCHEMA",
  TABLE = "TABLE",
  VIEW = "VIEW",
  MATERIALIZED_VIEW = "MATERIALIZED_VIEW",
  FUNCTION = "FUNCTION",
  PROCEDURE = "PROCEDURE",
  SEQUENCE = "SEQUENCE",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function getSchemaStringRequest_ObjectTypeFromJSON(object: any): GetSchemaStringRequest_ObjectType {
  switch (object) {
    case 0:
    case "OBJECT_TYPE_UNSPECIFIED":
      return GetSchemaStringRequest_ObjectType.OBJECT_TYPE_UNSPECIFIED;
    case 1:
    case "DATABASE":
      return GetSchemaStringRequest_ObjectType.DATABASE;
    case 2:
    case "SCHEMA":
      return GetSchemaStringRequest_ObjectType.SCHEMA;
    case 3:
    case "TABLE":
      return GetSchemaStringRequest_ObjectType.TABLE;
    case 4:
    case "VIEW":
      return GetSchemaStringRequest_ObjectType.VIEW;
    case 5:
    case "MATERIALIZED_VIEW":
      return GetSchemaStringRequest_ObjectType.MATERIALIZED_VIEW;
    case 6:
    case "FUNCTION":
      return GetSchemaStringRequest_ObjectType.FUNCTION;
    case 7:
    case "PROCEDURE":
      return GetSchemaStringRequest_ObjectType.PROCEDURE;
    case 8:
    case "SEQUENCE":
      return GetSchemaStringRequest_ObjectType.SEQUENCE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GetSchemaStringRequest_ObjectType.UNRECOGNIZED;
  }
}

export function getSchemaStringRequest_ObjectTypeToJSON(object: GetSchemaStringRequest_ObjectType): string {
  switch (object) {
    case GetSchemaStringRequest_ObjectType.OBJECT_TYPE_UNSPECIFIED:
      return "OBJECT_TYPE_UNSPECIFIED";
    case GetSchemaStringRequest_ObjectType.DATABASE:
      return "DATABASE";
    case GetSchemaStringRequest_ObjectType.SCHEMA:
      return "SCHEMA";
    case GetSchemaStringRequest_ObjectType.TABLE:
      return "TABLE";
    case GetSchemaStringRequest_ObjectType.VIEW:
      return "VIEW";
    case GetSchemaStringRequest_ObjectType.MATERIALIZED_VIEW:
      return "MATERIALIZED_VIEW";
    case GetSchemaStringRequest_ObjectType.FUNCTION:
      return "FUNCTION";
    case GetSchemaStringRequest_ObjectType.PROCEDURE:
      return "PROCEDURE";
    case GetSchemaStringRequest_ObjectType.SEQUENCE:
      return "SEQUENCE";
    case GetSchemaStringRequest_ObjectType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function getSchemaStringRequest_ObjectTypeToNumber(object: GetSchemaStringRequest_ObjectType): number {
  switch (object) {
    case GetSchemaStringRequest_ObjectType.OBJECT_TYPE_UNSPECIFIED:
      return 0;
    case GetSchemaStringRequest_ObjectType.DATABASE:
      return 1;
    case GetSchemaStringRequest_ObjectType.SCHEMA:
      return 2;
    case GetSchemaStringRequest_ObjectType.TABLE:
      return 3;
    case GetSchemaStringRequest_ObjectType.VIEW:
      return 4;
    case GetSchemaStringRequest_ObjectType.MATERIALIZED_VIEW:
      return 5;
    case GetSchemaStringRequest_ObjectType.FUNCTION:
      return 6;
    case GetSchemaStringRequest_ObjectType.PROCEDURE:
      return 7;
    case GetSchemaStringRequest_ObjectType.SEQUENCE:
      return 8;
    case GetSchemaStringRequest_ObjectType.UNRECOGNIZED:
    default:
      return -1;
  }
}

export interface GetSchemaStringResponse {
  schemaString: string;
}

function createBaseGetDatabaseRequest(): GetDatabaseRequest {
  return { name: "" };
}

export const GetDatabaseRequest: MessageFns<GetDatabaseRequest> = {
  encode(message: GetDatabaseRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDatabaseRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDatabaseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDatabaseRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetDatabaseRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetDatabaseRequest>): GetDatabaseRequest {
    return GetDatabaseRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetDatabaseRequest>): GetDatabaseRequest {
    const message = createBaseGetDatabaseRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseBatchGetDatabasesRequest(): BatchGetDatabasesRequest {
  return { parent: "", names: [] };
}

export const BatchGetDatabasesRequest: MessageFns<BatchGetDatabasesRequest> = {
  encode(message: BatchGetDatabasesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    for (const v of message.names) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchGetDatabasesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchGetDatabasesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.names.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchGetDatabasesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      names: globalThis.Array.isArray(object?.names) ? object.names.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: BatchGetDatabasesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.names?.length) {
      obj.names = message.names;
    }
    return obj;
  },

  create(base?: DeepPartial<BatchGetDatabasesRequest>): BatchGetDatabasesRequest {
    return BatchGetDatabasesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchGetDatabasesRequest>): BatchGetDatabasesRequest {
    const message = createBaseBatchGetDatabasesRequest();
    message.parent = object.parent ?? "";
    message.names = object.names?.map((e) => e) || [];
    return message;
  },
};

function createBaseBatchGetDatabasesResponse(): BatchGetDatabasesResponse {
  return { databases: [] };
}

export const BatchGetDatabasesResponse: MessageFns<BatchGetDatabasesResponse> = {
  encode(message: BatchGetDatabasesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.databases) {
      Database.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchGetDatabasesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchGetDatabasesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.databases.push(Database.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchGetDatabasesResponse {
    return {
      databases: globalThis.Array.isArray(object?.databases)
        ? object.databases.map((e: any) => Database.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BatchGetDatabasesResponse): unknown {
    const obj: any = {};
    if (message.databases?.length) {
      obj.databases = message.databases.map((e) => Database.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BatchGetDatabasesResponse>): BatchGetDatabasesResponse {
    return BatchGetDatabasesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchGetDatabasesResponse>): BatchGetDatabasesResponse {
    const message = createBaseBatchGetDatabasesResponse();
    message.databases = object.databases?.map((e) => Database.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListDatabasesRequest(): ListDatabasesRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", showDeleted: false };
}

export const ListDatabasesRequest: MessageFns<ListDatabasesRequest> = {
  encode(message: ListDatabasesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.showDeleted !== false) {
      writer.uint32(40).bool(message.showDeleted);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListDatabasesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDatabasesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.showDeleted = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDatabasesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      showDeleted: isSet(object.showDeleted) ? globalThis.Boolean(object.showDeleted) : false,
    };
  },

  toJSON(message: ListDatabasesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.showDeleted !== false) {
      obj.showDeleted = message.showDeleted;
    }
    return obj;
  },

  create(base?: DeepPartial<ListDatabasesRequest>): ListDatabasesRequest {
    return ListDatabasesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListDatabasesRequest>): ListDatabasesRequest {
    const message = createBaseListDatabasesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.showDeleted = object.showDeleted ?? false;
    return message;
  },
};

function createBaseListDatabasesResponse(): ListDatabasesResponse {
  return { databases: [], nextPageToken: "" };
}

export const ListDatabasesResponse: MessageFns<ListDatabasesResponse> = {
  encode(message: ListDatabasesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.databases) {
      Database.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListDatabasesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDatabasesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.databases.push(Database.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDatabasesResponse {
    return {
      databases: globalThis.Array.isArray(object?.databases)
        ? object.databases.map((e: any) => Database.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListDatabasesResponse): unknown {
    const obj: any = {};
    if (message.databases?.length) {
      obj.databases = message.databases.map((e) => Database.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListDatabasesResponse>): ListDatabasesResponse {
    return ListDatabasesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListDatabasesResponse>): ListDatabasesResponse {
    const message = createBaseListDatabasesResponse();
    message.databases = object.databases?.map((e) => Database.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseUpdateDatabaseRequest(): UpdateDatabaseRequest {
  return { database: undefined, updateMask: undefined };
}

export const UpdateDatabaseRequest: MessageFns<UpdateDatabaseRequest> = {
  encode(message: UpdateDatabaseRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.database !== undefined) {
      Database.encode(message.database, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateDatabaseRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateDatabaseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.database = Database.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateDatabaseRequest {
    return {
      database: isSet(object.database) ? Database.fromJSON(object.database) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateDatabaseRequest): unknown {
    const obj: any = {};
    if (message.database !== undefined) {
      obj.database = Database.toJSON(message.database);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateDatabaseRequest>): UpdateDatabaseRequest {
    return UpdateDatabaseRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateDatabaseRequest>): UpdateDatabaseRequest {
    const message = createBaseUpdateDatabaseRequest();
    message.database = (object.database !== undefined && object.database !== null)
      ? Database.fromPartial(object.database)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseBatchUpdateDatabasesRequest(): BatchUpdateDatabasesRequest {
  return { parent: "", requests: [] };
}

export const BatchUpdateDatabasesRequest: MessageFns<BatchUpdateDatabasesRequest> = {
  encode(message: BatchUpdateDatabasesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    for (const v of message.requests) {
      UpdateDatabaseRequest.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchUpdateDatabasesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchUpdateDatabasesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.requests.push(UpdateDatabaseRequest.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchUpdateDatabasesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      requests: globalThis.Array.isArray(object?.requests)
        ? object.requests.map((e: any) => UpdateDatabaseRequest.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BatchUpdateDatabasesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.requests?.length) {
      obj.requests = message.requests.map((e) => UpdateDatabaseRequest.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BatchUpdateDatabasesRequest>): BatchUpdateDatabasesRequest {
    return BatchUpdateDatabasesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchUpdateDatabasesRequest>): BatchUpdateDatabasesRequest {
    const message = createBaseBatchUpdateDatabasesRequest();
    message.parent = object.parent ?? "";
    message.requests = object.requests?.map((e) => UpdateDatabaseRequest.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBatchUpdateDatabasesResponse(): BatchUpdateDatabasesResponse {
  return { databases: [] };
}

export const BatchUpdateDatabasesResponse: MessageFns<BatchUpdateDatabasesResponse> = {
  encode(message: BatchUpdateDatabasesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.databases) {
      Database.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchUpdateDatabasesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchUpdateDatabasesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.databases.push(Database.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchUpdateDatabasesResponse {
    return {
      databases: globalThis.Array.isArray(object?.databases)
        ? object.databases.map((e: any) => Database.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BatchUpdateDatabasesResponse): unknown {
    const obj: any = {};
    if (message.databases?.length) {
      obj.databases = message.databases.map((e) => Database.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BatchUpdateDatabasesResponse>): BatchUpdateDatabasesResponse {
    return BatchUpdateDatabasesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchUpdateDatabasesResponse>): BatchUpdateDatabasesResponse {
    const message = createBaseBatchUpdateDatabasesResponse();
    message.databases = object.databases?.map((e) => Database.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBatchSyncDatabasesRequest(): BatchSyncDatabasesRequest {
  return { parent: "", names: [] };
}

export const BatchSyncDatabasesRequest: MessageFns<BatchSyncDatabasesRequest> = {
  encode(message: BatchSyncDatabasesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    for (const v of message.names) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchSyncDatabasesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchSyncDatabasesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.names.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchSyncDatabasesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      names: globalThis.Array.isArray(object?.names) ? object.names.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: BatchSyncDatabasesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.names?.length) {
      obj.names = message.names;
    }
    return obj;
  },

  create(base?: DeepPartial<BatchSyncDatabasesRequest>): BatchSyncDatabasesRequest {
    return BatchSyncDatabasesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchSyncDatabasesRequest>): BatchSyncDatabasesRequest {
    const message = createBaseBatchSyncDatabasesRequest();
    message.parent = object.parent ?? "";
    message.names = object.names?.map((e) => e) || [];
    return message;
  },
};

function createBaseBatchSyncDatabasesResponse(): BatchSyncDatabasesResponse {
  return {};
}

export const BatchSyncDatabasesResponse: MessageFns<BatchSyncDatabasesResponse> = {
  encode(_: BatchSyncDatabasesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchSyncDatabasesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchSyncDatabasesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): BatchSyncDatabasesResponse {
    return {};
  },

  toJSON(_: BatchSyncDatabasesResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<BatchSyncDatabasesResponse>): BatchSyncDatabasesResponse {
    return BatchSyncDatabasesResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<BatchSyncDatabasesResponse>): BatchSyncDatabasesResponse {
    const message = createBaseBatchSyncDatabasesResponse();
    return message;
  },
};

function createBaseSyncDatabaseRequest(): SyncDatabaseRequest {
  return { name: "" };
}

export const SyncDatabaseRequest: MessageFns<SyncDatabaseRequest> = {
  encode(message: SyncDatabaseRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SyncDatabaseRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncDatabaseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SyncDatabaseRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: SyncDatabaseRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<SyncDatabaseRequest>): SyncDatabaseRequest {
    return SyncDatabaseRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SyncDatabaseRequest>): SyncDatabaseRequest {
    const message = createBaseSyncDatabaseRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseSyncDatabaseResponse(): SyncDatabaseResponse {
  return {};
}

export const SyncDatabaseResponse: MessageFns<SyncDatabaseResponse> = {
  encode(_: SyncDatabaseResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SyncDatabaseResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncDatabaseResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): SyncDatabaseResponse {
    return {};
  },

  toJSON(_: SyncDatabaseResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<SyncDatabaseResponse>): SyncDatabaseResponse {
    return SyncDatabaseResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<SyncDatabaseResponse>): SyncDatabaseResponse {
    const message = createBaseSyncDatabaseResponse();
    return message;
  },
};

function createBaseGetDatabaseMetadataRequest(): GetDatabaseMetadataRequest {
  return { name: "", filter: "" };
}

export const GetDatabaseMetadataRequest: MessageFns<GetDatabaseMetadataRequest> = {
  encode(message: GetDatabaseMetadataRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.filter !== "") {
      writer.uint32(18).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDatabaseMetadataRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDatabaseMetadataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.filter = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDatabaseMetadataRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: GetDatabaseMetadataRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<GetDatabaseMetadataRequest>): GetDatabaseMetadataRequest {
    return GetDatabaseMetadataRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetDatabaseMetadataRequest>): GetDatabaseMetadataRequest {
    const message = createBaseGetDatabaseMetadataRequest();
    message.name = object.name ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseGetDatabaseSchemaRequest(): GetDatabaseSchemaRequest {
  return { name: "", sdlFormat: false };
}

export const GetDatabaseSchemaRequest: MessageFns<GetDatabaseSchemaRequest> = {
  encode(message: GetDatabaseSchemaRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.sdlFormat !== false) {
      writer.uint32(16).bool(message.sdlFormat);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDatabaseSchemaRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDatabaseSchemaRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.sdlFormat = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDatabaseSchemaRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      sdlFormat: isSet(object.sdlFormat) ? globalThis.Boolean(object.sdlFormat) : false,
    };
  },

  toJSON(message: GetDatabaseSchemaRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.sdlFormat !== false) {
      obj.sdlFormat = message.sdlFormat;
    }
    return obj;
  },

  create(base?: DeepPartial<GetDatabaseSchemaRequest>): GetDatabaseSchemaRequest {
    return GetDatabaseSchemaRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetDatabaseSchemaRequest>): GetDatabaseSchemaRequest {
    const message = createBaseGetDatabaseSchemaRequest();
    message.name = object.name ?? "";
    message.sdlFormat = object.sdlFormat ?? false;
    return message;
  },
};

function createBaseDiffSchemaRequest(): DiffSchemaRequest {
  return { name: "", schema: undefined, changelog: undefined, sdlFormat: false };
}

export const DiffSchemaRequest: MessageFns<DiffSchemaRequest> = {
  encode(message: DiffSchemaRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.schema !== undefined) {
      writer.uint32(18).string(message.schema);
    }
    if (message.changelog !== undefined) {
      writer.uint32(26).string(message.changelog);
    }
    if (message.sdlFormat !== false) {
      writer.uint32(32).bool(message.sdlFormat);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DiffSchemaRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiffSchemaRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.schema = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.changelog = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.sdlFormat = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DiffSchemaRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      schema: isSet(object.schema) ? globalThis.String(object.schema) : undefined,
      changelog: isSet(object.changelog) ? globalThis.String(object.changelog) : undefined,
      sdlFormat: isSet(object.sdlFormat) ? globalThis.Boolean(object.sdlFormat) : false,
    };
  },

  toJSON(message: DiffSchemaRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.schema !== undefined) {
      obj.schema = message.schema;
    }
    if (message.changelog !== undefined) {
      obj.changelog = message.changelog;
    }
    if (message.sdlFormat !== false) {
      obj.sdlFormat = message.sdlFormat;
    }
    return obj;
  },

  create(base?: DeepPartial<DiffSchemaRequest>): DiffSchemaRequest {
    return DiffSchemaRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DiffSchemaRequest>): DiffSchemaRequest {
    const message = createBaseDiffSchemaRequest();
    message.name = object.name ?? "";
    message.schema = object.schema ?? undefined;
    message.changelog = object.changelog ?? undefined;
    message.sdlFormat = object.sdlFormat ?? false;
    return message;
  },
};

function createBaseDiffSchemaResponse(): DiffSchemaResponse {
  return { diff: "" };
}

export const DiffSchemaResponse: MessageFns<DiffSchemaResponse> = {
  encode(message: DiffSchemaResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.diff !== "") {
      writer.uint32(10).string(message.diff);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DiffSchemaResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiffSchemaResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.diff = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DiffSchemaResponse {
    return { diff: isSet(object.diff) ? globalThis.String(object.diff) : "" };
  },

  toJSON(message: DiffSchemaResponse): unknown {
    const obj: any = {};
    if (message.diff !== "") {
      obj.diff = message.diff;
    }
    return obj;
  },

  create(base?: DeepPartial<DiffSchemaResponse>): DiffSchemaResponse {
    return DiffSchemaResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DiffSchemaResponse>): DiffSchemaResponse {
    const message = createBaseDiffSchemaResponse();
    message.diff = object.diff ?? "";
    return message;
  },
};

function createBaseDatabase(): Database {
  return {
    name: "",
    state: State.STATE_UNSPECIFIED,
    successfulSyncTime: undefined,
    project: "",
    schemaVersion: "",
    environment: "",
    effectiveEnvironment: "",
    labels: {},
    instanceResource: undefined,
    backupAvailable: false,
    drifted: false,
  };
}

export const Database: MessageFns<Database> = {
  encode(message: Database, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.state !== State.STATE_UNSPECIFIED) {
      writer.uint32(24).int32(stateToNumber(message.state));
    }
    if (message.successfulSyncTime !== undefined) {
      Timestamp.encode(message.successfulSyncTime, writer.uint32(34).fork()).join();
    }
    if (message.project !== "") {
      writer.uint32(42).string(message.project);
    }
    if (message.schemaVersion !== "") {
      writer.uint32(50).string(message.schemaVersion);
    }
    if (message.environment !== "") {
      writer.uint32(58).string(message.environment);
    }
    if (message.effectiveEnvironment !== "") {
      writer.uint32(66).string(message.effectiveEnvironment);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Database_LabelsEntry.encode({ key: key as any, value }, writer.uint32(74).fork()).join();
    });
    if (message.instanceResource !== undefined) {
      InstanceResource.encode(message.instanceResource, writer.uint32(82).fork()).join();
    }
    if (message.backupAvailable !== false) {
      writer.uint32(88).bool(message.backupAvailable);
    }
    if (message.drifted !== false) {
      writer.uint32(96).bool(message.drifted);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Database {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatabase();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.state = stateFromJSON(reader.int32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.successfulSyncTime = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.project = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.schemaVersion = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.environment = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.effectiveEnvironment = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          const entry9 = Database_LabelsEntry.decode(reader, reader.uint32());
          if (entry9.value !== undefined) {
            message.labels[entry9.key] = entry9.value;
          }
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.instanceResource = InstanceResource.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.backupAvailable = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.drifted = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Database {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      state: isSet(object.state) ? stateFromJSON(object.state) : State.STATE_UNSPECIFIED,
      successfulSyncTime: isSet(object.successfulSyncTime) ? fromJsonTimestamp(object.successfulSyncTime) : undefined,
      project: isSet(object.project) ? globalThis.String(object.project) : "",
      schemaVersion: isSet(object.schemaVersion) ? globalThis.String(object.schemaVersion) : "",
      environment: isSet(object.environment) ? globalThis.String(object.environment) : "",
      effectiveEnvironment: isSet(object.effectiveEnvironment) ? globalThis.String(object.effectiveEnvironment) : "",
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      instanceResource: isSet(object.instanceResource) ? InstanceResource.fromJSON(object.instanceResource) : undefined,
      backupAvailable: isSet(object.backupAvailable) ? globalThis.Boolean(object.backupAvailable) : false,
      drifted: isSet(object.drifted) ? globalThis.Boolean(object.drifted) : false,
    };
  },

  toJSON(message: Database): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.state !== State.STATE_UNSPECIFIED) {
      obj.state = stateToJSON(message.state);
    }
    if (message.successfulSyncTime !== undefined) {
      obj.successfulSyncTime = fromTimestamp(message.successfulSyncTime).toISOString();
    }
    if (message.project !== "") {
      obj.project = message.project;
    }
    if (message.schemaVersion !== "") {
      obj.schemaVersion = message.schemaVersion;
    }
    if (message.environment !== "") {
      obj.environment = message.environment;
    }
    if (message.effectiveEnvironment !== "") {
      obj.effectiveEnvironment = message.effectiveEnvironment;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.instanceResource !== undefined) {
      obj.instanceResource = InstanceResource.toJSON(message.instanceResource);
    }
    if (message.backupAvailable !== false) {
      obj.backupAvailable = message.backupAvailable;
    }
    if (message.drifted !== false) {
      obj.drifted = message.drifted;
    }
    return obj;
  },

  create(base?: DeepPartial<Database>): Database {
    return Database.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Database>): Database {
    const message = createBaseDatabase();
    message.name = object.name ?? "";
    message.state = object.state ?? State.STATE_UNSPECIFIED;
    message.successfulSyncTime = (object.successfulSyncTime !== undefined && object.successfulSyncTime !== null)
      ? Timestamp.fromPartial(object.successfulSyncTime)
      : undefined;
    message.project = object.project ?? "";
    message.schemaVersion = object.schemaVersion ?? "";
    message.environment = object.environment ?? "";
    message.effectiveEnvironment = object.effectiveEnvironment ?? "";
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.instanceResource = (object.instanceResource !== undefined && object.instanceResource !== null)
      ? InstanceResource.fromPartial(object.instanceResource)
      : undefined;
    message.backupAvailable = object.backupAvailable ?? false;
    message.drifted = object.drifted ?? false;
    return message;
  },
};

function createBaseDatabase_LabelsEntry(): Database_LabelsEntry {
  return { key: "", value: "" };
}

export const Database_LabelsEntry: MessageFns<Database_LabelsEntry> = {
  encode(message: Database_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Database_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatabase_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Database_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Database_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Database_LabelsEntry>): Database_LabelsEntry {
    return Database_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Database_LabelsEntry>): Database_LabelsEntry {
    const message = createBaseDatabase_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseDatabaseMetadata(): DatabaseMetadata {
  return { name: "", schemas: [], characterSet: "", collation: "", extensions: [], owner: "" };
}

export const DatabaseMetadata: MessageFns<DatabaseMetadata> = {
  encode(message: DatabaseMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.schemas) {
      SchemaMetadata.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.characterSet !== "") {
      writer.uint32(26).string(message.characterSet);
    }
    if (message.collation !== "") {
      writer.uint32(34).string(message.collation);
    }
    for (const v of message.extensions) {
      ExtensionMetadata.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.owner !== "") {
      writer.uint32(58).string(message.owner);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DatabaseMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatabaseMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.schemas.push(SchemaMetadata.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.characterSet = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.collation = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.extensions.push(ExtensionMetadata.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DatabaseMetadata {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      schemas: globalThis.Array.isArray(object?.schemas)
        ? object.schemas.map((e: any) => SchemaMetadata.fromJSON(e))
        : [],
      characterSet: isSet(object.characterSet) ? globalThis.String(object.characterSet) : "",
      collation: isSet(object.collation) ? globalThis.String(object.collation) : "",
      extensions: globalThis.Array.isArray(object?.extensions)
        ? object.extensions.map((e: any) => ExtensionMetadata.fromJSON(e))
        : [],
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
    };
  },

  toJSON(message: DatabaseMetadata): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.schemas?.length) {
      obj.schemas = message.schemas.map((e) => SchemaMetadata.toJSON(e));
    }
    if (message.characterSet !== "") {
      obj.characterSet = message.characterSet;
    }
    if (message.collation !== "") {
      obj.collation = message.collation;
    }
    if (message.extensions?.length) {
      obj.extensions = message.extensions.map((e) => ExtensionMetadata.toJSON(e));
    }
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    return obj;
  },

  create(base?: DeepPartial<DatabaseMetadata>): DatabaseMetadata {
    return DatabaseMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DatabaseMetadata>): DatabaseMetadata {
    const message = createBaseDatabaseMetadata();
    message.name = object.name ?? "";
    message.schemas = object.schemas?.map((e) => SchemaMetadata.fromPartial(e)) || [];
    message.characterSet = object.characterSet ?? "";
    message.collation = object.collation ?? "";
    message.extensions = object.extensions?.map((e) => ExtensionMetadata.fromPartial(e)) || [];
    message.owner = object.owner ?? "";
    return message;
  },
};

function createBaseSchemaMetadata(): SchemaMetadata {
  return {
    name: "",
    tables: [],
    externalTables: [],
    views: [],
    functions: [],
    procedures: [],
    streams: [],
    tasks: [],
    materializedViews: [],
    packages: [],
    owner: "",
    sequences: [],
    events: [],
    enumTypes: [],
    skipDump: false,
  };
}

export const SchemaMetadata: MessageFns<SchemaMetadata> = {
  encode(message: SchemaMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.tables) {
      TableMetadata.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.externalTables) {
      ExternalTableMetadata.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.views) {
      ViewMetadata.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.functions) {
      FunctionMetadata.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.procedures) {
      ProcedureMetadata.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.streams) {
      StreamMetadata.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.tasks) {
      TaskMetadata.encode(v!, writer.uint32(66).fork()).join();
    }
    for (const v of message.materializedViews) {
      MaterializedViewMetadata.encode(v!, writer.uint32(74).fork()).join();
    }
    for (const v of message.packages) {
      PackageMetadata.encode(v!, writer.uint32(82).fork()).join();
    }
    if (message.owner !== "") {
      writer.uint32(90).string(message.owner);
    }
    for (const v of message.sequences) {
      SequenceMetadata.encode(v!, writer.uint32(106).fork()).join();
    }
    for (const v of message.events) {
      EventMetadata.encode(v!, writer.uint32(114).fork()).join();
    }
    for (const v of message.enumTypes) {
      EnumTypeMetadata.encode(v!, writer.uint32(122).fork()).join();
    }
    if (message.skipDump !== false) {
      writer.uint32(128).bool(message.skipDump);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SchemaMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSchemaMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tables.push(TableMetadata.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.externalTables.push(ExternalTableMetadata.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.views.push(ViewMetadata.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.functions.push(FunctionMetadata.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.procedures.push(ProcedureMetadata.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.streams.push(StreamMetadata.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.tasks.push(TaskMetadata.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.materializedViews.push(MaterializedViewMetadata.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.packages.push(PackageMetadata.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.sequences.push(SequenceMetadata.decode(reader, reader.uint32()));
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.events.push(EventMetadata.decode(reader, reader.uint32()));
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.enumTypes.push(EnumTypeMetadata.decode(reader, reader.uint32()));
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.skipDump = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SchemaMetadata {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      tables: globalThis.Array.isArray(object?.tables) ? object.tables.map((e: any) => TableMetadata.fromJSON(e)) : [],
      externalTables: globalThis.Array.isArray(object?.externalTables)
        ? object.externalTables.map((e: any) => ExternalTableMetadata.fromJSON(e))
        : [],
      views: globalThis.Array.isArray(object?.views) ? object.views.map((e: any) => ViewMetadata.fromJSON(e)) : [],
      functions: globalThis.Array.isArray(object?.functions)
        ? object.functions.map((e: any) => FunctionMetadata.fromJSON(e))
        : [],
      procedures: globalThis.Array.isArray(object?.procedures)
        ? object.procedures.map((e: any) => ProcedureMetadata.fromJSON(e))
        : [],
      streams: globalThis.Array.isArray(object?.streams)
        ? object.streams.map((e: any) => StreamMetadata.fromJSON(e))
        : [],
      tasks: globalThis.Array.isArray(object?.tasks) ? object.tasks.map((e: any) => TaskMetadata.fromJSON(e)) : [],
      materializedViews: globalThis.Array.isArray(object?.materializedViews)
        ? object.materializedViews.map((e: any) => MaterializedViewMetadata.fromJSON(e))
        : [],
      packages: globalThis.Array.isArray(object?.packages)
        ? object.packages.map((e: any) => PackageMetadata.fromJSON(e))
        : [],
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      sequences: globalThis.Array.isArray(object?.sequences)
        ? object.sequences.map((e: any) => SequenceMetadata.fromJSON(e))
        : [],
      events: globalThis.Array.isArray(object?.events) ? object.events.map((e: any) => EventMetadata.fromJSON(e)) : [],
      enumTypes: globalThis.Array.isArray(object?.enumTypes)
        ? object.enumTypes.map((e: any) => EnumTypeMetadata.fromJSON(e))
        : [],
      skipDump: isSet(object.skipDump) ? globalThis.Boolean(object.skipDump) : false,
    };
  },

  toJSON(message: SchemaMetadata): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.tables?.length) {
      obj.tables = message.tables.map((e) => TableMetadata.toJSON(e));
    }
    if (message.externalTables?.length) {
      obj.externalTables = message.externalTables.map((e) => ExternalTableMetadata.toJSON(e));
    }
    if (message.views?.length) {
      obj.views = message.views.map((e) => ViewMetadata.toJSON(e));
    }
    if (message.functions?.length) {
      obj.functions = message.functions.map((e) => FunctionMetadata.toJSON(e));
    }
    if (message.procedures?.length) {
      obj.procedures = message.procedures.map((e) => ProcedureMetadata.toJSON(e));
    }
    if (message.streams?.length) {
      obj.streams = message.streams.map((e) => StreamMetadata.toJSON(e));
    }
    if (message.tasks?.length) {
      obj.tasks = message.tasks.map((e) => TaskMetadata.toJSON(e));
    }
    if (message.materializedViews?.length) {
      obj.materializedViews = message.materializedViews.map((e) => MaterializedViewMetadata.toJSON(e));
    }
    if (message.packages?.length) {
      obj.packages = message.packages.map((e) => PackageMetadata.toJSON(e));
    }
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.sequences?.length) {
      obj.sequences = message.sequences.map((e) => SequenceMetadata.toJSON(e));
    }
    if (message.events?.length) {
      obj.events = message.events.map((e) => EventMetadata.toJSON(e));
    }
    if (message.enumTypes?.length) {
      obj.enumTypes = message.enumTypes.map((e) => EnumTypeMetadata.toJSON(e));
    }
    if (message.skipDump !== false) {
      obj.skipDump = message.skipDump;
    }
    return obj;
  },

  create(base?: DeepPartial<SchemaMetadata>): SchemaMetadata {
    return SchemaMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SchemaMetadata>): SchemaMetadata {
    const message = createBaseSchemaMetadata();
    message.name = object.name ?? "";
    message.tables = object.tables?.map((e) => TableMetadata.fromPartial(e)) || [];
    message.externalTables = object.externalTables?.map((e) => ExternalTableMetadata.fromPartial(e)) || [];
    message.views = object.views?.map((e) => ViewMetadata.fromPartial(e)) || [];
    message.functions = object.functions?.map((e) => FunctionMetadata.fromPartial(e)) || [];
    message.procedures = object.procedures?.map((e) => ProcedureMetadata.fromPartial(e)) || [];
    message.streams = object.streams?.map((e) => StreamMetadata.fromPartial(e)) || [];
    message.tasks = object.tasks?.map((e) => TaskMetadata.fromPartial(e)) || [];
    message.materializedViews = object.materializedViews?.map((e) => MaterializedViewMetadata.fromPartial(e)) || [];
    message.packages = object.packages?.map((e) => PackageMetadata.fromPartial(e)) || [];
    message.owner = object.owner ?? "";
    message.sequences = object.sequences?.map((e) => SequenceMetadata.fromPartial(e)) || [];
    message.events = object.events?.map((e) => EventMetadata.fromPartial(e)) || [];
    message.enumTypes = object.enumTypes?.map((e) => EnumTypeMetadata.fromPartial(e)) || [];
    message.skipDump = object.skipDump ?? false;
    return message;
  },
};

function createBaseEnumTypeMetadata(): EnumTypeMetadata {
  return { name: "", values: [], comment: "", skipDump: false };
}

export const EnumTypeMetadata: MessageFns<EnumTypeMetadata> = {
  encode(message: EnumTypeMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.values) {
      writer.uint32(18).string(v!);
    }
    if (message.comment !== "") {
      writer.uint32(26).string(message.comment);
    }
    if (message.skipDump !== false) {
      writer.uint32(32).bool(message.skipDump);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnumTypeMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnumTypeMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.values.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.comment = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.skipDump = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnumTypeMetadata {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.String(e)) : [],
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      skipDump: isSet(object.skipDump) ? globalThis.Boolean(object.skipDump) : false,
    };
  },

  toJSON(message: EnumTypeMetadata): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.values?.length) {
      obj.values = message.values;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.skipDump !== false) {
      obj.skipDump = message.skipDump;
    }
    return obj;
  },

  create(base?: DeepPartial<EnumTypeMetadata>): EnumTypeMetadata {
    return EnumTypeMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EnumTypeMetadata>): EnumTypeMetadata {
    const message = createBaseEnumTypeMetadata();
    message.name = object.name ?? "";
    message.values = object.values?.map((e) => e) || [];
    message.comment = object.comment ?? "";
    message.skipDump = object.skipDump ?? false;
    return message;
  },
};

function createBaseEventMetadata(): EventMetadata {
  return { name: "", definition: "", timeZone: "", sqlMode: "", characterSetClient: "", collationConnection: "" };
}

export const EventMetadata: MessageFns<EventMetadata> = {
  encode(message: EventMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.definition !== "") {
      writer.uint32(18).string(message.definition);
    }
    if (message.timeZone !== "") {
      writer.uint32(26).string(message.timeZone);
    }
    if (message.sqlMode !== "") {
      writer.uint32(34).string(message.sqlMode);
    }
    if (message.characterSetClient !== "") {
      writer.uint32(42).string(message.characterSetClient);
    }
    if (message.collationConnection !== "") {
      writer.uint32(50).string(message.collationConnection);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.definition = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.timeZone = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sqlMode = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.characterSetClient = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.collationConnection = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventMetadata {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      definition: isSet(object.definition) ? globalThis.String(object.definition) : "",
      timeZone: isSet(object.timeZone) ? globalThis.String(object.timeZone) : "",
      sqlMode: isSet(object.sqlMode) ? globalThis.String(object.sqlMode) : "",
      characterSetClient: isSet(object.characterSetClient) ? globalThis.String(object.characterSetClient) : "",
      collationConnection: isSet(object.collationConnection) ? globalThis.String(object.collationConnection) : "",
    };
  },

  toJSON(message: EventMetadata): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.definition !== "") {
      obj.definition = message.definition;
    }
    if (message.timeZone !== "") {
      obj.timeZone = message.timeZone;
    }
    if (message.sqlMode !== "") {
      obj.sqlMode = message.sqlMode;
    }
    if (message.characterSetClient !== "") {
      obj.characterSetClient = message.characterSetClient;
    }
    if (message.collationConnection !== "") {
      obj.collationConnection = message.collationConnection;
    }
    return obj;
  },

  create(base?: DeepPartial<EventMetadata>): EventMetadata {
    return EventMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventMetadata>): EventMetadata {
    const message = createBaseEventMetadata();
    message.name = object.name ?? "";
    message.definition = object.definition ?? "";
    message.timeZone = object.timeZone ?? "";
    message.sqlMode = object.sqlMode ?? "";
    message.characterSetClient = object.characterSetClient ?? "";
    message.collationConnection = object.collationConnection ?? "";
    return message;
  },
};

function createBaseSequenceMetadata(): SequenceMetadata {
  return {
    name: "",
    dataType: "",
    start: "",
    minValue: "",
    maxValue: "",
    increment: "",
    cycle: false,
    cacheSize: "",
    lastValue: "",
    ownerTable: "",
    ownerColumn: "",
    comment: "",
    skipDump: false,
  };
}

export const SequenceMetadata: MessageFns<SequenceMetadata> = {
  encode(message: SequenceMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.dataType !== "") {
      writer.uint32(18).string(message.dataType);
    }
    if (message.start !== "") {
      writer.uint32(26).string(message.start);
    }
    if (message.minValue !== "") {
      writer.uint32(34).string(message.minValue);
    }
    if (message.maxValue !== "") {
      writer.uint32(42).string(message.maxValue);
    }
    if (message.increment !== "") {
      writer.uint32(50).string(message.increment);
    }
    if (message.cycle !== false) {
      writer.uint32(56).bool(message.cycle);
    }
    if (message.cacheSize !== "") {
      writer.uint32(66).string(message.cacheSize);
    }
    if (message.lastValue !== "") {
      writer.uint32(74).string(message.lastValue);
    }
    if (message.ownerTable !== "") {
      writer.uint32(82).string(message.ownerTable);
    }
    if (message.ownerColumn !== "") {
      writer.uint32(90).string(message.ownerColumn);
    }
    if (message.comment !== "") {
      writer.uint32(98).string(message.comment);
    }
    if (message.skipDump !== false) {
      writer.uint32(104).bool(message.skipDump);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SequenceMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSequenceMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.dataType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.start = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.minValue = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.maxValue = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.increment = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.cycle = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.cacheSize = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.lastValue = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.ownerTable = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.ownerColumn = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.comment = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.skipDump = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SequenceMetadata {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      dataType: isSet(object.dataType) ? globalThis.String(object.dataType) : "",
      start: isSet(object.start) ? globalThis.String(object.start) : "",
      minValue: isSet(object.minValue) ? globalThis.String(object.minValue) : "",
      maxValue: isSet(object.maxValue) ? globalThis.String(object.maxValue) : "",
      increment: isSet(object.increment) ? globalThis.String(object.increment) : "",
      cycle: isSet(object.cycle) ? globalThis.Boolean(object.cycle) : false,
      cacheSize: isSet(object.cacheSize) ? globalThis.String(object.cacheSize) : "",
      lastValue: isSet(object.lastValue) ? globalThis.String(object.lastValue) : "",
      ownerTable: isSet(object.ownerTable) ? globalThis.String(object.ownerTable) : "",
      ownerColumn: isSet(object.ownerColumn) ? globalThis.String(object.ownerColumn) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      skipDump: isSet(object.skipDump) ? globalThis.Boolean(object.skipDump) : false,
    };
  },

  toJSON(message: SequenceMetadata): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.dataType !== "") {
      obj.dataType = message.dataType;
    }
    if (message.start !== "") {
      obj.start = message.start;
    }
    if (message.minValue !== "") {
      obj.minValue = message.minValue;
    }
    if (message.maxValue !== "") {
      obj.maxValue = message.maxValue;
    }
    if (message.increment !== "") {
      obj.increment = message.increment;
    }
    if (message.cycle !== false) {
      obj.cycle = message.cycle;
    }
    if (message.cacheSize !== "") {
      obj.cacheSize = message.cacheSize;
    }
    if (message.lastValue !== "") {
      obj.lastValue = message.lastValue;
    }
    if (message.ownerTable !== "") {
      obj.ownerTable = message.ownerTable;
    }
    if (message.ownerColumn !== "") {
      obj.ownerColumn = message.ownerColumn;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.skipDump !== false) {
      obj.skipDump = message.skipDump;
    }
    return obj;
  },

  create(base?: DeepPartial<SequenceMetadata>): SequenceMetadata {
    return SequenceMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SequenceMetadata>): SequenceMetadata {
    const message = createBaseSequenceMetadata();
    message.name = object.name ?? "";
    message.dataType = object.dataType ?? "";
    message.start = object.start ?? "";
    message.minValue = object.minValue ?? "";
    message.maxValue = object.maxValue ?? "";
    message.increment = object.increment ?? "";
    message.cycle = object.cycle ?? false;
    message.cacheSize = object.cacheSize ?? "";
    message.lastValue = object.lastValue ?? "";
    message.ownerTable = object.ownerTable ?? "";
    message.ownerColumn = object.ownerColumn ?? "";
    message.comment = object.comment ?? "";
    message.skipDump = object.skipDump ?? false;
    return message;
  },
};

function createBaseTriggerMetadata(): TriggerMetadata {
  return {
    name: "",
    event: "",
    timing: "",
    body: "",
    sqlMode: "",
    characterSetClient: "",
    collationConnection: "",
    comment: "",
    skipDump: false,
  };
}

export const TriggerMetadata: MessageFns<TriggerMetadata> = {
  encode(message: TriggerMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.event !== "") {
      writer.uint32(26).string(message.event);
    }
    if (message.timing !== "") {
      writer.uint32(34).string(message.timing);
    }
    if (message.body !== "") {
      writer.uint32(42).string(message.body);
    }
    if (message.sqlMode !== "") {
      writer.uint32(50).string(message.sqlMode);
    }
    if (message.characterSetClient !== "") {
      writer.uint32(58).string(message.characterSetClient);
    }
    if (message.collationConnection !== "") {
      writer.uint32(66).string(message.collationConnection);
    }
    if (message.comment !== "") {
      writer.uint32(74).string(message.comment);
    }
    if (message.skipDump !== false) {
      writer.uint32(80).bool(message.skipDump);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TriggerMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTriggerMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.event = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.timing = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.body = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.sqlMode = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.characterSetClient = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.collationConnection = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.comment = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.skipDump = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TriggerMetadata {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      event: isSet(object.event) ? globalThis.String(object.event) : "",
      timing: isSet(object.timing) ? globalThis.String(object.timing) : "",
      body: isSet(object.body) ? globalThis.String(object.body) : "",
      sqlMode: isSet(object.sqlMode) ? globalThis.String(object.sqlMode) : "",
      characterSetClient: isSet(object.characterSetClient) ? globalThis.String(object.characterSetClient) : "",
      collationConnection: isSet(object.collationConnection) ? globalThis.String(object.collationConnection) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      skipDump: isSet(object.skipDump) ? globalThis.Boolean(object.skipDump) : false,
    };
  },

  toJSON(message: TriggerMetadata): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.event !== "") {
      obj.event = message.event;
    }
    if (message.timing !== "") {
      obj.timing = message.timing;
    }
    if (message.body !== "") {
      obj.body = message.body;
    }
    if (message.sqlMode !== "") {
      obj.sqlMode = message.sqlMode;
    }
    if (message.characterSetClient !== "") {
      obj.characterSetClient = message.characterSetClient;
    }
    if (message.collationConnection !== "") {
      obj.collationConnection = message.collationConnection;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.skipDump !== false) {
      obj.skipDump = message.skipDump;
    }
    return obj;
  },

  create(base?: DeepPartial<TriggerMetadata>): TriggerMetadata {
    return TriggerMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TriggerMetadata>): TriggerMetadata {
    const message = createBaseTriggerMetadata();
    message.name = object.name ?? "";
    message.event = object.event ?? "";
    message.timing = object.timing ?? "";
    message.body = object.body ?? "";
    message.sqlMode = object.sqlMode ?? "";
    message.characterSetClient = object.characterSetClient ?? "";
    message.collationConnection = object.collationConnection ?? "";
    message.comment = object.comment ?? "";
    message.skipDump = object.skipDump ?? false;
    return message;
  },
};

function createBaseExternalTableMetadata(): ExternalTableMetadata {
  return { name: "", externalServerName: "", externalDatabaseName: "", columns: [] };
}

export const ExternalTableMetadata: MessageFns<ExternalTableMetadata> = {
  encode(message: ExternalTableMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.externalServerName !== "") {
      writer.uint32(18).string(message.externalServerName);
    }
    if (message.externalDatabaseName !== "") {
      writer.uint32(26).string(message.externalDatabaseName);
    }
    for (const v of message.columns) {
      ColumnMetadata.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExternalTableMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExternalTableMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.externalServerName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.externalDatabaseName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.columns.push(ColumnMetadata.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExternalTableMetadata {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      externalServerName: isSet(object.externalServerName) ? globalThis.String(object.externalServerName) : "",
      externalDatabaseName: isSet(object.externalDatabaseName) ? globalThis.String(object.externalDatabaseName) : "",
      columns: globalThis.Array.isArray(object?.columns)
        ? object.columns.map((e: any) => ColumnMetadata.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ExternalTableMetadata): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.externalServerName !== "") {
      obj.externalServerName = message.externalServerName;
    }
    if (message.externalDatabaseName !== "") {
      obj.externalDatabaseName = message.externalDatabaseName;
    }
    if (message.columns?.length) {
      obj.columns = message.columns.map((e) => ColumnMetadata.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ExternalTableMetadata>): ExternalTableMetadata {
    return ExternalTableMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExternalTableMetadata>): ExternalTableMetadata {
    const message = createBaseExternalTableMetadata();
    message.name = object.name ?? "";
    message.externalServerName = object.externalServerName ?? "";
    message.externalDatabaseName = object.externalDatabaseName ?? "";
    message.columns = object.columns?.map((e) => ColumnMetadata.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTableMetadata(): TableMetadata {
  return {
    name: "",
    columns: [],
    indexes: [],
    engine: "",
    collation: "",
    charset: "",
    rowCount: Long.ZERO,
    dataSize: Long.ZERO,
    indexSize: Long.ZERO,
    dataFree: Long.ZERO,
    createOptions: "",
    comment: "",
    userComment: "",
    foreignKeys: [],
    partitions: [],
    checkConstraints: [],
    owner: "",
    sortingKeys: [],
    triggers: [],
    skipDump: false,
    shardingInfo: "",
    primaryKeyType: "",
  };
}

export const TableMetadata: MessageFns<TableMetadata> = {
  encode(message: TableMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.columns) {
      ColumnMetadata.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.indexes) {
      IndexMetadata.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.engine !== "") {
      writer.uint32(34).string(message.engine);
    }
    if (message.collation !== "") {
      writer.uint32(42).string(message.collation);
    }
    if (message.charset !== "") {
      writer.uint32(138).string(message.charset);
    }
    if (!message.rowCount.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.rowCount.toString());
    }
    if (!message.dataSize.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.dataSize.toString());
    }
    if (!message.indexSize.equals(Long.ZERO)) {
      writer.uint32(64).int64(message.indexSize.toString());
    }
    if (!message.dataFree.equals(Long.ZERO)) {
      writer.uint32(72).int64(message.dataFree.toString());
    }
    if (message.createOptions !== "") {
      writer.uint32(82).string(message.createOptions);
    }
    if (message.comment !== "") {
      writer.uint32(90).string(message.comment);
    }
    if (message.userComment !== "") {
      writer.uint32(114).string(message.userComment);
    }
    for (const v of message.foreignKeys) {
      ForeignKeyMetadata.encode(v!, writer.uint32(98).fork()).join();
    }
    for (const v of message.partitions) {
      TablePartitionMetadata.encode(v!, writer.uint32(122).fork()).join();
    }
    for (const v of message.checkConstraints) {
      CheckConstraintMetadata.encode(v!, writer.uint32(130).fork()).join();
    }
    if (message.owner !== "") {
      writer.uint32(146).string(message.owner);
    }
    for (const v of message.sortingKeys) {
      writer.uint32(154).string(v!);
    }
    for (const v of message.triggers) {
      TriggerMetadata.encode(v!, writer.uint32(162).fork()).join();
    }
    if (message.skipDump !== false) {
      writer.uint32(168).bool(message.skipDump);
    }
    if (message.shardingInfo !== "") {
      writer.uint32(178).string(message.shardingInfo);
    }
    if (message.primaryKeyType !== "") {
      writer.uint32(186).string(message.primaryKeyType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TableMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTableMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.columns.push(ColumnMetadata.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.indexes.push(IndexMetadata.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.engine = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.collation = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.charset = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.rowCount = Long.fromString(reader.int64().toString());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.dataSize = Long.fromString(reader.int64().toString());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.indexSize = Long.fromString(reader.int64().toString());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.dataFree = Long.fromString(reader.int64().toString());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.createOptions = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.comment = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.userComment = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.foreignKeys.push(ForeignKeyMetadata.decode(reader, reader.uint32()));
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.partitions.push(TablePartitionMetadata.decode(reader, reader.uint32()));
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.checkConstraints.push(CheckConstraintMetadata.decode(reader, reader.uint32()));
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.sortingKeys.push(reader.string());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.triggers.push(TriggerMetadata.decode(reader, reader.uint32()));
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.skipDump = reader.bool();
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.shardingInfo = reader.string();
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.primaryKeyType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TableMetadata {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      columns: globalThis.Array.isArray(object?.columns)
        ? object.columns.map((e: any) => ColumnMetadata.fromJSON(e))
        : [],
      indexes: globalThis.Array.isArray(object?.indexes)
        ? object.indexes.map((e: any) => IndexMetadata.fromJSON(e))
        : [],
      engine: isSet(object.engine) ? globalThis.String(object.engine) : "",
      collation: isSet(object.collation) ? globalThis.String(object.collation) : "",
      charset: isSet(object.charset) ? globalThis.String(object.charset) : "",
      rowCount: isSet(object.rowCount) ? Long.fromValue(object.rowCount) : Long.ZERO,
      dataSize: isSet(object.dataSize) ? Long.fromValue(object.dataSize) : Long.ZERO,
      indexSize: isSet(object.indexSize) ? Long.fromValue(object.indexSize) : Long.ZERO,
      dataFree: isSet(object.dataFree) ? Long.fromValue(object.dataFree) : Long.ZERO,
      createOptions: isSet(object.createOptions) ? globalThis.String(object.createOptions) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      userComment: isSet(object.userComment) ? globalThis.String(object.userComment) : "",
      foreignKeys: globalThis.Array.isArray(object?.foreignKeys)
        ? object.foreignKeys.map((e: any) => ForeignKeyMetadata.fromJSON(e))
        : [],
      partitions: globalThis.Array.isArray(object?.partitions)
        ? object.partitions.map((e: any) => TablePartitionMetadata.fromJSON(e))
        : [],
      checkConstraints: globalThis.Array.isArray(object?.checkConstraints)
        ? object.checkConstraints.map((e: any) => CheckConstraintMetadata.fromJSON(e))
        : [],
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      sortingKeys: globalThis.Array.isArray(object?.sortingKeys)
        ? object.sortingKeys.map((e: any) => globalThis.String(e))
        : [],
      triggers: globalThis.Array.isArray(object?.triggers)
        ? object.triggers.map((e: any) => TriggerMetadata.fromJSON(e))
        : [],
      skipDump: isSet(object.skipDump) ? globalThis.Boolean(object.skipDump) : false,
      shardingInfo: isSet(object.shardingInfo) ? globalThis.String(object.shardingInfo) : "",
      primaryKeyType: isSet(object.primaryKeyType) ? globalThis.String(object.primaryKeyType) : "",
    };
  },

  toJSON(message: TableMetadata): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.columns?.length) {
      obj.columns = message.columns.map((e) => ColumnMetadata.toJSON(e));
    }
    if (message.indexes?.length) {
      obj.indexes = message.indexes.map((e) => IndexMetadata.toJSON(e));
    }
    if (message.engine !== "") {
      obj.engine = message.engine;
    }
    if (message.collation !== "") {
      obj.collation = message.collation;
    }
    if (message.charset !== "") {
      obj.charset = message.charset;
    }
    if (!message.rowCount.equals(Long.ZERO)) {
      obj.rowCount = (message.rowCount || Long.ZERO).toString();
    }
    if (!message.dataSize.equals(Long.ZERO)) {
      obj.dataSize = (message.dataSize || Long.ZERO).toString();
    }
    if (!message.indexSize.equals(Long.ZERO)) {
      obj.indexSize = (message.indexSize || Long.ZERO).toString();
    }
    if (!message.dataFree.equals(Long.ZERO)) {
      obj.dataFree = (message.dataFree || Long.ZERO).toString();
    }
    if (message.createOptions !== "") {
      obj.createOptions = message.createOptions;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.userComment !== "") {
      obj.userComment = message.userComment;
    }
    if (message.foreignKeys?.length) {
      obj.foreignKeys = message.foreignKeys.map((e) => ForeignKeyMetadata.toJSON(e));
    }
    if (message.partitions?.length) {
      obj.partitions = message.partitions.map((e) => TablePartitionMetadata.toJSON(e));
    }
    if (message.checkConstraints?.length) {
      obj.checkConstraints = message.checkConstraints.map((e) => CheckConstraintMetadata.toJSON(e));
    }
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.sortingKeys?.length) {
      obj.sortingKeys = message.sortingKeys;
    }
    if (message.triggers?.length) {
      obj.triggers = message.triggers.map((e) => TriggerMetadata.toJSON(e));
    }
    if (message.skipDump !== false) {
      obj.skipDump = message.skipDump;
    }
    if (message.shardingInfo !== "") {
      obj.shardingInfo = message.shardingInfo;
    }
    if (message.primaryKeyType !== "") {
      obj.primaryKeyType = message.primaryKeyType;
    }
    return obj;
  },

  create(base?: DeepPartial<TableMetadata>): TableMetadata {
    return TableMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TableMetadata>): TableMetadata {
    const message = createBaseTableMetadata();
    message.name = object.name ?? "";
    message.columns = object.columns?.map((e) => ColumnMetadata.fromPartial(e)) || [];
    message.indexes = object.indexes?.map((e) => IndexMetadata.fromPartial(e)) || [];
    message.engine = object.engine ?? "";
    message.collation = object.collation ?? "";
    message.charset = object.charset ?? "";
    message.rowCount = (object.rowCount !== undefined && object.rowCount !== null)
      ? Long.fromValue(object.rowCount)
      : Long.ZERO;
    message.dataSize = (object.dataSize !== undefined && object.dataSize !== null)
      ? Long.fromValue(object.dataSize)
      : Long.ZERO;
    message.indexSize = (object.indexSize !== undefined && object.indexSize !== null)
      ? Long.fromValue(object.indexSize)
      : Long.ZERO;
    message.dataFree = (object.dataFree !== undefined && object.dataFree !== null)
      ? Long.fromValue(object.dataFree)
      : Long.ZERO;
    message.createOptions = object.createOptions ?? "";
    message.comment = object.comment ?? "";
    message.userComment = object.userComment ?? "";
    message.foreignKeys = object.foreignKeys?.map((e) => ForeignKeyMetadata.fromPartial(e)) || [];
    message.partitions = object.partitions?.map((e) => TablePartitionMetadata.fromPartial(e)) || [];
    message.checkConstraints = object.checkConstraints?.map((e) => CheckConstraintMetadata.fromPartial(e)) || [];
    message.owner = object.owner ?? "";
    message.sortingKeys = object.sortingKeys?.map((e) => e) || [];
    message.triggers = object.triggers?.map((e) => TriggerMetadata.fromPartial(e)) || [];
    message.skipDump = object.skipDump ?? false;
    message.shardingInfo = object.shardingInfo ?? "";
    message.primaryKeyType = object.primaryKeyType ?? "";
    return message;
  },
};

function createBaseCheckConstraintMetadata(): CheckConstraintMetadata {
  return { name: "", expression: "" };
}

export const CheckConstraintMetadata: MessageFns<CheckConstraintMetadata> = {
  encode(message: CheckConstraintMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.expression !== "") {
      writer.uint32(18).string(message.expression);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckConstraintMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckConstraintMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.expression = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckConstraintMetadata {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      expression: isSet(object.expression) ? globalThis.String(object.expression) : "",
    };
  },

  toJSON(message: CheckConstraintMetadata): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.expression !== "") {
      obj.expression = message.expression;
    }
    return obj;
  },

  create(base?: DeepPartial<CheckConstraintMetadata>): CheckConstraintMetadata {
    return CheckConstraintMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CheckConstraintMetadata>): CheckConstraintMetadata {
    const message = createBaseCheckConstraintMetadata();
    message.name = object.name ?? "";
    message.expression = object.expression ?? "";
    return message;
  },
};

function createBaseTablePartitionMetadata(): TablePartitionMetadata {
  return {
    name: "",
    type: TablePartitionMetadata_Type.TYPE_UNSPECIFIED,
    expression: "",
    value: "",
    useDefault: "",
    subpartitions: [],
    indexes: [],
    checkConstraints: [],
  };
}

export const TablePartitionMetadata: MessageFns<TablePartitionMetadata> = {
  encode(message: TablePartitionMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.type !== TablePartitionMetadata_Type.TYPE_UNSPECIFIED) {
      writer.uint32(16).int32(tablePartitionMetadata_TypeToNumber(message.type));
    }
    if (message.expression !== "") {
      writer.uint32(26).string(message.expression);
    }
    if (message.value !== "") {
      writer.uint32(34).string(message.value);
    }
    if (message.useDefault !== "") {
      writer.uint32(42).string(message.useDefault);
    }
    for (const v of message.subpartitions) {
      TablePartitionMetadata.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.indexes) {
      IndexMetadata.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.checkConstraints) {
      CheckConstraintMetadata.encode(v!, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TablePartitionMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTablePartitionMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.type = tablePartitionMetadata_TypeFromJSON(reader.int32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.expression = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.value = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.useDefault = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.subpartitions.push(TablePartitionMetadata.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.indexes.push(IndexMetadata.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.checkConstraints.push(CheckConstraintMetadata.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TablePartitionMetadata {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type)
        ? tablePartitionMetadata_TypeFromJSON(object.type)
        : TablePartitionMetadata_Type.TYPE_UNSPECIFIED,
      expression: isSet(object.expression) ? globalThis.String(object.expression) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      useDefault: isSet(object.useDefault) ? globalThis.String(object.useDefault) : "",
      subpartitions: globalThis.Array.isArray(object?.subpartitions)
        ? object.subpartitions.map((e: any) => TablePartitionMetadata.fromJSON(e))
        : [],
      indexes: globalThis.Array.isArray(object?.indexes)
        ? object.indexes.map((e: any) => IndexMetadata.fromJSON(e))
        : [],
      checkConstraints: globalThis.Array.isArray(object?.checkConstraints)
        ? object.checkConstraints.map((e: any) => CheckConstraintMetadata.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TablePartitionMetadata): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== TablePartitionMetadata_Type.TYPE_UNSPECIFIED) {
      obj.type = tablePartitionMetadata_TypeToJSON(message.type);
    }
    if (message.expression !== "") {
      obj.expression = message.expression;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.useDefault !== "") {
      obj.useDefault = message.useDefault;
    }
    if (message.subpartitions?.length) {
      obj.subpartitions = message.subpartitions.map((e) => TablePartitionMetadata.toJSON(e));
    }
    if (message.indexes?.length) {
      obj.indexes = message.indexes.map((e) => IndexMetadata.toJSON(e));
    }
    if (message.checkConstraints?.length) {
      obj.checkConstraints = message.checkConstraints.map((e) => CheckConstraintMetadata.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<TablePartitionMetadata>): TablePartitionMetadata {
    return TablePartitionMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TablePartitionMetadata>): TablePartitionMetadata {
    const message = createBaseTablePartitionMetadata();
    message.name = object.name ?? "";
    message.type = object.type ?? TablePartitionMetadata_Type.TYPE_UNSPECIFIED;
    message.expression = object.expression ?? "";
    message.value = object.value ?? "";
    message.useDefault = object.useDefault ?? "";
    message.subpartitions = object.subpartitions?.map((e) => TablePartitionMetadata.fromPartial(e)) || [];
    message.indexes = object.indexes?.map((e) => IndexMetadata.fromPartial(e)) || [];
    message.checkConstraints = object.checkConstraints?.map((e) => CheckConstraintMetadata.fromPartial(e)) || [];
    return message;
  },
};

function createBaseColumnMetadata(): ColumnMetadata {
  return {
    name: "",
    position: 0,
    hasDefault: false,
    defaultNull: undefined,
    defaultString: undefined,
    defaultExpression: undefined,
    defaultOnNull: false,
    onUpdate: "",
    nullable: false,
    type: "",
    characterSet: "",
    collation: "",
    comment: "",
    userComment: "",
    generation: undefined,
    isIdentity: false,
    identityGeneration: ColumnMetadata_IdentityGeneration.IDENTITY_GENERATION_UNSPECIFIED,
    identitySeed: Long.ZERO,
    identityIncrement: Long.ZERO,
  };
}

export const ColumnMetadata: MessageFns<ColumnMetadata> = {
  encode(message: ColumnMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.position !== 0) {
      writer.uint32(16).int32(message.position);
    }
    if (message.hasDefault !== false) {
      writer.uint32(24).bool(message.hasDefault);
    }
    if (message.defaultNull !== undefined) {
      writer.uint32(32).bool(message.defaultNull);
    }
    if (message.defaultString !== undefined) {
      writer.uint32(42).string(message.defaultString);
    }
    if (message.defaultExpression !== undefined) {
      writer.uint32(50).string(message.defaultExpression);
    }
    if (message.defaultOnNull !== false) {
      writer.uint32(144).bool(message.defaultOnNull);
    }
    if (message.onUpdate !== "") {
      writer.uint32(122).string(message.onUpdate);
    }
    if (message.nullable !== false) {
      writer.uint32(56).bool(message.nullable);
    }
    if (message.type !== "") {
      writer.uint32(66).string(message.type);
    }
    if (message.characterSet !== "") {
      writer.uint32(74).string(message.characterSet);
    }
    if (message.collation !== "") {
      writer.uint32(82).string(message.collation);
    }
    if (message.comment !== "") {
      writer.uint32(90).string(message.comment);
    }
    if (message.userComment !== "") {
      writer.uint32(106).string(message.userComment);
    }
    if (message.generation !== undefined) {
      GenerationMetadata.encode(message.generation, writer.uint32(130).fork()).join();
    }
    if (message.isIdentity !== false) {
      writer.uint32(152).bool(message.isIdentity);
    }
    if (message.identityGeneration !== ColumnMetadata_IdentityGeneration.IDENTITY_GENERATION_UNSPECIFIED) {
      writer.uint32(136).int32(columnMetadata_IdentityGenerationToNumber(message.identityGeneration));
    }
    if (!message.identitySeed.equals(Long.ZERO)) {
      writer.uint32(160).int64(message.identitySeed.toString());
    }
    if (!message.identityIncrement.equals(Long.ZERO)) {
      writer.uint32(168).int64(message.identityIncrement.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ColumnMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseColumnMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.position = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.hasDefault = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.defaultNull = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.defaultString = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.defaultExpression = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.defaultOnNull = reader.bool();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.onUpdate = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.nullable = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.characterSet = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.collation = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.comment = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.userComment = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.generation = GenerationMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.isIdentity = reader.bool();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.identityGeneration = columnMetadata_IdentityGenerationFromJSON(reader.int32());
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.identitySeed = Long.fromString(reader.int64().toString());
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.identityIncrement = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ColumnMetadata {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      position: isSet(object.position) ? globalThis.Number(object.position) : 0,
      hasDefault: isSet(object.hasDefault) ? globalThis.Boolean(object.hasDefault) : false,
      defaultNull: isSet(object.defaultNull) ? globalThis.Boolean(object.defaultNull) : undefined,
      defaultString: isSet(object.defaultString) ? globalThis.String(object.defaultString) : undefined,
      defaultExpression: isSet(object.defaultExpression) ? globalThis.String(object.defaultExpression) : undefined,
      defaultOnNull: isSet(object.defaultOnNull) ? globalThis.Boolean(object.defaultOnNull) : false,
      onUpdate: isSet(object.onUpdate) ? globalThis.String(object.onUpdate) : "",
      nullable: isSet(object.nullable) ? globalThis.Boolean(object.nullable) : false,
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      characterSet: isSet(object.characterSet) ? globalThis.String(object.characterSet) : "",
      collation: isSet(object.collation) ? globalThis.String(object.collation) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      userComment: isSet(object.userComment) ? globalThis.String(object.userComment) : "",
      generation: isSet(object.generation) ? GenerationMetadata.fromJSON(object.generation) : undefined,
      isIdentity: isSet(object.isIdentity) ? globalThis.Boolean(object.isIdentity) : false,
      identityGeneration: isSet(object.identityGeneration)
        ? columnMetadata_IdentityGenerationFromJSON(object.identityGeneration)
        : ColumnMetadata_IdentityGeneration.IDENTITY_GENERATION_UNSPECIFIED,
      identitySeed: isSet(object.identitySeed) ? Long.fromValue(object.identitySeed) : Long.ZERO,
      identityIncrement: isSet(object.identityIncrement) ? Long.fromValue(object.identityIncrement) : Long.ZERO,
    };
  },

  toJSON(message: ColumnMetadata): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.position !== 0) {
      obj.position = Math.round(message.position);
    }
    if (message.hasDefault !== false) {
      obj.hasDefault = message.hasDefault;
    }
    if (message.defaultNull !== undefined) {
      obj.defaultNull = message.defaultNull;
    }
    if (message.defaultString !== undefined) {
      obj.defaultString = message.defaultString;
    }
    if (message.defaultExpression !== undefined) {
      obj.defaultExpression = message.defaultExpression;
    }
    if (message.defaultOnNull !== false) {
      obj.defaultOnNull = message.defaultOnNull;
    }
    if (message.onUpdate !== "") {
      obj.onUpdate = message.onUpdate;
    }
    if (message.nullable !== false) {
      obj.nullable = message.nullable;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.characterSet !== "") {
      obj.characterSet = message.characterSet;
    }
    if (message.collation !== "") {
      obj.collation = message.collation;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.userComment !== "") {
      obj.userComment = message.userComment;
    }
    if (message.generation !== undefined) {
      obj.generation = GenerationMetadata.toJSON(message.generation);
    }
    if (message.isIdentity !== false) {
      obj.isIdentity = message.isIdentity;
    }
    if (message.identityGeneration !== ColumnMetadata_IdentityGeneration.IDENTITY_GENERATION_UNSPECIFIED) {
      obj.identityGeneration = columnMetadata_IdentityGenerationToJSON(message.identityGeneration);
    }
    if (!message.identitySeed.equals(Long.ZERO)) {
      obj.identitySeed = (message.identitySeed || Long.ZERO).toString();
    }
    if (!message.identityIncrement.equals(Long.ZERO)) {
      obj.identityIncrement = (message.identityIncrement || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<ColumnMetadata>): ColumnMetadata {
    return ColumnMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ColumnMetadata>): ColumnMetadata {
    const message = createBaseColumnMetadata();
    message.name = object.name ?? "";
    message.position = object.position ?? 0;
    message.hasDefault = object.hasDefault ?? false;
    message.defaultNull = object.defaultNull ?? undefined;
    message.defaultString = object.defaultString ?? undefined;
    message.defaultExpression = object.defaultExpression ?? undefined;
    message.defaultOnNull = object.defaultOnNull ?? false;
    message.onUpdate = object.onUpdate ?? "";
    message.nullable = object.nullable ?? false;
    message.type = object.type ?? "";
    message.characterSet = object.characterSet ?? "";
    message.collation = object.collation ?? "";
    message.comment = object.comment ?? "";
    message.userComment = object.userComment ?? "";
    message.generation = (object.generation !== undefined && object.generation !== null)
      ? GenerationMetadata.fromPartial(object.generation)
      : undefined;
    message.isIdentity = object.isIdentity ?? false;
    message.identityGeneration = object.identityGeneration ??
      ColumnMetadata_IdentityGeneration.IDENTITY_GENERATION_UNSPECIFIED;
    message.identitySeed = (object.identitySeed !== undefined && object.identitySeed !== null)
      ? Long.fromValue(object.identitySeed)
      : Long.ZERO;
    message.identityIncrement = (object.identityIncrement !== undefined && object.identityIncrement !== null)
      ? Long.fromValue(object.identityIncrement)
      : Long.ZERO;
    return message;
  },
};

function createBaseGenerationMetadata(): GenerationMetadata {
  return { type: GenerationMetadata_Type.TYPE_UNSPECIFIED, expression: "" };
}

export const GenerationMetadata: MessageFns<GenerationMetadata> = {
  encode(message: GenerationMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== GenerationMetadata_Type.TYPE_UNSPECIFIED) {
      writer.uint32(8).int32(generationMetadata_TypeToNumber(message.type));
    }
    if (message.expression !== "") {
      writer.uint32(18).string(message.expression);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = generationMetadata_TypeFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.expression = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerationMetadata {
    return {
      type: isSet(object.type)
        ? generationMetadata_TypeFromJSON(object.type)
        : GenerationMetadata_Type.TYPE_UNSPECIFIED,
      expression: isSet(object.expression) ? globalThis.String(object.expression) : "",
    };
  },

  toJSON(message: GenerationMetadata): unknown {
    const obj: any = {};
    if (message.type !== GenerationMetadata_Type.TYPE_UNSPECIFIED) {
      obj.type = generationMetadata_TypeToJSON(message.type);
    }
    if (message.expression !== "") {
      obj.expression = message.expression;
    }
    return obj;
  },

  create(base?: DeepPartial<GenerationMetadata>): GenerationMetadata {
    return GenerationMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerationMetadata>): GenerationMetadata {
    const message = createBaseGenerationMetadata();
    message.type = object.type ?? GenerationMetadata_Type.TYPE_UNSPECIFIED;
    message.expression = object.expression ?? "";
    return message;
  },
};

function createBaseViewMetadata(): ViewMetadata {
  return { name: "", definition: "", comment: "", dependencyColumns: [], columns: [], triggers: [], skipDump: false };
}

export const ViewMetadata: MessageFns<ViewMetadata> = {
  encode(message: ViewMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.definition !== "") {
      writer.uint32(18).string(message.definition);
    }
    if (message.comment !== "") {
      writer.uint32(26).string(message.comment);
    }
    for (const v of message.dependencyColumns) {
      DependencyColumn.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.columns) {
      ColumnMetadata.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.triggers) {
      TriggerMetadata.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.skipDump !== false) {
      writer.uint32(56).bool(message.skipDump);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ViewMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseViewMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.definition = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.comment = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.dependencyColumns.push(DependencyColumn.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.columns.push(ColumnMetadata.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.triggers.push(TriggerMetadata.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.skipDump = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ViewMetadata {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      definition: isSet(object.definition) ? globalThis.String(object.definition) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      dependencyColumns: globalThis.Array.isArray(object?.dependencyColumns)
        ? object.dependencyColumns.map((e: any) => DependencyColumn.fromJSON(e))
        : [],
      columns: globalThis.Array.isArray(object?.columns)
        ? object.columns.map((e: any) => ColumnMetadata.fromJSON(e))
        : [],
      triggers: globalThis.Array.isArray(object?.triggers)
        ? object.triggers.map((e: any) => TriggerMetadata.fromJSON(e))
        : [],
      skipDump: isSet(object.skipDump) ? globalThis.Boolean(object.skipDump) : false,
    };
  },

  toJSON(message: ViewMetadata): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.definition !== "") {
      obj.definition = message.definition;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.dependencyColumns?.length) {
      obj.dependencyColumns = message.dependencyColumns.map((e) => DependencyColumn.toJSON(e));
    }
    if (message.columns?.length) {
      obj.columns = message.columns.map((e) => ColumnMetadata.toJSON(e));
    }
    if (message.triggers?.length) {
      obj.triggers = message.triggers.map((e) => TriggerMetadata.toJSON(e));
    }
    if (message.skipDump !== false) {
      obj.skipDump = message.skipDump;
    }
    return obj;
  },

  create(base?: DeepPartial<ViewMetadata>): ViewMetadata {
    return ViewMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ViewMetadata>): ViewMetadata {
    const message = createBaseViewMetadata();
    message.name = object.name ?? "";
    message.definition = object.definition ?? "";
    message.comment = object.comment ?? "";
    message.dependencyColumns = object.dependencyColumns?.map((e) => DependencyColumn.fromPartial(e)) || [];
    message.columns = object.columns?.map((e) => ColumnMetadata.fromPartial(e)) || [];
    message.triggers = object.triggers?.map((e) => TriggerMetadata.fromPartial(e)) || [];
    message.skipDump = object.skipDump ?? false;
    return message;
  },
};

function createBaseDependencyColumn(): DependencyColumn {
  return { schema: "", table: "", column: "" };
}

export const DependencyColumn: MessageFns<DependencyColumn> = {
  encode(message: DependencyColumn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.schema !== "") {
      writer.uint32(10).string(message.schema);
    }
    if (message.table !== "") {
      writer.uint32(18).string(message.table);
    }
    if (message.column !== "") {
      writer.uint32(26).string(message.column);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DependencyColumn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDependencyColumn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.schema = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.table = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.column = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DependencyColumn {
    return {
      schema: isSet(object.schema) ? globalThis.String(object.schema) : "",
      table: isSet(object.table) ? globalThis.String(object.table) : "",
      column: isSet(object.column) ? globalThis.String(object.column) : "",
    };
  },

  toJSON(message: DependencyColumn): unknown {
    const obj: any = {};
    if (message.schema !== "") {
      obj.schema = message.schema;
    }
    if (message.table !== "") {
      obj.table = message.table;
    }
    if (message.column !== "") {
      obj.column = message.column;
    }
    return obj;
  },

  create(base?: DeepPartial<DependencyColumn>): DependencyColumn {
    return DependencyColumn.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DependencyColumn>): DependencyColumn {
    const message = createBaseDependencyColumn();
    message.schema = object.schema ?? "";
    message.table = object.table ?? "";
    message.column = object.column ?? "";
    return message;
  },
};

function createBaseMaterializedViewMetadata(): MaterializedViewMetadata {
  return { name: "", definition: "", comment: "", dependencyColumns: [], triggers: [], indexes: [], skipDump: false };
}

export const MaterializedViewMetadata: MessageFns<MaterializedViewMetadata> = {
  encode(message: MaterializedViewMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.definition !== "") {
      writer.uint32(18).string(message.definition);
    }
    if (message.comment !== "") {
      writer.uint32(26).string(message.comment);
    }
    for (const v of message.dependencyColumns) {
      DependencyColumn.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.triggers) {
      TriggerMetadata.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.indexes) {
      IndexMetadata.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.skipDump !== false) {
      writer.uint32(56).bool(message.skipDump);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MaterializedViewMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMaterializedViewMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.definition = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.comment = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.dependencyColumns.push(DependencyColumn.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.triggers.push(TriggerMetadata.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.indexes.push(IndexMetadata.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.skipDump = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MaterializedViewMetadata {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      definition: isSet(object.definition) ? globalThis.String(object.definition) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      dependencyColumns: globalThis.Array.isArray(object?.dependencyColumns)
        ? object.dependencyColumns.map((e: any) => DependencyColumn.fromJSON(e))
        : [],
      triggers: globalThis.Array.isArray(object?.triggers)
        ? object.triggers.map((e: any) => TriggerMetadata.fromJSON(e))
        : [],
      indexes: globalThis.Array.isArray(object?.indexes)
        ? object.indexes.map((e: any) => IndexMetadata.fromJSON(e))
        : [],
      skipDump: isSet(object.skipDump) ? globalThis.Boolean(object.skipDump) : false,
    };
  },

  toJSON(message: MaterializedViewMetadata): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.definition !== "") {
      obj.definition = message.definition;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.dependencyColumns?.length) {
      obj.dependencyColumns = message.dependencyColumns.map((e) => DependencyColumn.toJSON(e));
    }
    if (message.triggers?.length) {
      obj.triggers = message.triggers.map((e) => TriggerMetadata.toJSON(e));
    }
    if (message.indexes?.length) {
      obj.indexes = message.indexes.map((e) => IndexMetadata.toJSON(e));
    }
    if (message.skipDump !== false) {
      obj.skipDump = message.skipDump;
    }
    return obj;
  },

  create(base?: DeepPartial<MaterializedViewMetadata>): MaterializedViewMetadata {
    return MaterializedViewMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MaterializedViewMetadata>): MaterializedViewMetadata {
    const message = createBaseMaterializedViewMetadata();
    message.name = object.name ?? "";
    message.definition = object.definition ?? "";
    message.comment = object.comment ?? "";
    message.dependencyColumns = object.dependencyColumns?.map((e) => DependencyColumn.fromPartial(e)) || [];
    message.triggers = object.triggers?.map((e) => TriggerMetadata.fromPartial(e)) || [];
    message.indexes = object.indexes?.map((e) => IndexMetadata.fromPartial(e)) || [];
    message.skipDump = object.skipDump ?? false;
    return message;
  },
};

function createBaseDependencyTable(): DependencyTable {
  return { schema: "", table: "" };
}

export const DependencyTable: MessageFns<DependencyTable> = {
  encode(message: DependencyTable, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.schema !== "") {
      writer.uint32(10).string(message.schema);
    }
    if (message.table !== "") {
      writer.uint32(18).string(message.table);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DependencyTable {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDependencyTable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.schema = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.table = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DependencyTable {
    return {
      schema: isSet(object.schema) ? globalThis.String(object.schema) : "",
      table: isSet(object.table) ? globalThis.String(object.table) : "",
    };
  },

  toJSON(message: DependencyTable): unknown {
    const obj: any = {};
    if (message.schema !== "") {
      obj.schema = message.schema;
    }
    if (message.table !== "") {
      obj.table = message.table;
    }
    return obj;
  },

  create(base?: DeepPartial<DependencyTable>): DependencyTable {
    return DependencyTable.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DependencyTable>): DependencyTable {
    const message = createBaseDependencyTable();
    message.schema = object.schema ?? "";
    message.table = object.table ?? "";
    return message;
  },
};

function createBaseFunctionMetadata(): FunctionMetadata {
  return {
    name: "",
    definition: "",
    signature: "",
    characterSetClient: "",
    collationConnection: "",
    databaseCollation: "",
    sqlMode: "",
    comment: "",
    dependencyTables: [],
    skipDump: false,
  };
}

export const FunctionMetadata: MessageFns<FunctionMetadata> = {
  encode(message: FunctionMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.definition !== "") {
      writer.uint32(18).string(message.definition);
    }
    if (message.signature !== "") {
      writer.uint32(26).string(message.signature);
    }
    if (message.characterSetClient !== "") {
      writer.uint32(34).string(message.characterSetClient);
    }
    if (message.collationConnection !== "") {
      writer.uint32(42).string(message.collationConnection);
    }
    if (message.databaseCollation !== "") {
      writer.uint32(50).string(message.databaseCollation);
    }
    if (message.sqlMode !== "") {
      writer.uint32(58).string(message.sqlMode);
    }
    if (message.comment !== "") {
      writer.uint32(66).string(message.comment);
    }
    for (const v of message.dependencyTables) {
      DependencyTable.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.skipDump !== false) {
      writer.uint32(80).bool(message.skipDump);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunctionMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.definition = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.signature = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.characterSetClient = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.collationConnection = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.databaseCollation = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.sqlMode = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.comment = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.dependencyTables.push(DependencyTable.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.skipDump = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunctionMetadata {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      definition: isSet(object.definition) ? globalThis.String(object.definition) : "",
      signature: isSet(object.signature) ? globalThis.String(object.signature) : "",
      characterSetClient: isSet(object.characterSetClient) ? globalThis.String(object.characterSetClient) : "",
      collationConnection: isSet(object.collationConnection) ? globalThis.String(object.collationConnection) : "",
      databaseCollation: isSet(object.databaseCollation) ? globalThis.String(object.databaseCollation) : "",
      sqlMode: isSet(object.sqlMode) ? globalThis.String(object.sqlMode) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      dependencyTables: globalThis.Array.isArray(object?.dependencyTables)
        ? object.dependencyTables.map((e: any) => DependencyTable.fromJSON(e))
        : [],
      skipDump: isSet(object.skipDump) ? globalThis.Boolean(object.skipDump) : false,
    };
  },

  toJSON(message: FunctionMetadata): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.definition !== "") {
      obj.definition = message.definition;
    }
    if (message.signature !== "") {
      obj.signature = message.signature;
    }
    if (message.characterSetClient !== "") {
      obj.characterSetClient = message.characterSetClient;
    }
    if (message.collationConnection !== "") {
      obj.collationConnection = message.collationConnection;
    }
    if (message.databaseCollation !== "") {
      obj.databaseCollation = message.databaseCollation;
    }
    if (message.sqlMode !== "") {
      obj.sqlMode = message.sqlMode;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.dependencyTables?.length) {
      obj.dependencyTables = message.dependencyTables.map((e) => DependencyTable.toJSON(e));
    }
    if (message.skipDump !== false) {
      obj.skipDump = message.skipDump;
    }
    return obj;
  },

  create(base?: DeepPartial<FunctionMetadata>): FunctionMetadata {
    return FunctionMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FunctionMetadata>): FunctionMetadata {
    const message = createBaseFunctionMetadata();
    message.name = object.name ?? "";
    message.definition = object.definition ?? "";
    message.signature = object.signature ?? "";
    message.characterSetClient = object.characterSetClient ?? "";
    message.collationConnection = object.collationConnection ?? "";
    message.databaseCollation = object.databaseCollation ?? "";
    message.sqlMode = object.sqlMode ?? "";
    message.comment = object.comment ?? "";
    message.dependencyTables = object.dependencyTables?.map((e) => DependencyTable.fromPartial(e)) || [];
    message.skipDump = object.skipDump ?? false;
    return message;
  },
};

function createBaseProcedureMetadata(): ProcedureMetadata {
  return {
    name: "",
    definition: "",
    signature: "",
    characterSetClient: "",
    collationConnection: "",
    databaseCollation: "",
    sqlMode: "",
    skipDump: false,
  };
}

export const ProcedureMetadata: MessageFns<ProcedureMetadata> = {
  encode(message: ProcedureMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.definition !== "") {
      writer.uint32(18).string(message.definition);
    }
    if (message.signature !== "") {
      writer.uint32(26).string(message.signature);
    }
    if (message.characterSetClient !== "") {
      writer.uint32(34).string(message.characterSetClient);
    }
    if (message.collationConnection !== "") {
      writer.uint32(42).string(message.collationConnection);
    }
    if (message.databaseCollation !== "") {
      writer.uint32(50).string(message.databaseCollation);
    }
    if (message.sqlMode !== "") {
      writer.uint32(58).string(message.sqlMode);
    }
    if (message.skipDump !== false) {
      writer.uint32(64).bool(message.skipDump);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcedureMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcedureMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.definition = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.signature = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.characterSetClient = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.collationConnection = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.databaseCollation = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.sqlMode = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.skipDump = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcedureMetadata {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      definition: isSet(object.definition) ? globalThis.String(object.definition) : "",
      signature: isSet(object.signature) ? globalThis.String(object.signature) : "",
      characterSetClient: isSet(object.characterSetClient) ? globalThis.String(object.characterSetClient) : "",
      collationConnection: isSet(object.collationConnection) ? globalThis.String(object.collationConnection) : "",
      databaseCollation: isSet(object.databaseCollation) ? globalThis.String(object.databaseCollation) : "",
      sqlMode: isSet(object.sqlMode) ? globalThis.String(object.sqlMode) : "",
      skipDump: isSet(object.skipDump) ? globalThis.Boolean(object.skipDump) : false,
    };
  },

  toJSON(message: ProcedureMetadata): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.definition !== "") {
      obj.definition = message.definition;
    }
    if (message.signature !== "") {
      obj.signature = message.signature;
    }
    if (message.characterSetClient !== "") {
      obj.characterSetClient = message.characterSetClient;
    }
    if (message.collationConnection !== "") {
      obj.collationConnection = message.collationConnection;
    }
    if (message.databaseCollation !== "") {
      obj.databaseCollation = message.databaseCollation;
    }
    if (message.sqlMode !== "") {
      obj.sqlMode = message.sqlMode;
    }
    if (message.skipDump !== false) {
      obj.skipDump = message.skipDump;
    }
    return obj;
  },

  create(base?: DeepPartial<ProcedureMetadata>): ProcedureMetadata {
    return ProcedureMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProcedureMetadata>): ProcedureMetadata {
    const message = createBaseProcedureMetadata();
    message.name = object.name ?? "";
    message.definition = object.definition ?? "";
    message.signature = object.signature ?? "";
    message.characterSetClient = object.characterSetClient ?? "";
    message.collationConnection = object.collationConnection ?? "";
    message.databaseCollation = object.databaseCollation ?? "";
    message.sqlMode = object.sqlMode ?? "";
    message.skipDump = object.skipDump ?? false;
    return message;
  },
};

function createBasePackageMetadata(): PackageMetadata {
  return { name: "", definition: "" };
}

export const PackageMetadata: MessageFns<PackageMetadata> = {
  encode(message: PackageMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.definition !== "") {
      writer.uint32(18).string(message.definition);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PackageMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePackageMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.definition = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PackageMetadata {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      definition: isSet(object.definition) ? globalThis.String(object.definition) : "",
    };
  },

  toJSON(message: PackageMetadata): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.definition !== "") {
      obj.definition = message.definition;
    }
    return obj;
  },

  create(base?: DeepPartial<PackageMetadata>): PackageMetadata {
    return PackageMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PackageMetadata>): PackageMetadata {
    const message = createBasePackageMetadata();
    message.name = object.name ?? "";
    message.definition = object.definition ?? "";
    return message;
  },
};

function createBaseTaskMetadata(): TaskMetadata {
  return {
    name: "",
    id: "",
    owner: "",
    comment: "",
    warehouse: "",
    schedule: "",
    predecessors: [],
    state: TaskMetadata_State.STATE_UNSPECIFIED,
    condition: "",
    definition: "",
  };
}

export const TaskMetadata: MessageFns<TaskMetadata> = {
  encode(message: TaskMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.owner !== "") {
      writer.uint32(26).string(message.owner);
    }
    if (message.comment !== "") {
      writer.uint32(34).string(message.comment);
    }
    if (message.warehouse !== "") {
      writer.uint32(42).string(message.warehouse);
    }
    if (message.schedule !== "") {
      writer.uint32(50).string(message.schedule);
    }
    for (const v of message.predecessors) {
      writer.uint32(58).string(v!);
    }
    if (message.state !== TaskMetadata_State.STATE_UNSPECIFIED) {
      writer.uint32(64).int32(taskMetadata_StateToNumber(message.state));
    }
    if (message.condition !== "") {
      writer.uint32(74).string(message.condition);
    }
    if (message.definition !== "") {
      writer.uint32(82).string(message.definition);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.comment = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.warehouse = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.schedule = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.predecessors.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.state = taskMetadata_StateFromJSON(reader.int32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.condition = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.definition = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskMetadata {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      warehouse: isSet(object.warehouse) ? globalThis.String(object.warehouse) : "",
      schedule: isSet(object.schedule) ? globalThis.String(object.schedule) : "",
      predecessors: globalThis.Array.isArray(object?.predecessors)
        ? object.predecessors.map((e: any) => globalThis.String(e))
        : [],
      state: isSet(object.state) ? taskMetadata_StateFromJSON(object.state) : TaskMetadata_State.STATE_UNSPECIFIED,
      condition: isSet(object.condition) ? globalThis.String(object.condition) : "",
      definition: isSet(object.definition) ? globalThis.String(object.definition) : "",
    };
  },

  toJSON(message: TaskMetadata): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.warehouse !== "") {
      obj.warehouse = message.warehouse;
    }
    if (message.schedule !== "") {
      obj.schedule = message.schedule;
    }
    if (message.predecessors?.length) {
      obj.predecessors = message.predecessors;
    }
    if (message.state !== TaskMetadata_State.STATE_UNSPECIFIED) {
      obj.state = taskMetadata_StateToJSON(message.state);
    }
    if (message.condition !== "") {
      obj.condition = message.condition;
    }
    if (message.definition !== "") {
      obj.definition = message.definition;
    }
    return obj;
  },

  create(base?: DeepPartial<TaskMetadata>): TaskMetadata {
    return TaskMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TaskMetadata>): TaskMetadata {
    const message = createBaseTaskMetadata();
    message.name = object.name ?? "";
    message.id = object.id ?? "";
    message.owner = object.owner ?? "";
    message.comment = object.comment ?? "";
    message.warehouse = object.warehouse ?? "";
    message.schedule = object.schedule ?? "";
    message.predecessors = object.predecessors?.map((e) => e) || [];
    message.state = object.state ?? TaskMetadata_State.STATE_UNSPECIFIED;
    message.condition = object.condition ?? "";
    message.definition = object.definition ?? "";
    return message;
  },
};

function createBaseStreamMetadata(): StreamMetadata {
  return {
    name: "",
    tableName: "",
    owner: "",
    comment: "",
    type: StreamMetadata_Type.TYPE_UNSPECIFIED,
    stale: false,
    mode: StreamMetadata_Mode.MODE_UNSPECIFIED,
    definition: "",
  };
}

export const StreamMetadata: MessageFns<StreamMetadata> = {
  encode(message: StreamMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.tableName !== "") {
      writer.uint32(18).string(message.tableName);
    }
    if (message.owner !== "") {
      writer.uint32(26).string(message.owner);
    }
    if (message.comment !== "") {
      writer.uint32(34).string(message.comment);
    }
    if (message.type !== StreamMetadata_Type.TYPE_UNSPECIFIED) {
      writer.uint32(40).int32(streamMetadata_TypeToNumber(message.type));
    }
    if (message.stale !== false) {
      writer.uint32(48).bool(message.stale);
    }
    if (message.mode !== StreamMetadata_Mode.MODE_UNSPECIFIED) {
      writer.uint32(56).int32(streamMetadata_ModeToNumber(message.mode));
    }
    if (message.definition !== "") {
      writer.uint32(66).string(message.definition);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tableName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.comment = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.type = streamMetadata_TypeFromJSON(reader.int32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.stale = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.mode = streamMetadata_ModeFromJSON(reader.int32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.definition = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamMetadata {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      tableName: isSet(object.tableName) ? globalThis.String(object.tableName) : "",
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      type: isSet(object.type) ? streamMetadata_TypeFromJSON(object.type) : StreamMetadata_Type.TYPE_UNSPECIFIED,
      stale: isSet(object.stale) ? globalThis.Boolean(object.stale) : false,
      mode: isSet(object.mode) ? streamMetadata_ModeFromJSON(object.mode) : StreamMetadata_Mode.MODE_UNSPECIFIED,
      definition: isSet(object.definition) ? globalThis.String(object.definition) : "",
    };
  },

  toJSON(message: StreamMetadata): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.tableName !== "") {
      obj.tableName = message.tableName;
    }
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.type !== StreamMetadata_Type.TYPE_UNSPECIFIED) {
      obj.type = streamMetadata_TypeToJSON(message.type);
    }
    if (message.stale !== false) {
      obj.stale = message.stale;
    }
    if (message.mode !== StreamMetadata_Mode.MODE_UNSPECIFIED) {
      obj.mode = streamMetadata_ModeToJSON(message.mode);
    }
    if (message.definition !== "") {
      obj.definition = message.definition;
    }
    return obj;
  },

  create(base?: DeepPartial<StreamMetadata>): StreamMetadata {
    return StreamMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamMetadata>): StreamMetadata {
    const message = createBaseStreamMetadata();
    message.name = object.name ?? "";
    message.tableName = object.tableName ?? "";
    message.owner = object.owner ?? "";
    message.comment = object.comment ?? "";
    message.type = object.type ?? StreamMetadata_Type.TYPE_UNSPECIFIED;
    message.stale = object.stale ?? false;
    message.mode = object.mode ?? StreamMetadata_Mode.MODE_UNSPECIFIED;
    message.definition = object.definition ?? "";
    return message;
  },
};

function createBaseIndexMetadata(): IndexMetadata {
  return {
    name: "",
    expressions: [],
    keyLength: [],
    descending: [],
    type: "",
    unique: false,
    primary: false,
    visible: false,
    comment: "",
    definition: "",
    parentIndexSchema: "",
    parentIndexName: "",
    granularity: Long.ZERO,
    isConstraint: false,
  };
}

export const IndexMetadata: MessageFns<IndexMetadata> = {
  encode(message: IndexMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.expressions) {
      writer.uint32(18).string(v!);
    }
    writer.uint32(74).fork();
    for (const v of message.keyLength) {
      writer.int64(v.toString());
    }
    writer.join();
    writer.uint32(82).fork();
    for (const v of message.descending) {
      writer.bool(v);
    }
    writer.join();
    if (message.type !== "") {
      writer.uint32(26).string(message.type);
    }
    if (message.unique !== false) {
      writer.uint32(32).bool(message.unique);
    }
    if (message.primary !== false) {
      writer.uint32(40).bool(message.primary);
    }
    if (message.visible !== false) {
      writer.uint32(48).bool(message.visible);
    }
    if (message.comment !== "") {
      writer.uint32(58).string(message.comment);
    }
    if (message.definition !== "") {
      writer.uint32(66).string(message.definition);
    }
    if (message.parentIndexSchema !== "") {
      writer.uint32(90).string(message.parentIndexSchema);
    }
    if (message.parentIndexName !== "") {
      writer.uint32(98).string(message.parentIndexName);
    }
    if (!message.granularity.equals(Long.ZERO)) {
      writer.uint32(104).int64(message.granularity.toString());
    }
    if (message.isConstraint !== false) {
      writer.uint32(112).bool(message.isConstraint);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IndexMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIndexMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.expressions.push(reader.string());
          continue;
        }
        case 9: {
          if (tag === 72) {
            message.keyLength.push(Long.fromString(reader.int64().toString()));

            continue;
          }

          if (tag === 74) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.keyLength.push(Long.fromString(reader.int64().toString()));
            }

            continue;
          }

          break;
        }
        case 10: {
          if (tag === 80) {
            message.descending.push(reader.bool());

            continue;
          }

          if (tag === 82) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.descending.push(reader.bool());
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.unique = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.primary = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.visible = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.comment = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.definition = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.parentIndexSchema = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.parentIndexName = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.granularity = Long.fromString(reader.int64().toString());
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.isConstraint = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IndexMetadata {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      expressions: globalThis.Array.isArray(object?.expressions)
        ? object.expressions.map((e: any) => globalThis.String(e))
        : [],
      keyLength: globalThis.Array.isArray(object?.keyLength) ? object.keyLength.map((e: any) => Long.fromValue(e)) : [],
      descending: globalThis.Array.isArray(object?.descending)
        ? object.descending.map((e: any) => globalThis.Boolean(e))
        : [],
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      unique: isSet(object.unique) ? globalThis.Boolean(object.unique) : false,
      primary: isSet(object.primary) ? globalThis.Boolean(object.primary) : false,
      visible: isSet(object.visible) ? globalThis.Boolean(object.visible) : false,
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      definition: isSet(object.definition) ? globalThis.String(object.definition) : "",
      parentIndexSchema: isSet(object.parentIndexSchema) ? globalThis.String(object.parentIndexSchema) : "",
      parentIndexName: isSet(object.parentIndexName) ? globalThis.String(object.parentIndexName) : "",
      granularity: isSet(object.granularity) ? Long.fromValue(object.granularity) : Long.ZERO,
      isConstraint: isSet(object.isConstraint) ? globalThis.Boolean(object.isConstraint) : false,
    };
  },

  toJSON(message: IndexMetadata): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.expressions?.length) {
      obj.expressions = message.expressions;
    }
    if (message.keyLength?.length) {
      obj.keyLength = message.keyLength.map((e) => (e || Long.ZERO).toString());
    }
    if (message.descending?.length) {
      obj.descending = message.descending;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.unique !== false) {
      obj.unique = message.unique;
    }
    if (message.primary !== false) {
      obj.primary = message.primary;
    }
    if (message.visible !== false) {
      obj.visible = message.visible;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.definition !== "") {
      obj.definition = message.definition;
    }
    if (message.parentIndexSchema !== "") {
      obj.parentIndexSchema = message.parentIndexSchema;
    }
    if (message.parentIndexName !== "") {
      obj.parentIndexName = message.parentIndexName;
    }
    if (!message.granularity.equals(Long.ZERO)) {
      obj.granularity = (message.granularity || Long.ZERO).toString();
    }
    if (message.isConstraint !== false) {
      obj.isConstraint = message.isConstraint;
    }
    return obj;
  },

  create(base?: DeepPartial<IndexMetadata>): IndexMetadata {
    return IndexMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IndexMetadata>): IndexMetadata {
    const message = createBaseIndexMetadata();
    message.name = object.name ?? "";
    message.expressions = object.expressions?.map((e) => e) || [];
    message.keyLength = object.keyLength?.map((e) => Long.fromValue(e)) || [];
    message.descending = object.descending?.map((e) => e) || [];
    message.type = object.type ?? "";
    message.unique = object.unique ?? false;
    message.primary = object.primary ?? false;
    message.visible = object.visible ?? false;
    message.comment = object.comment ?? "";
    message.definition = object.definition ?? "";
    message.parentIndexSchema = object.parentIndexSchema ?? "";
    message.parentIndexName = object.parentIndexName ?? "";
    message.granularity = (object.granularity !== undefined && object.granularity !== null)
      ? Long.fromValue(object.granularity)
      : Long.ZERO;
    message.isConstraint = object.isConstraint ?? false;
    return message;
  },
};

function createBaseExtensionMetadata(): ExtensionMetadata {
  return { name: "", schema: "", version: "", description: "" };
}

export const ExtensionMetadata: MessageFns<ExtensionMetadata> = {
  encode(message: ExtensionMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.schema !== "") {
      writer.uint32(18).string(message.schema);
    }
    if (message.version !== "") {
      writer.uint32(26).string(message.version);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExtensionMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExtensionMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.schema = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExtensionMetadata {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      schema: isSet(object.schema) ? globalThis.String(object.schema) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: ExtensionMetadata): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.schema !== "") {
      obj.schema = message.schema;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create(base?: DeepPartial<ExtensionMetadata>): ExtensionMetadata {
    return ExtensionMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExtensionMetadata>): ExtensionMetadata {
    const message = createBaseExtensionMetadata();
    message.name = object.name ?? "";
    message.schema = object.schema ?? "";
    message.version = object.version ?? "";
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseForeignKeyMetadata(): ForeignKeyMetadata {
  return {
    name: "",
    columns: [],
    referencedSchema: "",
    referencedTable: "",
    referencedColumns: [],
    onDelete: "",
    onUpdate: "",
    matchType: "",
  };
}

export const ForeignKeyMetadata: MessageFns<ForeignKeyMetadata> = {
  encode(message: ForeignKeyMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.columns) {
      writer.uint32(18).string(v!);
    }
    if (message.referencedSchema !== "") {
      writer.uint32(26).string(message.referencedSchema);
    }
    if (message.referencedTable !== "") {
      writer.uint32(34).string(message.referencedTable);
    }
    for (const v of message.referencedColumns) {
      writer.uint32(42).string(v!);
    }
    if (message.onDelete !== "") {
      writer.uint32(50).string(message.onDelete);
    }
    if (message.onUpdate !== "") {
      writer.uint32(58).string(message.onUpdate);
    }
    if (message.matchType !== "") {
      writer.uint32(66).string(message.matchType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ForeignKeyMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForeignKeyMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.columns.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.referencedSchema = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.referencedTable = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.referencedColumns.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.onDelete = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.onUpdate = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.matchType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ForeignKeyMetadata {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      columns: globalThis.Array.isArray(object?.columns) ? object.columns.map((e: any) => globalThis.String(e)) : [],
      referencedSchema: isSet(object.referencedSchema) ? globalThis.String(object.referencedSchema) : "",
      referencedTable: isSet(object.referencedTable) ? globalThis.String(object.referencedTable) : "",
      referencedColumns: globalThis.Array.isArray(object?.referencedColumns)
        ? object.referencedColumns.map((e: any) => globalThis.String(e))
        : [],
      onDelete: isSet(object.onDelete) ? globalThis.String(object.onDelete) : "",
      onUpdate: isSet(object.onUpdate) ? globalThis.String(object.onUpdate) : "",
      matchType: isSet(object.matchType) ? globalThis.String(object.matchType) : "",
    };
  },

  toJSON(message: ForeignKeyMetadata): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.columns?.length) {
      obj.columns = message.columns;
    }
    if (message.referencedSchema !== "") {
      obj.referencedSchema = message.referencedSchema;
    }
    if (message.referencedTable !== "") {
      obj.referencedTable = message.referencedTable;
    }
    if (message.referencedColumns?.length) {
      obj.referencedColumns = message.referencedColumns;
    }
    if (message.onDelete !== "") {
      obj.onDelete = message.onDelete;
    }
    if (message.onUpdate !== "") {
      obj.onUpdate = message.onUpdate;
    }
    if (message.matchType !== "") {
      obj.matchType = message.matchType;
    }
    return obj;
  },

  create(base?: DeepPartial<ForeignKeyMetadata>): ForeignKeyMetadata {
    return ForeignKeyMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ForeignKeyMetadata>): ForeignKeyMetadata {
    const message = createBaseForeignKeyMetadata();
    message.name = object.name ?? "";
    message.columns = object.columns?.map((e) => e) || [];
    message.referencedSchema = object.referencedSchema ?? "";
    message.referencedTable = object.referencedTable ?? "";
    message.referencedColumns = object.referencedColumns?.map((e) => e) || [];
    message.onDelete = object.onDelete ?? "";
    message.onUpdate = object.onUpdate ?? "";
    message.matchType = object.matchType ?? "";
    return message;
  },
};

function createBaseDatabaseSchema(): DatabaseSchema {
  return { schema: "" };
}

export const DatabaseSchema: MessageFns<DatabaseSchema> = {
  encode(message: DatabaseSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.schema !== "") {
      writer.uint32(10).string(message.schema);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DatabaseSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatabaseSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.schema = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DatabaseSchema {
    return { schema: isSet(object.schema) ? globalThis.String(object.schema) : "" };
  },

  toJSON(message: DatabaseSchema): unknown {
    const obj: any = {};
    if (message.schema !== "") {
      obj.schema = message.schema;
    }
    return obj;
  },

  create(base?: DeepPartial<DatabaseSchema>): DatabaseSchema {
    return DatabaseSchema.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DatabaseSchema>): DatabaseSchema {
    const message = createBaseDatabaseSchema();
    message.schema = object.schema ?? "";
    return message;
  },
};

function createBaseListSecretsRequest(): ListSecretsRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListSecretsRequest: MessageFns<ListSecretsRequest> = {
  encode(message: ListSecretsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSecretsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSecretsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSecretsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListSecretsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListSecretsRequest>): ListSecretsRequest {
    return ListSecretsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSecretsRequest>): ListSecretsRequest {
    const message = createBaseListSecretsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListSecretsResponse(): ListSecretsResponse {
  return { secrets: [], nextPageToken: "" };
}

export const ListSecretsResponse: MessageFns<ListSecretsResponse> = {
  encode(message: ListSecretsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.secrets) {
      Secret.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSecretsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSecretsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.secrets.push(Secret.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSecretsResponse {
    return {
      secrets: globalThis.Array.isArray(object?.secrets) ? object.secrets.map((e: any) => Secret.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListSecretsResponse): unknown {
    const obj: any = {};
    if (message.secrets?.length) {
      obj.secrets = message.secrets.map((e) => Secret.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListSecretsResponse>): ListSecretsResponse {
    return ListSecretsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSecretsResponse>): ListSecretsResponse {
    const message = createBaseListSecretsResponse();
    message.secrets = object.secrets?.map((e) => Secret.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseUpdateSecretRequest(): UpdateSecretRequest {
  return { secret: undefined, updateMask: undefined, allowMissing: false };
}

export const UpdateSecretRequest: MessageFns<UpdateSecretRequest> = {
  encode(message: UpdateSecretRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.secret !== undefined) {
      Secret.encode(message.secret, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    if (message.allowMissing !== false) {
      writer.uint32(24).bool(message.allowMissing);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateSecretRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSecretRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.secret = Secret.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.allowMissing = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSecretRequest {
    return {
      secret: isSet(object.secret) ? Secret.fromJSON(object.secret) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      allowMissing: isSet(object.allowMissing) ? globalThis.Boolean(object.allowMissing) : false,
    };
  },

  toJSON(message: UpdateSecretRequest): unknown {
    const obj: any = {};
    if (message.secret !== undefined) {
      obj.secret = Secret.toJSON(message.secret);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.allowMissing !== false) {
      obj.allowMissing = message.allowMissing;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateSecretRequest>): UpdateSecretRequest {
    return UpdateSecretRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateSecretRequest>): UpdateSecretRequest {
    const message = createBaseUpdateSecretRequest();
    message.secret = (object.secret !== undefined && object.secret !== null)
      ? Secret.fromPartial(object.secret)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    message.allowMissing = object.allowMissing ?? false;
    return message;
  },
};

function createBaseDeleteSecretRequest(): DeleteSecretRequest {
  return { name: "" };
}

export const DeleteSecretRequest: MessageFns<DeleteSecretRequest> = {
  encode(message: DeleteSecretRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteSecretRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteSecretRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteSecretRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteSecretRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteSecretRequest>): DeleteSecretRequest {
    return DeleteSecretRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteSecretRequest>): DeleteSecretRequest {
    const message = createBaseDeleteSecretRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseSecret(): Secret {
  return { name: "", createdTime: undefined, updatedTime: undefined, value: "", description: "" };
}

export const Secret: MessageFns<Secret> = {
  encode(message: Secret, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createdTime !== undefined) {
      Timestamp.encode(message.createdTime, writer.uint32(18).fork()).join();
    }
    if (message.updatedTime !== undefined) {
      Timestamp.encode(message.updatedTime, writer.uint32(26).fork()).join();
    }
    if (message.value !== "") {
      writer.uint32(34).string(message.value);
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Secret {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSecret();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.createdTime = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.updatedTime = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.value = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Secret {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createdTime: isSet(object.createdTime) ? fromJsonTimestamp(object.createdTime) : undefined,
      updatedTime: isSet(object.updatedTime) ? fromJsonTimestamp(object.updatedTime) : undefined,
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: Secret): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createdTime !== undefined) {
      obj.createdTime = fromTimestamp(message.createdTime).toISOString();
    }
    if (message.updatedTime !== undefined) {
      obj.updatedTime = fromTimestamp(message.updatedTime).toISOString();
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create(base?: DeepPartial<Secret>): Secret {
    return Secret.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Secret>): Secret {
    const message = createBaseSecret();
    message.name = object.name ?? "";
    message.createdTime = (object.createdTime !== undefined && object.createdTime !== null)
      ? Timestamp.fromPartial(object.createdTime)
      : undefined;
    message.updatedTime = (object.updatedTime !== undefined && object.updatedTime !== null)
      ? Timestamp.fromPartial(object.updatedTime)
      : undefined;
    message.value = object.value ?? "";
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseChangedResources(): ChangedResources {
  return { databases: [] };
}

export const ChangedResources: MessageFns<ChangedResources> = {
  encode(message: ChangedResources, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.databases) {
      ChangedResourceDatabase.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChangedResources {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangedResources();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.databases.push(ChangedResourceDatabase.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChangedResources {
    return {
      databases: globalThis.Array.isArray(object?.databases)
        ? object.databases.map((e: any) => ChangedResourceDatabase.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ChangedResources): unknown {
    const obj: any = {};
    if (message.databases?.length) {
      obj.databases = message.databases.map((e) => ChangedResourceDatabase.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ChangedResources>): ChangedResources {
    return ChangedResources.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChangedResources>): ChangedResources {
    const message = createBaseChangedResources();
    message.databases = object.databases?.map((e) => ChangedResourceDatabase.fromPartial(e)) || [];
    return message;
  },
};

function createBaseChangedResourceDatabase(): ChangedResourceDatabase {
  return { name: "", schemas: [] };
}

export const ChangedResourceDatabase: MessageFns<ChangedResourceDatabase> = {
  encode(message: ChangedResourceDatabase, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.schemas) {
      ChangedResourceSchema.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChangedResourceDatabase {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangedResourceDatabase();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.schemas.push(ChangedResourceSchema.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChangedResourceDatabase {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      schemas: globalThis.Array.isArray(object?.schemas)
        ? object.schemas.map((e: any) => ChangedResourceSchema.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ChangedResourceDatabase): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.schemas?.length) {
      obj.schemas = message.schemas.map((e) => ChangedResourceSchema.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ChangedResourceDatabase>): ChangedResourceDatabase {
    return ChangedResourceDatabase.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChangedResourceDatabase>): ChangedResourceDatabase {
    const message = createBaseChangedResourceDatabase();
    message.name = object.name ?? "";
    message.schemas = object.schemas?.map((e) => ChangedResourceSchema.fromPartial(e)) || [];
    return message;
  },
};

function createBaseChangedResourceSchema(): ChangedResourceSchema {
  return { name: "", tables: [], views: [], functions: [], procedures: [] };
}

export const ChangedResourceSchema: MessageFns<ChangedResourceSchema> = {
  encode(message: ChangedResourceSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.tables) {
      ChangedResourceTable.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.views) {
      ChangedResourceView.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.functions) {
      ChangedResourceFunction.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.procedures) {
      ChangedResourceProcedure.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChangedResourceSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangedResourceSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tables.push(ChangedResourceTable.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.views.push(ChangedResourceView.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.functions.push(ChangedResourceFunction.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.procedures.push(ChangedResourceProcedure.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChangedResourceSchema {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      tables: globalThis.Array.isArray(object?.tables)
        ? object.tables.map((e: any) => ChangedResourceTable.fromJSON(e))
        : [],
      views: globalThis.Array.isArray(object?.views)
        ? object.views.map((e: any) => ChangedResourceView.fromJSON(e))
        : [],
      functions: globalThis.Array.isArray(object?.functions)
        ? object.functions.map((e: any) => ChangedResourceFunction.fromJSON(e))
        : [],
      procedures: globalThis.Array.isArray(object?.procedures)
        ? object.procedures.map((e: any) => ChangedResourceProcedure.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ChangedResourceSchema): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.tables?.length) {
      obj.tables = message.tables.map((e) => ChangedResourceTable.toJSON(e));
    }
    if (message.views?.length) {
      obj.views = message.views.map((e) => ChangedResourceView.toJSON(e));
    }
    if (message.functions?.length) {
      obj.functions = message.functions.map((e) => ChangedResourceFunction.toJSON(e));
    }
    if (message.procedures?.length) {
      obj.procedures = message.procedures.map((e) => ChangedResourceProcedure.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ChangedResourceSchema>): ChangedResourceSchema {
    return ChangedResourceSchema.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChangedResourceSchema>): ChangedResourceSchema {
    const message = createBaseChangedResourceSchema();
    message.name = object.name ?? "";
    message.tables = object.tables?.map((e) => ChangedResourceTable.fromPartial(e)) || [];
    message.views = object.views?.map((e) => ChangedResourceView.fromPartial(e)) || [];
    message.functions = object.functions?.map((e) => ChangedResourceFunction.fromPartial(e)) || [];
    message.procedures = object.procedures?.map((e) => ChangedResourceProcedure.fromPartial(e)) || [];
    return message;
  },
};

function createBaseChangedResourceTable(): ChangedResourceTable {
  return { name: "", ranges: [] };
}

export const ChangedResourceTable: MessageFns<ChangedResourceTable> = {
  encode(message: ChangedResourceTable, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.ranges) {
      Range.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChangedResourceTable {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangedResourceTable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ranges.push(Range.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChangedResourceTable {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      ranges: globalThis.Array.isArray(object?.ranges) ? object.ranges.map((e: any) => Range.fromJSON(e)) : [],
    };
  },

  toJSON(message: ChangedResourceTable): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.ranges?.length) {
      obj.ranges = message.ranges.map((e) => Range.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ChangedResourceTable>): ChangedResourceTable {
    return ChangedResourceTable.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChangedResourceTable>): ChangedResourceTable {
    const message = createBaseChangedResourceTable();
    message.name = object.name ?? "";
    message.ranges = object.ranges?.map((e) => Range.fromPartial(e)) || [];
    return message;
  },
};

function createBaseChangedResourceView(): ChangedResourceView {
  return { name: "", ranges: [] };
}

export const ChangedResourceView: MessageFns<ChangedResourceView> = {
  encode(message: ChangedResourceView, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.ranges) {
      Range.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChangedResourceView {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangedResourceView();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ranges.push(Range.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChangedResourceView {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      ranges: globalThis.Array.isArray(object?.ranges) ? object.ranges.map((e: any) => Range.fromJSON(e)) : [],
    };
  },

  toJSON(message: ChangedResourceView): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.ranges?.length) {
      obj.ranges = message.ranges.map((e) => Range.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ChangedResourceView>): ChangedResourceView {
    return ChangedResourceView.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChangedResourceView>): ChangedResourceView {
    const message = createBaseChangedResourceView();
    message.name = object.name ?? "";
    message.ranges = object.ranges?.map((e) => Range.fromPartial(e)) || [];
    return message;
  },
};

function createBaseChangedResourceFunction(): ChangedResourceFunction {
  return { name: "", ranges: [] };
}

export const ChangedResourceFunction: MessageFns<ChangedResourceFunction> = {
  encode(message: ChangedResourceFunction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.ranges) {
      Range.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChangedResourceFunction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangedResourceFunction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ranges.push(Range.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChangedResourceFunction {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      ranges: globalThis.Array.isArray(object?.ranges) ? object.ranges.map((e: any) => Range.fromJSON(e)) : [],
    };
  },

  toJSON(message: ChangedResourceFunction): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.ranges?.length) {
      obj.ranges = message.ranges.map((e) => Range.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ChangedResourceFunction>): ChangedResourceFunction {
    return ChangedResourceFunction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChangedResourceFunction>): ChangedResourceFunction {
    const message = createBaseChangedResourceFunction();
    message.name = object.name ?? "";
    message.ranges = object.ranges?.map((e) => Range.fromPartial(e)) || [];
    return message;
  },
};

function createBaseChangedResourceProcedure(): ChangedResourceProcedure {
  return { name: "", ranges: [] };
}

export const ChangedResourceProcedure: MessageFns<ChangedResourceProcedure> = {
  encode(message: ChangedResourceProcedure, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.ranges) {
      Range.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChangedResourceProcedure {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangedResourceProcedure();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ranges.push(Range.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChangedResourceProcedure {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      ranges: globalThis.Array.isArray(object?.ranges) ? object.ranges.map((e: any) => Range.fromJSON(e)) : [],
    };
  },

  toJSON(message: ChangedResourceProcedure): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.ranges?.length) {
      obj.ranges = message.ranges.map((e) => Range.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ChangedResourceProcedure>): ChangedResourceProcedure {
    return ChangedResourceProcedure.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChangedResourceProcedure>): ChangedResourceProcedure {
    const message = createBaseChangedResourceProcedure();
    message.name = object.name ?? "";
    message.ranges = object.ranges?.map((e) => Range.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListChangelogsRequest(): ListChangelogsRequest {
  return { parent: "", pageSize: 0, pageToken: "", view: ChangelogView.CHANGELOG_VIEW_UNSPECIFIED, filter: "" };
}

export const ListChangelogsRequest: MessageFns<ListChangelogsRequest> = {
  encode(message: ListChangelogsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.view !== ChangelogView.CHANGELOG_VIEW_UNSPECIFIED) {
      writer.uint32(32).int32(changelogViewToNumber(message.view));
    }
    if (message.filter !== "") {
      writer.uint32(42).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListChangelogsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListChangelogsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.view = changelogViewFromJSON(reader.int32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.filter = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListChangelogsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      view: isSet(object.view) ? changelogViewFromJSON(object.view) : ChangelogView.CHANGELOG_VIEW_UNSPECIFIED,
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListChangelogsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.view !== ChangelogView.CHANGELOG_VIEW_UNSPECIFIED) {
      obj.view = changelogViewToJSON(message.view);
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListChangelogsRequest>): ListChangelogsRequest {
    return ListChangelogsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListChangelogsRequest>): ListChangelogsRequest {
    const message = createBaseListChangelogsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.view = object.view ?? ChangelogView.CHANGELOG_VIEW_UNSPECIFIED;
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListChangelogsResponse(): ListChangelogsResponse {
  return { changelogs: [], nextPageToken: "" };
}

export const ListChangelogsResponse: MessageFns<ListChangelogsResponse> = {
  encode(message: ListChangelogsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.changelogs) {
      Changelog.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListChangelogsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListChangelogsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.changelogs.push(Changelog.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListChangelogsResponse {
    return {
      changelogs: globalThis.Array.isArray(object?.changelogs)
        ? object.changelogs.map((e: any) => Changelog.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListChangelogsResponse): unknown {
    const obj: any = {};
    if (message.changelogs?.length) {
      obj.changelogs = message.changelogs.map((e) => Changelog.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListChangelogsResponse>): ListChangelogsResponse {
    return ListChangelogsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListChangelogsResponse>): ListChangelogsResponse {
    const message = createBaseListChangelogsResponse();
    message.changelogs = object.changelogs?.map((e) => Changelog.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetChangelogRequest(): GetChangelogRequest {
  return { name: "", view: ChangelogView.CHANGELOG_VIEW_UNSPECIFIED, sdlFormat: false };
}

export const GetChangelogRequest: MessageFns<GetChangelogRequest> = {
  encode(message: GetChangelogRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.view !== ChangelogView.CHANGELOG_VIEW_UNSPECIFIED) {
      writer.uint32(16).int32(changelogViewToNumber(message.view));
    }
    if (message.sdlFormat !== false) {
      writer.uint32(24).bool(message.sdlFormat);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetChangelogRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetChangelogRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.view = changelogViewFromJSON(reader.int32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.sdlFormat = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetChangelogRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      view: isSet(object.view) ? changelogViewFromJSON(object.view) : ChangelogView.CHANGELOG_VIEW_UNSPECIFIED,
      sdlFormat: isSet(object.sdlFormat) ? globalThis.Boolean(object.sdlFormat) : false,
    };
  },

  toJSON(message: GetChangelogRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.view !== ChangelogView.CHANGELOG_VIEW_UNSPECIFIED) {
      obj.view = changelogViewToJSON(message.view);
    }
    if (message.sdlFormat !== false) {
      obj.sdlFormat = message.sdlFormat;
    }
    return obj;
  },

  create(base?: DeepPartial<GetChangelogRequest>): GetChangelogRequest {
    return GetChangelogRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetChangelogRequest>): GetChangelogRequest {
    const message = createBaseGetChangelogRequest();
    message.name = object.name ?? "";
    message.view = object.view ?? ChangelogView.CHANGELOG_VIEW_UNSPECIFIED;
    message.sdlFormat = object.sdlFormat ?? false;
    return message;
  },
};

function createBaseChangelog(): Changelog {
  return {
    name: "",
    createTime: undefined,
    status: Changelog_Status.STATUS_UNSPECIFIED,
    statement: "",
    statementSize: Long.ZERO,
    statementSheet: "",
    schema: "",
    schemaSize: Long.ZERO,
    prevSchema: "",
    prevSchemaSize: Long.ZERO,
    issue: "",
    taskRun: "",
    version: "",
    revision: "",
    changedResources: undefined,
    type: Changelog_Type.TYPE_UNSPECIFIED,
  };
}

export const Changelog: MessageFns<Changelog> = {
  encode(message: Changelog, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(message.createTime, writer.uint32(26).fork()).join();
    }
    if (message.status !== Changelog_Status.STATUS_UNSPECIFIED) {
      writer.uint32(32).int32(changelog_StatusToNumber(message.status));
    }
    if (message.statement !== "") {
      writer.uint32(42).string(message.statement);
    }
    if (!message.statementSize.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.statementSize.toString());
    }
    if (message.statementSheet !== "") {
      writer.uint32(58).string(message.statementSheet);
    }
    if (message.schema !== "") {
      writer.uint32(66).string(message.schema);
    }
    if (!message.schemaSize.equals(Long.ZERO)) {
      writer.uint32(72).int64(message.schemaSize.toString());
    }
    if (message.prevSchema !== "") {
      writer.uint32(82).string(message.prevSchema);
    }
    if (!message.prevSchemaSize.equals(Long.ZERO)) {
      writer.uint32(88).int64(message.prevSchemaSize.toString());
    }
    if (message.issue !== "") {
      writer.uint32(98).string(message.issue);
    }
    if (message.taskRun !== "") {
      writer.uint32(106).string(message.taskRun);
    }
    if (message.version !== "") {
      writer.uint32(114).string(message.version);
    }
    if (message.revision !== "") {
      writer.uint32(122).string(message.revision);
    }
    if (message.changedResources !== undefined) {
      ChangedResources.encode(message.changedResources, writer.uint32(130).fork()).join();
    }
    if (message.type !== Changelog_Type.TYPE_UNSPECIFIED) {
      writer.uint32(136).int32(changelog_TypeToNumber(message.type));
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Changelog {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangelog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.createTime = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.status = changelog_StatusFromJSON(reader.int32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.statement = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.statementSize = Long.fromString(reader.int64().toString());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.statementSheet = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.schema = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.schemaSize = Long.fromString(reader.int64().toString());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.prevSchema = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.prevSchemaSize = Long.fromString(reader.int64().toString());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.issue = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.taskRun = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.revision = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.changedResources = ChangedResources.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.type = changelog_TypeFromJSON(reader.int32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Changelog {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      status: isSet(object.status) ? changelog_StatusFromJSON(object.status) : Changelog_Status.STATUS_UNSPECIFIED,
      statement: isSet(object.statement) ? globalThis.String(object.statement) : "",
      statementSize: isSet(object.statementSize) ? Long.fromValue(object.statementSize) : Long.ZERO,
      statementSheet: isSet(object.statementSheet) ? globalThis.String(object.statementSheet) : "",
      schema: isSet(object.schema) ? globalThis.String(object.schema) : "",
      schemaSize: isSet(object.schemaSize) ? Long.fromValue(object.schemaSize) : Long.ZERO,
      prevSchema: isSet(object.prevSchema) ? globalThis.String(object.prevSchema) : "",
      prevSchemaSize: isSet(object.prevSchemaSize) ? Long.fromValue(object.prevSchemaSize) : Long.ZERO,
      issue: isSet(object.issue) ? globalThis.String(object.issue) : "",
      taskRun: isSet(object.taskRun) ? globalThis.String(object.taskRun) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      revision: isSet(object.revision) ? globalThis.String(object.revision) : "",
      changedResources: isSet(object.changedResources) ? ChangedResources.fromJSON(object.changedResources) : undefined,
      type: isSet(object.type) ? changelog_TypeFromJSON(object.type) : Changelog_Type.TYPE_UNSPECIFIED,
    };
  },

  toJSON(message: Changelog): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = fromTimestamp(message.createTime).toISOString();
    }
    if (message.status !== Changelog_Status.STATUS_UNSPECIFIED) {
      obj.status = changelog_StatusToJSON(message.status);
    }
    if (message.statement !== "") {
      obj.statement = message.statement;
    }
    if (!message.statementSize.equals(Long.ZERO)) {
      obj.statementSize = (message.statementSize || Long.ZERO).toString();
    }
    if (message.statementSheet !== "") {
      obj.statementSheet = message.statementSheet;
    }
    if (message.schema !== "") {
      obj.schema = message.schema;
    }
    if (!message.schemaSize.equals(Long.ZERO)) {
      obj.schemaSize = (message.schemaSize || Long.ZERO).toString();
    }
    if (message.prevSchema !== "") {
      obj.prevSchema = message.prevSchema;
    }
    if (!message.prevSchemaSize.equals(Long.ZERO)) {
      obj.prevSchemaSize = (message.prevSchemaSize || Long.ZERO).toString();
    }
    if (message.issue !== "") {
      obj.issue = message.issue;
    }
    if (message.taskRun !== "") {
      obj.taskRun = message.taskRun;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.revision !== "") {
      obj.revision = message.revision;
    }
    if (message.changedResources !== undefined) {
      obj.changedResources = ChangedResources.toJSON(message.changedResources);
    }
    if (message.type !== Changelog_Type.TYPE_UNSPECIFIED) {
      obj.type = changelog_TypeToJSON(message.type);
    }
    return obj;
  },

  create(base?: DeepPartial<Changelog>): Changelog {
    return Changelog.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Changelog>): Changelog {
    const message = createBaseChangelog();
    message.name = object.name ?? "";
    message.createTime = (object.createTime !== undefined && object.createTime !== null)
      ? Timestamp.fromPartial(object.createTime)
      : undefined;
    message.status = object.status ?? Changelog_Status.STATUS_UNSPECIFIED;
    message.statement = object.statement ?? "";
    message.statementSize = (object.statementSize !== undefined && object.statementSize !== null)
      ? Long.fromValue(object.statementSize)
      : Long.ZERO;
    message.statementSheet = object.statementSheet ?? "";
    message.schema = object.schema ?? "";
    message.schemaSize = (object.schemaSize !== undefined && object.schemaSize !== null)
      ? Long.fromValue(object.schemaSize)
      : Long.ZERO;
    message.prevSchema = object.prevSchema ?? "";
    message.prevSchemaSize = (object.prevSchemaSize !== undefined && object.prevSchemaSize !== null)
      ? Long.fromValue(object.prevSchemaSize)
      : Long.ZERO;
    message.issue = object.issue ?? "";
    message.taskRun = object.taskRun ?? "";
    message.version = object.version ?? "";
    message.revision = object.revision ?? "";
    message.changedResources = (object.changedResources !== undefined && object.changedResources !== null)
      ? ChangedResources.fromPartial(object.changedResources)
      : undefined;
    message.type = object.type ?? Changelog_Type.TYPE_UNSPECIFIED;
    return message;
  },
};

function createBaseGetSchemaStringRequest(): GetSchemaStringRequest {
  return {
    name: "",
    type: GetSchemaStringRequest_ObjectType.OBJECT_TYPE_UNSPECIFIED,
    schema: "",
    object: "",
    metadata: undefined,
  };
}

export const GetSchemaStringRequest: MessageFns<GetSchemaStringRequest> = {
  encode(message: GetSchemaStringRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.type !== GetSchemaStringRequest_ObjectType.OBJECT_TYPE_UNSPECIFIED) {
      writer.uint32(16).int32(getSchemaStringRequest_ObjectTypeToNumber(message.type));
    }
    if (message.schema !== "") {
      writer.uint32(26).string(message.schema);
    }
    if (message.object !== "") {
      writer.uint32(34).string(message.object);
    }
    if (message.metadata !== undefined) {
      DatabaseMetadata.encode(message.metadata, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSchemaStringRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSchemaStringRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.type = getSchemaStringRequest_ObjectTypeFromJSON(reader.int32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.schema = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.object = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.metadata = DatabaseMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSchemaStringRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type)
        ? getSchemaStringRequest_ObjectTypeFromJSON(object.type)
        : GetSchemaStringRequest_ObjectType.OBJECT_TYPE_UNSPECIFIED,
      schema: isSet(object.schema) ? globalThis.String(object.schema) : "",
      object: isSet(object.object) ? globalThis.String(object.object) : "",
      metadata: isSet(object.metadata) ? DatabaseMetadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: GetSchemaStringRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== GetSchemaStringRequest_ObjectType.OBJECT_TYPE_UNSPECIFIED) {
      obj.type = getSchemaStringRequest_ObjectTypeToJSON(message.type);
    }
    if (message.schema !== "") {
      obj.schema = message.schema;
    }
    if (message.object !== "") {
      obj.object = message.object;
    }
    if (message.metadata !== undefined) {
      obj.metadata = DatabaseMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create(base?: DeepPartial<GetSchemaStringRequest>): GetSchemaStringRequest {
    return GetSchemaStringRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetSchemaStringRequest>): GetSchemaStringRequest {
    const message = createBaseGetSchemaStringRequest();
    message.name = object.name ?? "";
    message.type = object.type ?? GetSchemaStringRequest_ObjectType.OBJECT_TYPE_UNSPECIFIED;
    message.schema = object.schema ?? "";
    message.object = object.object ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? DatabaseMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseGetSchemaStringResponse(): GetSchemaStringResponse {
  return { schemaString: "" };
}

export const GetSchemaStringResponse: MessageFns<GetSchemaStringResponse> = {
  encode(message: GetSchemaStringResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.schemaString !== "") {
      writer.uint32(10).string(message.schemaString);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSchemaStringResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSchemaStringResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.schemaString = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSchemaStringResponse {
    return { schemaString: isSet(object.schemaString) ? globalThis.String(object.schemaString) : "" };
  },

  toJSON(message: GetSchemaStringResponse): unknown {
    const obj: any = {};
    if (message.schemaString !== "") {
      obj.schemaString = message.schemaString;
    }
    return obj;
  },

  create(base?: DeepPartial<GetSchemaStringResponse>): GetSchemaStringResponse {
    return GetSchemaStringResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetSchemaStringResponse>): GetSchemaStringResponse {
    const message = createBaseGetSchemaStringResponse();
    message.schemaString = object.schemaString ?? "";
    return message;
  },
};

export type DatabaseServiceDefinition = typeof DatabaseServiceDefinition;
export const DatabaseServiceDefinition = {
  name: "DatabaseService",
  fullName: "bytebase.v1.DatabaseService",
  methods: {
    getDatabase: {
      name: "GetDatabase",
      requestType: GetDatabaseRequest,
      requestStream: false,
      responseType: Database,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [new Uint8Array([4, 110, 97, 109, 101])],
          800010: [new Uint8Array([16, 98, 98, 46, 100, 97, 116, 97, 98, 97, 115, 101, 115, 46, 103, 101, 116])],
          800016: [new Uint8Array([1])],
          578365826: [
            new Uint8Array([
              36,
              18,
              34,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              47,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    batchGetDatabases: {
      name: "BatchGetDatabases",
      requestType: BatchGetDatabasesRequest,
      requestStream: false,
      responseType: BatchGetDatabasesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          800010: [new Uint8Array([16, 98, 98, 46, 100, 97, 116, 97, 98, 97, 115, 101, 115, 46, 103, 101, 116])],
          800016: [new Uint8Array([1])],
          578365826: [
            new Uint8Array([
              91,
              90,
              45,
              18,
              43,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              125,
              47,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
              58,
              98,
              97,
              116,
              99,
              104,
              71,
              101,
              116,
              18,
              42,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
              58,
              98,
              97,
              116,
              99,
              104,
              71,
              101,
              116,
            ]),
          ],
        },
      },
    },
    listDatabases: {
      name: "ListDatabases",
      requestType: ListDatabasesRequest,
      requestStream: false,
      responseType: ListDatabasesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [new Uint8Array([0])],
          800010: [new Uint8Array([17, 98, 98, 46, 100, 97, 116, 97, 98, 97, 115, 101, 115, 46, 108, 105, 115, 116])],
          800016: [new Uint8Array([2])],
          578365826: [
            new Uint8Array([
              112,
              90,
              36,
              18,
              34,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              125,
              47,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
              90,
              37,
              18,
              35,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              119,
              111,
              114,
              107,
              115,
              112,
              97,
              99,
              101,
              115,
              47,
              42,
              125,
              47,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
              18,
              33,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
            ]),
          ],
        },
      },
    },
    updateDatabase: {
      name: "UpdateDatabase",
      requestType: UpdateDatabaseRequest,
      requestStream: false,
      responseType: Database,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            new Uint8Array([
              20,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          800010: [
            new Uint8Array([19, 98, 98, 46, 100, 97, 116, 97, 98, 97, 115, 101, 115, 46, 117, 112, 100, 97, 116, 101]),
          ],
          800016: [new Uint8Array([1])],
          800024: [new Uint8Array([1])],
          578365826: [
            new Uint8Array([
              55,
              58,
              8,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              50,
              43,
              47,
              118,
              49,
              47,
              123,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              46,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              47,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    batchUpdateDatabases: {
      name: "BatchUpdateDatabases",
      requestType: BatchUpdateDatabasesRequest,
      requestStream: false,
      responseType: BatchUpdateDatabasesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          800010: [
            new Uint8Array([19, 98, 98, 46, 100, 97, 116, 97, 98, 97, 115, 101, 115, 46, 117, 112, 100, 97, 116, 101]),
          ],
          800016: [new Uint8Array([1])],
          800024: [new Uint8Array([1])],
          578365826: [
            new Uint8Array([
              51,
              58,
              1,
              42,
              34,
              46,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              125,
              47,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
              58,
              98,
              97,
              116,
              99,
              104,
              85,
              112,
              100,
              97,
              116,
              101,
            ]),
          ],
        },
      },
    },
    syncDatabase: {
      name: "SyncDatabase",
      requestType: SyncDatabaseRequest,
      requestStream: false,
      responseType: SyncDatabaseResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          800010: [new Uint8Array([17, 98, 98, 46, 100, 97, 116, 97, 98, 97, 115, 101, 115, 46, 115, 121, 110, 99])],
          800016: [new Uint8Array([1])],
          578365826: [
            new Uint8Array([
              44,
              58,
              1,
              42,
              34,
              39,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              47,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
              47,
              42,
              125,
              58,
              115,
              121,
              110,
              99,
            ]),
          ],
        },
      },
    },
    batchSyncDatabases: {
      name: "BatchSyncDatabases",
      requestType: BatchSyncDatabasesRequest,
      requestStream: false,
      responseType: BatchSyncDatabasesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          800010: [new Uint8Array([17, 98, 98, 46, 100, 97, 116, 97, 98, 97, 115, 101, 115, 46, 115, 121, 110, 99])],
          800016: [new Uint8Array([1])],
          578365826: [
            new Uint8Array([
              49,
              58,
              1,
              42,
              34,
              44,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              125,
              47,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
              58,
              98,
              97,
              116,
              99,
              104,
              83,
              121,
              110,
              99,
            ]),
          ],
        },
      },
    },
    getDatabaseMetadata: {
      name: "GetDatabaseMetadata",
      requestType: GetDatabaseMetadataRequest,
      requestStream: false,
      responseType: DatabaseMetadata,
      responseStream: false,
      options: {
        _unknownFields: {
          800010: [
            new Uint8Array([
              22,
              98,
              98,
              46,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
              46,
              103,
              101,
              116,
              83,
              99,
              104,
              101,
              109,
              97,
            ]),
          ],
          800016: [new Uint8Array([1])],
          578365826: [
            new Uint8Array([
              45,
              18,
              43,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              47,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
              47,
              42,
              47,
              109,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
              125,
            ]),
          ],
        },
      },
    },
    getDatabaseSchema: {
      name: "GetDatabaseSchema",
      requestType: GetDatabaseSchemaRequest,
      requestStream: false,
      responseType: DatabaseSchema,
      responseStream: false,
      options: {
        _unknownFields: {
          800010: [
            new Uint8Array([
              22,
              98,
              98,
              46,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
              46,
              103,
              101,
              116,
              83,
              99,
              104,
              101,
              109,
              97,
            ]),
          ],
          800016: [new Uint8Array([1])],
          578365826: [
            new Uint8Array([
              43,
              18,
              41,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              47,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
              47,
              42,
              47,
              115,
              99,
              104,
              101,
              109,
              97,
              125,
            ]),
          ],
        },
      },
    },
    diffSchema: {
      name: "DiffSchema",
      requestType: DiffSchemaRequest,
      requestStream: false,
      responseType: DiffSchemaResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          800010: [new Uint8Array([16, 98, 98, 46, 100, 97, 116, 97, 98, 97, 115, 101, 115, 46, 103, 101, 116])],
          800016: [new Uint8Array([1])],
          578365826: [
            new Uint8Array([
              115,
              58,
              1,
              42,
              90,
              63,
              58,
              1,
              42,
              34,
              58,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              47,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
              47,
              42,
              47,
              99,
              104,
              97,
              110,
              103,
              101,
              108,
              111,
              103,
              115,
              47,
              42,
              125,
              58,
              100,
              105,
              102,
              102,
              83,
              99,
              104,
              101,
              109,
              97,
              34,
              45,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              47,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
              47,
              42,
              125,
              58,
              100,
              105,
              102,
              102,
              83,
              99,
              104,
              101,
              109,
              97,
            ]),
          ],
        },
      },
    },
    listSecrets: {
      name: "ListSecrets",
      requestType: ListSecretsRequest,
      requestStream: false,
      responseType: ListSecretsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [new Uint8Array([6, 112, 97, 114, 101, 110, 116])],
          800010: [
            new Uint8Array([
              23,
              98,
              98,
              46,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              83,
              101,
              99,
              114,
              101,
              116,
              115,
              46,
              108,
              105,
              115,
              116,
            ]),
          ],
          800016: [new Uint8Array([1])],
          578365826: [
            new Uint8Array([
              46,
              18,
              44,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              47,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
              47,
              42,
              125,
              47,
              115,
              101,
              99,
              114,
              101,
              116,
              115,
            ]),
          ],
        },
      },
    },
    updateSecret: {
      name: "UpdateSecret",
      requestType: UpdateSecretRequest,
      requestStream: false,
      responseType: Secret,
      responseStream: false,
      options: {
        _unknownFields: {
          800010: [
            new Uint8Array([
              25,
              98,
              98,
              46,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              83,
              101,
              99,
              114,
              101,
              116,
              115,
              46,
              117,
              112,
              100,
              97,
              116,
              101,
            ]),
          ],
          800016: [new Uint8Array([1])],
          800024: [new Uint8Array([1])],
          578365826: [
            new Uint8Array([
              61,
              58,
              6,
              115,
              101,
              99,
              114,
              101,
              116,
              50,
              51,
              47,
              118,
              49,
              47,
              123,
              115,
              101,
              99,
              114,
              101,
              116,
              46,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              47,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
              47,
              42,
              47,
              115,
              101,
              99,
              114,
              101,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    deleteSecret: {
      name: "DeleteSecret",
      requestType: DeleteSecretRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          800010: [
            new Uint8Array([
              25,
              98,
              98,
              46,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              83,
              101,
              99,
              114,
              101,
              116,
              115,
              46,
              100,
              101,
              108,
              101,
              116,
              101,
            ]),
          ],
          800016: [new Uint8Array([1])],
          800024: [new Uint8Array([1])],
          578365826: [
            new Uint8Array([
              46,
              42,
              44,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              47,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
              47,
              42,
              47,
              115,
              101,
              99,
              114,
              101,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    listChangelogs: {
      name: "ListChangelogs",
      requestType: ListChangelogsRequest,
      requestStream: false,
      responseType: ListChangelogsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [new Uint8Array([6, 112, 97, 114, 101, 110, 116])],
          800010: [
            new Uint8Array([18, 98, 98, 46, 99, 104, 97, 110, 103, 101, 108, 111, 103, 115, 46, 108, 105, 115, 116]),
          ],
          800016: [new Uint8Array([1])],
          578365826: [
            new Uint8Array([
              49,
              18,
              47,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              47,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
              47,
              42,
              125,
              47,
              99,
              104,
              97,
              110,
              103,
              101,
              108,
              111,
              103,
              115,
            ]),
          ],
        },
      },
    },
    getChangelog: {
      name: "GetChangelog",
      requestType: GetChangelogRequest,
      requestStream: false,
      responseType: Changelog,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [new Uint8Array([4, 110, 97, 109, 101])],
          800010: [new Uint8Array([17, 98, 98, 46, 99, 104, 97, 110, 103, 101, 108, 111, 103, 115, 46, 103, 101, 116])],
          800016: [new Uint8Array([1])],
          578365826: [
            new Uint8Array([
              49,
              18,
              47,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              47,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
              47,
              42,
              47,
              99,
              104,
              97,
              110,
              103,
              101,
              108,
              111,
              103,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    getSchemaString: {
      name: "GetSchemaString",
      requestType: GetSchemaStringRequest,
      requestStream: false,
      responseType: GetSchemaStringResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [new Uint8Array([4, 110, 97, 109, 101])],
          800010: [
            new Uint8Array([
              22,
              98,
              98,
              46,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
              46,
              103,
              101,
              116,
              83,
              99,
              104,
              101,
              109,
              97,
            ]),
          ],
          800016: [new Uint8Array([1])],
          578365826: [
            new Uint8Array([
              49,
              18,
              47,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              47,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
              47,
              42,
              47,
              115,
              99,
              104,
              101,
              109,
              97,
              83,
              116,
              114,
              105,
              110,
              103,
              125,
            ]),
          ],
        },
      },
    },
  },
} as const;

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Timestamp {
  if (o instanceof globalThis.Date) {
    return toTimestamp(o);
  } else if (typeof o === "string") {
    return toTimestamp(new globalThis.Date(o));
  } else {
    return Timestamp.fromJSON(o);
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
