// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.3.0
//   protoc               unknown
// source: store/instance.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../google/protobuf/duration";
import { Timestamp } from "../google/protobuf/timestamp";

export const protobufPackage = "bytebase.store";

export enum DataSourceType {
  DATA_SOURCE_UNSPECIFIED = "DATA_SOURCE_UNSPECIFIED",
  ADMIN = "ADMIN",
  READ_ONLY = "READ_ONLY",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function dataSourceTypeFromJSON(object: any): DataSourceType {
  switch (object) {
    case 0:
    case "DATA_SOURCE_UNSPECIFIED":
      return DataSourceType.DATA_SOURCE_UNSPECIFIED;
    case 1:
    case "ADMIN":
      return DataSourceType.ADMIN;
    case 2:
    case "READ_ONLY":
      return DataSourceType.READ_ONLY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DataSourceType.UNRECOGNIZED;
  }
}

export function dataSourceTypeToJSON(object: DataSourceType): string {
  switch (object) {
    case DataSourceType.DATA_SOURCE_UNSPECIFIED:
      return "DATA_SOURCE_UNSPECIFIED";
    case DataSourceType.ADMIN:
      return "ADMIN";
    case DataSourceType.READ_ONLY:
      return "READ_ONLY";
    case DataSourceType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function dataSourceTypeToNumber(object: DataSourceType): number {
  switch (object) {
    case DataSourceType.DATA_SOURCE_UNSPECIFIED:
      return 0;
    case DataSourceType.ADMIN:
      return 1;
    case DataSourceType.READ_ONLY:
      return 2;
    case DataSourceType.UNRECOGNIZED:
    default:
      return -1;
  }
}

/** Instance is the proto for instances. */
export interface Instance {
  /**
   * The lower_case_table_names config for MySQL instances.
   * It is used to determine whether the table names and database names are case sensitive.
   */
  mysqlLowerCaseTableNames: number;
  lastSyncTime: Timestamp | undefined;
  roles: InstanceRole[];
  /** How often the instance is synced. */
  syncInterval:
    | Duration
    | undefined;
  /**
   * The maximum number of connections.
   * The default is 10 if the value is unset or zero.
   */
  maximumConnections: number;
  /**
   * Enable sync for following databases.
   * Default empty, means sync all schemas & databases.
   */
  syncDatabases: string[];
  dataSources: DataSource[];
}

/** InstanceRole is the API message for instance role. */
export interface InstanceRole {
  /** The role name. */
  name: string;
  /** The connection count limit for this role. */
  connectionLimit?:
    | number
    | undefined;
  /** The expiration for the role's password. */
  validUntil?:
    | string
    | undefined;
  /**
   * The role attribute.
   * For PostgreSQL, it containt super_user, no_inherit, create_role, create_db, can_login, replication and bypass_rls. Docs: https://www.postgresql.org/docs/current/role-attributes.html
   * For MySQL, it's the global privileges as GRANT statements, which means it only contains "GRANT ... ON *.* TO ...". Docs: https://dev.mysql.com/doc/refman/8.0/en/grant.html
   */
  attribute?: string | undefined;
}

export interface DataSource {
  id: string;
  type: DataSourceType;
  username: string;
  obfuscatedPassword: string;
  /** Use SSL to connect to the data source. By default, we use system default SSL configuration. */
  useSsl: boolean;
  obfuscatedSslCa: string;
  obfuscatedSslCert: string;
  obfuscatedSslKey: string;
  host: string;
  port: string;
  database: string;
  /**
   * srv, authentication_database and replica_set are used for MongoDB.
   * srv is a boolean flag that indicates whether the host is a DNS SRV record.
   */
  srv: boolean;
  /** authentication_database is the database name to authenticate against, which stores the user credentials. */
  authenticationDatabase: string;
  /** replica_set is used for MongoDB replica set. */
  replicaSet: string;
  /** sid and service_name are used for Oracle. */
  sid: string;
  serviceName: string;
  /**
   * SSH related
   * The hostname of the SSH server agent.
   */
  sshHost: string;
  /** The port of the SSH server agent. It's 22 typically. */
  sshPort: string;
  /** The user to login the server. */
  sshUser: string;
  /** The password to login the server. If it's empty string, no password is required. */
  sshObfuscatedPassword: string;
  /** The private key to login the server. If it's empty string, we will use the system default private key from os.Getenv("SSH_AUTH_SOCK"). */
  sshObfuscatedPrivateKey: string;
  /**
   * PKCS#8 private key in PEM format. If it's empty string, no private key is required.
   * Used for authentication when connecting to the data source.
   */
  authenticationPrivateKeyObfuscated: string;
  externalSecret: DataSourceExternalSecret | undefined;
  authenticationType: DataSource_AuthenticationType;
  clientSecretCredential?: DataSource_ClientSecretCredential | undefined;
  saslConfig:
    | SASLConfig
    | undefined;
  /** additional_addresses is used for MongoDB replica set. */
  additionalAddresses: DataSource_Address[];
  /** direct_connection is used for MongoDB to dispatch all the operations to the node specified in the connection string. */
  directConnection: boolean;
  /** region is the location of where the DB is, works for AWS RDS. For example, us-east-1. */
  region: string;
  /** warehouse_id is used by Databricks. */
  warehouseId: string;
  /** master_name is the master name used by connecting redis-master via redis sentinel. */
  masterName: string;
  /** master_username and master_obfuscated_password are master credentials used by redis sentinel mode. */
  masterUsername: string;
  masterObfuscatedPassword: string;
  redisType: DataSource_RedisType;
  /** Cluster is the cluster name for the data source. Used by CockroachDB. */
  cluster: string;
  /**
   * Extra connection parameters for the database connection.
   * For PostgreSQL HA, this can be used to set target_session_attrs=read-write
   */
  extraConnectionParameters: { [key: string]: string };
}

export enum DataSource_AuthenticationType {
  AUTHENTICATION_UNSPECIFIED = "AUTHENTICATION_UNSPECIFIED",
  PASSWORD = "PASSWORD",
  GOOGLE_CLOUD_SQL_IAM = "GOOGLE_CLOUD_SQL_IAM",
  AWS_RDS_IAM = "AWS_RDS_IAM",
  AZURE_IAM = "AZURE_IAM",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function dataSource_AuthenticationTypeFromJSON(object: any): DataSource_AuthenticationType {
  switch (object) {
    case 0:
    case "AUTHENTICATION_UNSPECIFIED":
      return DataSource_AuthenticationType.AUTHENTICATION_UNSPECIFIED;
    case 1:
    case "PASSWORD":
      return DataSource_AuthenticationType.PASSWORD;
    case 2:
    case "GOOGLE_CLOUD_SQL_IAM":
      return DataSource_AuthenticationType.GOOGLE_CLOUD_SQL_IAM;
    case 3:
    case "AWS_RDS_IAM":
      return DataSource_AuthenticationType.AWS_RDS_IAM;
    case 4:
    case "AZURE_IAM":
      return DataSource_AuthenticationType.AZURE_IAM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DataSource_AuthenticationType.UNRECOGNIZED;
  }
}

export function dataSource_AuthenticationTypeToJSON(object: DataSource_AuthenticationType): string {
  switch (object) {
    case DataSource_AuthenticationType.AUTHENTICATION_UNSPECIFIED:
      return "AUTHENTICATION_UNSPECIFIED";
    case DataSource_AuthenticationType.PASSWORD:
      return "PASSWORD";
    case DataSource_AuthenticationType.GOOGLE_CLOUD_SQL_IAM:
      return "GOOGLE_CLOUD_SQL_IAM";
    case DataSource_AuthenticationType.AWS_RDS_IAM:
      return "AWS_RDS_IAM";
    case DataSource_AuthenticationType.AZURE_IAM:
      return "AZURE_IAM";
    case DataSource_AuthenticationType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function dataSource_AuthenticationTypeToNumber(object: DataSource_AuthenticationType): number {
  switch (object) {
    case DataSource_AuthenticationType.AUTHENTICATION_UNSPECIFIED:
      return 0;
    case DataSource_AuthenticationType.PASSWORD:
      return 1;
    case DataSource_AuthenticationType.GOOGLE_CLOUD_SQL_IAM:
      return 2;
    case DataSource_AuthenticationType.AWS_RDS_IAM:
      return 3;
    case DataSource_AuthenticationType.AZURE_IAM:
      return 4;
    case DataSource_AuthenticationType.UNRECOGNIZED:
    default:
      return -1;
  }
}

export enum DataSource_RedisType {
  REDIS_TYPE_UNSPECIFIED = "REDIS_TYPE_UNSPECIFIED",
  STANDALONE = "STANDALONE",
  SENTINEL = "SENTINEL",
  CLUSTER = "CLUSTER",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function dataSource_RedisTypeFromJSON(object: any): DataSource_RedisType {
  switch (object) {
    case 0:
    case "REDIS_TYPE_UNSPECIFIED":
      return DataSource_RedisType.REDIS_TYPE_UNSPECIFIED;
    case 1:
    case "STANDALONE":
      return DataSource_RedisType.STANDALONE;
    case 2:
    case "SENTINEL":
      return DataSource_RedisType.SENTINEL;
    case 3:
    case "CLUSTER":
      return DataSource_RedisType.CLUSTER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DataSource_RedisType.UNRECOGNIZED;
  }
}

export function dataSource_RedisTypeToJSON(object: DataSource_RedisType): string {
  switch (object) {
    case DataSource_RedisType.REDIS_TYPE_UNSPECIFIED:
      return "REDIS_TYPE_UNSPECIFIED";
    case DataSource_RedisType.STANDALONE:
      return "STANDALONE";
    case DataSource_RedisType.SENTINEL:
      return "SENTINEL";
    case DataSource_RedisType.CLUSTER:
      return "CLUSTER";
    case DataSource_RedisType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function dataSource_RedisTypeToNumber(object: DataSource_RedisType): number {
  switch (object) {
    case DataSource_RedisType.REDIS_TYPE_UNSPECIFIED:
      return 0;
    case DataSource_RedisType.STANDALONE:
      return 1;
    case DataSource_RedisType.SENTINEL:
      return 2;
    case DataSource_RedisType.CLUSTER:
      return 3;
    case DataSource_RedisType.UNRECOGNIZED:
    default:
      return -1;
  }
}

export interface DataSource_ClientSecretCredential {
  tenantId: string;
  clientId: string;
  clientSecret: string;
}

export interface DataSource_Address {
  host: string;
  port: string;
}

export interface DataSource_ExtraConnectionParametersEntry {
  key: string;
  value: string;
}

export interface SASLConfig {
  krbConfig?: KerberosConfig | undefined;
}

export interface KerberosConfig {
  primary: string;
  instance: string;
  realm: string;
  keytab: Uint8Array;
  kdcHost: string;
  kdcPort: string;
  kdcTransportProtocol: string;
}

export interface DataSourceExternalSecret {
  secretType: DataSourceExternalSecret_SecretType;
  url: string;
  authType: DataSourceExternalSecret_AuthType;
  appRole?: DataSourceExternalSecret_AppRoleAuthOption | undefined;
  token?:
    | string
    | undefined;
  /** engine name is the name for secret engine. */
  engineName: string;
  /** the secret name in the engine to store the password. */
  secretName: string;
  /** the key name for the password. */
  passwordKeyName: string;
}

export enum DataSourceExternalSecret_SecretType {
  SAECRET_TYPE_UNSPECIFIED = "SAECRET_TYPE_UNSPECIFIED",
  /** VAULT_KV_V2 - ref: https://developer.hashicorp.com/vault/api-docs/secret/kv/kv-v2 */
  VAULT_KV_V2 = "VAULT_KV_V2",
  /** AWS_SECRETS_MANAGER - ref: https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html */
  AWS_SECRETS_MANAGER = "AWS_SECRETS_MANAGER",
  /** GCP_SECRET_MANAGER - ref: https://cloud.google.com/secret-manager/docs */
  GCP_SECRET_MANAGER = "GCP_SECRET_MANAGER",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function dataSourceExternalSecret_SecretTypeFromJSON(object: any): DataSourceExternalSecret_SecretType {
  switch (object) {
    case 0:
    case "SAECRET_TYPE_UNSPECIFIED":
      return DataSourceExternalSecret_SecretType.SAECRET_TYPE_UNSPECIFIED;
    case 1:
    case "VAULT_KV_V2":
      return DataSourceExternalSecret_SecretType.VAULT_KV_V2;
    case 2:
    case "AWS_SECRETS_MANAGER":
      return DataSourceExternalSecret_SecretType.AWS_SECRETS_MANAGER;
    case 3:
    case "GCP_SECRET_MANAGER":
      return DataSourceExternalSecret_SecretType.GCP_SECRET_MANAGER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DataSourceExternalSecret_SecretType.UNRECOGNIZED;
  }
}

export function dataSourceExternalSecret_SecretTypeToJSON(object: DataSourceExternalSecret_SecretType): string {
  switch (object) {
    case DataSourceExternalSecret_SecretType.SAECRET_TYPE_UNSPECIFIED:
      return "SAECRET_TYPE_UNSPECIFIED";
    case DataSourceExternalSecret_SecretType.VAULT_KV_V2:
      return "VAULT_KV_V2";
    case DataSourceExternalSecret_SecretType.AWS_SECRETS_MANAGER:
      return "AWS_SECRETS_MANAGER";
    case DataSourceExternalSecret_SecretType.GCP_SECRET_MANAGER:
      return "GCP_SECRET_MANAGER";
    case DataSourceExternalSecret_SecretType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function dataSourceExternalSecret_SecretTypeToNumber(object: DataSourceExternalSecret_SecretType): number {
  switch (object) {
    case DataSourceExternalSecret_SecretType.SAECRET_TYPE_UNSPECIFIED:
      return 0;
    case DataSourceExternalSecret_SecretType.VAULT_KV_V2:
      return 1;
    case DataSourceExternalSecret_SecretType.AWS_SECRETS_MANAGER:
      return 2;
    case DataSourceExternalSecret_SecretType.GCP_SECRET_MANAGER:
      return 3;
    case DataSourceExternalSecret_SecretType.UNRECOGNIZED:
    default:
      return -1;
  }
}

export enum DataSourceExternalSecret_AuthType {
  AUTH_TYPE_UNSPECIFIED = "AUTH_TYPE_UNSPECIFIED",
  /** TOKEN - ref: https://developer.hashicorp.com/vault/docs/auth/token */
  TOKEN = "TOKEN",
  /** VAULT_APP_ROLE - ref: https://developer.hashicorp.com/vault/docs/auth/approle */
  VAULT_APP_ROLE = "VAULT_APP_ROLE",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function dataSourceExternalSecret_AuthTypeFromJSON(object: any): DataSourceExternalSecret_AuthType {
  switch (object) {
    case 0:
    case "AUTH_TYPE_UNSPECIFIED":
      return DataSourceExternalSecret_AuthType.AUTH_TYPE_UNSPECIFIED;
    case 1:
    case "TOKEN":
      return DataSourceExternalSecret_AuthType.TOKEN;
    case 2:
    case "VAULT_APP_ROLE":
      return DataSourceExternalSecret_AuthType.VAULT_APP_ROLE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DataSourceExternalSecret_AuthType.UNRECOGNIZED;
  }
}

export function dataSourceExternalSecret_AuthTypeToJSON(object: DataSourceExternalSecret_AuthType): string {
  switch (object) {
    case DataSourceExternalSecret_AuthType.AUTH_TYPE_UNSPECIFIED:
      return "AUTH_TYPE_UNSPECIFIED";
    case DataSourceExternalSecret_AuthType.TOKEN:
      return "TOKEN";
    case DataSourceExternalSecret_AuthType.VAULT_APP_ROLE:
      return "VAULT_APP_ROLE";
    case DataSourceExternalSecret_AuthType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function dataSourceExternalSecret_AuthTypeToNumber(object: DataSourceExternalSecret_AuthType): number {
  switch (object) {
    case DataSourceExternalSecret_AuthType.AUTH_TYPE_UNSPECIFIED:
      return 0;
    case DataSourceExternalSecret_AuthType.TOKEN:
      return 1;
    case DataSourceExternalSecret_AuthType.VAULT_APP_ROLE:
      return 2;
    case DataSourceExternalSecret_AuthType.UNRECOGNIZED:
    default:
      return -1;
  }
}

export interface DataSourceExternalSecret_AppRoleAuthOption {
  roleId: string;
  /** the secret id for the role without ttl. */
  secretId: string;
  type: DataSourceExternalSecret_AppRoleAuthOption_SecretType;
  /** The path where the approle auth method is mounted. */
  mountPath: string;
}

export enum DataSourceExternalSecret_AppRoleAuthOption_SecretType {
  SECRET_TYPE_UNSPECIFIED = "SECRET_TYPE_UNSPECIFIED",
  PLAIN = "PLAIN",
  ENVIRONMENT = "ENVIRONMENT",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function dataSourceExternalSecret_AppRoleAuthOption_SecretTypeFromJSON(
  object: any,
): DataSourceExternalSecret_AppRoleAuthOption_SecretType {
  switch (object) {
    case 0:
    case "SECRET_TYPE_UNSPECIFIED":
      return DataSourceExternalSecret_AppRoleAuthOption_SecretType.SECRET_TYPE_UNSPECIFIED;
    case 1:
    case "PLAIN":
      return DataSourceExternalSecret_AppRoleAuthOption_SecretType.PLAIN;
    case 2:
    case "ENVIRONMENT":
      return DataSourceExternalSecret_AppRoleAuthOption_SecretType.ENVIRONMENT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DataSourceExternalSecret_AppRoleAuthOption_SecretType.UNRECOGNIZED;
  }
}

export function dataSourceExternalSecret_AppRoleAuthOption_SecretTypeToJSON(
  object: DataSourceExternalSecret_AppRoleAuthOption_SecretType,
): string {
  switch (object) {
    case DataSourceExternalSecret_AppRoleAuthOption_SecretType.SECRET_TYPE_UNSPECIFIED:
      return "SECRET_TYPE_UNSPECIFIED";
    case DataSourceExternalSecret_AppRoleAuthOption_SecretType.PLAIN:
      return "PLAIN";
    case DataSourceExternalSecret_AppRoleAuthOption_SecretType.ENVIRONMENT:
      return "ENVIRONMENT";
    case DataSourceExternalSecret_AppRoleAuthOption_SecretType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function dataSourceExternalSecret_AppRoleAuthOption_SecretTypeToNumber(
  object: DataSourceExternalSecret_AppRoleAuthOption_SecretType,
): number {
  switch (object) {
    case DataSourceExternalSecret_AppRoleAuthOption_SecretType.SECRET_TYPE_UNSPECIFIED:
      return 0;
    case DataSourceExternalSecret_AppRoleAuthOption_SecretType.PLAIN:
      return 1;
    case DataSourceExternalSecret_AppRoleAuthOption_SecretType.ENVIRONMENT:
      return 2;
    case DataSourceExternalSecret_AppRoleAuthOption_SecretType.UNRECOGNIZED:
    default:
      return -1;
  }
}

function createBaseInstance(): Instance {
  return {
    mysqlLowerCaseTableNames: 0,
    lastSyncTime: undefined,
    roles: [],
    syncInterval: undefined,
    maximumConnections: 0,
    syncDatabases: [],
    dataSources: [],
  };
}

export const Instance: MessageFns<Instance> = {
  encode(message: Instance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mysqlLowerCaseTableNames !== 0) {
      writer.uint32(8).int32(message.mysqlLowerCaseTableNames);
    }
    if (message.lastSyncTime !== undefined) {
      Timestamp.encode(message.lastSyncTime, writer.uint32(18).fork()).join();
    }
    for (const v of message.roles) {
      InstanceRole.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.syncInterval !== undefined) {
      Duration.encode(message.syncInterval, writer.uint32(34).fork()).join();
    }
    if (message.maximumConnections !== 0) {
      writer.uint32(40).int32(message.maximumConnections);
    }
    for (const v of message.syncDatabases) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.dataSources) {
      DataSource.encode(v!, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Instance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.mysqlLowerCaseTableNames = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.lastSyncTime = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.roles.push(InstanceRole.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.syncInterval = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.maximumConnections = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.syncDatabases.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.dataSources.push(DataSource.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Instance {
    return {
      mysqlLowerCaseTableNames: isSet(object.mysqlLowerCaseTableNames)
        ? globalThis.Number(object.mysqlLowerCaseTableNames)
        : 0,
      lastSyncTime: isSet(object.lastSyncTime) ? fromJsonTimestamp(object.lastSyncTime) : undefined,
      roles: globalThis.Array.isArray(object?.roles) ? object.roles.map((e: any) => InstanceRole.fromJSON(e)) : [],
      syncInterval: isSet(object.syncInterval) ? Duration.fromJSON(object.syncInterval) : undefined,
      maximumConnections: isSet(object.maximumConnections) ? globalThis.Number(object.maximumConnections) : 0,
      syncDatabases: globalThis.Array.isArray(object?.syncDatabases)
        ? object.syncDatabases.map((e: any) => globalThis.String(e))
        : [],
      dataSources: globalThis.Array.isArray(object?.dataSources)
        ? object.dataSources.map((e: any) => DataSource.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Instance): unknown {
    const obj: any = {};
    if (message.mysqlLowerCaseTableNames !== 0) {
      obj.mysqlLowerCaseTableNames = Math.round(message.mysqlLowerCaseTableNames);
    }
    if (message.lastSyncTime !== undefined) {
      obj.lastSyncTime = fromTimestamp(message.lastSyncTime).toISOString();
    }
    if (message.roles?.length) {
      obj.roles = message.roles.map((e) => InstanceRole.toJSON(e));
    }
    if (message.syncInterval !== undefined) {
      obj.syncInterval = Duration.toJSON(message.syncInterval);
    }
    if (message.maximumConnections !== 0) {
      obj.maximumConnections = Math.round(message.maximumConnections);
    }
    if (message.syncDatabases?.length) {
      obj.syncDatabases = message.syncDatabases;
    }
    if (message.dataSources?.length) {
      obj.dataSources = message.dataSources.map((e) => DataSource.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Instance>): Instance {
    return Instance.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Instance>): Instance {
    const message = createBaseInstance();
    message.mysqlLowerCaseTableNames = object.mysqlLowerCaseTableNames ?? 0;
    message.lastSyncTime = (object.lastSyncTime !== undefined && object.lastSyncTime !== null)
      ? Timestamp.fromPartial(object.lastSyncTime)
      : undefined;
    message.roles = object.roles?.map((e) => InstanceRole.fromPartial(e)) || [];
    message.syncInterval = (object.syncInterval !== undefined && object.syncInterval !== null)
      ? Duration.fromPartial(object.syncInterval)
      : undefined;
    message.maximumConnections = object.maximumConnections ?? 0;
    message.syncDatabases = object.syncDatabases?.map((e) => e) || [];
    message.dataSources = object.dataSources?.map((e) => DataSource.fromPartial(e)) || [];
    return message;
  },
};

function createBaseInstanceRole(): InstanceRole {
  return { name: "", connectionLimit: undefined, validUntil: undefined, attribute: undefined };
}

export const InstanceRole: MessageFns<InstanceRole> = {
  encode(message: InstanceRole, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.connectionLimit !== undefined) {
      writer.uint32(16).int32(message.connectionLimit);
    }
    if (message.validUntil !== undefined) {
      writer.uint32(26).string(message.validUntil);
    }
    if (message.attribute !== undefined) {
      writer.uint32(34).string(message.attribute);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InstanceRole {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstanceRole();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.connectionLimit = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.validUntil = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.attribute = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InstanceRole {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      connectionLimit: isSet(object.connectionLimit) ? globalThis.Number(object.connectionLimit) : undefined,
      validUntil: isSet(object.validUntil) ? globalThis.String(object.validUntil) : undefined,
      attribute: isSet(object.attribute) ? globalThis.String(object.attribute) : undefined,
    };
  },

  toJSON(message: InstanceRole): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.connectionLimit !== undefined) {
      obj.connectionLimit = Math.round(message.connectionLimit);
    }
    if (message.validUntil !== undefined) {
      obj.validUntil = message.validUntil;
    }
    if (message.attribute !== undefined) {
      obj.attribute = message.attribute;
    }
    return obj;
  },

  create(base?: DeepPartial<InstanceRole>): InstanceRole {
    return InstanceRole.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InstanceRole>): InstanceRole {
    const message = createBaseInstanceRole();
    message.name = object.name ?? "";
    message.connectionLimit = object.connectionLimit ?? undefined;
    message.validUntil = object.validUntil ?? undefined;
    message.attribute = object.attribute ?? undefined;
    return message;
  },
};

function createBaseDataSource(): DataSource {
  return {
    id: "",
    type: DataSourceType.DATA_SOURCE_UNSPECIFIED,
    username: "",
    obfuscatedPassword: "",
    useSsl: false,
    obfuscatedSslCa: "",
    obfuscatedSslCert: "",
    obfuscatedSslKey: "",
    host: "",
    port: "",
    database: "",
    srv: false,
    authenticationDatabase: "",
    replicaSet: "",
    sid: "",
    serviceName: "",
    sshHost: "",
    sshPort: "",
    sshUser: "",
    sshObfuscatedPassword: "",
    sshObfuscatedPrivateKey: "",
    authenticationPrivateKeyObfuscated: "",
    externalSecret: undefined,
    authenticationType: DataSource_AuthenticationType.AUTHENTICATION_UNSPECIFIED,
    clientSecretCredential: undefined,
    saslConfig: undefined,
    additionalAddresses: [],
    directConnection: false,
    region: "",
    warehouseId: "",
    masterName: "",
    masterUsername: "",
    masterObfuscatedPassword: "",
    redisType: DataSource_RedisType.REDIS_TYPE_UNSPECIFIED,
    cluster: "",
    extraConnectionParameters: {},
  };
}

export const DataSource: MessageFns<DataSource> = {
  encode(message: DataSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.type !== DataSourceType.DATA_SOURCE_UNSPECIFIED) {
      writer.uint32(16).int32(dataSourceTypeToNumber(message.type));
    }
    if (message.username !== "") {
      writer.uint32(26).string(message.username);
    }
    if (message.obfuscatedPassword !== "") {
      writer.uint32(34).string(message.obfuscatedPassword);
    }
    if (message.useSsl !== false) {
      writer.uint32(240).bool(message.useSsl);
    }
    if (message.obfuscatedSslCa !== "") {
      writer.uint32(42).string(message.obfuscatedSslCa);
    }
    if (message.obfuscatedSslCert !== "") {
      writer.uint32(50).string(message.obfuscatedSslCert);
    }
    if (message.obfuscatedSslKey !== "") {
      writer.uint32(58).string(message.obfuscatedSslKey);
    }
    if (message.host !== "") {
      writer.uint32(66).string(message.host);
    }
    if (message.port !== "") {
      writer.uint32(74).string(message.port);
    }
    if (message.database !== "") {
      writer.uint32(82).string(message.database);
    }
    if (message.srv !== false) {
      writer.uint32(88).bool(message.srv);
    }
    if (message.authenticationDatabase !== "") {
      writer.uint32(98).string(message.authenticationDatabase);
    }
    if (message.replicaSet !== "") {
      writer.uint32(202).string(message.replicaSet);
    }
    if (message.sid !== "") {
      writer.uint32(106).string(message.sid);
    }
    if (message.serviceName !== "") {
      writer.uint32(114).string(message.serviceName);
    }
    if (message.sshHost !== "") {
      writer.uint32(122).string(message.sshHost);
    }
    if (message.sshPort !== "") {
      writer.uint32(130).string(message.sshPort);
    }
    if (message.sshUser !== "") {
      writer.uint32(138).string(message.sshUser);
    }
    if (message.sshObfuscatedPassword !== "") {
      writer.uint32(146).string(message.sshObfuscatedPassword);
    }
    if (message.sshObfuscatedPrivateKey !== "") {
      writer.uint32(154).string(message.sshObfuscatedPrivateKey);
    }
    if (message.authenticationPrivateKeyObfuscated !== "") {
      writer.uint32(162).string(message.authenticationPrivateKeyObfuscated);
    }
    if (message.externalSecret !== undefined) {
      DataSourceExternalSecret.encode(message.externalSecret, writer.uint32(170).fork()).join();
    }
    if (message.authenticationType !== DataSource_AuthenticationType.AUTHENTICATION_UNSPECIFIED) {
      writer.uint32(176).int32(dataSource_AuthenticationTypeToNumber(message.authenticationType));
    }
    if (message.clientSecretCredential !== undefined) {
      DataSource_ClientSecretCredential.encode(message.clientSecretCredential, writer.uint32(186).fork()).join();
    }
    if (message.saslConfig !== undefined) {
      SASLConfig.encode(message.saslConfig, writer.uint32(194).fork()).join();
    }
    for (const v of message.additionalAddresses) {
      DataSource_Address.encode(v!, writer.uint32(210).fork()).join();
    }
    if (message.directConnection !== false) {
      writer.uint32(216).bool(message.directConnection);
    }
    if (message.region !== "") {
      writer.uint32(226).string(message.region);
    }
    if (message.warehouseId !== "") {
      writer.uint32(234).string(message.warehouseId);
    }
    if (message.masterName !== "") {
      writer.uint32(250).string(message.masterName);
    }
    if (message.masterUsername !== "") {
      writer.uint32(258).string(message.masterUsername);
    }
    if (message.masterObfuscatedPassword !== "") {
      writer.uint32(266).string(message.masterObfuscatedPassword);
    }
    if (message.redisType !== DataSource_RedisType.REDIS_TYPE_UNSPECIFIED) {
      writer.uint32(272).int32(dataSource_RedisTypeToNumber(message.redisType));
    }
    if (message.cluster !== "") {
      writer.uint32(282).string(message.cluster);
    }
    Object.entries(message.extraConnectionParameters).forEach(([key, value]) => {
      DataSource_ExtraConnectionParametersEntry.encode({ key: key as any, value }, writer.uint32(290).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.type = dataSourceTypeFromJSON(reader.int32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.obfuscatedPassword = reader.string();
          continue;
        }
        case 30: {
          if (tag !== 240) {
            break;
          }

          message.useSsl = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.obfuscatedSslCa = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.obfuscatedSslCert = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.obfuscatedSslKey = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.host = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.port = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.database = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.srv = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.authenticationDatabase = reader.string();
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.replicaSet = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.sid = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.serviceName = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.sshHost = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.sshPort = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.sshUser = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.sshObfuscatedPassword = reader.string();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.sshObfuscatedPrivateKey = reader.string();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.authenticationPrivateKeyObfuscated = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.externalSecret = DataSourceExternalSecret.decode(reader, reader.uint32());
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }

          message.authenticationType = dataSource_AuthenticationTypeFromJSON(reader.int32());
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.clientSecretCredential = DataSource_ClientSecretCredential.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.saslConfig = SASLConfig.decode(reader, reader.uint32());
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.additionalAddresses.push(DataSource_Address.decode(reader, reader.uint32()));
          continue;
        }
        case 27: {
          if (tag !== 216) {
            break;
          }

          message.directConnection = reader.bool();
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }

          message.region = reader.string();
          continue;
        }
        case 29: {
          if (tag !== 234) {
            break;
          }

          message.warehouseId = reader.string();
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }

          message.masterName = reader.string();
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }

          message.masterUsername = reader.string();
          continue;
        }
        case 33: {
          if (tag !== 266) {
            break;
          }

          message.masterObfuscatedPassword = reader.string();
          continue;
        }
        case 34: {
          if (tag !== 272) {
            break;
          }

          message.redisType = dataSource_RedisTypeFromJSON(reader.int32());
          continue;
        }
        case 35: {
          if (tag !== 282) {
            break;
          }

          message.cluster = reader.string();
          continue;
        }
        case 36: {
          if (tag !== 290) {
            break;
          }

          const entry36 = DataSource_ExtraConnectionParametersEntry.decode(reader, reader.uint32());
          if (entry36.value !== undefined) {
            message.extraConnectionParameters[entry36.key] = entry36.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataSource {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      type: isSet(object.type) ? dataSourceTypeFromJSON(object.type) : DataSourceType.DATA_SOURCE_UNSPECIFIED,
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      obfuscatedPassword: isSet(object.obfuscatedPassword) ? globalThis.String(object.obfuscatedPassword) : "",
      useSsl: isSet(object.useSsl) ? globalThis.Boolean(object.useSsl) : false,
      obfuscatedSslCa: isSet(object.obfuscatedSslCa) ? globalThis.String(object.obfuscatedSslCa) : "",
      obfuscatedSslCert: isSet(object.obfuscatedSslCert) ? globalThis.String(object.obfuscatedSslCert) : "",
      obfuscatedSslKey: isSet(object.obfuscatedSslKey) ? globalThis.String(object.obfuscatedSslKey) : "",
      host: isSet(object.host) ? globalThis.String(object.host) : "",
      port: isSet(object.port) ? globalThis.String(object.port) : "",
      database: isSet(object.database) ? globalThis.String(object.database) : "",
      srv: isSet(object.srv) ? globalThis.Boolean(object.srv) : false,
      authenticationDatabase: isSet(object.authenticationDatabase)
        ? globalThis.String(object.authenticationDatabase)
        : "",
      replicaSet: isSet(object.replicaSet) ? globalThis.String(object.replicaSet) : "",
      sid: isSet(object.sid) ? globalThis.String(object.sid) : "",
      serviceName: isSet(object.serviceName) ? globalThis.String(object.serviceName) : "",
      sshHost: isSet(object.sshHost) ? globalThis.String(object.sshHost) : "",
      sshPort: isSet(object.sshPort) ? globalThis.String(object.sshPort) : "",
      sshUser: isSet(object.sshUser) ? globalThis.String(object.sshUser) : "",
      sshObfuscatedPassword: isSet(object.sshObfuscatedPassword) ? globalThis.String(object.sshObfuscatedPassword) : "",
      sshObfuscatedPrivateKey: isSet(object.sshObfuscatedPrivateKey)
        ? globalThis.String(object.sshObfuscatedPrivateKey)
        : "",
      authenticationPrivateKeyObfuscated: isSet(object.authenticationPrivateKeyObfuscated)
        ? globalThis.String(object.authenticationPrivateKeyObfuscated)
        : "",
      externalSecret: isSet(object.externalSecret)
        ? DataSourceExternalSecret.fromJSON(object.externalSecret)
        : undefined,
      authenticationType: isSet(object.authenticationType)
        ? dataSource_AuthenticationTypeFromJSON(object.authenticationType)
        : DataSource_AuthenticationType.AUTHENTICATION_UNSPECIFIED,
      clientSecretCredential: isSet(object.clientSecretCredential)
        ? DataSource_ClientSecretCredential.fromJSON(object.clientSecretCredential)
        : undefined,
      saslConfig: isSet(object.saslConfig) ? SASLConfig.fromJSON(object.saslConfig) : undefined,
      additionalAddresses: globalThis.Array.isArray(object?.additionalAddresses)
        ? object.additionalAddresses.map((e: any) => DataSource_Address.fromJSON(e))
        : [],
      directConnection: isSet(object.directConnection) ? globalThis.Boolean(object.directConnection) : false,
      region: isSet(object.region) ? globalThis.String(object.region) : "",
      warehouseId: isSet(object.warehouseId) ? globalThis.String(object.warehouseId) : "",
      masterName: isSet(object.masterName) ? globalThis.String(object.masterName) : "",
      masterUsername: isSet(object.masterUsername) ? globalThis.String(object.masterUsername) : "",
      masterObfuscatedPassword: isSet(object.masterObfuscatedPassword)
        ? globalThis.String(object.masterObfuscatedPassword)
        : "",
      redisType: isSet(object.redisType)
        ? dataSource_RedisTypeFromJSON(object.redisType)
        : DataSource_RedisType.REDIS_TYPE_UNSPECIFIED,
      cluster: isSet(object.cluster) ? globalThis.String(object.cluster) : "",
      extraConnectionParameters: isObject(object.extraConnectionParameters)
        ? Object.entries(object.extraConnectionParameters).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: DataSource): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.type !== DataSourceType.DATA_SOURCE_UNSPECIFIED) {
      obj.type = dataSourceTypeToJSON(message.type);
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.obfuscatedPassword !== "") {
      obj.obfuscatedPassword = message.obfuscatedPassword;
    }
    if (message.useSsl !== false) {
      obj.useSsl = message.useSsl;
    }
    if (message.obfuscatedSslCa !== "") {
      obj.obfuscatedSslCa = message.obfuscatedSslCa;
    }
    if (message.obfuscatedSslCert !== "") {
      obj.obfuscatedSslCert = message.obfuscatedSslCert;
    }
    if (message.obfuscatedSslKey !== "") {
      obj.obfuscatedSslKey = message.obfuscatedSslKey;
    }
    if (message.host !== "") {
      obj.host = message.host;
    }
    if (message.port !== "") {
      obj.port = message.port;
    }
    if (message.database !== "") {
      obj.database = message.database;
    }
    if (message.srv !== false) {
      obj.srv = message.srv;
    }
    if (message.authenticationDatabase !== "") {
      obj.authenticationDatabase = message.authenticationDatabase;
    }
    if (message.replicaSet !== "") {
      obj.replicaSet = message.replicaSet;
    }
    if (message.sid !== "") {
      obj.sid = message.sid;
    }
    if (message.serviceName !== "") {
      obj.serviceName = message.serviceName;
    }
    if (message.sshHost !== "") {
      obj.sshHost = message.sshHost;
    }
    if (message.sshPort !== "") {
      obj.sshPort = message.sshPort;
    }
    if (message.sshUser !== "") {
      obj.sshUser = message.sshUser;
    }
    if (message.sshObfuscatedPassword !== "") {
      obj.sshObfuscatedPassword = message.sshObfuscatedPassword;
    }
    if (message.sshObfuscatedPrivateKey !== "") {
      obj.sshObfuscatedPrivateKey = message.sshObfuscatedPrivateKey;
    }
    if (message.authenticationPrivateKeyObfuscated !== "") {
      obj.authenticationPrivateKeyObfuscated = message.authenticationPrivateKeyObfuscated;
    }
    if (message.externalSecret !== undefined) {
      obj.externalSecret = DataSourceExternalSecret.toJSON(message.externalSecret);
    }
    if (message.authenticationType !== DataSource_AuthenticationType.AUTHENTICATION_UNSPECIFIED) {
      obj.authenticationType = dataSource_AuthenticationTypeToJSON(message.authenticationType);
    }
    if (message.clientSecretCredential !== undefined) {
      obj.clientSecretCredential = DataSource_ClientSecretCredential.toJSON(message.clientSecretCredential);
    }
    if (message.saslConfig !== undefined) {
      obj.saslConfig = SASLConfig.toJSON(message.saslConfig);
    }
    if (message.additionalAddresses?.length) {
      obj.additionalAddresses = message.additionalAddresses.map((e) => DataSource_Address.toJSON(e));
    }
    if (message.directConnection !== false) {
      obj.directConnection = message.directConnection;
    }
    if (message.region !== "") {
      obj.region = message.region;
    }
    if (message.warehouseId !== "") {
      obj.warehouseId = message.warehouseId;
    }
    if (message.masterName !== "") {
      obj.masterName = message.masterName;
    }
    if (message.masterUsername !== "") {
      obj.masterUsername = message.masterUsername;
    }
    if (message.masterObfuscatedPassword !== "") {
      obj.masterObfuscatedPassword = message.masterObfuscatedPassword;
    }
    if (message.redisType !== DataSource_RedisType.REDIS_TYPE_UNSPECIFIED) {
      obj.redisType = dataSource_RedisTypeToJSON(message.redisType);
    }
    if (message.cluster !== "") {
      obj.cluster = message.cluster;
    }
    if (message.extraConnectionParameters) {
      const entries = Object.entries(message.extraConnectionParameters);
      if (entries.length > 0) {
        obj.extraConnectionParameters = {};
        entries.forEach(([k, v]) => {
          obj.extraConnectionParameters[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<DataSource>): DataSource {
    return DataSource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataSource>): DataSource {
    const message = createBaseDataSource();
    message.id = object.id ?? "";
    message.type = object.type ?? DataSourceType.DATA_SOURCE_UNSPECIFIED;
    message.username = object.username ?? "";
    message.obfuscatedPassword = object.obfuscatedPassword ?? "";
    message.useSsl = object.useSsl ?? false;
    message.obfuscatedSslCa = object.obfuscatedSslCa ?? "";
    message.obfuscatedSslCert = object.obfuscatedSslCert ?? "";
    message.obfuscatedSslKey = object.obfuscatedSslKey ?? "";
    message.host = object.host ?? "";
    message.port = object.port ?? "";
    message.database = object.database ?? "";
    message.srv = object.srv ?? false;
    message.authenticationDatabase = object.authenticationDatabase ?? "";
    message.replicaSet = object.replicaSet ?? "";
    message.sid = object.sid ?? "";
    message.serviceName = object.serviceName ?? "";
    message.sshHost = object.sshHost ?? "";
    message.sshPort = object.sshPort ?? "";
    message.sshUser = object.sshUser ?? "";
    message.sshObfuscatedPassword = object.sshObfuscatedPassword ?? "";
    message.sshObfuscatedPrivateKey = object.sshObfuscatedPrivateKey ?? "";
    message.authenticationPrivateKeyObfuscated = object.authenticationPrivateKeyObfuscated ?? "";
    message.externalSecret = (object.externalSecret !== undefined && object.externalSecret !== null)
      ? DataSourceExternalSecret.fromPartial(object.externalSecret)
      : undefined;
    message.authenticationType = object.authenticationType ?? DataSource_AuthenticationType.AUTHENTICATION_UNSPECIFIED;
    message.clientSecretCredential =
      (object.clientSecretCredential !== undefined && object.clientSecretCredential !== null)
        ? DataSource_ClientSecretCredential.fromPartial(object.clientSecretCredential)
        : undefined;
    message.saslConfig = (object.saslConfig !== undefined && object.saslConfig !== null)
      ? SASLConfig.fromPartial(object.saslConfig)
      : undefined;
    message.additionalAddresses = object.additionalAddresses?.map((e) => DataSource_Address.fromPartial(e)) || [];
    message.directConnection = object.directConnection ?? false;
    message.region = object.region ?? "";
    message.warehouseId = object.warehouseId ?? "";
    message.masterName = object.masterName ?? "";
    message.masterUsername = object.masterUsername ?? "";
    message.masterObfuscatedPassword = object.masterObfuscatedPassword ?? "";
    message.redisType = object.redisType ?? DataSource_RedisType.REDIS_TYPE_UNSPECIFIED;
    message.cluster = object.cluster ?? "";
    message.extraConnectionParameters = Object.entries(object.extraConnectionParameters ?? {}).reduce<
      { [key: string]: string }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseDataSource_ClientSecretCredential(): DataSource_ClientSecretCredential {
  return { tenantId: "", clientId: "", clientSecret: "" };
}

export const DataSource_ClientSecretCredential: MessageFns<DataSource_ClientSecretCredential> = {
  encode(message: DataSource_ClientSecretCredential, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tenantId !== "") {
      writer.uint32(10).string(message.tenantId);
    }
    if (message.clientId !== "") {
      writer.uint32(18).string(message.clientId);
    }
    if (message.clientSecret !== "") {
      writer.uint32(26).string(message.clientSecret);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataSource_ClientSecretCredential {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataSource_ClientSecretCredential();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tenantId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.clientSecret = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataSource_ClientSecretCredential {
    return {
      tenantId: isSet(object.tenantId) ? globalThis.String(object.tenantId) : "",
      clientId: isSet(object.clientId) ? globalThis.String(object.clientId) : "",
      clientSecret: isSet(object.clientSecret) ? globalThis.String(object.clientSecret) : "",
    };
  },

  toJSON(message: DataSource_ClientSecretCredential): unknown {
    const obj: any = {};
    if (message.tenantId !== "") {
      obj.tenantId = message.tenantId;
    }
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.clientSecret !== "") {
      obj.clientSecret = message.clientSecret;
    }
    return obj;
  },

  create(base?: DeepPartial<DataSource_ClientSecretCredential>): DataSource_ClientSecretCredential {
    return DataSource_ClientSecretCredential.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataSource_ClientSecretCredential>): DataSource_ClientSecretCredential {
    const message = createBaseDataSource_ClientSecretCredential();
    message.tenantId = object.tenantId ?? "";
    message.clientId = object.clientId ?? "";
    message.clientSecret = object.clientSecret ?? "";
    return message;
  },
};

function createBaseDataSource_Address(): DataSource_Address {
  return { host: "", port: "" };
}

export const DataSource_Address: MessageFns<DataSource_Address> = {
  encode(message: DataSource_Address, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.host !== "") {
      writer.uint32(10).string(message.host);
    }
    if (message.port !== "") {
      writer.uint32(18).string(message.port);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataSource_Address {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataSource_Address();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.host = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.port = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataSource_Address {
    return {
      host: isSet(object.host) ? globalThis.String(object.host) : "",
      port: isSet(object.port) ? globalThis.String(object.port) : "",
    };
  },

  toJSON(message: DataSource_Address): unknown {
    const obj: any = {};
    if (message.host !== "") {
      obj.host = message.host;
    }
    if (message.port !== "") {
      obj.port = message.port;
    }
    return obj;
  },

  create(base?: DeepPartial<DataSource_Address>): DataSource_Address {
    return DataSource_Address.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataSource_Address>): DataSource_Address {
    const message = createBaseDataSource_Address();
    message.host = object.host ?? "";
    message.port = object.port ?? "";
    return message;
  },
};

function createBaseDataSource_ExtraConnectionParametersEntry(): DataSource_ExtraConnectionParametersEntry {
  return { key: "", value: "" };
}

export const DataSource_ExtraConnectionParametersEntry: MessageFns<DataSource_ExtraConnectionParametersEntry> = {
  encode(message: DataSource_ExtraConnectionParametersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataSource_ExtraConnectionParametersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataSource_ExtraConnectionParametersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataSource_ExtraConnectionParametersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: DataSource_ExtraConnectionParametersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<DataSource_ExtraConnectionParametersEntry>): DataSource_ExtraConnectionParametersEntry {
    return DataSource_ExtraConnectionParametersEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<DataSource_ExtraConnectionParametersEntry>,
  ): DataSource_ExtraConnectionParametersEntry {
    const message = createBaseDataSource_ExtraConnectionParametersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSASLConfig(): SASLConfig {
  return { krbConfig: undefined };
}

export const SASLConfig: MessageFns<SASLConfig> = {
  encode(message: SASLConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.krbConfig !== undefined) {
      KerberosConfig.encode(message.krbConfig, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SASLConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSASLConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.krbConfig = KerberosConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SASLConfig {
    return { krbConfig: isSet(object.krbConfig) ? KerberosConfig.fromJSON(object.krbConfig) : undefined };
  },

  toJSON(message: SASLConfig): unknown {
    const obj: any = {};
    if (message.krbConfig !== undefined) {
      obj.krbConfig = KerberosConfig.toJSON(message.krbConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<SASLConfig>): SASLConfig {
    return SASLConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SASLConfig>): SASLConfig {
    const message = createBaseSASLConfig();
    message.krbConfig = (object.krbConfig !== undefined && object.krbConfig !== null)
      ? KerberosConfig.fromPartial(object.krbConfig)
      : undefined;
    return message;
  },
};

function createBaseKerberosConfig(): KerberosConfig {
  return {
    primary: "",
    instance: "",
    realm: "",
    keytab: new Uint8Array(0),
    kdcHost: "",
    kdcPort: "",
    kdcTransportProtocol: "",
  };
}

export const KerberosConfig: MessageFns<KerberosConfig> = {
  encode(message: KerberosConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.primary !== "") {
      writer.uint32(10).string(message.primary);
    }
    if (message.instance !== "") {
      writer.uint32(18).string(message.instance);
    }
    if (message.realm !== "") {
      writer.uint32(26).string(message.realm);
    }
    if (message.keytab.length !== 0) {
      writer.uint32(34).bytes(message.keytab);
    }
    if (message.kdcHost !== "") {
      writer.uint32(42).string(message.kdcHost);
    }
    if (message.kdcPort !== "") {
      writer.uint32(50).string(message.kdcPort);
    }
    if (message.kdcTransportProtocol !== "") {
      writer.uint32(58).string(message.kdcTransportProtocol);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KerberosConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKerberosConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.primary = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.instance = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.realm = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.keytab = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.kdcHost = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.kdcPort = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.kdcTransportProtocol = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KerberosConfig {
    return {
      primary: isSet(object.primary) ? globalThis.String(object.primary) : "",
      instance: isSet(object.instance) ? globalThis.String(object.instance) : "",
      realm: isSet(object.realm) ? globalThis.String(object.realm) : "",
      keytab: isSet(object.keytab) ? bytesFromBase64(object.keytab) : new Uint8Array(0),
      kdcHost: isSet(object.kdcHost) ? globalThis.String(object.kdcHost) : "",
      kdcPort: isSet(object.kdcPort) ? globalThis.String(object.kdcPort) : "",
      kdcTransportProtocol: isSet(object.kdcTransportProtocol) ? globalThis.String(object.kdcTransportProtocol) : "",
    };
  },

  toJSON(message: KerberosConfig): unknown {
    const obj: any = {};
    if (message.primary !== "") {
      obj.primary = message.primary;
    }
    if (message.instance !== "") {
      obj.instance = message.instance;
    }
    if (message.realm !== "") {
      obj.realm = message.realm;
    }
    if (message.keytab.length !== 0) {
      obj.keytab = base64FromBytes(message.keytab);
    }
    if (message.kdcHost !== "") {
      obj.kdcHost = message.kdcHost;
    }
    if (message.kdcPort !== "") {
      obj.kdcPort = message.kdcPort;
    }
    if (message.kdcTransportProtocol !== "") {
      obj.kdcTransportProtocol = message.kdcTransportProtocol;
    }
    return obj;
  },

  create(base?: DeepPartial<KerberosConfig>): KerberosConfig {
    return KerberosConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KerberosConfig>): KerberosConfig {
    const message = createBaseKerberosConfig();
    message.primary = object.primary ?? "";
    message.instance = object.instance ?? "";
    message.realm = object.realm ?? "";
    message.keytab = object.keytab ?? new Uint8Array(0);
    message.kdcHost = object.kdcHost ?? "";
    message.kdcPort = object.kdcPort ?? "";
    message.kdcTransportProtocol = object.kdcTransportProtocol ?? "";
    return message;
  },
};

function createBaseDataSourceExternalSecret(): DataSourceExternalSecret {
  return {
    secretType: DataSourceExternalSecret_SecretType.SAECRET_TYPE_UNSPECIFIED,
    url: "",
    authType: DataSourceExternalSecret_AuthType.AUTH_TYPE_UNSPECIFIED,
    appRole: undefined,
    token: undefined,
    engineName: "",
    secretName: "",
    passwordKeyName: "",
  };
}

export const DataSourceExternalSecret: MessageFns<DataSourceExternalSecret> = {
  encode(message: DataSourceExternalSecret, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.secretType !== DataSourceExternalSecret_SecretType.SAECRET_TYPE_UNSPECIFIED) {
      writer.uint32(8).int32(dataSourceExternalSecret_SecretTypeToNumber(message.secretType));
    }
    if (message.url !== "") {
      writer.uint32(18).string(message.url);
    }
    if (message.authType !== DataSourceExternalSecret_AuthType.AUTH_TYPE_UNSPECIFIED) {
      writer.uint32(24).int32(dataSourceExternalSecret_AuthTypeToNumber(message.authType));
    }
    if (message.appRole !== undefined) {
      DataSourceExternalSecret_AppRoleAuthOption.encode(message.appRole, writer.uint32(34).fork()).join();
    }
    if (message.token !== undefined) {
      writer.uint32(42).string(message.token);
    }
    if (message.engineName !== "") {
      writer.uint32(50).string(message.engineName);
    }
    if (message.secretName !== "") {
      writer.uint32(58).string(message.secretName);
    }
    if (message.passwordKeyName !== "") {
      writer.uint32(66).string(message.passwordKeyName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataSourceExternalSecret {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataSourceExternalSecret();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.secretType = dataSourceExternalSecret_SecretTypeFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.authType = dataSourceExternalSecret_AuthTypeFromJSON(reader.int32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.appRole = DataSourceExternalSecret_AppRoleAuthOption.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.token = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.engineName = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.secretName = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.passwordKeyName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataSourceExternalSecret {
    return {
      secretType: isSet(object.secretType)
        ? dataSourceExternalSecret_SecretTypeFromJSON(object.secretType)
        : DataSourceExternalSecret_SecretType.SAECRET_TYPE_UNSPECIFIED,
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      authType: isSet(object.authType)
        ? dataSourceExternalSecret_AuthTypeFromJSON(object.authType)
        : DataSourceExternalSecret_AuthType.AUTH_TYPE_UNSPECIFIED,
      appRole: isSet(object.appRole) ? DataSourceExternalSecret_AppRoleAuthOption.fromJSON(object.appRole) : undefined,
      token: isSet(object.token) ? globalThis.String(object.token) : undefined,
      engineName: isSet(object.engineName) ? globalThis.String(object.engineName) : "",
      secretName: isSet(object.secretName) ? globalThis.String(object.secretName) : "",
      passwordKeyName: isSet(object.passwordKeyName) ? globalThis.String(object.passwordKeyName) : "",
    };
  },

  toJSON(message: DataSourceExternalSecret): unknown {
    const obj: any = {};
    if (message.secretType !== DataSourceExternalSecret_SecretType.SAECRET_TYPE_UNSPECIFIED) {
      obj.secretType = dataSourceExternalSecret_SecretTypeToJSON(message.secretType);
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.authType !== DataSourceExternalSecret_AuthType.AUTH_TYPE_UNSPECIFIED) {
      obj.authType = dataSourceExternalSecret_AuthTypeToJSON(message.authType);
    }
    if (message.appRole !== undefined) {
      obj.appRole = DataSourceExternalSecret_AppRoleAuthOption.toJSON(message.appRole);
    }
    if (message.token !== undefined) {
      obj.token = message.token;
    }
    if (message.engineName !== "") {
      obj.engineName = message.engineName;
    }
    if (message.secretName !== "") {
      obj.secretName = message.secretName;
    }
    if (message.passwordKeyName !== "") {
      obj.passwordKeyName = message.passwordKeyName;
    }
    return obj;
  },

  create(base?: DeepPartial<DataSourceExternalSecret>): DataSourceExternalSecret {
    return DataSourceExternalSecret.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataSourceExternalSecret>): DataSourceExternalSecret {
    const message = createBaseDataSourceExternalSecret();
    message.secretType = object.secretType ?? DataSourceExternalSecret_SecretType.SAECRET_TYPE_UNSPECIFIED;
    message.url = object.url ?? "";
    message.authType = object.authType ?? DataSourceExternalSecret_AuthType.AUTH_TYPE_UNSPECIFIED;
    message.appRole = (object.appRole !== undefined && object.appRole !== null)
      ? DataSourceExternalSecret_AppRoleAuthOption.fromPartial(object.appRole)
      : undefined;
    message.token = object.token ?? undefined;
    message.engineName = object.engineName ?? "";
    message.secretName = object.secretName ?? "";
    message.passwordKeyName = object.passwordKeyName ?? "";
    return message;
  },
};

function createBaseDataSourceExternalSecret_AppRoleAuthOption(): DataSourceExternalSecret_AppRoleAuthOption {
  return {
    roleId: "",
    secretId: "",
    type: DataSourceExternalSecret_AppRoleAuthOption_SecretType.SECRET_TYPE_UNSPECIFIED,
    mountPath: "",
  };
}

export const DataSourceExternalSecret_AppRoleAuthOption: MessageFns<DataSourceExternalSecret_AppRoleAuthOption> = {
  encode(message: DataSourceExternalSecret_AppRoleAuthOption, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.roleId !== "") {
      writer.uint32(10).string(message.roleId);
    }
    if (message.secretId !== "") {
      writer.uint32(18).string(message.secretId);
    }
    if (message.type !== DataSourceExternalSecret_AppRoleAuthOption_SecretType.SECRET_TYPE_UNSPECIFIED) {
      writer.uint32(24).int32(dataSourceExternalSecret_AppRoleAuthOption_SecretTypeToNumber(message.type));
    }
    if (message.mountPath !== "") {
      writer.uint32(34).string(message.mountPath);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataSourceExternalSecret_AppRoleAuthOption {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataSourceExternalSecret_AppRoleAuthOption();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.roleId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.secretId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.type = dataSourceExternalSecret_AppRoleAuthOption_SecretTypeFromJSON(reader.int32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.mountPath = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataSourceExternalSecret_AppRoleAuthOption {
    return {
      roleId: isSet(object.roleId) ? globalThis.String(object.roleId) : "",
      secretId: isSet(object.secretId) ? globalThis.String(object.secretId) : "",
      type: isSet(object.type)
        ? dataSourceExternalSecret_AppRoleAuthOption_SecretTypeFromJSON(object.type)
        : DataSourceExternalSecret_AppRoleAuthOption_SecretType.SECRET_TYPE_UNSPECIFIED,
      mountPath: isSet(object.mountPath) ? globalThis.String(object.mountPath) : "",
    };
  },

  toJSON(message: DataSourceExternalSecret_AppRoleAuthOption): unknown {
    const obj: any = {};
    if (message.roleId !== "") {
      obj.roleId = message.roleId;
    }
    if (message.secretId !== "") {
      obj.secretId = message.secretId;
    }
    if (message.type !== DataSourceExternalSecret_AppRoleAuthOption_SecretType.SECRET_TYPE_UNSPECIFIED) {
      obj.type = dataSourceExternalSecret_AppRoleAuthOption_SecretTypeToJSON(message.type);
    }
    if (message.mountPath !== "") {
      obj.mountPath = message.mountPath;
    }
    return obj;
  },

  create(base?: DeepPartial<DataSourceExternalSecret_AppRoleAuthOption>): DataSourceExternalSecret_AppRoleAuthOption {
    return DataSourceExternalSecret_AppRoleAuthOption.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<DataSourceExternalSecret_AppRoleAuthOption>,
  ): DataSourceExternalSecret_AppRoleAuthOption {
    const message = createBaseDataSourceExternalSecret_AppRoleAuthOption();
    message.roleId = object.roleId ?? "";
    message.secretId = object.secretId ?? "";
    message.type = object.type ?? DataSourceExternalSecret_AppRoleAuthOption_SecretType.SECRET_TYPE_UNSPECIFIED;
    message.mountPath = object.mountPath ?? "";
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  const bin = globalThis.atob(b64);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; ++i) {
    arr[i] = bin.charCodeAt(i);
  }
  return arr;
}

function base64FromBytes(arr: Uint8Array): string {
  const bin: string[] = [];
  arr.forEach((byte) => {
    bin.push(globalThis.String.fromCharCode(byte));
  });
  return globalThis.btoa(bin.join(""));
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Timestamp {
  if (o instanceof globalThis.Date) {
    return toTimestamp(o);
  } else if (typeof o === "string") {
    return toTimestamp(new globalThis.Date(o));
  } else {
    return Timestamp.fromJSON(o);
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
