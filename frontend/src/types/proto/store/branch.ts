// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.3.0
//   protoc               unknown
// source: store/branch.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../google/protobuf/timestamp";
import { MaskingLevel, maskingLevelFromJSON, maskingLevelToJSON, maskingLevelToNumber } from "./common";
import { DatabaseConfig, DatabaseSchemaMetadata } from "./database";

export const protobufPackage = "bytebase.store";

export interface BranchSnapshot {
  metadata: DatabaseSchemaMetadata | undefined;
  databaseConfig: DatabaseConfig | undefined;
}

export interface BranchConfig {
  /**
   * The name of source database.
   * Optional.
   * Example: instances/instance-id/databases/database-name.
   */
  sourceDatabase: string;
  /**
   * The name of the source branch.
   * Optional.
   * Example: projects/project-id/branches/branch-id.
   */
  sourceBranch: string;
}

export interface BranchDatabaseConfig {
  name: string;
  /** The schema_configs is the list of configs for schemas in a database. */
  schemaConfigs: BranchSchemaConfig[];
}

export interface BranchSchemaConfig {
  /**
   * The name is the schema name.
   * It is an empty string for databases without such concept such as MySQL.
   */
  name: string;
  /** The table_configs is the list of configs for tables in a schema. */
  tableConfigs: BranchTableConfig[];
  functionConfigs: BranchFunctionConfig[];
  procedureConfigs: BranchProcedureConfig[];
  viewConfigs: BranchViewConfig[];
}

export interface BranchTableConfig {
  /** The name is the name of a table. */
  name: string;
  /** The column_configs is the ordered list of configs for columns in a table. */
  columnConfigs: BranchColumnConfig[];
  classificationId: string;
  /**
   * The last updater of the table in branch.
   * Format: users/{userUID}.
   */
  updater: string;
  /**
   * The last change come from branch.
   * Format: projcets/{project}/branches/{branch}
   */
  sourceBranch: string;
  /** The timestamp when the table is updated in branch. */
  updateTime: Timestamp | undefined;
}

export interface BranchFunctionConfig {
  /** The name is the name of a function. */
  name: string;
  /**
   * The last updater of the function in branch.
   * Format: users/{userUID}.
   */
  updater: string;
  /**
   * The last change come from branch.
   * Format: projcets/{project}/branches/{branch}
   */
  sourceBranch: string;
  /** The timestamp when the function is updated in branch. */
  updateTime: Timestamp | undefined;
}

export interface BranchProcedureConfig {
  /** The name is the name of a procedure. */
  name: string;
  /**
   * The last updater of the procedure in branch.
   * Format: users/{userUID}.
   */
  updater: string;
  /**
   * The last change come from branch.
   * Format: projcets/{project}/branches/{branch}
   */
  sourceBranch: string;
  /** The timestamp when the procedure is updated in branch. */
  updateTime: Timestamp | undefined;
}

export interface BranchViewConfig {
  /** The name is the name of a view. */
  name: string;
  /**
   * The last updater of the view in branch.
   * Format: users/{userUID}.
   */
  updater: string;
  /**
   * The last change come from branch.
   * Format: projcets/{project}/branches/{branch}
   */
  sourceBranch: string;
  /** The timestamp when the view is updated in branch. */
  updateTime: Timestamp | undefined;
}

export interface BranchColumnConfig {
  /** The name is the name of a column. */
  name: string;
  semanticTypeId: string;
  /** The user labels for a column. */
  labels: { [key: string]: string };
  classificationId: string;
  maskingLevel: MaskingLevel;
  fullMaskingAlgorithmId: string;
  partialMaskingAlgorithmId: string;
}

export interface BranchColumnConfig_LabelsEntry {
  key: string;
  value: string;
}

function createBaseBranchSnapshot(): BranchSnapshot {
  return { metadata: undefined, databaseConfig: undefined };
}

export const BranchSnapshot: MessageFns<BranchSnapshot> = {
  encode(message: BranchSnapshot, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metadata !== undefined) {
      DatabaseSchemaMetadata.encode(message.metadata, writer.uint32(10).fork()).join();
    }
    if (message.databaseConfig !== undefined) {
      DatabaseConfig.encode(message.databaseConfig, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BranchSnapshot {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBranchSnapshot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.metadata = DatabaseSchemaMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.databaseConfig = DatabaseConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BranchSnapshot {
    return {
      metadata: isSet(object.metadata) ? DatabaseSchemaMetadata.fromJSON(object.metadata) : undefined,
      databaseConfig: isSet(object.databaseConfig) ? DatabaseConfig.fromJSON(object.databaseConfig) : undefined,
    };
  },

  toJSON(message: BranchSnapshot): unknown {
    const obj: any = {};
    if (message.metadata !== undefined) {
      obj.metadata = DatabaseSchemaMetadata.toJSON(message.metadata);
    }
    if (message.databaseConfig !== undefined) {
      obj.databaseConfig = DatabaseConfig.toJSON(message.databaseConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<BranchSnapshot>): BranchSnapshot {
    return BranchSnapshot.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BranchSnapshot>): BranchSnapshot {
    const message = createBaseBranchSnapshot();
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? DatabaseSchemaMetadata.fromPartial(object.metadata)
      : undefined;
    message.databaseConfig = (object.databaseConfig !== undefined && object.databaseConfig !== null)
      ? DatabaseConfig.fromPartial(object.databaseConfig)
      : undefined;
    return message;
  },
};

function createBaseBranchConfig(): BranchConfig {
  return { sourceDatabase: "", sourceBranch: "" };
}

export const BranchConfig: MessageFns<BranchConfig> = {
  encode(message: BranchConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sourceDatabase !== "") {
      writer.uint32(10).string(message.sourceDatabase);
    }
    if (message.sourceBranch !== "") {
      writer.uint32(18).string(message.sourceBranch);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BranchConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBranchConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sourceDatabase = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sourceBranch = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BranchConfig {
    return {
      sourceDatabase: isSet(object.sourceDatabase) ? globalThis.String(object.sourceDatabase) : "",
      sourceBranch: isSet(object.sourceBranch) ? globalThis.String(object.sourceBranch) : "",
    };
  },

  toJSON(message: BranchConfig): unknown {
    const obj: any = {};
    if (message.sourceDatabase !== "") {
      obj.sourceDatabase = message.sourceDatabase;
    }
    if (message.sourceBranch !== "") {
      obj.sourceBranch = message.sourceBranch;
    }
    return obj;
  },

  create(base?: DeepPartial<BranchConfig>): BranchConfig {
    return BranchConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BranchConfig>): BranchConfig {
    const message = createBaseBranchConfig();
    message.sourceDatabase = object.sourceDatabase ?? "";
    message.sourceBranch = object.sourceBranch ?? "";
    return message;
  },
};

function createBaseBranchDatabaseConfig(): BranchDatabaseConfig {
  return { name: "", schemaConfigs: [] };
}

export const BranchDatabaseConfig: MessageFns<BranchDatabaseConfig> = {
  encode(message: BranchDatabaseConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.schemaConfigs) {
      BranchSchemaConfig.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BranchDatabaseConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBranchDatabaseConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.schemaConfigs.push(BranchSchemaConfig.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BranchDatabaseConfig {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      schemaConfigs: globalThis.Array.isArray(object?.schemaConfigs)
        ? object.schemaConfigs.map((e: any) => BranchSchemaConfig.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BranchDatabaseConfig): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.schemaConfigs?.length) {
      obj.schemaConfigs = message.schemaConfigs.map((e) => BranchSchemaConfig.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BranchDatabaseConfig>): BranchDatabaseConfig {
    return BranchDatabaseConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BranchDatabaseConfig>): BranchDatabaseConfig {
    const message = createBaseBranchDatabaseConfig();
    message.name = object.name ?? "";
    message.schemaConfigs = object.schemaConfigs?.map((e) => BranchSchemaConfig.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBranchSchemaConfig(): BranchSchemaConfig {
  return { name: "", tableConfigs: [], functionConfigs: [], procedureConfigs: [], viewConfigs: [] };
}

export const BranchSchemaConfig: MessageFns<BranchSchemaConfig> = {
  encode(message: BranchSchemaConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.tableConfigs) {
      BranchTableConfig.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.functionConfigs) {
      BranchFunctionConfig.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.procedureConfigs) {
      BranchProcedureConfig.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.viewConfigs) {
      BranchViewConfig.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BranchSchemaConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBranchSchemaConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tableConfigs.push(BranchTableConfig.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.functionConfigs.push(BranchFunctionConfig.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.procedureConfigs.push(BranchProcedureConfig.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.viewConfigs.push(BranchViewConfig.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BranchSchemaConfig {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      tableConfigs: globalThis.Array.isArray(object?.tableConfigs)
        ? object.tableConfigs.map((e: any) => BranchTableConfig.fromJSON(e))
        : [],
      functionConfigs: globalThis.Array.isArray(object?.functionConfigs)
        ? object.functionConfigs.map((e: any) => BranchFunctionConfig.fromJSON(e))
        : [],
      procedureConfigs: globalThis.Array.isArray(object?.procedureConfigs)
        ? object.procedureConfigs.map((e: any) => BranchProcedureConfig.fromJSON(e))
        : [],
      viewConfigs: globalThis.Array.isArray(object?.viewConfigs)
        ? object.viewConfigs.map((e: any) => BranchViewConfig.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BranchSchemaConfig): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.tableConfigs?.length) {
      obj.tableConfigs = message.tableConfigs.map((e) => BranchTableConfig.toJSON(e));
    }
    if (message.functionConfigs?.length) {
      obj.functionConfigs = message.functionConfigs.map((e) => BranchFunctionConfig.toJSON(e));
    }
    if (message.procedureConfigs?.length) {
      obj.procedureConfigs = message.procedureConfigs.map((e) => BranchProcedureConfig.toJSON(e));
    }
    if (message.viewConfigs?.length) {
      obj.viewConfigs = message.viewConfigs.map((e) => BranchViewConfig.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BranchSchemaConfig>): BranchSchemaConfig {
    return BranchSchemaConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BranchSchemaConfig>): BranchSchemaConfig {
    const message = createBaseBranchSchemaConfig();
    message.name = object.name ?? "";
    message.tableConfigs = object.tableConfigs?.map((e) => BranchTableConfig.fromPartial(e)) || [];
    message.functionConfigs = object.functionConfigs?.map((e) => BranchFunctionConfig.fromPartial(e)) || [];
    message.procedureConfigs = object.procedureConfigs?.map((e) => BranchProcedureConfig.fromPartial(e)) || [];
    message.viewConfigs = object.viewConfigs?.map((e) => BranchViewConfig.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBranchTableConfig(): BranchTableConfig {
  return { name: "", columnConfigs: [], classificationId: "", updater: "", sourceBranch: "", updateTime: undefined };
}

export const BranchTableConfig: MessageFns<BranchTableConfig> = {
  encode(message: BranchTableConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.columnConfigs) {
      BranchColumnConfig.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.classificationId !== "") {
      writer.uint32(26).string(message.classificationId);
    }
    if (message.updater !== "") {
      writer.uint32(34).string(message.updater);
    }
    if (message.sourceBranch !== "") {
      writer.uint32(50).string(message.sourceBranch);
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(message.updateTime, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BranchTableConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBranchTableConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.columnConfigs.push(BranchColumnConfig.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.classificationId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.updater = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.sourceBranch = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.updateTime = Timestamp.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BranchTableConfig {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      columnConfigs: globalThis.Array.isArray(object?.columnConfigs)
        ? object.columnConfigs.map((e: any) => BranchColumnConfig.fromJSON(e))
        : [],
      classificationId: isSet(object.classificationId) ? globalThis.String(object.classificationId) : "",
      updater: isSet(object.updater) ? globalThis.String(object.updater) : "",
      sourceBranch: isSet(object.sourceBranch) ? globalThis.String(object.sourceBranch) : "",
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
    };
  },

  toJSON(message: BranchTableConfig): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.columnConfigs?.length) {
      obj.columnConfigs = message.columnConfigs.map((e) => BranchColumnConfig.toJSON(e));
    }
    if (message.classificationId !== "") {
      obj.classificationId = message.classificationId;
    }
    if (message.updater !== "") {
      obj.updater = message.updater;
    }
    if (message.sourceBranch !== "") {
      obj.sourceBranch = message.sourceBranch;
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = fromTimestamp(message.updateTime).toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<BranchTableConfig>): BranchTableConfig {
    return BranchTableConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BranchTableConfig>): BranchTableConfig {
    const message = createBaseBranchTableConfig();
    message.name = object.name ?? "";
    message.columnConfigs = object.columnConfigs?.map((e) => BranchColumnConfig.fromPartial(e)) || [];
    message.classificationId = object.classificationId ?? "";
    message.updater = object.updater ?? "";
    message.sourceBranch = object.sourceBranch ?? "";
    message.updateTime = (object.updateTime !== undefined && object.updateTime !== null)
      ? Timestamp.fromPartial(object.updateTime)
      : undefined;
    return message;
  },
};

function createBaseBranchFunctionConfig(): BranchFunctionConfig {
  return { name: "", updater: "", sourceBranch: "", updateTime: undefined };
}

export const BranchFunctionConfig: MessageFns<BranchFunctionConfig> = {
  encode(message: BranchFunctionConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.updater !== "") {
      writer.uint32(18).string(message.updater);
    }
    if (message.sourceBranch !== "") {
      writer.uint32(34).string(message.sourceBranch);
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(message.updateTime, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BranchFunctionConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBranchFunctionConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.updater = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sourceBranch = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.updateTime = Timestamp.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BranchFunctionConfig {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      updater: isSet(object.updater) ? globalThis.String(object.updater) : "",
      sourceBranch: isSet(object.sourceBranch) ? globalThis.String(object.sourceBranch) : "",
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
    };
  },

  toJSON(message: BranchFunctionConfig): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.updater !== "") {
      obj.updater = message.updater;
    }
    if (message.sourceBranch !== "") {
      obj.sourceBranch = message.sourceBranch;
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = fromTimestamp(message.updateTime).toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<BranchFunctionConfig>): BranchFunctionConfig {
    return BranchFunctionConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BranchFunctionConfig>): BranchFunctionConfig {
    const message = createBaseBranchFunctionConfig();
    message.name = object.name ?? "";
    message.updater = object.updater ?? "";
    message.sourceBranch = object.sourceBranch ?? "";
    message.updateTime = (object.updateTime !== undefined && object.updateTime !== null)
      ? Timestamp.fromPartial(object.updateTime)
      : undefined;
    return message;
  },
};

function createBaseBranchProcedureConfig(): BranchProcedureConfig {
  return { name: "", updater: "", sourceBranch: "", updateTime: undefined };
}

export const BranchProcedureConfig: MessageFns<BranchProcedureConfig> = {
  encode(message: BranchProcedureConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.updater !== "") {
      writer.uint32(18).string(message.updater);
    }
    if (message.sourceBranch !== "") {
      writer.uint32(34).string(message.sourceBranch);
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(message.updateTime, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BranchProcedureConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBranchProcedureConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.updater = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sourceBranch = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.updateTime = Timestamp.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BranchProcedureConfig {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      updater: isSet(object.updater) ? globalThis.String(object.updater) : "",
      sourceBranch: isSet(object.sourceBranch) ? globalThis.String(object.sourceBranch) : "",
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
    };
  },

  toJSON(message: BranchProcedureConfig): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.updater !== "") {
      obj.updater = message.updater;
    }
    if (message.sourceBranch !== "") {
      obj.sourceBranch = message.sourceBranch;
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = fromTimestamp(message.updateTime).toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<BranchProcedureConfig>): BranchProcedureConfig {
    return BranchProcedureConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BranchProcedureConfig>): BranchProcedureConfig {
    const message = createBaseBranchProcedureConfig();
    message.name = object.name ?? "";
    message.updater = object.updater ?? "";
    message.sourceBranch = object.sourceBranch ?? "";
    message.updateTime = (object.updateTime !== undefined && object.updateTime !== null)
      ? Timestamp.fromPartial(object.updateTime)
      : undefined;
    return message;
  },
};

function createBaseBranchViewConfig(): BranchViewConfig {
  return { name: "", updater: "", sourceBranch: "", updateTime: undefined };
}

export const BranchViewConfig: MessageFns<BranchViewConfig> = {
  encode(message: BranchViewConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.updater !== "") {
      writer.uint32(18).string(message.updater);
    }
    if (message.sourceBranch !== "") {
      writer.uint32(34).string(message.sourceBranch);
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(message.updateTime, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BranchViewConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBranchViewConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.updater = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sourceBranch = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.updateTime = Timestamp.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BranchViewConfig {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      updater: isSet(object.updater) ? globalThis.String(object.updater) : "",
      sourceBranch: isSet(object.sourceBranch) ? globalThis.String(object.sourceBranch) : "",
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
    };
  },

  toJSON(message: BranchViewConfig): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.updater !== "") {
      obj.updater = message.updater;
    }
    if (message.sourceBranch !== "") {
      obj.sourceBranch = message.sourceBranch;
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = fromTimestamp(message.updateTime).toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<BranchViewConfig>): BranchViewConfig {
    return BranchViewConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BranchViewConfig>): BranchViewConfig {
    const message = createBaseBranchViewConfig();
    message.name = object.name ?? "";
    message.updater = object.updater ?? "";
    message.sourceBranch = object.sourceBranch ?? "";
    message.updateTime = (object.updateTime !== undefined && object.updateTime !== null)
      ? Timestamp.fromPartial(object.updateTime)
      : undefined;
    return message;
  },
};

function createBaseBranchColumnConfig(): BranchColumnConfig {
  return {
    name: "",
    semanticTypeId: "",
    labels: {},
    classificationId: "",
    maskingLevel: MaskingLevel.MASKING_LEVEL_UNSPECIFIED,
    fullMaskingAlgorithmId: "",
    partialMaskingAlgorithmId: "",
  };
}

export const BranchColumnConfig: MessageFns<BranchColumnConfig> = {
  encode(message: BranchColumnConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.semanticTypeId !== "") {
      writer.uint32(18).string(message.semanticTypeId);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      BranchColumnConfig_LabelsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.classificationId !== "") {
      writer.uint32(34).string(message.classificationId);
    }
    if (message.maskingLevel !== MaskingLevel.MASKING_LEVEL_UNSPECIFIED) {
      writer.uint32(40).int32(maskingLevelToNumber(message.maskingLevel));
    }
    if (message.fullMaskingAlgorithmId !== "") {
      writer.uint32(50).string(message.fullMaskingAlgorithmId);
    }
    if (message.partialMaskingAlgorithmId !== "") {
      writer.uint32(58).string(message.partialMaskingAlgorithmId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BranchColumnConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBranchColumnConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.semanticTypeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = BranchColumnConfig_LabelsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.labels[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.classificationId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.maskingLevel = maskingLevelFromJSON(reader.int32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.fullMaskingAlgorithmId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.partialMaskingAlgorithmId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BranchColumnConfig {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      semanticTypeId: isSet(object.semanticTypeId) ? globalThis.String(object.semanticTypeId) : "",
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      classificationId: isSet(object.classificationId) ? globalThis.String(object.classificationId) : "",
      maskingLevel: isSet(object.maskingLevel)
        ? maskingLevelFromJSON(object.maskingLevel)
        : MaskingLevel.MASKING_LEVEL_UNSPECIFIED,
      fullMaskingAlgorithmId: isSet(object.fullMaskingAlgorithmId)
        ? globalThis.String(object.fullMaskingAlgorithmId)
        : "",
      partialMaskingAlgorithmId: isSet(object.partialMaskingAlgorithmId)
        ? globalThis.String(object.partialMaskingAlgorithmId)
        : "",
    };
  },

  toJSON(message: BranchColumnConfig): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.semanticTypeId !== "") {
      obj.semanticTypeId = message.semanticTypeId;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.classificationId !== "") {
      obj.classificationId = message.classificationId;
    }
    if (message.maskingLevel !== MaskingLevel.MASKING_LEVEL_UNSPECIFIED) {
      obj.maskingLevel = maskingLevelToJSON(message.maskingLevel);
    }
    if (message.fullMaskingAlgorithmId !== "") {
      obj.fullMaskingAlgorithmId = message.fullMaskingAlgorithmId;
    }
    if (message.partialMaskingAlgorithmId !== "") {
      obj.partialMaskingAlgorithmId = message.partialMaskingAlgorithmId;
    }
    return obj;
  },

  create(base?: DeepPartial<BranchColumnConfig>): BranchColumnConfig {
    return BranchColumnConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BranchColumnConfig>): BranchColumnConfig {
    const message = createBaseBranchColumnConfig();
    message.name = object.name ?? "";
    message.semanticTypeId = object.semanticTypeId ?? "";
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.classificationId = object.classificationId ?? "";
    message.maskingLevel = object.maskingLevel ?? MaskingLevel.MASKING_LEVEL_UNSPECIFIED;
    message.fullMaskingAlgorithmId = object.fullMaskingAlgorithmId ?? "";
    message.partialMaskingAlgorithmId = object.partialMaskingAlgorithmId ?? "";
    return message;
  },
};

function createBaseBranchColumnConfig_LabelsEntry(): BranchColumnConfig_LabelsEntry {
  return { key: "", value: "" };
}

export const BranchColumnConfig_LabelsEntry: MessageFns<BranchColumnConfig_LabelsEntry> = {
  encode(message: BranchColumnConfig_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BranchColumnConfig_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBranchColumnConfig_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BranchColumnConfig_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: BranchColumnConfig_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<BranchColumnConfig_LabelsEntry>): BranchColumnConfig_LabelsEntry {
    return BranchColumnConfig_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BranchColumnConfig_LabelsEntry>): BranchColumnConfig_LabelsEntry {
    const message = createBaseBranchColumnConfig_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Timestamp {
  if (o instanceof globalThis.Date) {
    return toTimestamp(o);
  } else if (typeof o === "string") {
    return toTimestamp(new globalThis.Date(o));
  } else {
    return Timestamp.fromJSON(o);
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
