// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.3.0
//   protoc               unknown
// source: google/api/expr/v1alpha1/syntax.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../../protobuf/duration";
import { NullValue, nullValueFromJSON, nullValueToJSON, nullValueToNumber } from "../../../protobuf/struct";
import { Timestamp } from "../../../protobuf/timestamp";

export const protobufPackage = "google.api.expr.v1alpha1";

/**
 * An abstract representation of a common expression.
 *
 * Expressions are abstractly represented as a collection of identifiers,
 * select statements, function calls, literals, and comprehensions. All
 * operators with the exception of the '.' operator are modelled as function
 * calls. This makes it easy to represent new operators into the existing AST.
 *
 * All references within expressions must resolve to a [Decl][google.api.expr.v1alpha1.Decl] provided at
 * type-check for an expression to be valid. A reference may either be a bare
 * identifier `name` or a qualified identifier `google.api.name`. References
 * may either refer to a value or a function declaration.
 *
 * For example, the expression `google.api.name.startsWith('expr')` references
 * the declaration `google.api.name` within a [Expr.Select][google.api.expr.v1alpha1.Expr.Select] expression, and
 * the function declaration `startsWith`.
 */
export interface Expr {
  /**
   * Required. An id assigned to this node by the parser which is unique in a
   * given expression tree. This is used to associate type information and other
   * attributes to a node in the parse tree.
   */
  id: Long;
  /** A literal expression. */
  constExpr?:
    | Constant
    | undefined;
  /** An identifier expression. */
  identExpr?:
    | Expr_Ident
    | undefined;
  /** A field selection expression, e.g. `request.auth`. */
  selectExpr?:
    | Expr_Select
    | undefined;
  /** A call expression, including calls to predefined functions and operators. */
  callExpr?:
    | Expr_Call
    | undefined;
  /** A list creation expression. */
  listExpr?:
    | Expr_CreateList
    | undefined;
  /** A map or message creation expression. */
  structExpr?:
    | Expr_CreateStruct
    | undefined;
  /** A comprehension expression. */
  comprehensionExpr?: Expr_Comprehension | undefined;
}

/** An identifier expression. e.g. `request`. */
export interface Expr_Ident {
  /**
   * Required. Holds a single, unqualified identifier, possibly preceded by a
   * '.'.
   *
   * Qualified names are represented by the [Expr.Select][google.api.expr.v1alpha1.Expr.Select] expression.
   */
  name: string;
}

/** A field selection expression. e.g. `request.auth`. */
export interface Expr_Select {
  /**
   * Required. The target of the selection expression.
   *
   * For example, in the select expression `request.auth`, the `request`
   * portion of the expression is the `operand`.
   */
  operand:
    | Expr
    | undefined;
  /**
   * Required. The name of the field to select.
   *
   * For example, in the select expression `request.auth`, the `auth` portion
   * of the expression would be the `field`.
   */
  field: string;
  /**
   * Whether the select is to be interpreted as a field presence test.
   *
   * This results from the macro `has(request.auth)`.
   */
  testOnly: boolean;
}

/**
 * A call expression, including calls to predefined functions and operators.
 *
 * For example, `value == 10`, `size(map_value)`.
 */
export interface Expr_Call {
  /**
   * The target of an method call-style expression. For example, `x` in
   * `x.f()`.
   */
  target:
    | Expr
    | undefined;
  /** Required. The name of the function or method being called. */
  function: string;
  /** The arguments. */
  args: Expr[];
}

/**
 * A list creation expression.
 *
 * Lists may either be homogenous, e.g. `[1, 2, 3]`, or heterogeneous, e.g.
 * `dyn([1, 'hello', 2.0])`
 */
export interface Expr_CreateList {
  /** The elements part of the list. */
  elements: Expr[];
  /**
   * The indices within the elements list which are marked as optional
   * elements.
   *
   * When an optional-typed value is present, the value it contains
   * is included in the list. If the optional-typed value is absent, the list
   * element is omitted from the CreateList result.
   */
  optionalIndices: number[];
}

/**
 * A map or message creation expression.
 *
 * Maps are constructed as `{'key_name': 'value'}`. Message construction is
 * similar, but prefixed with a type name and composed of field ids:
 * `types.MyType{field_id: 'value'}`.
 */
export interface Expr_CreateStruct {
  /**
   * The type name of the message to be created, empty when creating map
   * literals.
   */
  messageName: string;
  /** The entries in the creation expression. */
  entries: Expr_CreateStruct_Entry[];
}

/** Represents an entry. */
export interface Expr_CreateStruct_Entry {
  /**
   * Required. An id assigned to this node by the parser which is unique
   * in a given expression tree. This is used to associate type
   * information and other attributes to the node.
   */
  id: Long;
  /** The field key for a message creator statement. */
  fieldKey?:
    | string
    | undefined;
  /** The key expression for a map creation statement. */
  mapKey?:
    | Expr
    | undefined;
  /**
   * Required. The value assigned to the key.
   *
   * If the optional_entry field is true, the expression must resolve to an
   * optional-typed value. If the optional value is present, the key will be
   * set; however, if the optional value is absent, the key will be unset.
   */
  value:
    | Expr
    | undefined;
  /** Whether the key-value pair is optional. */
  optionalEntry: boolean;
}

/**
 * A comprehension expression applied to a list or map.
 *
 * Comprehensions are not part of the core syntax, but enabled with macros.
 * A macro matches a specific call signature within a parsed AST and replaces
 * the call with an alternate AST block. Macro expansion happens at parse
 * time.
 *
 * The following macros are supported within CEL:
 *
 * Aggregate type macros may be applied to all elements in a list or all keys
 * in a map:
 *
 * *  `all`, `exists`, `exists_one` -  test a predicate expression against
 *    the inputs and return `true` if the predicate is satisfied for all,
 *    any, or only one value `list.all(x, x < 10)`.
 * *  `filter` - test a predicate expression against the inputs and return
 *    the subset of elements which satisfy the predicate:
 *    `payments.filter(p, p > 1000)`.
 * *  `map` - apply an expression to all elements in the input and return the
 *    output aggregate type: `[1, 2, 3].map(i, i * i)`.
 *
 * The `has(m.x)` macro tests whether the property `x` is present in struct
 * `m`. The semantics of this macro depend on the type of `m`. For proto2
 * messages `has(m.x)` is defined as 'defined, but not set`. For proto3, the
 * macro tests whether the property is set to its default. For map and struct
 * types, the macro tests whether the property `x` is defined on `m`.
 */
export interface Expr_Comprehension {
  /** The name of the iteration variable. */
  iterVar: string;
  /** The range over which var iterates. */
  iterRange:
    | Expr
    | undefined;
  /** The name of the variable used for accumulation of the result. */
  accuVar: string;
  /** The initial value of the accumulator. */
  accuInit:
    | Expr
    | undefined;
  /**
   * An expression which can contain iter_var and accu_var.
   *
   * Returns false when the result has been computed and may be used as
   * a hint to short-circuit the remainder of the comprehension.
   */
  loopCondition:
    | Expr
    | undefined;
  /**
   * An expression which can contain iter_var and accu_var.
   *
   * Computes the next value of accu_var.
   */
  loopStep:
    | Expr
    | undefined;
  /**
   * An expression which can contain accu_var.
   *
   * Computes the result.
   */
  result: Expr | undefined;
}

/**
 * Represents a primitive literal.
 *
 * Named 'Constant' here for backwards compatibility.
 *
 * This is similar as the primitives supported in the well-known type
 * `google.protobuf.Value`, but richer so it can represent CEL's full range of
 * primitives.
 *
 * Lists and structs are not included as constants as these aggregate types may
 * contain [Expr][google.api.expr.v1alpha1.Expr] elements which require evaluation and are thus not constant.
 *
 * Examples of literals include: `"hello"`, `b'bytes'`, `1u`, `4.2`, `-2`,
 * `true`, `null`.
 */
export interface Constant {
  /** null value. */
  nullValue?:
    | NullValue
    | undefined;
  /** boolean value. */
  boolValue?:
    | boolean
    | undefined;
  /** int64 value. */
  int64Value?:
    | Long
    | undefined;
  /** uint64 value. */
  uint64Value?:
    | Long
    | undefined;
  /** double value. */
  doubleValue?:
    | number
    | undefined;
  /** string value. */
  stringValue?:
    | string
    | undefined;
  /** bytes value. */
  bytesValue?:
    | Uint8Array
    | undefined;
  /**
   * protobuf.Duration value.
   *
   * Deprecated: duration is no longer considered a builtin cel type.
   *
   * @deprecated
   */
  durationValue?:
    | Duration
    | undefined;
  /**
   * protobuf.Timestamp value.
   *
   * Deprecated: timestamp is no longer considered a builtin cel type.
   *
   * @deprecated
   */
  timestampValue?: Timestamp | undefined;
}

function createBaseExpr(): Expr {
  return {
    id: Long.ZERO,
    constExpr: undefined,
    identExpr: undefined,
    selectExpr: undefined,
    callExpr: undefined,
    listExpr: undefined,
    structExpr: undefined,
    comprehensionExpr: undefined,
  };
}

export const Expr: MessageFns<Expr> = {
  encode(message: Expr, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.id.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.id.toString());
    }
    if (message.constExpr !== undefined) {
      Constant.encode(message.constExpr, writer.uint32(26).fork()).join();
    }
    if (message.identExpr !== undefined) {
      Expr_Ident.encode(message.identExpr, writer.uint32(34).fork()).join();
    }
    if (message.selectExpr !== undefined) {
      Expr_Select.encode(message.selectExpr, writer.uint32(42).fork()).join();
    }
    if (message.callExpr !== undefined) {
      Expr_Call.encode(message.callExpr, writer.uint32(50).fork()).join();
    }
    if (message.listExpr !== undefined) {
      Expr_CreateList.encode(message.listExpr, writer.uint32(58).fork()).join();
    }
    if (message.structExpr !== undefined) {
      Expr_CreateStruct.encode(message.structExpr, writer.uint32(66).fork()).join();
    }
    if (message.comprehensionExpr !== undefined) {
      Expr_Comprehension.encode(message.comprehensionExpr, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Expr {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExpr();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.id = Long.fromString(reader.int64().toString());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.constExpr = Constant.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.identExpr = Expr_Ident.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.selectExpr = Expr_Select.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.callExpr = Expr_Call.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.listExpr = Expr_CreateList.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.structExpr = Expr_CreateStruct.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.comprehensionExpr = Expr_Comprehension.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  toJSON(message: Expr): unknown {
    const obj: any = {};
    if (!message.id.equals(Long.ZERO)) {
      obj.id = (message.id || Long.ZERO).toString();
    }
    if (message.constExpr !== undefined) {
      obj.constExpr = Constant.toJSON(message.constExpr);
    }
    if (message.identExpr !== undefined) {
      obj.identExpr = Expr_Ident.toJSON(message.identExpr);
    }
    if (message.selectExpr !== undefined) {
      obj.selectExpr = Expr_Select.toJSON(message.selectExpr);
    }
    if (message.callExpr !== undefined) {
      obj.callExpr = Expr_Call.toJSON(message.callExpr);
    }
    if (message.listExpr !== undefined) {
      obj.listExpr = Expr_CreateList.toJSON(message.listExpr);
    }
    if (message.structExpr !== undefined) {
      obj.structExpr = Expr_CreateStruct.toJSON(message.structExpr);
    }
    if (message.comprehensionExpr !== undefined) {
      obj.comprehensionExpr = Expr_Comprehension.toJSON(message.comprehensionExpr);
    }
    return obj;
  },

  create(base?: DeepPartial<Expr>): Expr {
    return Expr.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Expr>): Expr {
    const message = createBaseExpr();
    message.id = (object.id !== undefined && object.id !== null) ? Long.fromValue(object.id) : Long.ZERO;
    message.constExpr = (object.constExpr !== undefined && object.constExpr !== null)
      ? Constant.fromPartial(object.constExpr)
      : undefined;
    message.identExpr = (object.identExpr !== undefined && object.identExpr !== null)
      ? Expr_Ident.fromPartial(object.identExpr)
      : undefined;
    message.selectExpr = (object.selectExpr !== undefined && object.selectExpr !== null)
      ? Expr_Select.fromPartial(object.selectExpr)
      : undefined;
    message.callExpr = (object.callExpr !== undefined && object.callExpr !== null)
      ? Expr_Call.fromPartial(object.callExpr)
      : undefined;
    message.listExpr = (object.listExpr !== undefined && object.listExpr !== null)
      ? Expr_CreateList.fromPartial(object.listExpr)
      : undefined;
    message.structExpr = (object.structExpr !== undefined && object.structExpr !== null)
      ? Expr_CreateStruct.fromPartial(object.structExpr)
      : undefined;
    message.comprehensionExpr = (object.comprehensionExpr !== undefined && object.comprehensionExpr !== null)
      ? Expr_Comprehension.fromPartial(object.comprehensionExpr)
      : undefined;
    return message;
  },
};

function createBaseExpr_Ident(): Expr_Ident {
  return { name: "" };
}

export const Expr_Ident: MessageFns<Expr_Ident> = {
  encode(message: Expr_Ident, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Expr_Ident {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExpr_Ident();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  toJSON(message: Expr_Ident): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<Expr_Ident>): Expr_Ident {
    return Expr_Ident.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Expr_Ident>): Expr_Ident {
    const message = createBaseExpr_Ident();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseExpr_Select(): Expr_Select {
  return { operand: undefined, field: "", testOnly: false };
}

export const Expr_Select: MessageFns<Expr_Select> = {
  encode(message: Expr_Select, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operand !== undefined) {
      Expr.encode(message.operand, writer.uint32(10).fork()).join();
    }
    if (message.field !== "") {
      writer.uint32(18).string(message.field);
    }
    if (message.testOnly !== false) {
      writer.uint32(24).bool(message.testOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Expr_Select {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExpr_Select();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.operand = Expr.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.field = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.testOnly = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  toJSON(message: Expr_Select): unknown {
    const obj: any = {};
    if (message.operand !== undefined) {
      obj.operand = Expr.toJSON(message.operand);
    }
    if (message.field !== "") {
      obj.field = message.field;
    }
    if (message.testOnly !== false) {
      obj.testOnly = message.testOnly;
    }
    return obj;
  },

  create(base?: DeepPartial<Expr_Select>): Expr_Select {
    return Expr_Select.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Expr_Select>): Expr_Select {
    const message = createBaseExpr_Select();
    message.operand = (object.operand !== undefined && object.operand !== null)
      ? Expr.fromPartial(object.operand)
      : undefined;
    message.field = object.field ?? "";
    message.testOnly = object.testOnly ?? false;
    return message;
  },
};

function createBaseExpr_Call(): Expr_Call {
  return { target: undefined, function: "", args: [] };
}

export const Expr_Call: MessageFns<Expr_Call> = {
  encode(message: Expr_Call, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.target !== undefined) {
      Expr.encode(message.target, writer.uint32(10).fork()).join();
    }
    if (message.function !== "") {
      writer.uint32(18).string(message.function);
    }
    for (const v of message.args) {
      Expr.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Expr_Call {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExpr_Call();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.target = Expr.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.function = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.args.push(Expr.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  toJSON(message: Expr_Call): unknown {
    const obj: any = {};
    if (message.target !== undefined) {
      obj.target = Expr.toJSON(message.target);
    }
    if (message.function !== "") {
      obj.function = message.function;
    }
    if (message.args?.length) {
      obj.args = message.args.map((e) => Expr.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Expr_Call>): Expr_Call {
    return Expr_Call.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Expr_Call>): Expr_Call {
    const message = createBaseExpr_Call();
    message.target = (object.target !== undefined && object.target !== null)
      ? Expr.fromPartial(object.target)
      : undefined;
    message.function = object.function ?? "";
    message.args = object.args?.map((e) => Expr.fromPartial(e)) || [];
    return message;
  },
};

function createBaseExpr_CreateList(): Expr_CreateList {
  return { elements: [], optionalIndices: [] };
}

export const Expr_CreateList: MessageFns<Expr_CreateList> = {
  encode(message: Expr_CreateList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.elements) {
      Expr.encode(v!, writer.uint32(10).fork()).join();
    }
    writer.uint32(18).fork();
    for (const v of message.optionalIndices) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Expr_CreateList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExpr_CreateList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.elements.push(Expr.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.optionalIndices.push(reader.int32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.optionalIndices.push(reader.int32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  toJSON(message: Expr_CreateList): unknown {
    const obj: any = {};
    if (message.elements?.length) {
      obj.elements = message.elements.map((e) => Expr.toJSON(e));
    }
    if (message.optionalIndices?.length) {
      obj.optionalIndices = message.optionalIndices.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Expr_CreateList>): Expr_CreateList {
    return Expr_CreateList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Expr_CreateList>): Expr_CreateList {
    const message = createBaseExpr_CreateList();
    message.elements = object.elements?.map((e) => Expr.fromPartial(e)) || [];
    message.optionalIndices = object.optionalIndices?.map((e) => e) || [];
    return message;
  },
};

function createBaseExpr_CreateStruct(): Expr_CreateStruct {
  return { messageName: "", entries: [] };
}

export const Expr_CreateStruct: MessageFns<Expr_CreateStruct> = {
  encode(message: Expr_CreateStruct, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.messageName !== "") {
      writer.uint32(10).string(message.messageName);
    }
    for (const v of message.entries) {
      Expr_CreateStruct_Entry.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Expr_CreateStruct {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExpr_CreateStruct();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.messageName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.entries.push(Expr_CreateStruct_Entry.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  toJSON(message: Expr_CreateStruct): unknown {
    const obj: any = {};
    if (message.messageName !== "") {
      obj.messageName = message.messageName;
    }
    if (message.entries?.length) {
      obj.entries = message.entries.map((e) => Expr_CreateStruct_Entry.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Expr_CreateStruct>): Expr_CreateStruct {
    return Expr_CreateStruct.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Expr_CreateStruct>): Expr_CreateStruct {
    const message = createBaseExpr_CreateStruct();
    message.messageName = object.messageName ?? "";
    message.entries = object.entries?.map((e) => Expr_CreateStruct_Entry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseExpr_CreateStruct_Entry(): Expr_CreateStruct_Entry {
  return { id: Long.ZERO, fieldKey: undefined, mapKey: undefined, value: undefined, optionalEntry: false };
}

export const Expr_CreateStruct_Entry: MessageFns<Expr_CreateStruct_Entry> = {
  encode(message: Expr_CreateStruct_Entry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.id.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.id.toString());
    }
    if (message.fieldKey !== undefined) {
      writer.uint32(18).string(message.fieldKey);
    }
    if (message.mapKey !== undefined) {
      Expr.encode(message.mapKey, writer.uint32(26).fork()).join();
    }
    if (message.value !== undefined) {
      Expr.encode(message.value, writer.uint32(34).fork()).join();
    }
    if (message.optionalEntry !== false) {
      writer.uint32(40).bool(message.optionalEntry);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Expr_CreateStruct_Entry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExpr_CreateStruct_Entry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = Long.fromString(reader.int64().toString());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fieldKey = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.mapKey = Expr.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.value = Expr.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.optionalEntry = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  toJSON(message: Expr_CreateStruct_Entry): unknown {
    const obj: any = {};
    if (!message.id.equals(Long.ZERO)) {
      obj.id = (message.id || Long.ZERO).toString();
    }
    if (message.fieldKey !== undefined) {
      obj.fieldKey = message.fieldKey;
    }
    if (message.mapKey !== undefined) {
      obj.mapKey = Expr.toJSON(message.mapKey);
    }
    if (message.value !== undefined) {
      obj.value = Expr.toJSON(message.value);
    }
    if (message.optionalEntry !== false) {
      obj.optionalEntry = message.optionalEntry;
    }
    return obj;
  },

  create(base?: DeepPartial<Expr_CreateStruct_Entry>): Expr_CreateStruct_Entry {
    return Expr_CreateStruct_Entry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Expr_CreateStruct_Entry>): Expr_CreateStruct_Entry {
    const message = createBaseExpr_CreateStruct_Entry();
    message.id = (object.id !== undefined && object.id !== null) ? Long.fromValue(object.id) : Long.ZERO;
    message.fieldKey = object.fieldKey ?? undefined;
    message.mapKey = (object.mapKey !== undefined && object.mapKey !== null)
      ? Expr.fromPartial(object.mapKey)
      : undefined;
    message.value = (object.value !== undefined && object.value !== null) ? Expr.fromPartial(object.value) : undefined;
    message.optionalEntry = object.optionalEntry ?? false;
    return message;
  },
};

function createBaseExpr_Comprehension(): Expr_Comprehension {
  return {
    iterVar: "",
    iterRange: undefined,
    accuVar: "",
    accuInit: undefined,
    loopCondition: undefined,
    loopStep: undefined,
    result: undefined,
  };
}

export const Expr_Comprehension: MessageFns<Expr_Comprehension> = {
  encode(message: Expr_Comprehension, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.iterVar !== "") {
      writer.uint32(10).string(message.iterVar);
    }
    if (message.iterRange !== undefined) {
      Expr.encode(message.iterRange, writer.uint32(18).fork()).join();
    }
    if (message.accuVar !== "") {
      writer.uint32(26).string(message.accuVar);
    }
    if (message.accuInit !== undefined) {
      Expr.encode(message.accuInit, writer.uint32(34).fork()).join();
    }
    if (message.loopCondition !== undefined) {
      Expr.encode(message.loopCondition, writer.uint32(42).fork()).join();
    }
    if (message.loopStep !== undefined) {
      Expr.encode(message.loopStep, writer.uint32(50).fork()).join();
    }
    if (message.result !== undefined) {
      Expr.encode(message.result, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Expr_Comprehension {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExpr_Comprehension();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.iterVar = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.iterRange = Expr.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.accuVar = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.accuInit = Expr.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.loopCondition = Expr.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.loopStep = Expr.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.result = Expr.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  toJSON(message: Expr_Comprehension): unknown {
    const obj: any = {};
    if (message.iterVar !== "") {
      obj.iterVar = message.iterVar;
    }
    if (message.iterRange !== undefined) {
      obj.iterRange = Expr.toJSON(message.iterRange);
    }
    if (message.accuVar !== "") {
      obj.accuVar = message.accuVar;
    }
    if (message.accuInit !== undefined) {
      obj.accuInit = Expr.toJSON(message.accuInit);
    }
    if (message.loopCondition !== undefined) {
      obj.loopCondition = Expr.toJSON(message.loopCondition);
    }
    if (message.loopStep !== undefined) {
      obj.loopStep = Expr.toJSON(message.loopStep);
    }
    if (message.result !== undefined) {
      obj.result = Expr.toJSON(message.result);
    }
    return obj;
  },

  create(base?: DeepPartial<Expr_Comprehension>): Expr_Comprehension {
    return Expr_Comprehension.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Expr_Comprehension>): Expr_Comprehension {
    const message = createBaseExpr_Comprehension();
    message.iterVar = object.iterVar ?? "";
    message.iterRange = (object.iterRange !== undefined && object.iterRange !== null)
      ? Expr.fromPartial(object.iterRange)
      : undefined;
    message.accuVar = object.accuVar ?? "";
    message.accuInit = (object.accuInit !== undefined && object.accuInit !== null)
      ? Expr.fromPartial(object.accuInit)
      : undefined;
    message.loopCondition = (object.loopCondition !== undefined && object.loopCondition !== null)
      ? Expr.fromPartial(object.loopCondition)
      : undefined;
    message.loopStep = (object.loopStep !== undefined && object.loopStep !== null)
      ? Expr.fromPartial(object.loopStep)
      : undefined;
    message.result = (object.result !== undefined && object.result !== null)
      ? Expr.fromPartial(object.result)
      : undefined;
    return message;
  },
};

function createBaseConstant(): Constant {
  return {
    nullValue: undefined,
    boolValue: undefined,
    int64Value: undefined,
    uint64Value: undefined,
    doubleValue: undefined,
    stringValue: undefined,
    bytesValue: undefined,
    durationValue: undefined,
    timestampValue: undefined,
  };
}

export const Constant: MessageFns<Constant> = {
  encode(message: Constant, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nullValue !== undefined) {
      writer.uint32(8).int32(nullValueToNumber(message.nullValue));
    }
    if (message.boolValue !== undefined) {
      writer.uint32(16).bool(message.boolValue);
    }
    if (message.int64Value !== undefined) {
      writer.uint32(24).int64(message.int64Value.toString());
    }
    if (message.uint64Value !== undefined) {
      writer.uint32(32).uint64(message.uint64Value.toString());
    }
    if (message.doubleValue !== undefined) {
      writer.uint32(41).double(message.doubleValue);
    }
    if (message.stringValue !== undefined) {
      writer.uint32(50).string(message.stringValue);
    }
    if (message.bytesValue !== undefined) {
      writer.uint32(58).bytes(message.bytesValue);
    }
    if (message.durationValue !== undefined) {
      Duration.encode(message.durationValue, writer.uint32(66).fork()).join();
    }
    if (message.timestampValue !== undefined) {
      Timestamp.encode(message.timestampValue, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Constant {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConstant();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.nullValue = nullValueFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.boolValue = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.int64Value = Long.fromString(reader.int64().toString());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.uint64Value = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.doubleValue = reader.double();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.stringValue = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.bytesValue = reader.bytes();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.durationValue = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.timestampValue = Timestamp.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  toJSON(message: Constant): unknown {
    const obj: any = {};
    if (message.nullValue !== undefined) {
      obj.nullValue = nullValueToJSON(message.nullValue);
    }
    if (message.boolValue !== undefined) {
      obj.boolValue = message.boolValue;
    }
    if (message.int64Value !== undefined) {
      obj.int64Value = (message.int64Value || Long.ZERO).toString();
    }
    if (message.uint64Value !== undefined) {
      obj.uint64Value = (message.uint64Value || Long.UZERO).toString();
    }
    if (message.doubleValue !== undefined) {
      obj.doubleValue = message.doubleValue;
    }
    if (message.stringValue !== undefined) {
      obj.stringValue = message.stringValue;
    }
    if (message.bytesValue !== undefined) {
      obj.bytesValue = base64FromBytes(message.bytesValue);
    }
    if (message.durationValue !== undefined) {
      obj.durationValue = Duration.toJSON(message.durationValue);
    }
    if (message.timestampValue !== undefined) {
      obj.timestampValue = fromTimestamp(message.timestampValue).toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<Constant>): Constant {
    return Constant.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Constant>): Constant {
    const message = createBaseConstant();
    message.nullValue = object.nullValue ?? undefined;
    message.boolValue = object.boolValue ?? undefined;
    message.int64Value = (object.int64Value !== undefined && object.int64Value !== null)
      ? Long.fromValue(object.int64Value)
      : undefined;
    message.uint64Value = (object.uint64Value !== undefined && object.uint64Value !== null)
      ? Long.fromValue(object.uint64Value)
      : undefined;
    message.doubleValue = object.doubleValue ?? undefined;
    message.stringValue = object.stringValue ?? undefined;
    message.bytesValue = object.bytesValue ?? undefined;
    message.durationValue = (object.durationValue !== undefined && object.durationValue !== null)
      ? Duration.fromPartial(object.durationValue)
      : undefined;
    message.timestampValue = (object.timestampValue !== undefined && object.timestampValue !== null)
      ? Timestamp.fromPartial(object.timestampValue)
      : undefined;
    return message;
  },
};

function base64FromBytes(arr: Uint8Array): string {
  const bin: string[] = [];
  arr.forEach((byte) => {
    bin.push(globalThis.String.fromCharCode(byte));
  });
  return globalThis.btoa(bin.join(""));
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
