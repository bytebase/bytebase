<template>
  <div
    class="w-full h-auto flex-grow flex flex-col justify-start items-start overflow-auto"
  >
    <MonacoEditor
      class="w-full h-full"
      :filename="filename"
      :content="content"
      :language="language"
      :dialect="dialect"
      :readonly="readonly"
      :advices="advices"
      :auto-complete-context="{
        instance: instance.name,
        database: database.name,
        schema: chosenSchema,
        scene: 'query',
      }"
      @update:content="handleUpdateStatement"
      @select-content="handleUpdateSelectedStatement"
      @update:selection="handleUpdateSelection"
      @ready="handleEditorReady"
    />
  </div>
</template>

<script lang="ts" setup>
import { storeToRefs } from "pinia";
import { v1 as uuidv1 } from "uuid";
import { computed, nextTick, ref, watch } from "vue";
import type {
  AdviceOption,
  IStandaloneCodeEditor,
  MonacoModule,
} from "@/components/MonacoEditor";
import type { Selection as MonacoSelection } from "@/components/MonacoEditor";
import MonacoEditor from "@/components/MonacoEditor/MonacoEditor.vue";
import {
  extensionNameOfLanguage,
  formatEditorContent,
  positionWithOffset,
} from "@/components/MonacoEditor/utils";
import { useEmitteryEventListener } from "@/composables/useEmitteryEventListener";
import { useExecuteSQL } from "@/composables/useExecuteSQL";
import {
  useUIStateStore,
  useWorkSheetAndTabStore,
  useSQLEditorTabStore,
  useConnectionOfCurrentSQLEditorTab,
} from "@/store";
import type { SQLDialect, SQLEditorQueryParams, SQLEditorTab } from "@/types";
import { dialectOfEngineV1 } from "@/types";
import { Advice_Status, type Advice } from "@/types/proto/v1/sql_service";
import { useInstanceV1EditorLanguage } from "@/utils";
import { useSQLEditorContext } from "../../context";

const emit = defineEmits<{
  (e: "execute", params: SQLEditorQueryParams): void;
}>();

const tabStore = useSQLEditorTabStore();
const sheetAndTabStore = useWorkSheetAndTabStore();
const uiStateStore = useUIStateStore();
const { events: editorEvents } = useSQLEditorContext();
const { currentTab, isSwitchingTab } = storeToRefs(tabStore);
const pendingFormatContentCommand = ref(false);
const pendingSetSelectionCommand = ref<{
  start: { line: number; column: number };
  end?: { line: number; column: number };
}>();
const { events: executeSQLEvents } = useExecuteSQL();

const content = computed(() => currentTab.value?.statement ?? "");
const advices = computed((): AdviceOption[] => {
  const tab = currentTab.value;
  if (!tab) {
    return [];
  }
  return tab.editorState.advices;
});
const { instance, database } = useConnectionOfCurrentSQLEditorTab();
const language = useInstanceV1EditorLanguage(instance);
const dialect = computed((): SQLDialect => {
  const engine = instance.value.engine;
  return dialectOfEngineV1(engine);
});
const readonly = computed(() => sheetAndTabStore.isReadOnly);

const filename = computed(() => {
  const name = currentTab.value?.id || uuidv1();
  const ext = extensionNameOfLanguage(language.value);
  return `${name}.${ext}`;
});

const chosenSchema = computed(() => {
  const tab = currentTab.value;
  if (!tab || tab.connection.schema === "") return undefined;
  return tab.connection.schema;
});

const handleUpdateStatement = (value: string) => {
  // When we are switching between tabs, the MonacoEditor emits a 'change'
  // event, but we shouldn't update the current tab;
  if (isSwitchingTab.value) {
    return;
  }
  const tab = currentTab.value;
  if (!tab) {
    return;
  }
  if (value === tab.statement) {
    return;
  }
  tabStore.updateCurrentTab({
    statement: value,
    status: "DIRTY",
  });
};

const handleUpdateSelectedStatement = (value: string) => {
  tabStore.updateCurrentTab({
    selectedStatement: value,
  });
};

const handleUpdateSelection = (selection: MonacoSelection | null) => {
  const tab = currentTab.value;
  if (!tab) return;
  tabStore.updateCurrentTab({
    editorState: {
      ...tab.editorState,
      selection,
    },
  });
};

const handleSaveSheet = () => {
  const tab = currentTab.value;
  if (!tab) {
    return;
  }
  editorEvents.emit("save-sheet", { tab });
};

const runQueryAction = (explain = false) => {
  const tab = tabStore.currentTab;
  if (!tab) {
    return;
  }
  const statement = tab.selectedStatement || tab.statement || "";
  emit("execute", {
    connection: { ...tab.connection },
    statement,
    engine: instance.value.engine,
    explain,
    selection: tab.editorState.selection,
  });
  uiStateStore.saveIntroStateByKey({
    key: "data.query",
    newState: true,
  });
};

const handleEditorReady = (
  monaco: MonacoModule,
  editor: IStandaloneCodeEditor
) => {
  editor.addAction({
    id: "RunQuery",
    label: "Run Query",
    keybindings: [monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter],
    contextMenuGroupId: "operation",
    contextMenuOrder: 0,
    run: () => runQueryAction(false),
  });
  editor.addAction({
    id: "ExplainQuery",
    label: "Explain Query",
    keybindings: [monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyE],
    contextMenuGroupId: "operation",
    contextMenuOrder: 0,
    run: () => runQueryAction(true),
  });
  editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyS, () => {
    handleSaveSheet();
  });

  watch(
    pendingFormatContentCommand,
    (pending) => {
      if (pending) {
        formatEditorContent(editor, dialect.value);
        nextTick(() => {
          pendingFormatContentCommand.value = false;
        });
      }
    },
    { immediate: true }
  );

  watch(
    pendingSetSelectionCommand,
    (range) => {
      if (range) {
        const start = range.start;
        const end = range.end ?? start;
        editor.setSelection({
          startLineNumber: start.line,
          startColumn: start.column,
          endLineNumber: end.line,
          endColumn: end.column,
        });
        editor.revealLineNearTop(start.line);
        editor.focus();
        nextTick(() => {
          pendingSetSelectionCommand.value = undefined;
        });
      }
    },
    { immediate: true }
  );
};
const updateAdvices = (
  tab: SQLEditorTab,
  params: SQLEditorQueryParams,
  advices: Advice[]
) => {
  tab.editorState.advices = advices.map<AdviceOption>((advice) => {
    const [startLine, startColumn] = positionWithOffset(
      advice.startPosition?.line ?? advice.line,
      advice.startPosition?.column ?? advice.column,
      params.selection
    );
    const [endLine, endColumn] = positionWithOffset(
      advice.endPosition?.line ?? advice.startPosition?.line ?? advice.line,
      advice.endPosition?.column ??
        advice.startPosition?.column ??
        advice.column,
      params.selection
    );
    const code = advice.code;
    const source = [`L${startLine}:C${startColumn}`];
    if (code > 0) {
      source.unshift(`(${code})`);
    }
    if (advice.title) {
      source.unshift(advice.title);
    }
    return {
      severity: advice.status === Advice_Status.ERROR ? "ERROR" : "WARNING",
      message: advice.content,
      source: source.join(" "),
      startLineNumber: startLine,
      endLineNumber: endLine,
      startColumn: startColumn,
      endColumn: endColumn,
    };
  });
};

useEmitteryEventListener(editorEvents, "format-content", () => {
  pendingFormatContentCommand.value = true;
});
useEmitteryEventListener(editorEvents, "set-editor-selection", (range) => {
  pendingSetSelectionCommand.value = range;
});

useEmitteryEventListener(
  executeSQLEvents,
  "update:advices",
  ({ tab, params, advices }) => {
    if (tab.id !== currentTab.value?.id) return;
    updateAdvices(tab, params, advices);
  }
);
</script>
