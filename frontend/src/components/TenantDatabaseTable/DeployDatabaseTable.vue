<template>
  <div>
    <BBTable
      :data-source="groupedStages"
      :show-header="true"
      :custom-header="true"
      :row-clickable="false"
    >
      <template #header>
        <tr>
          <BBTableHeaderCell compact class="w-1/12 pl-3 pr-2">
            <YAxisSwitch v-model:label="state.label" :label-list="labelList" />
          </BBTableHeaderCell>

          <BBTableHeaderCell
            v-for="(xValue, i) in xAxisValues"
            :key="xValue"
            :style="{ width: headerColumnWidth }"
            compact
            class="text-center py-2"
          >
            <NPopover placement="top" trigger="hover">
              <template #trigger>
                <span
                  class="px-1.5 py-1 relative rounded inline-flex items-center hover:bg-control-bg-hover cursor-pointer select-none"
                >
                  {{ xValue }}
                </span>
              </template>
              <div class="space-y-1">
                <div class="textlabel">
                  {{ $t("deployment-config.selectors") }}
                </div>
                <DeploymentStage
                  :allow-edit="false"
                  :show-header="false"
                  :deployment="deployment.schedule.deployments[i]"
                />
              </div>
            </NPopover>
          </BBTableHeaderCell>

          <BBTableHeaderCell v-if="hasRest" compact class="text-center py-2">
            <NPopover placement="top" trigger="hover">
              <template #trigger>
                <span
                  class="px-1.5 py-1 relative rounded inline-flex items-center hover:bg-control-bg-hover cursor-pointer select-none"
                >
                  <heroicons-outline:exclamation
                    class="h-4 w-4 mr-1 text-warning"
                  />
                  {{ $t("common.others") }}
                </span>
              </template>
              <div class="flex items-center text-sm">
                {{ $t("deployment-config.wont-be-deployed") }}
              </div>
            </NPopover>
          </BBTableHeaderCell>
        </tr>
      </template>

      <template #body="{ rowData: matrix }">
        <BBTableCell
          :left-padding="4"
          class="pr-2 whitespace-nowrap"
          :class="{
            'text-control-placeholder': !matrix.labelValue,
          }"
        >
          <template v-if="matrix.labelValue">{{ matrix.labelValue }}</template>
          <template v-else>{{ $t("label.empty-label-value") }}</template>
        </BBTableCell>
        <BBTableCell v-for="(dbList, i) in matrix.stages" :key="i">
          <div class="flex flex-col items-center space-y-1">
            <DatabaseMatrixItem
              v-for="db in dbList"
              :key="db.id"
              :database="db"
              :clickable="false"
            />
            <span v-if="dbList.length === 0">-</span>
          </div>
        </BBTableCell>

        <BBTableCell v-if="hasRest">
          <div class="flex flex-col items-center space-y-1">
            <DatabaseMatrixItem
              v-for="db in matrix.rest"
              :key="db.id"
              :database="db"
              :clickable="false"
            />
            <span v-if="matrix.rest.length === 0">-</span>
          </div>
        </BBTableCell>
      </template>
    </BBTable>
  </div>
</template>

<script lang="ts" setup>
import { groupBy } from "lodash-es";
import { computed, defineProps, reactive, withDefaults } from "vue";
import type {
  Database,
  DeploymentConfig,
  Environment,
  Label,
} from "../../types";
import { getLabelValue, getPipelineFromDeploymentSchedule } from "../../utils";
import { NPopover } from "naive-ui";
import { DeploymentStage } from "../DeploymentConfigTool";
import YAxisSwitch from "./YAxisSwitch.vue";

const props = withDefaults(
  defineProps<{
    databaseList: Database[];
    labelList: Label[];
    environmentList: Environment[];
    deployment: DeploymentConfig;
    bordered?: boolean;
    showRest?: boolean;
  }>(),
  {
    bordered: true,
    showRest: true,
  }
);

const state = reactive({
  label: "bb.environment",
});

const yAxisValues = computed(() => {
  // order based on label.valueList
  // plus one more "<empty value>"
  const key = state.label;
  const label = props.labelList.find((label) => label.key === key);
  if (!label) return [];
  return [...label.valueList, ""];
});

const xAxisValues = computed(() => {
  // x-axis is generated by deployment stages
  return props.deployment.schedule.deployments.map((dep) => dep.name);
});

const databaseGroups = computed(() => {
  const key = state.label;
  const dict = groupBy(props.databaseList, (db) => getLabelValue(db, key));
  const rows = yAxisValues.value.map((labelValue) => {
    const databaseList = dict[labelValue] || [];
    return {
      labelValue,
      databaseList,
    };
  });

  if (rows.length > 0 && rows[rows.length - 1].databaseList.length === 0) {
    // ignore "<empty value>" row if no databases
    rows.pop();
  }

  return rows;
});

const groupedStages = computed(() => {
  return databaseGroups.value.map(({ labelValue, databaseList }) => {
    const stages = getPipelineFromDeploymentSchedule(
      databaseList,
      props.deployment.schedule
    );
    const affectedIds = stages.flatMap((dbs) => dbs.map((db) => db.id));
    const dict = new Set(affectedIds);
    const rest = props.showRest
      ? databaseList.filter((db) => !dict.has(db.id))
      : [];

    return {
      labelValue,
      stages,
      rest,
    };
  });
});

const hasRest = computed(() => {
  return groupedStages.value.some((group) => group.rest.length > 0);
});

const headerColumnWidth = computed(() => {
  let base = xAxisValues.value.length;
  if (hasRest.value) base += 1;
  return `${(100 - 1 / 12) / base - 1}%`;
});
</script>
