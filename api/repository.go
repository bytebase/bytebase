package api

import (
	"context"
	"encoding/json"
)

type Repository struct {
	ID int `jsonapi:"primary,repository"`

	// Standard fields
	CreatorID int
	Creator   *Principal `jsonapi:"attr,creator"`
	CreatedTs int64      `jsonapi:"attr,createdTs"`
	UpdaterID int
	Updater   *Principal `jsonapi:"attr,updater"`
	UpdatedTs int64      `jsonapi:"attr,updatedTs"`

	// Related fields
	VCSID     int
	VCS       *VCS `jsonapi:"relation,vcs"`
	ProjectID int
	Project   *Project `jsonapi:"relation,project"`

	// Domain specific fields
	Name          string `jsonapi:"attr,name"`
	FullPath      string `jsonapi:"attr,fullPath"`
	WebURL        string `jsonapi:"attr,webURL"`
	BranchFilter  string `jsonapi:"attr,branchFilter"`
	BaseDirectory string `jsonapi:"attr,baseDirectory"`
	// The file path template for matching the commited migration script.
	FilePathTemplate string `jsonapi:"attr,filePathTemplate"`
	// The file path template for storing the latest schema auto-generated by Bytebase after migration.
	// If empty, then Bytebase won't auto generate it.
	SchemaPathTemplate string `jsonapi:"attr,schemaPathTemplate"`
	ExternalID         string `jsonapi:"attr,externalID"`
	ExternalWebhookID  string
	WebhookURLHost     string
	WebhookEndpointID  string
	WebhookSecretToken string
	// These will be exclusively used on the server side and we don't return it to the client.
	AccessToken  string
	ExpiresTs    int64
	RefreshToken string
}

type RepositoryCreate struct {
	// Standard fields
	// Value is assigned from the jwt subject field passed by the client.
	CreatorID int

	// Related fields
	VCSID     int `jsonapi:"attr,vcsID"`
	ProjectID int `jsonapi:"attr,projectID"`

	// Domain specific fields
	Name               string `jsonapi:"attr,name"`
	FullPath           string `jsonapi:"attr,fullPath"`
	WebURL             string `jsonapi:"attr,webURL"`
	BranchFilter       string `jsonapi:"attr,branchFilter"`
	BaseDirectory      string `jsonapi:"attr,baseDirectory"`
	FilePathTemplate   string `jsonapi:"attr,filePathTemplate"`
	SchemaPathTemplate string `jsonapi:"attr,schemaPathTemplate"`
	ExternalID         string `jsonapi:"attr,externalID"`
	// Token belonged by the user linking the project to the VCS repository. We store this token together
	// with the refresh token in the new repository record so we can use it to call VCS API on
	// behalf of that user to perform tasks like webhook CRUD later.
	AccessToken        string `jsonapi:"attr,accessToken"`
	ExpiresTs          int64  `jsonapi:"attr,expiresTs"`
	RefreshToken       string `jsonapi:"attr,refreshToken"`
	ExternalWebhookID  string
	WebhookURLHost     string
	WebhookEndpointID  string
	WebhookSecretToken string
}

type RepositoryFind struct {
	ID *int

	// Related fields
	VCSID     *int
	ProjectID *int

	// Domain specific fields
	WebhookEndpointID *string
}

func (find *RepositoryFind) String() string {
	str, err := json.Marshal(*find)
	if err != nil {
		return err.Error()
	}
	return string(str)
}

type RepositoryPatch struct {
	ID int `jsonapi:"primary,repositoryPatch"`

	// Standard fields
	// Value is assigned from the jwt subject field passed by the client.
	UpdaterID int

	// Domain specific fields
	BranchFilter       *string `jsonapi:"attr,branchFilter"`
	BaseDirectory      *string `jsonapi:"attr,baseDirectory"`
	FilePathTemplate   *string `jsonapi:"attr,filePathTemplate"`
	SchemaPathTemplate *string `jsonapi:"attr,schemaPathTemplate"`
}

type RepositoryDelete struct {
	// Related fields
	// When deleting the repository, we need to update the correponding project workflow type to "UI",
	// thus we use ProjectID here.
	ProjectID int

	// Standard fields
	// Value is assigned from the jwt subject field passed by the client.
	DeleterID int
}

type RepositoryService interface {
	CreateRepository(ctx context.Context, create *RepositoryCreate) (*Repository, error)
	FindRepositoryList(ctx context.Context, find *RepositoryFind) ([]*Repository, error)
	FindRepository(ctx context.Context, find *RepositoryFind) (*Repository, error)
	PatchRepository(ctx context.Context, patch *RepositoryPatch) (*Repository, error)
	DeleteRepository(ctx context.Context, delete *RepositoryDelete) error
}
