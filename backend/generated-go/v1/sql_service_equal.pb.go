// Code generated by protoc-gen-equal-go. DO NOT EDIT.
// source: v1/sql_service.proto

package v1

import (
	proto "google.golang.org/protobuf/proto"
	structpb "google.golang.org/protobuf/types/known/structpb"
	math "math"
)

func (x *AdminExecuteRequest) Equal(y *AdminExecuteRequest) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if x.Statement != y.Statement {
		return false
	}
	if x.Limit != y.Limit {
		return false
	}
	if p, q := x.Schema, y.Schema; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := x.Container, y.Container; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	return true
}

func (x *AdminExecuteResponse) Equal(y *AdminExecuteResponse) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if len(x.Results) != len(y.Results) {
		return false
	}
	for i := 0; i < len(x.Results); i++ {
		if !x.Results[i].Equal(y.Results[i]) {
			return false
		}
	}
	return true
}

func (x *QueryRequest) Equal(y *QueryRequest) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if x.Statement != y.Statement {
		return false
	}
	if x.Limit != y.Limit {
		return false
	}
	if x.DataSourceId != y.DataSourceId {
		return false
	}
	if x.Explain != y.Explain {
		return false
	}
	if p, q := x.Schema, y.Schema; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if !x.QueryOption.Equal(y.QueryOption) {
		return false
	}
	if p, q := x.Container, y.Container; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	return true
}

func (x *QueryResponse) Equal(y *QueryResponse) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if len(x.Results) != len(y.Results) {
		return false
	}
	for i := 0; i < len(x.Results); i++ {
		if !x.Results[i].Equal(y.Results[i]) {
			return false
		}
	}
	return true
}

func (x *QueryOption) Equal(y *QueryOption) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.RedisRunCommandsOn != y.RedisRunCommandsOn {
		return false
	}
	return true
}

func (x *QueryResult_PostgresError) Equal(y *QueryResult_PostgresError) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Severity != y.Severity {
		return false
	}
	if x.Code != y.Code {
		return false
	}
	if x.Message != y.Message {
		return false
	}
	if x.Detail != y.Detail {
		return false
	}
	if x.Hint != y.Hint {
		return false
	}
	if x.Position != y.Position {
		return false
	}
	if x.InternalPosition != y.InternalPosition {
		return false
	}
	if x.InternalQuery != y.InternalQuery {
		return false
	}
	if x.Where != y.Where {
		return false
	}
	if x.SchemaName != y.SchemaName {
		return false
	}
	if x.TableName != y.TableName {
		return false
	}
	if x.ColumnName != y.ColumnName {
		return false
	}
	if x.DataTypeName != y.DataTypeName {
		return false
	}
	if x.ConstraintName != y.ConstraintName {
		return false
	}
	if x.File != y.File {
		return false
	}
	if x.Line != y.Line {
		return false
	}
	if x.Routine != y.Routine {
		return false
	}
	return true
}

func (x *QueryResult_Message) Equal(y *QueryResult_Message) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Level != y.Level {
		return false
	}
	if x.Content != y.Content {
		return false
	}
	return true
}

func (x *QueryResult) Equal(y *QueryResult) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if len(x.ColumnNames) != len(y.ColumnNames) {
		return false
	}
	for i := 0; i < len(x.ColumnNames); i++ {
		if x.ColumnNames[i] != y.ColumnNames[i] {
			return false
		}
	}
	if len(x.ColumnTypeNames) != len(y.ColumnTypeNames) {
		return false
	}
	for i := 0; i < len(x.ColumnTypeNames); i++ {
		if x.ColumnTypeNames[i] != y.ColumnTypeNames[i] {
			return false
		}
	}
	if len(x.Rows) != len(y.Rows) {
		return false
	}
	for i := 0; i < len(x.Rows); i++ {
		if !x.Rows[i].Equal(y.Rows[i]) {
			return false
		}
	}
	if x.RowsCount != y.RowsCount {
		return false
	}
	if x.Error != y.Error {
		return false
	}
	if p, q := x.Latency, y.Latency; (p == nil && q != nil) || (p != nil && (q == nil || p.Seconds != q.Seconds || p.Nanos != q.Nanos)) {
		return false
	}
	if x.Statement != y.Statement {
		return false
	}
	if !x.GetPostgresError().Equal(y.GetPostgresError()) {
		return false
	}
	if x.AllowExport != y.AllowExport {
		return false
	}
	if len(x.Messages) != len(y.Messages) {
		return false
	}
	for i := 0; i < len(x.Messages); i++ {
		if !x.Messages[i].Equal(y.Messages[i]) {
			return false
		}
	}
	if len(x.Masked) != len(y.Masked) {
		return false
	}
	for i := 0; i < len(x.Masked); i++ {
		if !x.Masked[i].Equal(y.Masked[i]) {
			return false
		}
	}
	return true
}

func (x *MaskingReason) Equal(y *MaskingReason) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.SemanticTypeId != y.SemanticTypeId {
		return false
	}
	if x.SemanticTypeTitle != y.SemanticTypeTitle {
		return false
	}
	if x.MaskingRuleId != y.MaskingRuleId {
		return false
	}
	if x.Algorithm != y.Algorithm {
		return false
	}
	if x.Context != y.Context {
		return false
	}
	if x.ClassificationLevel != y.ClassificationLevel {
		return false
	}
	if x.SemanticTypeIcon != y.SemanticTypeIcon {
		return false
	}
	return true
}

func (x *QueryRow) Equal(y *QueryRow) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if len(x.Values) != len(y.Values) {
		return false
	}
	for i := 0; i < len(x.Values); i++ {
		if !x.Values[i].Equal(y.Values[i]) {
			return false
		}
	}
	return true
}

func (x *RowValue_Timestamp) Equal(y *RowValue_Timestamp) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if p, q := x.GoogleTimestamp, y.GoogleTimestamp; (p == nil && q != nil) || (p != nil && (q == nil || p.Seconds != q.Seconds || p.Nanos != q.Nanos)) {
		return false
	}
	if x.Accuracy != y.Accuracy {
		return false
	}
	return true
}

func (x *RowValue_TimestampTZ) Equal(y *RowValue_TimestampTZ) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if p, q := x.GoogleTimestamp, y.GoogleTimestamp; (p == nil && q != nil) || (p != nil && (q == nil || p.Seconds != q.Seconds || p.Nanos != q.Nanos)) {
		return false
	}
	if x.Zone != y.Zone {
		return false
	}
	if x.Offset != y.Offset {
		return false
	}
	if x.Accuracy != y.Accuracy {
		return false
	}
	return true
}

func (x *RowValue) Equal(y *RowValue) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.GetNullValue() != y.GetNullValue() {
		return false
	}
	if x.GetBoolValue() != y.GetBoolValue() {
		return false
	}
	if string(x.GetBytesValue()) != string(y.GetBytesValue()) {
		return false
	}
	if (math.IsNaN(float64(x.GetDoubleValue())) && !math.IsNaN(float64(y.GetDoubleValue())) || !math.IsNaN(float64(x.GetDoubleValue())) && math.IsNaN(float64(y.GetDoubleValue()))) || (!math.IsNaN(float64(x.GetDoubleValue())) && !math.IsNaN(float64(y.GetDoubleValue())) && x.GetDoubleValue() != y.GetDoubleValue()) {
		return false
	}
	if (math.IsNaN(float64(x.GetFloatValue())) && !math.IsNaN(float64(y.GetFloatValue())) || !math.IsNaN(float64(x.GetFloatValue())) && math.IsNaN(float64(y.GetFloatValue()))) || (!math.IsNaN(float64(x.GetFloatValue())) && !math.IsNaN(float64(y.GetFloatValue())) && x.GetFloatValue() != y.GetFloatValue()) {
		return false
	}
	if x.GetInt32Value() != y.GetInt32Value() {
		return false
	}
	if x.GetInt64Value() != y.GetInt64Value() {
		return false
	}
	if x.GetStringValue() != y.GetStringValue() {
		return false
	}
	if x.GetUint32Value() != y.GetUint32Value() {
		return false
	}
	if x.GetUint64Value() != y.GetUint64Value() {
		return false
	}
	if equal, ok := interface{}(x.GetValueValue()).(interface{ Equal(*structpb.Value) bool }); !ok || !equal.Equal(y.GetValueValue()) {
		return false
	} else if !proto.Equal(x.GetValueValue(), y.GetValueValue()) {
		return false
	}
	if !x.GetTimestampValue().Equal(y.GetTimestampValue()) {
		return false
	}
	if !x.GetTimestampTzValue().Equal(y.GetTimestampTzValue()) {
		return false
	}
	return true
}

func (x *Advice) Equal(y *Advice) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Status != y.Status {
		return false
	}
	if x.Code != y.Code {
		return false
	}
	if x.Title != y.Title {
		return false
	}
	if x.Content != y.Content {
		return false
	}
	if !x.StartPosition.Equal(y.StartPosition) {
		return false
	}
	if !x.EndPosition.Equal(y.EndPosition) {
		return false
	}
	return true
}

func (x *ExportRequest) Equal(y *ExportRequest) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if x.Statement != y.Statement {
		return false
	}
	if x.Limit != y.Limit {
		return false
	}
	if x.Format != y.Format {
		return false
	}
	if x.Admin != y.Admin {
		return false
	}
	if x.Password != y.Password {
		return false
	}
	if x.DataSourceId != y.DataSourceId {
		return false
	}
	if p, q := x.Schema, y.Schema; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	return true
}

func (x *ExportResponse) Equal(y *ExportResponse) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if string(x.Content) != string(y.Content) {
		return false
	}
	return true
}

func (x *CheckRequest) Equal(y *CheckRequest) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if x.Statement != y.Statement {
		return false
	}
	if x.ChangeType != y.ChangeType {
		return false
	}
	return true
}

func (x *CheckResponse) Equal(y *CheckResponse) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if len(x.Advices) != len(y.Advices) {
		return false
	}
	for i := 0; i < len(x.Advices); i++ {
		if !x.Advices[i].Equal(y.Advices[i]) {
			return false
		}
	}
	if x.AffectedRows != y.AffectedRows {
		return false
	}
	return true
}

func (x *DiffMetadataRequest) Equal(y *DiffMetadataRequest) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if !x.SourceMetadata.Equal(y.SourceMetadata) {
		return false
	}
	if !x.TargetMetadata.Equal(y.TargetMetadata) {
		return false
	}
	if !x.SourceCatalog.Equal(y.SourceCatalog) {
		return false
	}
	if !x.TargetCatalog.Equal(y.TargetCatalog) {
		return false
	}
	if x.Engine != y.Engine {
		return false
	}
	if x.ClassificationFromConfig != y.ClassificationFromConfig {
		return false
	}
	return true
}

func (x *DiffMetadataResponse) Equal(y *DiffMetadataResponse) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Diff != y.Diff {
		return false
	}
	return true
}

func (x *SearchQueryHistoriesRequest) Equal(y *SearchQueryHistoriesRequest) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.PageSize != y.PageSize {
		return false
	}
	if x.PageToken != y.PageToken {
		return false
	}
	if x.Filter != y.Filter {
		return false
	}
	return true
}

func (x *SearchQueryHistoriesResponse) Equal(y *SearchQueryHistoriesResponse) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if len(x.QueryHistories) != len(y.QueryHistories) {
		return false
	}
	for i := 0; i < len(x.QueryHistories); i++ {
		if !x.QueryHistories[i].Equal(y.QueryHistories[i]) {
			return false
		}
	}
	if x.NextPageToken != y.NextPageToken {
		return false
	}
	return true
}

func (x *QueryHistory) Equal(y *QueryHistory) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if x.Database != y.Database {
		return false
	}
	if x.Creator != y.Creator {
		return false
	}
	if p, q := x.CreateTime, y.CreateTime; (p == nil && q != nil) || (p != nil && (q == nil || p.Seconds != q.Seconds || p.Nanos != q.Nanos)) {
		return false
	}
	if x.Statement != y.Statement {
		return false
	}
	if p, q := x.Error, y.Error; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := x.Duration, y.Duration; (p == nil && q != nil) || (p != nil && (q == nil || p.Seconds != q.Seconds || p.Nanos != q.Nanos)) {
		return false
	}
	if x.Type != y.Type {
		return false
	}
	return true
}

func (x *AICompletionRequest_Message) Equal(y *AICompletionRequest_Message) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Role != y.Role {
		return false
	}
	if x.Content != y.Content {
		return false
	}
	return true
}

func (x *AICompletionRequest) Equal(y *AICompletionRequest) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if len(x.Messages) != len(y.Messages) {
		return false
	}
	for i := 0; i < len(x.Messages); i++ {
		if !x.Messages[i].Equal(y.Messages[i]) {
			return false
		}
	}
	return true
}

func (x *AICompletionResponse_Candidate_Content_Part) Equal(y *AICompletionResponse_Candidate_Content_Part) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Text != y.Text {
		return false
	}
	return true
}

func (x *AICompletionResponse_Candidate_Content) Equal(y *AICompletionResponse_Candidate_Content) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if len(x.Parts) != len(y.Parts) {
		return false
	}
	for i := 0; i < len(x.Parts); i++ {
		if !x.Parts[i].Equal(y.Parts[i]) {
			return false
		}
	}
	return true
}

func (x *AICompletionResponse_Candidate) Equal(y *AICompletionResponse_Candidate) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if !x.Content.Equal(y.Content) {
		return false
	}
	return true
}

func (x *AICompletionResponse) Equal(y *AICompletionResponse) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if len(x.Candidates) != len(y.Candidates) {
		return false
	}
	for i := 0; i < len(x.Candidates); i++ {
		if !x.Candidates[i].Equal(y.Candidates[i]) {
			return false
		}
	}
	return true
}
