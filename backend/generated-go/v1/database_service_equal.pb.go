// Code generated by protoc-gen-equal-go. DO NOT EDIT.
// source: v1/database_service.proto

package v1

import (
	proto "google.golang.org/protobuf/proto"
	fieldmaskpb "google.golang.org/protobuf/types/known/fieldmaskpb"
	math "math"
)

func (x *GetDatabaseRequest) Equal(y *GetDatabaseRequest) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	return true
}

func (x *BatchGetDatabasesRequest) Equal(y *BatchGetDatabasesRequest) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Parent != y.Parent {
		return false
	}
	if len(x.Names) != len(y.Names) {
		return false
	}
	for i := 0; i < len(x.Names); i++ {
		if x.Names[i] != y.Names[i] {
			return false
		}
	}
	return true
}

func (x *BatchGetDatabasesResponse) Equal(y *BatchGetDatabasesResponse) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if len(x.Databases) != len(y.Databases) {
		return false
	}
	for i := 0; i < len(x.Databases); i++ {
		if !x.Databases[i].Equal(y.Databases[i]) {
			return false
		}
	}
	return true
}

func (x *ListDatabasesRequest) Equal(y *ListDatabasesRequest) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Parent != y.Parent {
		return false
	}
	if x.PageSize != y.PageSize {
		return false
	}
	if x.PageToken != y.PageToken {
		return false
	}
	if x.Filter != y.Filter {
		return false
	}
	if x.ShowDeleted != y.ShowDeleted {
		return false
	}
	return true
}

func (x *ListDatabasesResponse) Equal(y *ListDatabasesResponse) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if len(x.Databases) != len(y.Databases) {
		return false
	}
	for i := 0; i < len(x.Databases); i++ {
		if !x.Databases[i].Equal(y.Databases[i]) {
			return false
		}
	}
	if x.NextPageToken != y.NextPageToken {
		return false
	}
	return true
}

func (x *UpdateDatabaseRequest) Equal(y *UpdateDatabaseRequest) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if !x.Database.Equal(y.Database) {
		return false
	}
	if equal, ok := interface{}(x.UpdateMask).(interface {
		Equal(*fieldmaskpb.FieldMask) bool
	}); !ok || !equal.Equal(y.UpdateMask) {
		return false
	} else if !proto.Equal(x.UpdateMask, y.UpdateMask) {
		return false
	}
	if x.AllowMissing != y.AllowMissing {
		return false
	}
	return true
}

func (x *BatchUpdateDatabasesRequest) Equal(y *BatchUpdateDatabasesRequest) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Parent != y.Parent {
		return false
	}
	if len(x.Requests) != len(y.Requests) {
		return false
	}
	for i := 0; i < len(x.Requests); i++ {
		if !x.Requests[i].Equal(y.Requests[i]) {
			return false
		}
	}
	return true
}

func (x *BatchUpdateDatabasesResponse) Equal(y *BatchUpdateDatabasesResponse) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if len(x.Databases) != len(y.Databases) {
		return false
	}
	for i := 0; i < len(x.Databases); i++ {
		if !x.Databases[i].Equal(y.Databases[i]) {
			return false
		}
	}
	return true
}

func (x *BatchSyncDatabasesRequest) Equal(y *BatchSyncDatabasesRequest) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Parent != y.Parent {
		return false
	}
	if len(x.Names) != len(y.Names) {
		return false
	}
	for i := 0; i < len(x.Names); i++ {
		if x.Names[i] != y.Names[i] {
			return false
		}
	}
	return true
}

func (x *BatchSyncDatabasesResponse) Equal(y *BatchSyncDatabasesResponse) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	return true
}

func (x *SyncDatabaseRequest) Equal(y *SyncDatabaseRequest) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	return true
}

func (x *SyncDatabaseResponse) Equal(y *SyncDatabaseResponse) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	return true
}

func (x *GetDatabaseMetadataRequest) Equal(y *GetDatabaseMetadataRequest) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if x.Filter != y.Filter {
		return false
	}
	if x.Limit != y.Limit {
		return false
	}
	return true
}

func (x *GetDatabaseSchemaRequest) Equal(y *GetDatabaseSchemaRequest) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	return true
}

func (x *GetDatabaseSDLSchemaRequest) Equal(y *GetDatabaseSDLSchemaRequest) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if x.Format != y.Format {
		return false
	}
	return true
}

func (x *DiffSchemaRequest) Equal(y *DiffSchemaRequest) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if x.GetSchema() != y.GetSchema() {
		return false
	}
	if x.GetChangelog() != y.GetChangelog() {
		return false
	}
	return true
}

func (x *DiffSchemaResponse) Equal(y *DiffSchemaResponse) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Diff != y.Diff {
		return false
	}
	return true
}

func (x *Database) Equal(y *Database) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if x.State != y.State {
		return false
	}
	if p, q := x.SuccessfulSyncTime, y.SuccessfulSyncTime; (p == nil && q != nil) || (p != nil && (q == nil || p.Seconds != q.Seconds || p.Nanos != q.Nanos)) {
		return false
	}
	if x.Project != y.Project {
		return false
	}
	if x.SchemaVersion != y.SchemaVersion {
		return false
	}
	if p, q := x.Environment, y.Environment; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := x.EffectiveEnvironment, y.EffectiveEnvironment; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if len(x.Labels) != len(y.Labels) {
		return false
	}
	for k := range x.Labels {
		_, ok := y.Labels[k]
		if !ok {
			return false
		}
		if x.Labels[k] != y.Labels[k] {
			return false
		}
	}
	if !x.InstanceResource.Equal(y.InstanceResource) {
		return false
	}
	if x.BackupAvailable != y.BackupAvailable {
		return false
	}
	if x.Drifted != y.Drifted {
		return false
	}
	return true
}

func (x *DatabaseMetadata) Equal(y *DatabaseMetadata) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if len(x.Schemas) != len(y.Schemas) {
		return false
	}
	for i := 0; i < len(x.Schemas); i++ {
		if !x.Schemas[i].Equal(y.Schemas[i]) {
			return false
		}
	}
	if x.CharacterSet != y.CharacterSet {
		return false
	}
	if x.Collation != y.Collation {
		return false
	}
	if len(x.Extensions) != len(y.Extensions) {
		return false
	}
	for i := 0; i < len(x.Extensions); i++ {
		if !x.Extensions[i].Equal(y.Extensions[i]) {
			return false
		}
	}
	if x.Owner != y.Owner {
		return false
	}
	if x.SearchPath != y.SearchPath {
		return false
	}
	return true
}

func (x *SchemaMetadata) Equal(y *SchemaMetadata) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if len(x.Tables) != len(y.Tables) {
		return false
	}
	for i := 0; i < len(x.Tables); i++ {
		if !x.Tables[i].Equal(y.Tables[i]) {
			return false
		}
	}
	if len(x.ExternalTables) != len(y.ExternalTables) {
		return false
	}
	for i := 0; i < len(x.ExternalTables); i++ {
		if !x.ExternalTables[i].Equal(y.ExternalTables[i]) {
			return false
		}
	}
	if len(x.Views) != len(y.Views) {
		return false
	}
	for i := 0; i < len(x.Views); i++ {
		if !x.Views[i].Equal(y.Views[i]) {
			return false
		}
	}
	if len(x.Functions) != len(y.Functions) {
		return false
	}
	for i := 0; i < len(x.Functions); i++ {
		if !x.Functions[i].Equal(y.Functions[i]) {
			return false
		}
	}
	if len(x.Procedures) != len(y.Procedures) {
		return false
	}
	for i := 0; i < len(x.Procedures); i++ {
		if !x.Procedures[i].Equal(y.Procedures[i]) {
			return false
		}
	}
	if len(x.Streams) != len(y.Streams) {
		return false
	}
	for i := 0; i < len(x.Streams); i++ {
		if !x.Streams[i].Equal(y.Streams[i]) {
			return false
		}
	}
	if len(x.Tasks) != len(y.Tasks) {
		return false
	}
	for i := 0; i < len(x.Tasks); i++ {
		if !x.Tasks[i].Equal(y.Tasks[i]) {
			return false
		}
	}
	if len(x.MaterializedViews) != len(y.MaterializedViews) {
		return false
	}
	for i := 0; i < len(x.MaterializedViews); i++ {
		if !x.MaterializedViews[i].Equal(y.MaterializedViews[i]) {
			return false
		}
	}
	if len(x.Packages) != len(y.Packages) {
		return false
	}
	for i := 0; i < len(x.Packages); i++ {
		if !x.Packages[i].Equal(y.Packages[i]) {
			return false
		}
	}
	if x.Owner != y.Owner {
		return false
	}
	if len(x.Sequences) != len(y.Sequences) {
		return false
	}
	for i := 0; i < len(x.Sequences); i++ {
		if !x.Sequences[i].Equal(y.Sequences[i]) {
			return false
		}
	}
	if len(x.Events) != len(y.Events) {
		return false
	}
	for i := 0; i < len(x.Events); i++ {
		if !x.Events[i].Equal(y.Events[i]) {
			return false
		}
	}
	if len(x.EnumTypes) != len(y.EnumTypes) {
		return false
	}
	for i := 0; i < len(x.EnumTypes); i++ {
		if !x.EnumTypes[i].Equal(y.EnumTypes[i]) {
			return false
		}
	}
	if x.SkipDump != y.SkipDump {
		return false
	}
	if x.Comment != y.Comment {
		return false
	}
	return true
}

func (x *EnumTypeMetadata) Equal(y *EnumTypeMetadata) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if len(x.Values) != len(y.Values) {
		return false
	}
	for i := 0; i < len(x.Values); i++ {
		if x.Values[i] != y.Values[i] {
			return false
		}
	}
	if x.Comment != y.Comment {
		return false
	}
	if x.SkipDump != y.SkipDump {
		return false
	}
	return true
}

func (x *EventMetadata) Equal(y *EventMetadata) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if x.Definition != y.Definition {
		return false
	}
	if x.TimeZone != y.TimeZone {
		return false
	}
	if x.SqlMode != y.SqlMode {
		return false
	}
	if x.CharacterSetClient != y.CharacterSetClient {
		return false
	}
	if x.CollationConnection != y.CollationConnection {
		return false
	}
	if x.Comment != y.Comment {
		return false
	}
	return true
}

func (x *SequenceMetadata) Equal(y *SequenceMetadata) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if x.DataType != y.DataType {
		return false
	}
	if x.Start != y.Start {
		return false
	}
	if x.MinValue != y.MinValue {
		return false
	}
	if x.MaxValue != y.MaxValue {
		return false
	}
	if x.Increment != y.Increment {
		return false
	}
	if x.Cycle != y.Cycle {
		return false
	}
	if x.CacheSize != y.CacheSize {
		return false
	}
	if x.LastValue != y.LastValue {
		return false
	}
	if x.OwnerTable != y.OwnerTable {
		return false
	}
	if x.OwnerColumn != y.OwnerColumn {
		return false
	}
	if x.Comment != y.Comment {
		return false
	}
	if x.SkipDump != y.SkipDump {
		return false
	}
	return true
}

func (x *TriggerMetadata) Equal(y *TriggerMetadata) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if x.Event != y.Event {
		return false
	}
	if x.Timing != y.Timing {
		return false
	}
	if x.Body != y.Body {
		return false
	}
	if x.SqlMode != y.SqlMode {
		return false
	}
	if x.CharacterSetClient != y.CharacterSetClient {
		return false
	}
	if x.CollationConnection != y.CollationConnection {
		return false
	}
	if x.Comment != y.Comment {
		return false
	}
	if x.SkipDump != y.SkipDump {
		return false
	}
	return true
}

func (x *ExternalTableMetadata) Equal(y *ExternalTableMetadata) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if x.ExternalServerName != y.ExternalServerName {
		return false
	}
	if x.ExternalDatabaseName != y.ExternalDatabaseName {
		return false
	}
	if len(x.Columns) != len(y.Columns) {
		return false
	}
	for i := 0; i < len(x.Columns); i++ {
		if !x.Columns[i].Equal(y.Columns[i]) {
			return false
		}
	}
	return true
}

func (x *TableMetadata) Equal(y *TableMetadata) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if len(x.Columns) != len(y.Columns) {
		return false
	}
	for i := 0; i < len(x.Columns); i++ {
		if !x.Columns[i].Equal(y.Columns[i]) {
			return false
		}
	}
	if len(x.Indexes) != len(y.Indexes) {
		return false
	}
	for i := 0; i < len(x.Indexes); i++ {
		if !x.Indexes[i].Equal(y.Indexes[i]) {
			return false
		}
	}
	if x.Engine != y.Engine {
		return false
	}
	if x.Collation != y.Collation {
		return false
	}
	if x.Charset != y.Charset {
		return false
	}
	if x.RowCount != y.RowCount {
		return false
	}
	if x.DataSize != y.DataSize {
		return false
	}
	if x.IndexSize != y.IndexSize {
		return false
	}
	if x.DataFree != y.DataFree {
		return false
	}
	if x.CreateOptions != y.CreateOptions {
		return false
	}
	if x.Comment != y.Comment {
		return false
	}
	if len(x.ForeignKeys) != len(y.ForeignKeys) {
		return false
	}
	for i := 0; i < len(x.ForeignKeys); i++ {
		if !x.ForeignKeys[i].Equal(y.ForeignKeys[i]) {
			return false
		}
	}
	if len(x.Partitions) != len(y.Partitions) {
		return false
	}
	for i := 0; i < len(x.Partitions); i++ {
		if !x.Partitions[i].Equal(y.Partitions[i]) {
			return false
		}
	}
	if len(x.CheckConstraints) != len(y.CheckConstraints) {
		return false
	}
	for i := 0; i < len(x.CheckConstraints); i++ {
		if !x.CheckConstraints[i].Equal(y.CheckConstraints[i]) {
			return false
		}
	}
	if x.Owner != y.Owner {
		return false
	}
	if len(x.SortingKeys) != len(y.SortingKeys) {
		return false
	}
	for i := 0; i < len(x.SortingKeys); i++ {
		if x.SortingKeys[i] != y.SortingKeys[i] {
			return false
		}
	}
	if len(x.Triggers) != len(y.Triggers) {
		return false
	}
	for i := 0; i < len(x.Triggers); i++ {
		if !x.Triggers[i].Equal(y.Triggers[i]) {
			return false
		}
	}
	if x.SkipDump != y.SkipDump {
		return false
	}
	if x.ShardingInfo != y.ShardingInfo {
		return false
	}
	if x.PrimaryKeyType != y.PrimaryKeyType {
		return false
	}
	return true
}

func (x *CheckConstraintMetadata) Equal(y *CheckConstraintMetadata) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if x.Expression != y.Expression {
		return false
	}
	return true
}

func (x *TablePartitionMetadata) Equal(y *TablePartitionMetadata) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if x.Type != y.Type {
		return false
	}
	if x.Expression != y.Expression {
		return false
	}
	if x.Value != y.Value {
		return false
	}
	if x.UseDefault != y.UseDefault {
		return false
	}
	if len(x.Subpartitions) != len(y.Subpartitions) {
		return false
	}
	for i := 0; i < len(x.Subpartitions); i++ {
		if !x.Subpartitions[i].Equal(y.Subpartitions[i]) {
			return false
		}
	}
	if len(x.Indexes) != len(y.Indexes) {
		return false
	}
	for i := 0; i < len(x.Indexes); i++ {
		if !x.Indexes[i].Equal(y.Indexes[i]) {
			return false
		}
	}
	if len(x.CheckConstraints) != len(y.CheckConstraints) {
		return false
	}
	for i := 0; i < len(x.CheckConstraints); i++ {
		if !x.CheckConstraints[i].Equal(y.CheckConstraints[i]) {
			return false
		}
	}
	return true
}

func (x *ColumnMetadata) Equal(y *ColumnMetadata) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if x.Position != y.Position {
		return false
	}
	if x.HasDefault != y.HasDefault {
		return false
	}
	if x.Default != y.Default {
		return false
	}
	if x.DefaultOnNull != y.DefaultOnNull {
		return false
	}
	if x.OnUpdate != y.OnUpdate {
		return false
	}
	if x.Nullable != y.Nullable {
		return false
	}
	if x.Type != y.Type {
		return false
	}
	if x.CharacterSet != y.CharacterSet {
		return false
	}
	if x.Collation != y.Collation {
		return false
	}
	if x.Comment != y.Comment {
		return false
	}
	if !x.Generation.Equal(y.Generation) {
		return false
	}
	if x.IsIdentity != y.IsIdentity {
		return false
	}
	if x.IdentityGeneration != y.IdentityGeneration {
		return false
	}
	if x.IdentitySeed != y.IdentitySeed {
		return false
	}
	if x.IdentityIncrement != y.IdentityIncrement {
		return false
	}
	if x.DefaultConstraintName != y.DefaultConstraintName {
		return false
	}
	return true
}

func (x *GenerationMetadata) Equal(y *GenerationMetadata) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Type != y.Type {
		return false
	}
	if x.Expression != y.Expression {
		return false
	}
	return true
}

func (x *ViewMetadata) Equal(y *ViewMetadata) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if x.Definition != y.Definition {
		return false
	}
	if x.Comment != y.Comment {
		return false
	}
	if len(x.DependencyColumns) != len(y.DependencyColumns) {
		return false
	}
	for i := 0; i < len(x.DependencyColumns); i++ {
		if !x.DependencyColumns[i].Equal(y.DependencyColumns[i]) {
			return false
		}
	}
	if len(x.Columns) != len(y.Columns) {
		return false
	}
	for i := 0; i < len(x.Columns); i++ {
		if !x.Columns[i].Equal(y.Columns[i]) {
			return false
		}
	}
	if len(x.Triggers) != len(y.Triggers) {
		return false
	}
	for i := 0; i < len(x.Triggers); i++ {
		if !x.Triggers[i].Equal(y.Triggers[i]) {
			return false
		}
	}
	if x.SkipDump != y.SkipDump {
		return false
	}
	return true
}

func (x *DependencyColumn) Equal(y *DependencyColumn) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Schema != y.Schema {
		return false
	}
	if x.Table != y.Table {
		return false
	}
	if x.Column != y.Column {
		return false
	}
	return true
}

func (x *MaterializedViewMetadata) Equal(y *MaterializedViewMetadata) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if x.Definition != y.Definition {
		return false
	}
	if x.Comment != y.Comment {
		return false
	}
	if len(x.DependencyColumns) != len(y.DependencyColumns) {
		return false
	}
	for i := 0; i < len(x.DependencyColumns); i++ {
		if !x.DependencyColumns[i].Equal(y.DependencyColumns[i]) {
			return false
		}
	}
	if len(x.Triggers) != len(y.Triggers) {
		return false
	}
	for i := 0; i < len(x.Triggers); i++ {
		if !x.Triggers[i].Equal(y.Triggers[i]) {
			return false
		}
	}
	if len(x.Indexes) != len(y.Indexes) {
		return false
	}
	for i := 0; i < len(x.Indexes); i++ {
		if !x.Indexes[i].Equal(y.Indexes[i]) {
			return false
		}
	}
	if x.SkipDump != y.SkipDump {
		return false
	}
	return true
}

func (x *DependencyTable) Equal(y *DependencyTable) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Schema != y.Schema {
		return false
	}
	if x.Table != y.Table {
		return false
	}
	return true
}

func (x *FunctionMetadata) Equal(y *FunctionMetadata) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if x.Definition != y.Definition {
		return false
	}
	if x.Signature != y.Signature {
		return false
	}
	if x.CharacterSetClient != y.CharacterSetClient {
		return false
	}
	if x.CollationConnection != y.CollationConnection {
		return false
	}
	if x.DatabaseCollation != y.DatabaseCollation {
		return false
	}
	if x.SqlMode != y.SqlMode {
		return false
	}
	if x.Comment != y.Comment {
		return false
	}
	if len(x.DependencyTables) != len(y.DependencyTables) {
		return false
	}
	for i := 0; i < len(x.DependencyTables); i++ {
		if !x.DependencyTables[i].Equal(y.DependencyTables[i]) {
			return false
		}
	}
	if x.SkipDump != y.SkipDump {
		return false
	}
	return true
}

func (x *ProcedureMetadata) Equal(y *ProcedureMetadata) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if x.Definition != y.Definition {
		return false
	}
	if x.Signature != y.Signature {
		return false
	}
	if x.CharacterSetClient != y.CharacterSetClient {
		return false
	}
	if x.CollationConnection != y.CollationConnection {
		return false
	}
	if x.DatabaseCollation != y.DatabaseCollation {
		return false
	}
	if x.SqlMode != y.SqlMode {
		return false
	}
	if x.Comment != y.Comment {
		return false
	}
	if x.SkipDump != y.SkipDump {
		return false
	}
	return true
}

func (x *PackageMetadata) Equal(y *PackageMetadata) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if x.Definition != y.Definition {
		return false
	}
	return true
}

func (x *TaskMetadata) Equal(y *TaskMetadata) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if x.Id != y.Id {
		return false
	}
	if x.Owner != y.Owner {
		return false
	}
	if x.Comment != y.Comment {
		return false
	}
	if x.Warehouse != y.Warehouse {
		return false
	}
	if x.Schedule != y.Schedule {
		return false
	}
	if len(x.Predecessors) != len(y.Predecessors) {
		return false
	}
	for i := 0; i < len(x.Predecessors); i++ {
		if x.Predecessors[i] != y.Predecessors[i] {
			return false
		}
	}
	if x.State != y.State {
		return false
	}
	if x.Condition != y.Condition {
		return false
	}
	if x.Definition != y.Definition {
		return false
	}
	return true
}

func (x *StreamMetadata) Equal(y *StreamMetadata) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if x.TableName != y.TableName {
		return false
	}
	if x.Owner != y.Owner {
		return false
	}
	if x.Comment != y.Comment {
		return false
	}
	if x.Type != y.Type {
		return false
	}
	if x.Stale != y.Stale {
		return false
	}
	if x.Mode != y.Mode {
		return false
	}
	if x.Definition != y.Definition {
		return false
	}
	return true
}

func (x *SpatialIndexConfig) Equal(y *SpatialIndexConfig) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Method != y.Method {
		return false
	}
	if !x.Tessellation.Equal(y.Tessellation) {
		return false
	}
	if !x.Storage.Equal(y.Storage) {
		return false
	}
	if !x.Dimensional.Equal(y.Dimensional) {
		return false
	}
	return true
}

func (x *TessellationConfig) Equal(y *TessellationConfig) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Scheme != y.Scheme {
		return false
	}
	if len(x.GridLevels) != len(y.GridLevels) {
		return false
	}
	for i := 0; i < len(x.GridLevels); i++ {
		if !x.GridLevels[i].Equal(y.GridLevels[i]) {
			return false
		}
	}
	if x.CellsPerObject != y.CellsPerObject {
		return false
	}
	if !x.BoundingBox.Equal(y.BoundingBox) {
		return false
	}
	return true
}

func (x *GridLevel) Equal(y *GridLevel) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Level != y.Level {
		return false
	}
	if x.Density != y.Density {
		return false
	}
	return true
}

func (x *BoundingBox) Equal(y *BoundingBox) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if (math.IsNaN(float64(x.Xmin)) && !math.IsNaN(float64(y.Xmin)) || !math.IsNaN(float64(x.Xmin)) && math.IsNaN(float64(y.Xmin))) || (!math.IsNaN(float64(x.Xmin)) && !math.IsNaN(float64(y.Xmin)) && x.Xmin != y.Xmin) {
		return false
	}
	if (math.IsNaN(float64(x.Ymin)) && !math.IsNaN(float64(y.Ymin)) || !math.IsNaN(float64(x.Ymin)) && math.IsNaN(float64(y.Ymin))) || (!math.IsNaN(float64(x.Ymin)) && !math.IsNaN(float64(y.Ymin)) && x.Ymin != y.Ymin) {
		return false
	}
	if (math.IsNaN(float64(x.Xmax)) && !math.IsNaN(float64(y.Xmax)) || !math.IsNaN(float64(x.Xmax)) && math.IsNaN(float64(y.Xmax))) || (!math.IsNaN(float64(x.Xmax)) && !math.IsNaN(float64(y.Xmax)) && x.Xmax != y.Xmax) {
		return false
	}
	if (math.IsNaN(float64(x.Ymax)) && !math.IsNaN(float64(y.Ymax)) || !math.IsNaN(float64(x.Ymax)) && math.IsNaN(float64(y.Ymax))) || (!math.IsNaN(float64(x.Ymax)) && !math.IsNaN(float64(y.Ymax)) && x.Ymax != y.Ymax) {
		return false
	}
	return true
}

func (x *StorageConfig) Equal(y *StorageConfig) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Fillfactor != y.Fillfactor {
		return false
	}
	if x.Buffering != y.Buffering {
		return false
	}
	if x.Tablespace != y.Tablespace {
		return false
	}
	if x.WorkTablespace != y.WorkTablespace {
		return false
	}
	if x.SdoLevel != y.SdoLevel {
		return false
	}
	if x.CommitInterval != y.CommitInterval {
		return false
	}
	if x.PadIndex != y.PadIndex {
		return false
	}
	if x.SortInTempdb != y.SortInTempdb {
		return false
	}
	if x.DropExisting != y.DropExisting {
		return false
	}
	if x.Online != y.Online {
		return false
	}
	if x.AllowRowLocks != y.AllowRowLocks {
		return false
	}
	if x.AllowPageLocks != y.AllowPageLocks {
		return false
	}
	if x.Maxdop != y.Maxdop {
		return false
	}
	if x.DataCompression != y.DataCompression {
		return false
	}
	return true
}

func (x *DimensionalConfig) Equal(y *DimensionalConfig) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Dimensions != y.Dimensions {
		return false
	}
	if x.DataType != y.DataType {
		return false
	}
	if x.Srid != y.Srid {
		return false
	}
	if len(x.Constraints) != len(y.Constraints) {
		return false
	}
	for i := 0; i < len(x.Constraints); i++ {
		if !x.Constraints[i].Equal(y.Constraints[i]) {
			return false
		}
	}
	return true
}

func (x *DimensionConstraint) Equal(y *DimensionConstraint) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Dimension != y.Dimension {
		return false
	}
	if (math.IsNaN(float64(x.MinValue)) && !math.IsNaN(float64(y.MinValue)) || !math.IsNaN(float64(x.MinValue)) && math.IsNaN(float64(y.MinValue))) || (!math.IsNaN(float64(x.MinValue)) && !math.IsNaN(float64(y.MinValue)) && x.MinValue != y.MinValue) {
		return false
	}
	if (math.IsNaN(float64(x.MaxValue)) && !math.IsNaN(float64(y.MaxValue)) || !math.IsNaN(float64(x.MaxValue)) && math.IsNaN(float64(y.MaxValue))) || (!math.IsNaN(float64(x.MaxValue)) && !math.IsNaN(float64(y.MaxValue)) && x.MaxValue != y.MaxValue) {
		return false
	}
	if (math.IsNaN(float64(x.Tolerance)) && !math.IsNaN(float64(y.Tolerance)) || !math.IsNaN(float64(x.Tolerance)) && math.IsNaN(float64(y.Tolerance))) || (!math.IsNaN(float64(x.Tolerance)) && !math.IsNaN(float64(y.Tolerance)) && x.Tolerance != y.Tolerance) {
		return false
	}
	return true
}

func (x *IndexMetadata) Equal(y *IndexMetadata) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if len(x.Expressions) != len(y.Expressions) {
		return false
	}
	for i := 0; i < len(x.Expressions); i++ {
		if x.Expressions[i] != y.Expressions[i] {
			return false
		}
	}
	if len(x.KeyLength) != len(y.KeyLength) {
		return false
	}
	for i := 0; i < len(x.KeyLength); i++ {
		if x.KeyLength[i] != y.KeyLength[i] {
			return false
		}
	}
	if len(x.Descending) != len(y.Descending) {
		return false
	}
	for i := 0; i < len(x.Descending); i++ {
		if x.Descending[i] != y.Descending[i] {
			return false
		}
	}
	if x.Type != y.Type {
		return false
	}
	if x.Unique != y.Unique {
		return false
	}
	if x.Primary != y.Primary {
		return false
	}
	if x.Visible != y.Visible {
		return false
	}
	if x.Comment != y.Comment {
		return false
	}
	if x.Definition != y.Definition {
		return false
	}
	if x.ParentIndexSchema != y.ParentIndexSchema {
		return false
	}
	if x.ParentIndexName != y.ParentIndexName {
		return false
	}
	if x.Granularity != y.Granularity {
		return false
	}
	if x.IsConstraint != y.IsConstraint {
		return false
	}
	if !x.SpatialConfig.Equal(y.SpatialConfig) {
		return false
	}
	if len(x.OpclassNames) != len(y.OpclassNames) {
		return false
	}
	for i := 0; i < len(x.OpclassNames); i++ {
		if x.OpclassNames[i] != y.OpclassNames[i] {
			return false
		}
	}
	if len(x.OpclassDefaults) != len(y.OpclassDefaults) {
		return false
	}
	for i := 0; i < len(x.OpclassDefaults); i++ {
		if x.OpclassDefaults[i] != y.OpclassDefaults[i] {
			return false
		}
	}
	return true
}

func (x *ExtensionMetadata) Equal(y *ExtensionMetadata) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if x.Schema != y.Schema {
		return false
	}
	if x.Version != y.Version {
		return false
	}
	if x.Description != y.Description {
		return false
	}
	return true
}

func (x *ForeignKeyMetadata) Equal(y *ForeignKeyMetadata) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if len(x.Columns) != len(y.Columns) {
		return false
	}
	for i := 0; i < len(x.Columns); i++ {
		if x.Columns[i] != y.Columns[i] {
			return false
		}
	}
	if x.ReferencedSchema != y.ReferencedSchema {
		return false
	}
	if x.ReferencedTable != y.ReferencedTable {
		return false
	}
	if len(x.ReferencedColumns) != len(y.ReferencedColumns) {
		return false
	}
	for i := 0; i < len(x.ReferencedColumns); i++ {
		if x.ReferencedColumns[i] != y.ReferencedColumns[i] {
			return false
		}
	}
	if x.OnDelete != y.OnDelete {
		return false
	}
	if x.OnUpdate != y.OnUpdate {
		return false
	}
	if x.MatchType != y.MatchType {
		return false
	}
	return true
}

func (x *DatabaseSchema) Equal(y *DatabaseSchema) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Schema != y.Schema {
		return false
	}
	return true
}

func (x *DatabaseSDLSchema) Equal(y *DatabaseSDLSchema) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if string(x.Schema) != string(y.Schema) {
		return false
	}
	if x.ContentType != y.ContentType {
		return false
	}
	return true
}

func (x *ChangedResources) Equal(y *ChangedResources) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if len(x.Databases) != len(y.Databases) {
		return false
	}
	for i := 0; i < len(x.Databases); i++ {
		if !x.Databases[i].Equal(y.Databases[i]) {
			return false
		}
	}
	return true
}

func (x *ChangedResourceDatabase) Equal(y *ChangedResourceDatabase) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if len(x.Schemas) != len(y.Schemas) {
		return false
	}
	for i := 0; i < len(x.Schemas); i++ {
		if !x.Schemas[i].Equal(y.Schemas[i]) {
			return false
		}
	}
	return true
}

func (x *ChangedResourceSchema) Equal(y *ChangedResourceSchema) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if len(x.Tables) != len(y.Tables) {
		return false
	}
	for i := 0; i < len(x.Tables); i++ {
		if !x.Tables[i].Equal(y.Tables[i]) {
			return false
		}
	}
	if len(x.Views) != len(y.Views) {
		return false
	}
	for i := 0; i < len(x.Views); i++ {
		if !x.Views[i].Equal(y.Views[i]) {
			return false
		}
	}
	if len(x.Functions) != len(y.Functions) {
		return false
	}
	for i := 0; i < len(x.Functions); i++ {
		if !x.Functions[i].Equal(y.Functions[i]) {
			return false
		}
	}
	if len(x.Procedures) != len(y.Procedures) {
		return false
	}
	for i := 0; i < len(x.Procedures); i++ {
		if !x.Procedures[i].Equal(y.Procedures[i]) {
			return false
		}
	}
	return true
}

func (x *ChangedResourceTable) Equal(y *ChangedResourceTable) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if len(x.Ranges) != len(y.Ranges) {
		return false
	}
	for i := 0; i < len(x.Ranges); i++ {
		if !x.Ranges[i].Equal(y.Ranges[i]) {
			return false
		}
	}
	return true
}

func (x *ChangedResourceView) Equal(y *ChangedResourceView) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if len(x.Ranges) != len(y.Ranges) {
		return false
	}
	for i := 0; i < len(x.Ranges); i++ {
		if !x.Ranges[i].Equal(y.Ranges[i]) {
			return false
		}
	}
	return true
}

func (x *ChangedResourceFunction) Equal(y *ChangedResourceFunction) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if len(x.Ranges) != len(y.Ranges) {
		return false
	}
	for i := 0; i < len(x.Ranges); i++ {
		if !x.Ranges[i].Equal(y.Ranges[i]) {
			return false
		}
	}
	return true
}

func (x *ChangedResourceProcedure) Equal(y *ChangedResourceProcedure) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if len(x.Ranges) != len(y.Ranges) {
		return false
	}
	for i := 0; i < len(x.Ranges); i++ {
		if !x.Ranges[i].Equal(y.Ranges[i]) {
			return false
		}
	}
	return true
}

func (x *ListChangelogsRequest) Equal(y *ListChangelogsRequest) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Parent != y.Parent {
		return false
	}
	if x.PageSize != y.PageSize {
		return false
	}
	if x.PageToken != y.PageToken {
		return false
	}
	if x.View != y.View {
		return false
	}
	if x.Filter != y.Filter {
		return false
	}
	return true
}

func (x *ListChangelogsResponse) Equal(y *ListChangelogsResponse) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if len(x.Changelogs) != len(y.Changelogs) {
		return false
	}
	for i := 0; i < len(x.Changelogs); i++ {
		if !x.Changelogs[i].Equal(y.Changelogs[i]) {
			return false
		}
	}
	if x.NextPageToken != y.NextPageToken {
		return false
	}
	return true
}

func (x *GetChangelogRequest) Equal(y *GetChangelogRequest) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if x.View != y.View {
		return false
	}
	return true
}

func (x *Changelog) Equal(y *Changelog) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if p, q := x.CreateTime, y.CreateTime; (p == nil && q != nil) || (p != nil && (q == nil || p.Seconds != q.Seconds || p.Nanos != q.Nanos)) {
		return false
	}
	if x.Status != y.Status {
		return false
	}
	if x.Statement != y.Statement {
		return false
	}
	if x.StatementSize != y.StatementSize {
		return false
	}
	if x.StatementSheet != y.StatementSheet {
		return false
	}
	if x.Schema != y.Schema {
		return false
	}
	if x.SchemaSize != y.SchemaSize {
		return false
	}
	if x.PrevSchema != y.PrevSchema {
		return false
	}
	if x.PrevSchemaSize != y.PrevSchemaSize {
		return false
	}
	if x.Issue != y.Issue {
		return false
	}
	if x.TaskRun != y.TaskRun {
		return false
	}
	if x.Version != y.Version {
		return false
	}
	if x.Revision != y.Revision {
		return false
	}
	if !x.ChangedResources.Equal(y.ChangedResources) {
		return false
	}
	if x.Type != y.Type {
		return false
	}
	return true
}

func (x *GetSchemaStringRequest) Equal(y *GetSchemaStringRequest) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if x.Type != y.Type {
		return false
	}
	if x.Schema != y.Schema {
		return false
	}
	if x.Object != y.Object {
		return false
	}
	if !x.Metadata.Equal(y.Metadata) {
		return false
	}
	return true
}

func (x *GetSchemaStringResponse) Equal(y *GetSchemaStringResponse) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.SchemaString != y.SchemaString {
		return false
	}
	return true
}
