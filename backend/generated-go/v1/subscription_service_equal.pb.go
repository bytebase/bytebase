// Code generated by protoc-gen-equal-go. DO NOT EDIT.
// source: v1/subscription_service.proto

package v1

func (x *GetSubscriptionRequest) Equal(y *GetSubscriptionRequest) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	return true
}

func (x *UpdateSubscriptionRequest) Equal(y *UpdateSubscriptionRequest) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.License != y.License {
		return false
	}
	if x.AllowMissing != y.AllowMissing {
		return false
	}
	return true
}

func (x *Subscription) Equal(y *Subscription) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Plan != y.Plan {
		return false
	}
	if x.Seats != y.Seats {
		return false
	}
	if x.Instances != y.Instances {
		return false
	}
	if x.ActiveInstances != y.ActiveInstances {
		return false
	}
	if p, q := x.ExpiresTime, y.ExpiresTime; (p == nil && q != nil) || (p != nil && (q == nil || p.Seconds != q.Seconds || p.Nanos != q.Nanos)) {
		return false
	}
	if x.Trialing != y.Trialing {
		return false
	}
	if x.OrgName != y.OrgName {
		return false
	}
	return true
}

func (x *PlanConfig) Equal(y *PlanConfig) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if len(x.Plans) != len(y.Plans) {
		return false
	}
	for i := 0; i < len(x.Plans); i++ {
		if !x.Plans[i].Equal(y.Plans[i]) {
			return false
		}
	}
	if len(x.InstanceFeatures) != len(y.InstanceFeatures) {
		return false
	}
	for i := 0; i < len(x.InstanceFeatures); i++ {
		if x.InstanceFeatures[i] != y.InstanceFeatures[i] {
			return false
		}
	}
	return true
}

func (x *PlanLimitConfig) Equal(y *PlanLimitConfig) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Type != y.Type {
		return false
	}
	if x.MaximumInstanceCount != y.MaximumInstanceCount {
		return false
	}
	if x.MaximumSeatCount != y.MaximumSeatCount {
		return false
	}
	if len(x.Features) != len(y.Features) {
		return false
	}
	for i := 0; i < len(x.Features); i++ {
		if x.Features[i] != y.Features[i] {
			return false
		}
	}
	return true
}
