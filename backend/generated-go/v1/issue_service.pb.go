// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        (unknown)
// source: v1/issue_service.proto

package v1

import (
	_ "buf.build/gen/go/bufbuild/protovalidate/protocolbuffers/go/buf/validate"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	expr "google.golang.org/genproto/googleapis/type/expr"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	fieldmaskpb "google.golang.org/protobuf/types/known/fieldmaskpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// The status of an issue.
type IssueStatus int32

const (
	// Unspecified status.
	IssueStatus_ISSUE_STATUS_UNSPECIFIED IssueStatus = 0
	// Issue is open and active.
	IssueStatus_OPEN IssueStatus = 1
	// Issue is completed.
	IssueStatus_DONE IssueStatus = 2
	// Issue is canceled.
	IssueStatus_CANCELED IssueStatus = 3
)

// Enum value maps for IssueStatus.
var (
	IssueStatus_name = map[int32]string{
		0: "ISSUE_STATUS_UNSPECIFIED",
		1: "OPEN",
		2: "DONE",
		3: "CANCELED",
	}
	IssueStatus_value = map[string]int32{
		"ISSUE_STATUS_UNSPECIFIED": 0,
		"OPEN":                     1,
		"DONE":                     2,
		"CANCELED":                 3,
	}
)

func (x IssueStatus) Enum() *IssueStatus {
	p := new(IssueStatus)
	*p = x
	return p
}

func (x IssueStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (IssueStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_v1_issue_service_proto_enumTypes[0].Descriptor()
}

func (IssueStatus) Type() protoreflect.EnumType {
	return &file_v1_issue_service_proto_enumTypes[0]
}

func (x IssueStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use IssueStatus.Descriptor instead.
func (IssueStatus) EnumDescriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{0}
}

// The type of issue.
type Issue_Type int32

const (
	// Unspecified issue type.
	Issue_TYPE_UNSPECIFIED Issue_Type = 0
	// Database schema or data change.
	Issue_DATABASE_CHANGE Issue_Type = 1
	// Database access grant request.
	Issue_GRANT_REQUEST Issue_Type = 2
	// Database data export request.
	Issue_DATABASE_EXPORT Issue_Type = 3
)

// Enum value maps for Issue_Type.
var (
	Issue_Type_name = map[int32]string{
		0: "TYPE_UNSPECIFIED",
		1: "DATABASE_CHANGE",
		2: "GRANT_REQUEST",
		3: "DATABASE_EXPORT",
	}
	Issue_Type_value = map[string]int32{
		"TYPE_UNSPECIFIED": 0,
		"DATABASE_CHANGE":  1,
		"GRANT_REQUEST":    2,
		"DATABASE_EXPORT":  3,
	}
)

func (x Issue_Type) Enum() *Issue_Type {
	p := new(Issue_Type)
	*p = x
	return p
}

func (x Issue_Type) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Issue_Type) Descriptor() protoreflect.EnumDescriptor {
	return file_v1_issue_service_proto_enumTypes[1].Descriptor()
}

func (Issue_Type) Type() protoreflect.EnumType {
	return &file_v1_issue_service_proto_enumTypes[1]
}

func (x Issue_Type) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Issue_Type.Descriptor instead.
func (Issue_Type) EnumDescriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{12, 0}
}

// The overall approval status for the issue.
type Issue_ApprovalStatus int32

const (
	// Unspecified approval status.
	Issue_APPROVAL_STATUS_UNSPECIFIED Issue_ApprovalStatus = 0
	// Approval checks are being evaluated.
	Issue_CHECKING Issue_ApprovalStatus = 1
	// Approval is pending.
	Issue_PENDING Issue_ApprovalStatus = 2
	// Issue has been approved.
	Issue_APPROVED Issue_ApprovalStatus = 3
	// Issue has been rejected.
	Issue_REJECTED Issue_ApprovalStatus = 4
	// Approval was skipped.
	Issue_SKIPPED Issue_ApprovalStatus = 5
)

// Enum value maps for Issue_ApprovalStatus.
var (
	Issue_ApprovalStatus_name = map[int32]string{
		0: "APPROVAL_STATUS_UNSPECIFIED",
		1: "CHECKING",
		2: "PENDING",
		3: "APPROVED",
		4: "REJECTED",
		5: "SKIPPED",
	}
	Issue_ApprovalStatus_value = map[string]int32{
		"APPROVAL_STATUS_UNSPECIFIED": 0,
		"CHECKING":                    1,
		"PENDING":                     2,
		"APPROVED":                    3,
		"REJECTED":                    4,
		"SKIPPED":                     5,
	}
)

func (x Issue_ApprovalStatus) Enum() *Issue_ApprovalStatus {
	p := new(Issue_ApprovalStatus)
	*p = x
	return p
}

func (x Issue_ApprovalStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Issue_ApprovalStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_v1_issue_service_proto_enumTypes[2].Descriptor()
}

func (Issue_ApprovalStatus) Type() protoreflect.EnumType {
	return &file_v1_issue_service_proto_enumTypes[2]
}

func (x Issue_ApprovalStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Issue_ApprovalStatus.Descriptor instead.
func (Issue_ApprovalStatus) EnumDescriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{12, 1}
}

// The approval status of an approver.
type Issue_Approver_Status int32

const (
	// Unspecified status.
	Issue_Approver_STATUS_UNSPECIFIED Issue_Approver_Status = 0
	// Awaiting approval.
	Issue_Approver_PENDING Issue_Approver_Status = 1
	// Approved.
	Issue_Approver_APPROVED Issue_Approver_Status = 2
	// Rejected.
	Issue_Approver_REJECTED Issue_Approver_Status = 3
)

// Enum value maps for Issue_Approver_Status.
var (
	Issue_Approver_Status_name = map[int32]string{
		0: "STATUS_UNSPECIFIED",
		1: "PENDING",
		2: "APPROVED",
		3: "REJECTED",
	}
	Issue_Approver_Status_value = map[string]int32{
		"STATUS_UNSPECIFIED": 0,
		"PENDING":            1,
		"APPROVED":           2,
		"REJECTED":           3,
	}
)

func (x Issue_Approver_Status) Enum() *Issue_Approver_Status {
	p := new(Issue_Approver_Status)
	*p = x
	return p
}

func (x Issue_Approver_Status) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Issue_Approver_Status) Descriptor() protoreflect.EnumDescriptor {
	return file_v1_issue_service_proto_enumTypes[3].Descriptor()
}

func (Issue_Approver_Status) Type() protoreflect.EnumType {
	return &file_v1_issue_service_proto_enumTypes[3]
}

func (x Issue_Approver_Status) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Issue_Approver_Status.Descriptor instead.
func (Issue_Approver_Status) EnumDescriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{12, 0, 0}
}

// Approval status values.
type IssueComment_Approval_Status int32

const (
	// Unspecified status.
	IssueComment_Approval_STATUS_UNSPECIFIED IssueComment_Approval_Status = 0
	// Approval pending.
	IssueComment_Approval_PENDING IssueComment_Approval_Status = 1
	// Approved.
	IssueComment_Approval_APPROVED IssueComment_Approval_Status = 2
	// Rejected.
	IssueComment_Approval_REJECTED IssueComment_Approval_Status = 3
)

// Enum value maps for IssueComment_Approval_Status.
var (
	IssueComment_Approval_Status_name = map[int32]string{
		0: "STATUS_UNSPECIFIED",
		1: "PENDING",
		2: "APPROVED",
		3: "REJECTED",
	}
	IssueComment_Approval_Status_value = map[string]int32{
		"STATUS_UNSPECIFIED": 0,
		"PENDING":            1,
		"APPROVED":           2,
		"REJECTED":           3,
	}
)

func (x IssueComment_Approval_Status) Enum() *IssueComment_Approval_Status {
	p := new(IssueComment_Approval_Status)
	*p = x
	return p
}

func (x IssueComment_Approval_Status) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (IssueComment_Approval_Status) Descriptor() protoreflect.EnumDescriptor {
	return file_v1_issue_service_proto_enumTypes[4].Descriptor()
}

func (IssueComment_Approval_Status) Type() protoreflect.EnumType {
	return &file_v1_issue_service_proto_enumTypes[4]
}

func (x IssueComment_Approval_Status) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use IssueComment_Approval_Status.Descriptor instead.
func (IssueComment_Approval_Status) EnumDescriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{20, 0, 0}
}

type GetIssueRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The name of the issue to retrieve.
	// Format: projects/{project}/issues/{issue}
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// If set to true, bypass cache and fetch the latest data.
	Force         bool `protobuf:"varint,2,opt,name=force,proto3" json:"force,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetIssueRequest) Reset() {
	*x = GetIssueRequest{}
	mi := &file_v1_issue_service_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetIssueRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetIssueRequest) ProtoMessage() {}

func (x *GetIssueRequest) ProtoReflect() protoreflect.Message {
	mi := &file_v1_issue_service_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetIssueRequest.ProtoReflect.Descriptor instead.
func (*GetIssueRequest) Descriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{0}
}

func (x *GetIssueRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *GetIssueRequest) GetForce() bool {
	if x != nil {
		return x.Force
	}
	return false
}

type CreateIssueRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The parent, which owns this collection of issues.
	// Format: projects/{project}
	Parent string `protobuf:"bytes,1,opt,name=parent,proto3" json:"parent,omitempty"`
	// The issue to create.
	Issue         *Issue `protobuf:"bytes,2,opt,name=issue,proto3" json:"issue,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateIssueRequest) Reset() {
	*x = CreateIssueRequest{}
	mi := &file_v1_issue_service_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateIssueRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateIssueRequest) ProtoMessage() {}

func (x *CreateIssueRequest) ProtoReflect() protoreflect.Message {
	mi := &file_v1_issue_service_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateIssueRequest.ProtoReflect.Descriptor instead.
func (*CreateIssueRequest) Descriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{1}
}

func (x *CreateIssueRequest) GetParent() string {
	if x != nil {
		return x.Parent
	}
	return ""
}

func (x *CreateIssueRequest) GetIssue() *Issue {
	if x != nil {
		return x.Issue
	}
	return nil
}

type ListIssuesRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The parent, which owns this collection of issues.
	// Format: projects/{project}
	Parent string `protobuf:"bytes,1,opt,name=parent,proto3" json:"parent,omitempty"`
	// The maximum number of issues to return. The service may return fewer than
	// this value.
	// If unspecified, at most 10 issues will be returned.
	// The maximum value is 1000; values above 1000 will be coerced to 1000.
	PageSize int32 `protobuf:"varint,2,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	// A page token, received from a previous `ListIssues` call.
	// Provide this to retrieve the subsequent page.
	//
	// When paginating, all other parameters provided to `ListIssues` must match
	// the call that provided the page token.
	PageToken string `protobuf:"bytes,3,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
	// Filter is used to filter issues returned in the list.
	// The syntax and semantics of CEL are documented at https://github.com/google/cel-spec
	//
	// Supported filters:
	// - creator: issue creator full name in "users/{email or id}" format, support "==" operator.
	// - status: the issue status, support "==" and "in" operator, check the IssueStatus enum for the values.
	// - create_time: issue create time in "2006-01-02T15:04:05Z07:00" format, support ">=" or "<=" operator.
	// - type: the issue type, support "==" and "in" operator, check the Type enum in the Issue message for the values.
	// - labels: the issue labels, support "==" and "in" operator.
	// - approval_status: issue approval status, support "==" operator.
	// - current_approver: the issue approver, should in "users/{email} format", support "==" operator.
	//
	// For example:
	// creator == "users/ed@bytebase.com" && status in ["OPEN", "DONE"]
	// status == "CANCELED" && type == "DATABASE_CHANGE"
	// labels in ["label1", "label2"]
	// create_time >= "2025-01-02T15:04:05Z07:00"
	Filter string `protobuf:"bytes,4,opt,name=filter,proto3" json:"filter,omitempty"`
	// Query is the query statement.
	Query         string `protobuf:"bytes,5,opt,name=query,proto3" json:"query,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListIssuesRequest) Reset() {
	*x = ListIssuesRequest{}
	mi := &file_v1_issue_service_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListIssuesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListIssuesRequest) ProtoMessage() {}

func (x *ListIssuesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_v1_issue_service_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListIssuesRequest.ProtoReflect.Descriptor instead.
func (*ListIssuesRequest) Descriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{2}
}

func (x *ListIssuesRequest) GetParent() string {
	if x != nil {
		return x.Parent
	}
	return ""
}

func (x *ListIssuesRequest) GetPageSize() int32 {
	if x != nil {
		return x.PageSize
	}
	return 0
}

func (x *ListIssuesRequest) GetPageToken() string {
	if x != nil {
		return x.PageToken
	}
	return ""
}

func (x *ListIssuesRequest) GetFilter() string {
	if x != nil {
		return x.Filter
	}
	return ""
}

func (x *ListIssuesRequest) GetQuery() string {
	if x != nil {
		return x.Query
	}
	return ""
}

type ListIssuesResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The issues from the specified request.
	Issues []*Issue `protobuf:"bytes,1,rep,name=issues,proto3" json:"issues,omitempty"`
	// A token, which can be sent as `page_token` to retrieve the next page.
	// If this field is omitted, there are no subsequent pages.
	NextPageToken string `protobuf:"bytes,2,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListIssuesResponse) Reset() {
	*x = ListIssuesResponse{}
	mi := &file_v1_issue_service_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListIssuesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListIssuesResponse) ProtoMessage() {}

func (x *ListIssuesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_v1_issue_service_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListIssuesResponse.ProtoReflect.Descriptor instead.
func (*ListIssuesResponse) Descriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{3}
}

func (x *ListIssuesResponse) GetIssues() []*Issue {
	if x != nil {
		return x.Issues
	}
	return nil
}

func (x *ListIssuesResponse) GetNextPageToken() string {
	if x != nil {
		return x.NextPageToken
	}
	return ""
}

type SearchIssuesRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The parent, which owns this collection of issues.
	// Format: projects/{project}
	// Use "projects/-" to list all issues from all projects.
	Parent string `protobuf:"bytes,1,opt,name=parent,proto3" json:"parent,omitempty"`
	// The maximum number of issues to return. The service may return fewer than
	// this value.
	// If unspecified, at most 10 issues will be returned.
	// The maximum value is 1000; values above 1000 will be coerced to 1000.
	PageSize int32 `protobuf:"varint,2,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	// A page token, received from a previous `SearchIssues` call.
	// Provide this to retrieve the subsequent page.
	//
	// When paginating, all other parameters provided to `SearchIssues` must match
	// the call that provided the page token.
	PageToken string `protobuf:"bytes,3,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
	// Filter is used to filter issues returned in the list.
	// Check the filter field in the ListIssuesRequest message.
	Filter string `protobuf:"bytes,4,opt,name=filter,proto3" json:"filter,omitempty"`
	// Query is the query statement.
	Query         string `protobuf:"bytes,5,opt,name=query,proto3" json:"query,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SearchIssuesRequest) Reset() {
	*x = SearchIssuesRequest{}
	mi := &file_v1_issue_service_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SearchIssuesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SearchIssuesRequest) ProtoMessage() {}

func (x *SearchIssuesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_v1_issue_service_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SearchIssuesRequest.ProtoReflect.Descriptor instead.
func (*SearchIssuesRequest) Descriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{4}
}

func (x *SearchIssuesRequest) GetParent() string {
	if x != nil {
		return x.Parent
	}
	return ""
}

func (x *SearchIssuesRequest) GetPageSize() int32 {
	if x != nil {
		return x.PageSize
	}
	return 0
}

func (x *SearchIssuesRequest) GetPageToken() string {
	if x != nil {
		return x.PageToken
	}
	return ""
}

func (x *SearchIssuesRequest) GetFilter() string {
	if x != nil {
		return x.Filter
	}
	return ""
}

func (x *SearchIssuesRequest) GetQuery() string {
	if x != nil {
		return x.Query
	}
	return ""
}

type SearchIssuesResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The issues from the specified request.
	Issues []*Issue `protobuf:"bytes,1,rep,name=issues,proto3" json:"issues,omitempty"`
	// A token, which can be sent as `page_token` to retrieve the next page.
	// If this field is omitted, there are no subsequent pages.
	NextPageToken string `protobuf:"bytes,2,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SearchIssuesResponse) Reset() {
	*x = SearchIssuesResponse{}
	mi := &file_v1_issue_service_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SearchIssuesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SearchIssuesResponse) ProtoMessage() {}

func (x *SearchIssuesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_v1_issue_service_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SearchIssuesResponse.ProtoReflect.Descriptor instead.
func (*SearchIssuesResponse) Descriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{5}
}

func (x *SearchIssuesResponse) GetIssues() []*Issue {
	if x != nil {
		return x.Issues
	}
	return nil
}

func (x *SearchIssuesResponse) GetNextPageToken() string {
	if x != nil {
		return x.NextPageToken
	}
	return ""
}

type UpdateIssueRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The issue to update.
	//
	// The issue's `name` field is used to identify the issue to update.
	// Format: projects/{project}/issues/{issue}
	Issue *Issue `protobuf:"bytes,1,opt,name=issue,proto3" json:"issue,omitempty"`
	// The list of fields to update.
	UpdateMask *fieldmaskpb.FieldMask `protobuf:"bytes,2,opt,name=update_mask,json=updateMask,proto3" json:"update_mask,omitempty"`
	// If set to true, and the issue is not found, a new issue will be created.
	// In this situation, `update_mask` is ignored.
	AllowMissing  bool `protobuf:"varint,3,opt,name=allow_missing,json=allowMissing,proto3" json:"allow_missing,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateIssueRequest) Reset() {
	*x = UpdateIssueRequest{}
	mi := &file_v1_issue_service_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateIssueRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateIssueRequest) ProtoMessage() {}

func (x *UpdateIssueRequest) ProtoReflect() protoreflect.Message {
	mi := &file_v1_issue_service_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateIssueRequest.ProtoReflect.Descriptor instead.
func (*UpdateIssueRequest) Descriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{6}
}

func (x *UpdateIssueRequest) GetIssue() *Issue {
	if x != nil {
		return x.Issue
	}
	return nil
}

func (x *UpdateIssueRequest) GetUpdateMask() *fieldmaskpb.FieldMask {
	if x != nil {
		return x.UpdateMask
	}
	return nil
}

func (x *UpdateIssueRequest) GetAllowMissing() bool {
	if x != nil {
		return x.AllowMissing
	}
	return false
}

type BatchUpdateIssuesStatusRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The parent resource shared by all issues being updated.
	// Format: projects/{project}
	// If the operation spans parents, a dash (-) may be accepted as a wildcard.
	// We only support updating the status of databases for now.
	Parent string `protobuf:"bytes,1,opt,name=parent,proto3" json:"parent,omitempty"`
	// The list of issues to update.
	// Format: projects/{project}/issues/{issue}
	Issues []string `protobuf:"bytes,2,rep,name=issues,proto3" json:"issues,omitempty"`
	// The new status.
	Status IssueStatus `protobuf:"varint,3,opt,name=status,proto3,enum=bytebase.v1.IssueStatus" json:"status,omitempty"`
	// The reason for the status change.
	Reason        string `protobuf:"bytes,4,opt,name=reason,proto3" json:"reason,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BatchUpdateIssuesStatusRequest) Reset() {
	*x = BatchUpdateIssuesStatusRequest{}
	mi := &file_v1_issue_service_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BatchUpdateIssuesStatusRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BatchUpdateIssuesStatusRequest) ProtoMessage() {}

func (x *BatchUpdateIssuesStatusRequest) ProtoReflect() protoreflect.Message {
	mi := &file_v1_issue_service_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BatchUpdateIssuesStatusRequest.ProtoReflect.Descriptor instead.
func (*BatchUpdateIssuesStatusRequest) Descriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{7}
}

func (x *BatchUpdateIssuesStatusRequest) GetParent() string {
	if x != nil {
		return x.Parent
	}
	return ""
}

func (x *BatchUpdateIssuesStatusRequest) GetIssues() []string {
	if x != nil {
		return x.Issues
	}
	return nil
}

func (x *BatchUpdateIssuesStatusRequest) GetStatus() IssueStatus {
	if x != nil {
		return x.Status
	}
	return IssueStatus_ISSUE_STATUS_UNSPECIFIED
}

func (x *BatchUpdateIssuesStatusRequest) GetReason() string {
	if x != nil {
		return x.Reason
	}
	return ""
}

type BatchUpdateIssuesStatusResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BatchUpdateIssuesStatusResponse) Reset() {
	*x = BatchUpdateIssuesStatusResponse{}
	mi := &file_v1_issue_service_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BatchUpdateIssuesStatusResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BatchUpdateIssuesStatusResponse) ProtoMessage() {}

func (x *BatchUpdateIssuesStatusResponse) ProtoReflect() protoreflect.Message {
	mi := &file_v1_issue_service_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BatchUpdateIssuesStatusResponse.ProtoReflect.Descriptor instead.
func (*BatchUpdateIssuesStatusResponse) Descriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{8}
}

type ApproveIssueRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The name of the issue to add an approver.
	// Format: projects/{project}/issues/{issue}
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The comment explaining the approval decision.
	Comment       string `protobuf:"bytes,2,opt,name=comment,proto3" json:"comment,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ApproveIssueRequest) Reset() {
	*x = ApproveIssueRequest{}
	mi := &file_v1_issue_service_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ApproveIssueRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ApproveIssueRequest) ProtoMessage() {}

func (x *ApproveIssueRequest) ProtoReflect() protoreflect.Message {
	mi := &file_v1_issue_service_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ApproveIssueRequest.ProtoReflect.Descriptor instead.
func (*ApproveIssueRequest) Descriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{9}
}

func (x *ApproveIssueRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *ApproveIssueRequest) GetComment() string {
	if x != nil {
		return x.Comment
	}
	return ""
}

type RejectIssueRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The name of the issue to add a rejection.
	// Format: projects/{project}/issues/{issue}
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The comment explaining the rejection decision.
	Comment       string `protobuf:"bytes,2,opt,name=comment,proto3" json:"comment,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RejectIssueRequest) Reset() {
	*x = RejectIssueRequest{}
	mi := &file_v1_issue_service_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RejectIssueRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RejectIssueRequest) ProtoMessage() {}

func (x *RejectIssueRequest) ProtoReflect() protoreflect.Message {
	mi := &file_v1_issue_service_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RejectIssueRequest.ProtoReflect.Descriptor instead.
func (*RejectIssueRequest) Descriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{10}
}

func (x *RejectIssueRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *RejectIssueRequest) GetComment() string {
	if x != nil {
		return x.Comment
	}
	return ""
}

type RequestIssueRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The name of the issue to request a issue.
	// Format: projects/{project}/issues/{issue}
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The comment explaining the request.
	Comment       string `protobuf:"bytes,2,opt,name=comment,proto3" json:"comment,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RequestIssueRequest) Reset() {
	*x = RequestIssueRequest{}
	mi := &file_v1_issue_service_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RequestIssueRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RequestIssueRequest) ProtoMessage() {}

func (x *RequestIssueRequest) ProtoReflect() protoreflect.Message {
	mi := &file_v1_issue_service_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RequestIssueRequest.ProtoReflect.Descriptor instead.
func (*RequestIssueRequest) Descriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{11}
}

func (x *RequestIssueRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *RequestIssueRequest) GetComment() string {
	if x != nil {
		return x.Comment
	}
	return ""
}

type Issue struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The name of the issue.
	// Format: projects/{project}/issues/{issue}
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The title of the issue.
	Title string `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
	// The description of the issue.
	Description string     `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	Type        Issue_Type `protobuf:"varint,4,opt,name=type,proto3,enum=bytebase.v1.Issue_Type" json:"type,omitempty"`
	// The status of the issue.
	Status    IssueStatus       `protobuf:"varint,5,opt,name=status,proto3,enum=bytebase.v1.IssueStatus" json:"status,omitempty"`
	Approvers []*Issue_Approver `protobuf:"bytes,6,rep,name=approvers,proto3" json:"approvers,omitempty"`
	// The approval template for the issue.
	ApprovalTemplate *ApprovalTemplate `protobuf:"bytes,7,opt,name=approval_template,json=approvalTemplate,proto3" json:"approval_template,omitempty"`
	// Format: users/hello@world.com
	Creator    string                 `protobuf:"bytes,8,opt,name=creator,proto3" json:"creator,omitempty"`
	CreateTime *timestamppb.Timestamp `protobuf:"bytes,9,opt,name=create_time,json=createTime,proto3" json:"create_time,omitempty"`
	UpdateTime *timestamppb.Timestamp `protobuf:"bytes,10,opt,name=update_time,json=updateTime,proto3" json:"update_time,omitempty"`
	// The plan associated with the issue.
	// Can be empty.
	// Format: projects/{project}/plans/{plan}
	Plan string `protobuf:"bytes,11,opt,name=plan,proto3" json:"plan,omitempty"`
	// Used if the issue type is GRANT_REQUEST.
	GrantRequest *GrantRequest `protobuf:"bytes,13,opt,name=grant_request,json=grantRequest,proto3" json:"grant_request,omitempty"`
	// The risk level of the issue.
	RiskLevel RiskLevel `protobuf:"varint,15,opt,name=risk_level,json=riskLevel,proto3,enum=bytebase.v1.RiskLevel" json:"risk_level,omitempty"`
	// Labels attached to the issue for categorization and filtering.
	Labels         []string             `protobuf:"bytes,17,rep,name=labels,proto3" json:"labels,omitempty"`
	ApprovalStatus Issue_ApprovalStatus `protobuf:"varint,18,opt,name=approval_status,json=approvalStatus,proto3,enum=bytebase.v1.Issue_ApprovalStatus" json:"approval_status,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *Issue) Reset() {
	*x = Issue{}
	mi := &file_v1_issue_service_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Issue) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Issue) ProtoMessage() {}

func (x *Issue) ProtoReflect() protoreflect.Message {
	mi := &file_v1_issue_service_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Issue.ProtoReflect.Descriptor instead.
func (*Issue) Descriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{12}
}

func (x *Issue) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Issue) GetTitle() string {
	if x != nil {
		return x.Title
	}
	return ""
}

func (x *Issue) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *Issue) GetType() Issue_Type {
	if x != nil {
		return x.Type
	}
	return Issue_TYPE_UNSPECIFIED
}

func (x *Issue) GetStatus() IssueStatus {
	if x != nil {
		return x.Status
	}
	return IssueStatus_ISSUE_STATUS_UNSPECIFIED
}

func (x *Issue) GetApprovers() []*Issue_Approver {
	if x != nil {
		return x.Approvers
	}
	return nil
}

func (x *Issue) GetApprovalTemplate() *ApprovalTemplate {
	if x != nil {
		return x.ApprovalTemplate
	}
	return nil
}

func (x *Issue) GetCreator() string {
	if x != nil {
		return x.Creator
	}
	return ""
}

func (x *Issue) GetCreateTime() *timestamppb.Timestamp {
	if x != nil {
		return x.CreateTime
	}
	return nil
}

func (x *Issue) GetUpdateTime() *timestamppb.Timestamp {
	if x != nil {
		return x.UpdateTime
	}
	return nil
}

func (x *Issue) GetPlan() string {
	if x != nil {
		return x.Plan
	}
	return ""
}

func (x *Issue) GetGrantRequest() *GrantRequest {
	if x != nil {
		return x.GrantRequest
	}
	return nil
}

func (x *Issue) GetRiskLevel() RiskLevel {
	if x != nil {
		return x.RiskLevel
	}
	return RiskLevel_RISK_LEVEL_UNSPECIFIED
}

func (x *Issue) GetLabels() []string {
	if x != nil {
		return x.Labels
	}
	return nil
}

func (x *Issue) GetApprovalStatus() Issue_ApprovalStatus {
	if x != nil {
		return x.ApprovalStatus
	}
	return Issue_APPROVAL_STATUS_UNSPECIFIED
}

type GrantRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The requested role.
	// Format: roles/EXPORTER.
	Role string `protobuf:"bytes,1,opt,name=role,proto3" json:"role,omitempty"`
	// The user to be granted.
	// Format: users/{email}.
	User string `protobuf:"bytes,2,opt,name=user,proto3" json:"user,omitempty"`
	// The condition for the role. Same as the condition in IAM Binding message.
	Condition *expr.Expr `protobuf:"bytes,3,opt,name=condition,proto3" json:"condition,omitempty"`
	// The duration for which the grant is valid.
	Expiration    *durationpb.Duration `protobuf:"bytes,4,opt,name=expiration,proto3" json:"expiration,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GrantRequest) Reset() {
	*x = GrantRequest{}
	mi := &file_v1_issue_service_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GrantRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GrantRequest) ProtoMessage() {}

func (x *GrantRequest) ProtoReflect() protoreflect.Message {
	mi := &file_v1_issue_service_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GrantRequest.ProtoReflect.Descriptor instead.
func (*GrantRequest) Descriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{13}
}

func (x *GrantRequest) GetRole() string {
	if x != nil {
		return x.Role
	}
	return ""
}

func (x *GrantRequest) GetUser() string {
	if x != nil {
		return x.User
	}
	return ""
}

func (x *GrantRequest) GetCondition() *expr.Expr {
	if x != nil {
		return x.Condition
	}
	return nil
}

func (x *GrantRequest) GetExpiration() *durationpb.Duration {
	if x != nil {
		return x.Expiration
	}
	return nil
}

type ApprovalTemplate struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The approval flow definition.
	Flow *ApprovalFlow `protobuf:"bytes,1,opt,name=flow,proto3" json:"flow,omitempty"`
	// The title of the approval template.
	Title string `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
	// The description of the approval template.
	Description   string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ApprovalTemplate) Reset() {
	*x = ApprovalTemplate{}
	mi := &file_v1_issue_service_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ApprovalTemplate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ApprovalTemplate) ProtoMessage() {}

func (x *ApprovalTemplate) ProtoReflect() protoreflect.Message {
	mi := &file_v1_issue_service_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ApprovalTemplate.ProtoReflect.Descriptor instead.
func (*ApprovalTemplate) Descriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{14}
}

func (x *ApprovalTemplate) GetFlow() *ApprovalFlow {
	if x != nil {
		return x.Flow
	}
	return nil
}

func (x *ApprovalTemplate) GetTitle() string {
	if x != nil {
		return x.Title
	}
	return ""
}

func (x *ApprovalTemplate) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

type ApprovalFlow struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The roles required for approval in order.
	Roles         []string `protobuf:"bytes,1,rep,name=roles,proto3" json:"roles,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ApprovalFlow) Reset() {
	*x = ApprovalFlow{}
	mi := &file_v1_issue_service_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ApprovalFlow) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ApprovalFlow) ProtoMessage() {}

func (x *ApprovalFlow) ProtoReflect() protoreflect.Message {
	mi := &file_v1_issue_service_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ApprovalFlow.ProtoReflect.Descriptor instead.
func (*ApprovalFlow) Descriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{15}
}

func (x *ApprovalFlow) GetRoles() []string {
	if x != nil {
		return x.Roles
	}
	return nil
}

type ListIssueCommentsRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Format: projects/{projects}/issues/{issue}
	Parent string `protobuf:"bytes,1,opt,name=parent,proto3" json:"parent,omitempty"`
	// The maximum number of issue comments to return. The service may return fewer than
	// this value.
	// If unspecified, at most 10 issue comments will be returned.
	// The maximum value is 1000; values above 1000 will be coerced to 1000.
	PageSize int32 `protobuf:"varint,2,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	// A page token, received from a previous `ListIssueComments` call.
	// Provide this to retrieve the subsequent page.
	//
	// When paginating, all other parameters provided to `ListIssueComments` must match
	// the call that provided the page token.
	PageToken     string `protobuf:"bytes,3,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListIssueCommentsRequest) Reset() {
	*x = ListIssueCommentsRequest{}
	mi := &file_v1_issue_service_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListIssueCommentsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListIssueCommentsRequest) ProtoMessage() {}

func (x *ListIssueCommentsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_v1_issue_service_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListIssueCommentsRequest.ProtoReflect.Descriptor instead.
func (*ListIssueCommentsRequest) Descriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{16}
}

func (x *ListIssueCommentsRequest) GetParent() string {
	if x != nil {
		return x.Parent
	}
	return ""
}

func (x *ListIssueCommentsRequest) GetPageSize() int32 {
	if x != nil {
		return x.PageSize
	}
	return 0
}

func (x *ListIssueCommentsRequest) GetPageToken() string {
	if x != nil {
		return x.PageToken
	}
	return ""
}

type ListIssueCommentsResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The issue comments from the specified request.
	IssueComments []*IssueComment `protobuf:"bytes,1,rep,name=issue_comments,json=issueComments,proto3" json:"issue_comments,omitempty"`
	// A token, which can be sent as `page_token` to retrieve the next page.
	// If this field is omitted, there are no subsequent pages.
	NextPageToken string `protobuf:"bytes,2,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListIssueCommentsResponse) Reset() {
	*x = ListIssueCommentsResponse{}
	mi := &file_v1_issue_service_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListIssueCommentsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListIssueCommentsResponse) ProtoMessage() {}

func (x *ListIssueCommentsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_v1_issue_service_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListIssueCommentsResponse.ProtoReflect.Descriptor instead.
func (*ListIssueCommentsResponse) Descriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{17}
}

func (x *ListIssueCommentsResponse) GetIssueComments() []*IssueComment {
	if x != nil {
		return x.IssueComments
	}
	return nil
}

func (x *ListIssueCommentsResponse) GetNextPageToken() string {
	if x != nil {
		return x.NextPageToken
	}
	return ""
}

type CreateIssueCommentRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The issue name
	// Format: projects/{project}/issues/{issue}
	Parent string `protobuf:"bytes,1,opt,name=parent,proto3" json:"parent,omitempty"`
	// The comment to create.
	IssueComment  *IssueComment `protobuf:"bytes,2,opt,name=issue_comment,json=issueComment,proto3" json:"issue_comment,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateIssueCommentRequest) Reset() {
	*x = CreateIssueCommentRequest{}
	mi := &file_v1_issue_service_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateIssueCommentRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateIssueCommentRequest) ProtoMessage() {}

func (x *CreateIssueCommentRequest) ProtoReflect() protoreflect.Message {
	mi := &file_v1_issue_service_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateIssueCommentRequest.ProtoReflect.Descriptor instead.
func (*CreateIssueCommentRequest) Descriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{18}
}

func (x *CreateIssueCommentRequest) GetParent() string {
	if x != nil {
		return x.Parent
	}
	return ""
}

func (x *CreateIssueCommentRequest) GetIssueComment() *IssueComment {
	if x != nil {
		return x.IssueComment
	}
	return nil
}

type UpdateIssueCommentRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The issue name
	// Format: projects/{project}/issues/{issue}
	Parent string `protobuf:"bytes,1,opt,name=parent,proto3" json:"parent,omitempty"`
	// The comment to update.
	IssueComment *IssueComment `protobuf:"bytes,2,opt,name=issue_comment,json=issueComment,proto3" json:"issue_comment,omitempty"`
	// The list of fields to update.
	UpdateMask *fieldmaskpb.FieldMask `protobuf:"bytes,3,opt,name=update_mask,json=updateMask,proto3" json:"update_mask,omitempty"`
	// If set to true, and the issue comment is not found, a new issue comment will be created.
	// In this situation, `update_mask` is ignored.
	AllowMissing  bool `protobuf:"varint,4,opt,name=allow_missing,json=allowMissing,proto3" json:"allow_missing,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateIssueCommentRequest) Reset() {
	*x = UpdateIssueCommentRequest{}
	mi := &file_v1_issue_service_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateIssueCommentRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateIssueCommentRequest) ProtoMessage() {}

func (x *UpdateIssueCommentRequest) ProtoReflect() protoreflect.Message {
	mi := &file_v1_issue_service_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateIssueCommentRequest.ProtoReflect.Descriptor instead.
func (*UpdateIssueCommentRequest) Descriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{19}
}

func (x *UpdateIssueCommentRequest) GetParent() string {
	if x != nil {
		return x.Parent
	}
	return ""
}

func (x *UpdateIssueCommentRequest) GetIssueComment() *IssueComment {
	if x != nil {
		return x.IssueComment
	}
	return nil
}

func (x *UpdateIssueCommentRequest) GetUpdateMask() *fieldmaskpb.FieldMask {
	if x != nil {
		return x.UpdateMask
	}
	return nil
}

func (x *UpdateIssueCommentRequest) GetAllowMissing() bool {
	if x != nil {
		return x.AllowMissing
	}
	return false
}

// A comment on an issue.
type IssueComment struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Format: projects/{project}/issues/{issue}/issueComments/{issueComment-uid}
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The text content of the comment.
	Comment string `protobuf:"bytes,2,opt,name=comment,proto3" json:"comment,omitempty"`
	// TODO: use struct message instead.
	Payload    string                 `protobuf:"bytes,3,opt,name=payload,proto3" json:"payload,omitempty"`
	CreateTime *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=create_time,json=createTime,proto3" json:"create_time,omitempty"`
	UpdateTime *timestamppb.Timestamp `protobuf:"bytes,5,opt,name=update_time,json=updateTime,proto3" json:"update_time,omitempty"`
	// Format: users/{email}
	Creator string `protobuf:"bytes,6,opt,name=creator,proto3" json:"creator,omitempty"`
	// The event associated with this comment.
	//
	// Types that are valid to be assigned to Event:
	//
	//	*IssueComment_Approval_
	//	*IssueComment_IssueUpdate_
	//	*IssueComment_PlanSpecUpdate_
	Event         isIssueComment_Event `protobuf_oneof:"event"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IssueComment) Reset() {
	*x = IssueComment{}
	mi := &file_v1_issue_service_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IssueComment) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IssueComment) ProtoMessage() {}

func (x *IssueComment) ProtoReflect() protoreflect.Message {
	mi := &file_v1_issue_service_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IssueComment.ProtoReflect.Descriptor instead.
func (*IssueComment) Descriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{20}
}

func (x *IssueComment) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *IssueComment) GetComment() string {
	if x != nil {
		return x.Comment
	}
	return ""
}

func (x *IssueComment) GetPayload() string {
	if x != nil {
		return x.Payload
	}
	return ""
}

func (x *IssueComment) GetCreateTime() *timestamppb.Timestamp {
	if x != nil {
		return x.CreateTime
	}
	return nil
}

func (x *IssueComment) GetUpdateTime() *timestamppb.Timestamp {
	if x != nil {
		return x.UpdateTime
	}
	return nil
}

func (x *IssueComment) GetCreator() string {
	if x != nil {
		return x.Creator
	}
	return ""
}

func (x *IssueComment) GetEvent() isIssueComment_Event {
	if x != nil {
		return x.Event
	}
	return nil
}

func (x *IssueComment) GetApproval() *IssueComment_Approval {
	if x != nil {
		if x, ok := x.Event.(*IssueComment_Approval_); ok {
			return x.Approval
		}
	}
	return nil
}

func (x *IssueComment) GetIssueUpdate() *IssueComment_IssueUpdate {
	if x != nil {
		if x, ok := x.Event.(*IssueComment_IssueUpdate_); ok {
			return x.IssueUpdate
		}
	}
	return nil
}

func (x *IssueComment) GetPlanSpecUpdate() *IssueComment_PlanSpecUpdate {
	if x != nil {
		if x, ok := x.Event.(*IssueComment_PlanSpecUpdate_); ok {
			return x.PlanSpecUpdate
		}
	}
	return nil
}

type isIssueComment_Event interface {
	isIssueComment_Event()
}

type IssueComment_Approval_ struct {
	// Approval event.
	Approval *IssueComment_Approval `protobuf:"bytes,7,opt,name=approval,proto3,oneof"`
}

type IssueComment_IssueUpdate_ struct {
	// Issue update event.
	IssueUpdate *IssueComment_IssueUpdate `protobuf:"bytes,8,opt,name=issue_update,json=issueUpdate,proto3,oneof"`
}

type IssueComment_PlanSpecUpdate_ struct {
	// Plan spec update event.
	PlanSpecUpdate *IssueComment_PlanSpecUpdate `protobuf:"bytes,12,opt,name=plan_spec_update,json=planSpecUpdate,proto3,oneof"`
}

func (*IssueComment_Approval_) isIssueComment_Event() {}

func (*IssueComment_IssueUpdate_) isIssueComment_Event() {}

func (*IssueComment_PlanSpecUpdate_) isIssueComment_Event() {}

// Approvers and their approval status for the issue.
type Issue_Approver struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The new status.
	Status Issue_Approver_Status `protobuf:"varint,1,opt,name=status,proto3,enum=bytebase.v1.Issue_Approver_Status" json:"status,omitempty"`
	// Format: users/hello@world.com
	Principal     string `protobuf:"bytes,2,opt,name=principal,proto3" json:"principal,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Issue_Approver) Reset() {
	*x = Issue_Approver{}
	mi := &file_v1_issue_service_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Issue_Approver) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Issue_Approver) ProtoMessage() {}

func (x *Issue_Approver) ProtoReflect() protoreflect.Message {
	mi := &file_v1_issue_service_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Issue_Approver.ProtoReflect.Descriptor instead.
func (*Issue_Approver) Descriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{12, 0}
}

func (x *Issue_Approver) GetStatus() Issue_Approver_Status {
	if x != nil {
		return x.Status
	}
	return Issue_Approver_STATUS_UNSPECIFIED
}

func (x *Issue_Approver) GetPrincipal() string {
	if x != nil {
		return x.Principal
	}
	return ""
}

// Approval event information.
type IssueComment_Approval struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The approval status.
	Status        IssueComment_Approval_Status `protobuf:"varint,1,opt,name=status,proto3,enum=bytebase.v1.IssueComment_Approval_Status" json:"status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IssueComment_Approval) Reset() {
	*x = IssueComment_Approval{}
	mi := &file_v1_issue_service_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IssueComment_Approval) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IssueComment_Approval) ProtoMessage() {}

func (x *IssueComment_Approval) ProtoReflect() protoreflect.Message {
	mi := &file_v1_issue_service_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IssueComment_Approval.ProtoReflect.Descriptor instead.
func (*IssueComment_Approval) Descriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{20, 0}
}

func (x *IssueComment_Approval) GetStatus() IssueComment_Approval_Status {
	if x != nil {
		return x.Status
	}
	return IssueComment_Approval_STATUS_UNSPECIFIED
}

// Issue update event information.
type IssueComment_IssueUpdate struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	FromTitle       *string                `protobuf:"bytes,1,opt,name=from_title,json=fromTitle,proto3,oneof" json:"from_title,omitempty"`
	ToTitle         *string                `protobuf:"bytes,2,opt,name=to_title,json=toTitle,proto3,oneof" json:"to_title,omitempty"`
	FromDescription *string                `protobuf:"bytes,3,opt,name=from_description,json=fromDescription,proto3,oneof" json:"from_description,omitempty"`
	ToDescription   *string                `protobuf:"bytes,4,opt,name=to_description,json=toDescription,proto3,oneof" json:"to_description,omitempty"`
	FromStatus      *IssueStatus           `protobuf:"varint,5,opt,name=from_status,json=fromStatus,proto3,enum=bytebase.v1.IssueStatus,oneof" json:"from_status,omitempty"`
	ToStatus        *IssueStatus           `protobuf:"varint,6,opt,name=to_status,json=toStatus,proto3,enum=bytebase.v1.IssueStatus,oneof" json:"to_status,omitempty"`
	FromLabels      []string               `protobuf:"bytes,7,rep,name=from_labels,json=fromLabels,proto3" json:"from_labels,omitempty"`
	ToLabels        []string               `protobuf:"bytes,8,rep,name=to_labels,json=toLabels,proto3" json:"to_labels,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *IssueComment_IssueUpdate) Reset() {
	*x = IssueComment_IssueUpdate{}
	mi := &file_v1_issue_service_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IssueComment_IssueUpdate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IssueComment_IssueUpdate) ProtoMessage() {}

func (x *IssueComment_IssueUpdate) ProtoReflect() protoreflect.Message {
	mi := &file_v1_issue_service_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IssueComment_IssueUpdate.ProtoReflect.Descriptor instead.
func (*IssueComment_IssueUpdate) Descriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{20, 1}
}

func (x *IssueComment_IssueUpdate) GetFromTitle() string {
	if x != nil && x.FromTitle != nil {
		return *x.FromTitle
	}
	return ""
}

func (x *IssueComment_IssueUpdate) GetToTitle() string {
	if x != nil && x.ToTitle != nil {
		return *x.ToTitle
	}
	return ""
}

func (x *IssueComment_IssueUpdate) GetFromDescription() string {
	if x != nil && x.FromDescription != nil {
		return *x.FromDescription
	}
	return ""
}

func (x *IssueComment_IssueUpdate) GetToDescription() string {
	if x != nil && x.ToDescription != nil {
		return *x.ToDescription
	}
	return ""
}

func (x *IssueComment_IssueUpdate) GetFromStatus() IssueStatus {
	if x != nil && x.FromStatus != nil {
		return *x.FromStatus
	}
	return IssueStatus_ISSUE_STATUS_UNSPECIFIED
}

func (x *IssueComment_IssueUpdate) GetToStatus() IssueStatus {
	if x != nil && x.ToStatus != nil {
		return *x.ToStatus
	}
	return IssueStatus_ISSUE_STATUS_UNSPECIFIED
}

func (x *IssueComment_IssueUpdate) GetFromLabels() []string {
	if x != nil {
		return x.FromLabels
	}
	return nil
}

func (x *IssueComment_IssueUpdate) GetToLabels() []string {
	if x != nil {
		return x.ToLabels
	}
	return nil
}

// Plan spec update event information (tracks sheet changes to plan specs).
type IssueComment_PlanSpecUpdate struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The spec that was updated.
	// Format: projects/{project}/plans/{plan}/specs/{spec}
	Spec string `protobuf:"bytes,1,opt,name=spec,proto3" json:"spec,omitempty"`
	// The previous sheet.
	// Format: projects/{project}/sheets/{sheet}
	FromSheet *string `protobuf:"bytes,2,opt,name=from_sheet,json=fromSheet,proto3,oneof" json:"from_sheet,omitempty"`
	// The new sheet.
	// Format: projects/{project}/sheets/{sheet}
	ToSheet       *string `protobuf:"bytes,3,opt,name=to_sheet,json=toSheet,proto3,oneof" json:"to_sheet,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IssueComment_PlanSpecUpdate) Reset() {
	*x = IssueComment_PlanSpecUpdate{}
	mi := &file_v1_issue_service_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IssueComment_PlanSpecUpdate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IssueComment_PlanSpecUpdate) ProtoMessage() {}

func (x *IssueComment_PlanSpecUpdate) ProtoReflect() protoreflect.Message {
	mi := &file_v1_issue_service_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IssueComment_PlanSpecUpdate.ProtoReflect.Descriptor instead.
func (*IssueComment_PlanSpecUpdate) Descriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{20, 2}
}

func (x *IssueComment_PlanSpecUpdate) GetSpec() string {
	if x != nil {
		return x.Spec
	}
	return ""
}

func (x *IssueComment_PlanSpecUpdate) GetFromSheet() string {
	if x != nil && x.FromSheet != nil {
		return *x.FromSheet
	}
	return ""
}

func (x *IssueComment_PlanSpecUpdate) GetToSheet() string {
	if x != nil && x.ToSheet != nil {
		return *x.ToSheet
	}
	return ""
}

var File_v1_issue_service_proto protoreflect.FileDescriptor

const file_v1_issue_service_proto_rawDesc = "" +
	"\n" +
	"\x16v1/issue_service.proto\x12\vbytebase.v1\x1a\x1bbuf/validate/validate.proto\x1a\x1cgoogle/api/annotations.proto\x1a\x17google/api/client.proto\x1a\x1fgoogle/api/field_behavior.proto\x1a\x19google/api/resource.proto\x1a\x1egoogle/protobuf/duration.proto\x1a google/protobuf/field_mask.proto\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x16google/type/expr.proto\x1a\x13v1/annotation.proto\x1a\x0fv1/common.proto\"W\n" +
	"\x0fGetIssueRequest\x12.\n" +
	"\x04name\x18\x01 \x01(\tB\x1a\xe0A\x02\xfaA\x14\n" +
	"\x12bytebase.com/IssueR\x04name\x12\x14\n" +
	"\x05force\x18\x02 \x01(\bR\x05force\"y\n" +
	"\x12CreateIssueRequest\x124\n" +
	"\x06parent\x18\x01 \x01(\tB\x1c\xe0A\x02\xfaA\x16\n" +
	"\x14bytebase.com/ProjectR\x06parent\x12-\n" +
	"\x05issue\x18\x02 \x01(\v2\x12.bytebase.v1.IssueB\x03\xe0A\x02R\x05issue\"\xb3\x01\n" +
	"\x11ListIssuesRequest\x124\n" +
	"\x06parent\x18\x01 \x01(\tB\x1c\xe0A\x02\xfaA\x16\n" +
	"\x14bytebase.com/ProjectR\x06parent\x12\x1b\n" +
	"\tpage_size\x18\x02 \x01(\x05R\bpageSize\x12\x1d\n" +
	"\n" +
	"page_token\x18\x03 \x01(\tR\tpageToken\x12\x16\n" +
	"\x06filter\x18\x04 \x01(\tR\x06filter\x12\x14\n" +
	"\x05query\x18\x05 \x01(\tR\x05query\"h\n" +
	"\x12ListIssuesResponse\x12*\n" +
	"\x06issues\x18\x01 \x03(\v2\x12.bytebase.v1.IssueR\x06issues\x12&\n" +
	"\x0fnext_page_token\x18\x02 \x01(\tR\rnextPageToken\"\x9c\x01\n" +
	"\x13SearchIssuesRequest\x12\x1b\n" +
	"\x06parent\x18\x01 \x01(\tB\x03\xe0A\x02R\x06parent\x12\x1b\n" +
	"\tpage_size\x18\x02 \x01(\x05R\bpageSize\x12\x1d\n" +
	"\n" +
	"page_token\x18\x03 \x01(\tR\tpageToken\x12\x16\n" +
	"\x06filter\x18\x04 \x01(\tR\x06filter\x12\x14\n" +
	"\x05query\x18\x05 \x01(\tR\x05query\"j\n" +
	"\x14SearchIssuesResponse\x12*\n" +
	"\x06issues\x18\x01 \x03(\v2\x12.bytebase.v1.IssueR\x06issues\x12&\n" +
	"\x0fnext_page_token\x18\x02 \x01(\tR\rnextPageToken\"\xc1\x01\n" +
	"\x12UpdateIssueRequest\x12D\n" +
	"\x05issue\x18\x01 \x01(\v2\x12.bytebase.v1.IssueB\x1a\xe0A\x02\xfaA\x14\n" +
	"\x12bytebase.com/IssueR\x05issue\x12@\n" +
	"\vupdate_mask\x18\x02 \x01(\v2\x1a.google.protobuf.FieldMaskB\x03\xe0A\x02R\n" +
	"updateMask\x12#\n" +
	"\rallow_missing\x18\x03 \x01(\bR\fallowMissing\"\xb8\x01\n" +
	"\x1eBatchUpdateIssuesStatusRequest\x124\n" +
	"\x06parent\x18\x01 \x01(\tB\x1c\xe0A\x02\xfaA\x16\n" +
	"\x14bytebase.com/ProjectR\x06parent\x12\x16\n" +
	"\x06issues\x18\x02 \x03(\tR\x06issues\x120\n" +
	"\x06status\x18\x03 \x01(\x0e2\x18.bytebase.v1.IssueStatusR\x06status\x12\x16\n" +
	"\x06reason\x18\x04 \x01(\tR\x06reason\"!\n" +
	"\x1fBatchUpdateIssuesStatusResponse\"_\n" +
	"\x13ApproveIssueRequest\x12.\n" +
	"\x04name\x18\x01 \x01(\tB\x1a\xe0A\x02\xfaA\x14\n" +
	"\x12bytebase.com/IssueR\x04name\x12\x18\n" +
	"\acomment\x18\x02 \x01(\tR\acomment\"^\n" +
	"\x12RejectIssueRequest\x12.\n" +
	"\x04name\x18\x01 \x01(\tB\x1a\xe0A\x02\xfaA\x14\n" +
	"\x12bytebase.com/IssueR\x04name\x12\x18\n" +
	"\acomment\x18\x02 \x01(\tR\acomment\"_\n" +
	"\x13RequestIssueRequest\x12.\n" +
	"\x04name\x18\x01 \x01(\tB\x1a\xe0A\x02\xfaA\x14\n" +
	"\x12bytebase.com/IssueR\x04name\x12\x18\n" +
	"\acomment\x18\x02 \x01(\tR\acomment\"\xa4\t\n" +
	"\x05Issue\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x1e\n" +
	"\x05title\x18\x02 \x01(\tB\b\xbaH\x05r\x03\x18\xc8\x01R\x05title\x12*\n" +
	"\vdescription\x18\x03 \x01(\tB\b\xbaH\x05r\x03\x18\x90NR\vdescription\x12+\n" +
	"\x04type\x18\x04 \x01(\x0e2\x17.bytebase.v1.Issue.TypeR\x04type\x120\n" +
	"\x06status\x18\x05 \x01(\x0e2\x18.bytebase.v1.IssueStatusR\x06status\x129\n" +
	"\tapprovers\x18\x06 \x03(\v2\x1b.bytebase.v1.Issue.ApproverR\tapprovers\x12J\n" +
	"\x11approval_template\x18\a \x01(\v2\x1d.bytebase.v1.ApprovalTemplateR\x10approvalTemplate\x12\x1d\n" +
	"\acreator\x18\b \x01(\tB\x03\xe0A\x03R\acreator\x12@\n" +
	"\vcreate_time\x18\t \x01(\v2\x1a.google.protobuf.TimestampB\x03\xe0A\x03R\n" +
	"createTime\x12@\n" +
	"\vupdate_time\x18\n" +
	" \x01(\v2\x1a.google.protobuf.TimestampB\x03\xe0A\x03R\n" +
	"updateTime\x12\x12\n" +
	"\x04plan\x18\v \x01(\tR\x04plan\x12>\n" +
	"\rgrant_request\x18\r \x01(\v2\x19.bytebase.v1.GrantRequestR\fgrantRequest\x125\n" +
	"\n" +
	"risk_level\x18\x0f \x01(\x0e2\x16.bytebase.v1.RiskLevelR\triskLevel\x12\x16\n" +
	"\x06labels\x18\x11 \x03(\tR\x06labels\x12O\n" +
	"\x0fapproval_status\x18\x12 \x01(\x0e2!.bytebase.v1.Issue.ApprovalStatusB\x03\xe0A\x03R\x0eapprovalStatus\x1a\xaf\x01\n" +
	"\bApprover\x12:\n" +
	"\x06status\x18\x01 \x01(\x0e2\".bytebase.v1.Issue.Approver.StatusR\x06status\x12\x1c\n" +
	"\tprincipal\x18\x02 \x01(\tR\tprincipal\"I\n" +
	"\x06Status\x12\x16\n" +
	"\x12STATUS_UNSPECIFIED\x10\x00\x12\v\n" +
	"\aPENDING\x10\x01\x12\f\n" +
	"\bAPPROVED\x10\x02\x12\f\n" +
	"\bREJECTED\x10\x03\"Y\n" +
	"\x04Type\x12\x14\n" +
	"\x10TYPE_UNSPECIFIED\x10\x00\x12\x13\n" +
	"\x0fDATABASE_CHANGE\x10\x01\x12\x11\n" +
	"\rGRANT_REQUEST\x10\x02\x12\x13\n" +
	"\x0fDATABASE_EXPORT\x10\x03\"u\n" +
	"\x0eApprovalStatus\x12\x1f\n" +
	"\x1bAPPROVAL_STATUS_UNSPECIFIED\x10\x00\x12\f\n" +
	"\bCHECKING\x10\x01\x12\v\n" +
	"\aPENDING\x10\x02\x12\f\n" +
	"\bAPPROVED\x10\x03\x12\f\n" +
	"\bREJECTED\x10\x04\x12\v\n" +
	"\aSKIPPED\x10\x05::\xeaA7\n" +
	"\x12bytebase.com/Issue\x12!projects/{project}/issues/{issue}\"\xa2\x01\n" +
	"\fGrantRequest\x12\x12\n" +
	"\x04role\x18\x01 \x01(\tR\x04role\x12\x12\n" +
	"\x04user\x18\x02 \x01(\tR\x04user\x12/\n" +
	"\tcondition\x18\x03 \x01(\v2\x11.google.type.ExprR\tcondition\x129\n" +
	"\n" +
	"expiration\x18\x04 \x01(\v2\x19.google.protobuf.DurationR\n" +
	"expiration\"y\n" +
	"\x10ApprovalTemplate\x12-\n" +
	"\x04flow\x18\x01 \x01(\v2\x19.bytebase.v1.ApprovalFlowR\x04flow\x12\x14\n" +
	"\x05title\x18\x02 \x01(\tR\x05title\x12 \n" +
	"\vdescription\x18\x03 \x01(\tR\vdescription\"$\n" +
	"\fApprovalFlow\x12\x14\n" +
	"\x05roles\x18\x01 \x03(\tR\x05roles\"\x8a\x01\n" +
	"\x18ListIssueCommentsRequest\x122\n" +
	"\x06parent\x18\x01 \x01(\tB\x1a\xe0A\x02\xfaA\x14\n" +
	"\x12bytebase.com/IssueR\x06parent\x12\x1b\n" +
	"\tpage_size\x18\x02 \x01(\x05R\bpageSize\x12\x1d\n" +
	"\n" +
	"page_token\x18\x03 \x01(\tR\tpageToken\"\x85\x01\n" +
	"\x19ListIssueCommentsResponse\x12@\n" +
	"\x0eissue_comments\x18\x01 \x03(\v2\x19.bytebase.v1.IssueCommentR\rissueComments\x12&\n" +
	"\x0fnext_page_token\x18\x02 \x01(\tR\rnextPageToken\"\x8f\x01\n" +
	"\x19CreateIssueCommentRequest\x122\n" +
	"\x06parent\x18\x01 \x01(\tB\x1a\xe0A\x02\xfaA\x14\n" +
	"\x12bytebase.com/IssueR\x06parent\x12>\n" +
	"\rissue_comment\x18\x02 \x01(\v2\x19.bytebase.v1.IssueCommentR\fissueComment\"\xf6\x01\n" +
	"\x19UpdateIssueCommentRequest\x122\n" +
	"\x06parent\x18\x01 \x01(\tB\x1a\xe0A\x02\xfaA\x14\n" +
	"\x12bytebase.com/IssueR\x06parent\x12>\n" +
	"\rissue_comment\x18\x02 \x01(\v2\x19.bytebase.v1.IssueCommentR\fissueComment\x12@\n" +
	"\vupdate_mask\x18\x03 \x01(\v2\x1a.google.protobuf.FieldMaskB\x03\xe0A\x02R\n" +
	"updateMask\x12#\n" +
	"\rallow_missing\x18\x04 \x01(\bR\fallowMissing\"\xdf\t\n" +
	"\fIssueComment\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12#\n" +
	"\acomment\x18\x02 \x01(\tB\t\xbaH\x06r\x04\x18\x80\x80\x04R\acomment\x12\x18\n" +
	"\apayload\x18\x03 \x01(\tR\apayload\x12@\n" +
	"\vcreate_time\x18\x04 \x01(\v2\x1a.google.protobuf.TimestampB\x03\xe0A\x03R\n" +
	"createTime\x12@\n" +
	"\vupdate_time\x18\x05 \x01(\v2\x1a.google.protobuf.TimestampB\x03\xe0A\x03R\n" +
	"updateTime\x12\x1d\n" +
	"\acreator\x18\x06 \x01(\tB\x03\xe0A\x03R\acreator\x12@\n" +
	"\bapproval\x18\a \x01(\v2\".bytebase.v1.IssueComment.ApprovalH\x00R\bapproval\x12J\n" +
	"\fissue_update\x18\b \x01(\v2%.bytebase.v1.IssueComment.IssueUpdateH\x00R\vissueUpdate\x12T\n" +
	"\x10plan_spec_update\x18\f \x01(\v2(.bytebase.v1.IssueComment.PlanSpecUpdateH\x00R\x0eplanSpecUpdate\x1a\x98\x01\n" +
	"\bApproval\x12A\n" +
	"\x06status\x18\x01 \x01(\x0e2).bytebase.v1.IssueComment.Approval.StatusR\x06status\"I\n" +
	"\x06Status\x12\x16\n" +
	"\x12STATUS_UNSPECIFIED\x10\x00\x12\v\n" +
	"\aPENDING\x10\x01\x12\f\n" +
	"\bAPPROVED\x10\x02\x12\f\n" +
	"\bREJECTED\x10\x03\x1a\xc9\x03\n" +
	"\vIssueUpdate\x12\"\n" +
	"\n" +
	"from_title\x18\x01 \x01(\tH\x00R\tfromTitle\x88\x01\x01\x12\x1e\n" +
	"\bto_title\x18\x02 \x01(\tH\x01R\atoTitle\x88\x01\x01\x12.\n" +
	"\x10from_description\x18\x03 \x01(\tH\x02R\x0ffromDescription\x88\x01\x01\x12*\n" +
	"\x0eto_description\x18\x04 \x01(\tH\x03R\rtoDescription\x88\x01\x01\x12>\n" +
	"\vfrom_status\x18\x05 \x01(\x0e2\x18.bytebase.v1.IssueStatusH\x04R\n" +
	"fromStatus\x88\x01\x01\x12:\n" +
	"\tto_status\x18\x06 \x01(\x0e2\x18.bytebase.v1.IssueStatusH\x05R\btoStatus\x88\x01\x01\x12\x1f\n" +
	"\vfrom_labels\x18\a \x03(\tR\n" +
	"fromLabels\x12\x1b\n" +
	"\tto_labels\x18\b \x03(\tR\btoLabelsB\r\n" +
	"\v_from_titleB\v\n" +
	"\t_to_titleB\x13\n" +
	"\x11_from_descriptionB\x11\n" +
	"\x0f_to_descriptionB\x0e\n" +
	"\f_from_statusB\f\n" +
	"\n" +
	"_to_status\x1a\x84\x01\n" +
	"\x0ePlanSpecUpdate\x12\x12\n" +
	"\x04spec\x18\x01 \x01(\tR\x04spec\x12\"\n" +
	"\n" +
	"from_sheet\x18\x02 \x01(\tH\x00R\tfromSheet\x88\x01\x01\x12\x1e\n" +
	"\bto_sheet\x18\x03 \x01(\tH\x01R\atoSheet\x88\x01\x01B\r\n" +
	"\v_from_sheetB\v\n" +
	"\t_to_sheetB\a\n" +
	"\x05event*M\n" +
	"\vIssueStatus\x12\x1c\n" +
	"\x18ISSUE_STATUS_UNSPECIFIED\x10\x00\x12\b\n" +
	"\x04OPEN\x10\x01\x12\b\n" +
	"\x04DONE\x10\x02\x12\f\n" +
	"\bCANCELED\x10\x032\xd8\x0f\n" +
	"\fIssueService\x12\x80\x01\n" +
	"\bGetIssue\x12\x1c.bytebase.v1.GetIssueRequest\x1a\x12.bytebase.v1.Issue\"B\xdaA\x04name\x8a\xea0\rbb.issues.get\x90\xea0\x01\x82\xd3\xe4\x93\x02 \x12\x1e/v1/{name=projects/*/issues/*}\x12\x9c\x01\n" +
	"\vCreateIssue\x12\x1f.bytebase.v1.CreateIssueRequest\x1a\x12.bytebase.v1.Issue\"X\xdaA\fparent,issue\x8a\xea0\x10bb.issues.create\x90\xea0\x01\x98\xea0\x01\x82\xd3\xe4\x93\x02':\x05issue\"\x1e/v1/{parent=projects/*}/issues\x12\x94\x01\n" +
	"\n" +
	"ListIssues\x12\x1e.bytebase.v1.ListIssuesRequest\x1a\x1f.bytebase.v1.ListIssuesResponse\"E\xdaA\x06parent\x8a\xea0\x0ebb.issues.list\x90\xea0\x01\x82\xd3\xe4\x93\x02 \x12\x1e/v1/{parent=projects/*}/issues\x12\x9a\x01\n" +
	"\fSearchIssues\x12 .bytebase.v1.SearchIssuesRequest\x1a!.bytebase.v1.SearchIssuesResponse\"E\x8a\xea0\rbb.issues.get\x90\xea0\x02\x82\xd3\xe4\x93\x02*:\x01*\"%/v1/{parent=projects/*}/issues:search\x12\xa7\x01\n" +
	"\vUpdateIssue\x12\x1f.bytebase.v1.UpdateIssueRequest\x1a\x12.bytebase.v1.Issue\"c\xdaA\x11issue,update_mask\x8a\xea0\x10bb.issues.update\x90\xea0\x01\x98\xea0\x01\x82\xd3\xe4\x93\x02-:\x05issue2$/v1/{issue.name=projects/*/issues/*}\x12\xc0\x01\n" +
	"\x11ListIssueComments\x12%.bytebase.v1.ListIssueCommentsRequest\x1a&.bytebase.v1.ListIssueCommentsResponse\"\\\xdaA\x06parent\x8a\xea0\x15bb.issueComments.list\x90\xea0\x01\x82\xd3\xe4\x93\x020\x12./v1/{parent=projects/*/issues/*}/issueComments\x12\xd2\x01\n" +
	"\x12CreateIssueComment\x12&.bytebase.v1.CreateIssueCommentRequest\x1a\x19.bytebase.v1.IssueComment\"y\xdaA\x14parent,issue_comment\x8a\xea0\x17bb.issueComments.create\x90\xea0\x01\x98\xea0\x01\x82\xd3\xe4\x93\x029:\rissue_comment\"(/v1/{parent=projects/*/issues/*}:comment\x12\xdf\x01\n" +
	"\x12UpdateIssueComment\x12&.bytebase.v1.UpdateIssueCommentRequest\x1a\x19.bytebase.v1.IssueComment\"\x85\x01\xdaA parent,issue_comment,update_mask\x8a\xea0\x17bb.issueComments.update\x90\xea0\x01\x98\xea0\x01\x82\xd3\xe4\x93\x029:\rissue_comment2(/v1/{parent=projects/*/issues/*}:comment\x12\xcd\x01\n" +
	"\x17BatchUpdateIssuesStatus\x12+.bytebase.v1.BatchUpdateIssuesStatusRequest\x1a,.bytebase.v1.BatchUpdateIssuesStatusResponse\"W\x8a\xea0\x10bb.issues.update\x90\xea0\x01\x98\xea0\x01\x82\xd3\xe4\x93\x025:\x01*\"0/v1/{parent=projects/*}/issues:batchUpdateStatus\x12\x7f\n" +
	"\fApproveIssue\x12 .bytebase.v1.ApproveIssueRequest\x1a\x12.bytebase.v1.Issue\"9\x90\xea0\x02\x98\xea0\x01\x82\xd3\xe4\x93\x02+:\x01*\"&/v1/{name=projects/*/issues/*}:approve\x12|\n" +
	"\vRejectIssue\x12\x1f.bytebase.v1.RejectIssueRequest\x1a\x12.bytebase.v1.Issue\"8\x90\xea0\x02\x98\xea0\x01\x82\xd3\xe4\x93\x02*:\x01*\"%/v1/{name=projects/*/issues/*}:reject\x12\x7f\n" +
	"\fRequestIssue\x12 .bytebase.v1.RequestIssueRequest\x1a\x12.bytebase.v1.Issue\"9\x90\xea0\x02\x98\xea0\x01\x82\xd3\xe4\x93\x02+:\x01*\"&/v1/{name=projects/*/issues/*}:requestB\xa7\x01\n" +
	"\x0fcom.bytebase.v1B\x11IssueServiceProtoP\x01Z4github.com/bytebase/bytebase/backend/generated-go/v1\xa2\x02\x03BXX\xaa\x02\vBytebase.V1\xca\x02\vBytebase\\V1\xe2\x02\x17Bytebase\\V1\\GPBMetadata\xea\x02\fBytebase::V1b\x06proto3"

var (
	file_v1_issue_service_proto_rawDescOnce sync.Once
	file_v1_issue_service_proto_rawDescData []byte
)

func file_v1_issue_service_proto_rawDescGZIP() []byte {
	file_v1_issue_service_proto_rawDescOnce.Do(func() {
		file_v1_issue_service_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_v1_issue_service_proto_rawDesc), len(file_v1_issue_service_proto_rawDesc)))
	})
	return file_v1_issue_service_proto_rawDescData
}

var file_v1_issue_service_proto_enumTypes = make([]protoimpl.EnumInfo, 5)
var file_v1_issue_service_proto_msgTypes = make([]protoimpl.MessageInfo, 25)
var file_v1_issue_service_proto_goTypes = []any{
	(IssueStatus)(0),                        // 0: bytebase.v1.IssueStatus
	(Issue_Type)(0),                         // 1: bytebase.v1.Issue.Type
	(Issue_ApprovalStatus)(0),               // 2: bytebase.v1.Issue.ApprovalStatus
	(Issue_Approver_Status)(0),              // 3: bytebase.v1.Issue.Approver.Status
	(IssueComment_Approval_Status)(0),       // 4: bytebase.v1.IssueComment.Approval.Status
	(*GetIssueRequest)(nil),                 // 5: bytebase.v1.GetIssueRequest
	(*CreateIssueRequest)(nil),              // 6: bytebase.v1.CreateIssueRequest
	(*ListIssuesRequest)(nil),               // 7: bytebase.v1.ListIssuesRequest
	(*ListIssuesResponse)(nil),              // 8: bytebase.v1.ListIssuesResponse
	(*SearchIssuesRequest)(nil),             // 9: bytebase.v1.SearchIssuesRequest
	(*SearchIssuesResponse)(nil),            // 10: bytebase.v1.SearchIssuesResponse
	(*UpdateIssueRequest)(nil),              // 11: bytebase.v1.UpdateIssueRequest
	(*BatchUpdateIssuesStatusRequest)(nil),  // 12: bytebase.v1.BatchUpdateIssuesStatusRequest
	(*BatchUpdateIssuesStatusResponse)(nil), // 13: bytebase.v1.BatchUpdateIssuesStatusResponse
	(*ApproveIssueRequest)(nil),             // 14: bytebase.v1.ApproveIssueRequest
	(*RejectIssueRequest)(nil),              // 15: bytebase.v1.RejectIssueRequest
	(*RequestIssueRequest)(nil),             // 16: bytebase.v1.RequestIssueRequest
	(*Issue)(nil),                           // 17: bytebase.v1.Issue
	(*GrantRequest)(nil),                    // 18: bytebase.v1.GrantRequest
	(*ApprovalTemplate)(nil),                // 19: bytebase.v1.ApprovalTemplate
	(*ApprovalFlow)(nil),                    // 20: bytebase.v1.ApprovalFlow
	(*ListIssueCommentsRequest)(nil),        // 21: bytebase.v1.ListIssueCommentsRequest
	(*ListIssueCommentsResponse)(nil),       // 22: bytebase.v1.ListIssueCommentsResponse
	(*CreateIssueCommentRequest)(nil),       // 23: bytebase.v1.CreateIssueCommentRequest
	(*UpdateIssueCommentRequest)(nil),       // 24: bytebase.v1.UpdateIssueCommentRequest
	(*IssueComment)(nil),                    // 25: bytebase.v1.IssueComment
	(*Issue_Approver)(nil),                  // 26: bytebase.v1.Issue.Approver
	(*IssueComment_Approval)(nil),           // 27: bytebase.v1.IssueComment.Approval
	(*IssueComment_IssueUpdate)(nil),        // 28: bytebase.v1.IssueComment.IssueUpdate
	(*IssueComment_PlanSpecUpdate)(nil),     // 29: bytebase.v1.IssueComment.PlanSpecUpdate
	(*fieldmaskpb.FieldMask)(nil),           // 30: google.protobuf.FieldMask
	(*timestamppb.Timestamp)(nil),           // 31: google.protobuf.Timestamp
	(RiskLevel)(0),                          // 32: bytebase.v1.RiskLevel
	(*expr.Expr)(nil),                       // 33: google.type.Expr
	(*durationpb.Duration)(nil),             // 34: google.protobuf.Duration
}
var file_v1_issue_service_proto_depIdxs = []int32{
	17, // 0: bytebase.v1.CreateIssueRequest.issue:type_name -> bytebase.v1.Issue
	17, // 1: bytebase.v1.ListIssuesResponse.issues:type_name -> bytebase.v1.Issue
	17, // 2: bytebase.v1.SearchIssuesResponse.issues:type_name -> bytebase.v1.Issue
	17, // 3: bytebase.v1.UpdateIssueRequest.issue:type_name -> bytebase.v1.Issue
	30, // 4: bytebase.v1.UpdateIssueRequest.update_mask:type_name -> google.protobuf.FieldMask
	0,  // 5: bytebase.v1.BatchUpdateIssuesStatusRequest.status:type_name -> bytebase.v1.IssueStatus
	1,  // 6: bytebase.v1.Issue.type:type_name -> bytebase.v1.Issue.Type
	0,  // 7: bytebase.v1.Issue.status:type_name -> bytebase.v1.IssueStatus
	26, // 8: bytebase.v1.Issue.approvers:type_name -> bytebase.v1.Issue.Approver
	19, // 9: bytebase.v1.Issue.approval_template:type_name -> bytebase.v1.ApprovalTemplate
	31, // 10: bytebase.v1.Issue.create_time:type_name -> google.protobuf.Timestamp
	31, // 11: bytebase.v1.Issue.update_time:type_name -> google.protobuf.Timestamp
	18, // 12: bytebase.v1.Issue.grant_request:type_name -> bytebase.v1.GrantRequest
	32, // 13: bytebase.v1.Issue.risk_level:type_name -> bytebase.v1.RiskLevel
	2,  // 14: bytebase.v1.Issue.approval_status:type_name -> bytebase.v1.Issue.ApprovalStatus
	33, // 15: bytebase.v1.GrantRequest.condition:type_name -> google.type.Expr
	34, // 16: bytebase.v1.GrantRequest.expiration:type_name -> google.protobuf.Duration
	20, // 17: bytebase.v1.ApprovalTemplate.flow:type_name -> bytebase.v1.ApprovalFlow
	25, // 18: bytebase.v1.ListIssueCommentsResponse.issue_comments:type_name -> bytebase.v1.IssueComment
	25, // 19: bytebase.v1.CreateIssueCommentRequest.issue_comment:type_name -> bytebase.v1.IssueComment
	25, // 20: bytebase.v1.UpdateIssueCommentRequest.issue_comment:type_name -> bytebase.v1.IssueComment
	30, // 21: bytebase.v1.UpdateIssueCommentRequest.update_mask:type_name -> google.protobuf.FieldMask
	31, // 22: bytebase.v1.IssueComment.create_time:type_name -> google.protobuf.Timestamp
	31, // 23: bytebase.v1.IssueComment.update_time:type_name -> google.protobuf.Timestamp
	27, // 24: bytebase.v1.IssueComment.approval:type_name -> bytebase.v1.IssueComment.Approval
	28, // 25: bytebase.v1.IssueComment.issue_update:type_name -> bytebase.v1.IssueComment.IssueUpdate
	29, // 26: bytebase.v1.IssueComment.plan_spec_update:type_name -> bytebase.v1.IssueComment.PlanSpecUpdate
	3,  // 27: bytebase.v1.Issue.Approver.status:type_name -> bytebase.v1.Issue.Approver.Status
	4,  // 28: bytebase.v1.IssueComment.Approval.status:type_name -> bytebase.v1.IssueComment.Approval.Status
	0,  // 29: bytebase.v1.IssueComment.IssueUpdate.from_status:type_name -> bytebase.v1.IssueStatus
	0,  // 30: bytebase.v1.IssueComment.IssueUpdate.to_status:type_name -> bytebase.v1.IssueStatus
	5,  // 31: bytebase.v1.IssueService.GetIssue:input_type -> bytebase.v1.GetIssueRequest
	6,  // 32: bytebase.v1.IssueService.CreateIssue:input_type -> bytebase.v1.CreateIssueRequest
	7,  // 33: bytebase.v1.IssueService.ListIssues:input_type -> bytebase.v1.ListIssuesRequest
	9,  // 34: bytebase.v1.IssueService.SearchIssues:input_type -> bytebase.v1.SearchIssuesRequest
	11, // 35: bytebase.v1.IssueService.UpdateIssue:input_type -> bytebase.v1.UpdateIssueRequest
	21, // 36: bytebase.v1.IssueService.ListIssueComments:input_type -> bytebase.v1.ListIssueCommentsRequest
	23, // 37: bytebase.v1.IssueService.CreateIssueComment:input_type -> bytebase.v1.CreateIssueCommentRequest
	24, // 38: bytebase.v1.IssueService.UpdateIssueComment:input_type -> bytebase.v1.UpdateIssueCommentRequest
	12, // 39: bytebase.v1.IssueService.BatchUpdateIssuesStatus:input_type -> bytebase.v1.BatchUpdateIssuesStatusRequest
	14, // 40: bytebase.v1.IssueService.ApproveIssue:input_type -> bytebase.v1.ApproveIssueRequest
	15, // 41: bytebase.v1.IssueService.RejectIssue:input_type -> bytebase.v1.RejectIssueRequest
	16, // 42: bytebase.v1.IssueService.RequestIssue:input_type -> bytebase.v1.RequestIssueRequest
	17, // 43: bytebase.v1.IssueService.GetIssue:output_type -> bytebase.v1.Issue
	17, // 44: bytebase.v1.IssueService.CreateIssue:output_type -> bytebase.v1.Issue
	8,  // 45: bytebase.v1.IssueService.ListIssues:output_type -> bytebase.v1.ListIssuesResponse
	10, // 46: bytebase.v1.IssueService.SearchIssues:output_type -> bytebase.v1.SearchIssuesResponse
	17, // 47: bytebase.v1.IssueService.UpdateIssue:output_type -> bytebase.v1.Issue
	22, // 48: bytebase.v1.IssueService.ListIssueComments:output_type -> bytebase.v1.ListIssueCommentsResponse
	25, // 49: bytebase.v1.IssueService.CreateIssueComment:output_type -> bytebase.v1.IssueComment
	25, // 50: bytebase.v1.IssueService.UpdateIssueComment:output_type -> bytebase.v1.IssueComment
	13, // 51: bytebase.v1.IssueService.BatchUpdateIssuesStatus:output_type -> bytebase.v1.BatchUpdateIssuesStatusResponse
	17, // 52: bytebase.v1.IssueService.ApproveIssue:output_type -> bytebase.v1.Issue
	17, // 53: bytebase.v1.IssueService.RejectIssue:output_type -> bytebase.v1.Issue
	17, // 54: bytebase.v1.IssueService.RequestIssue:output_type -> bytebase.v1.Issue
	43, // [43:55] is the sub-list for method output_type
	31, // [31:43] is the sub-list for method input_type
	31, // [31:31] is the sub-list for extension type_name
	31, // [31:31] is the sub-list for extension extendee
	0,  // [0:31] is the sub-list for field type_name
}

func init() { file_v1_issue_service_proto_init() }
func file_v1_issue_service_proto_init() {
	if File_v1_issue_service_proto != nil {
		return
	}
	file_v1_annotation_proto_init()
	file_v1_common_proto_init()
	file_v1_issue_service_proto_msgTypes[20].OneofWrappers = []any{
		(*IssueComment_Approval_)(nil),
		(*IssueComment_IssueUpdate_)(nil),
		(*IssueComment_PlanSpecUpdate_)(nil),
	}
	file_v1_issue_service_proto_msgTypes[23].OneofWrappers = []any{}
	file_v1_issue_service_proto_msgTypes[24].OneofWrappers = []any{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_v1_issue_service_proto_rawDesc), len(file_v1_issue_service_proto_rawDesc)),
			NumEnums:      5,
			NumMessages:   25,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_v1_issue_service_proto_goTypes,
		DependencyIndexes: file_v1_issue_service_proto_depIdxs,
		EnumInfos:         file_v1_issue_service_proto_enumTypes,
		MessageInfos:      file_v1_issue_service_proto_msgTypes,
	}.Build()
	File_v1_issue_service_proto = out.File
	file_v1_issue_service_proto_goTypes = nil
	file_v1_issue_service_proto_depIdxs = nil
}
