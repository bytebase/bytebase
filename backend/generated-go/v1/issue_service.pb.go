// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.7
// 	protoc        (unknown)
// source: v1/issue_service.proto

package v1

import (
	_ "google.golang.org/genproto/googleapis/api/annotations"
	expr "google.golang.org/genproto/googleapis/type/expr"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	fieldmaskpb "google.golang.org/protobuf/types/known/fieldmaskpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type IssueStatus int32

const (
	IssueStatus_ISSUE_STATUS_UNSPECIFIED IssueStatus = 0
	IssueStatus_OPEN                     IssueStatus = 1
	IssueStatus_DONE                     IssueStatus = 2
	IssueStatus_CANCELED                 IssueStatus = 3
)

// Enum value maps for IssueStatus.
var (
	IssueStatus_name = map[int32]string{
		0: "ISSUE_STATUS_UNSPECIFIED",
		1: "OPEN",
		2: "DONE",
		3: "CANCELED",
	}
	IssueStatus_value = map[string]int32{
		"ISSUE_STATUS_UNSPECIFIED": 0,
		"OPEN":                     1,
		"DONE":                     2,
		"CANCELED":                 3,
	}
)

func (x IssueStatus) Enum() *IssueStatus {
	p := new(IssueStatus)
	*p = x
	return p
}

func (x IssueStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (IssueStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_v1_issue_service_proto_enumTypes[0].Descriptor()
}

func (IssueStatus) Type() protoreflect.EnumType {
	return &file_v1_issue_service_proto_enumTypes[0]
}

func (x IssueStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use IssueStatus.Descriptor instead.
func (IssueStatus) EnumDescriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{0}
}

type Issue_Type int32

const (
	Issue_TYPE_UNSPECIFIED Issue_Type = 0
	Issue_DATABASE_CHANGE  Issue_Type = 1
	Issue_GRANT_REQUEST    Issue_Type = 2
	Issue_DATABASE_EXPORT  Issue_Type = 3
)

// Enum value maps for Issue_Type.
var (
	Issue_Type_name = map[int32]string{
		0: "TYPE_UNSPECIFIED",
		1: "DATABASE_CHANGE",
		2: "GRANT_REQUEST",
		3: "DATABASE_EXPORT",
	}
	Issue_Type_value = map[string]int32{
		"TYPE_UNSPECIFIED": 0,
		"DATABASE_CHANGE":  1,
		"GRANT_REQUEST":    2,
		"DATABASE_EXPORT":  3,
	}
)

func (x Issue_Type) Enum() *Issue_Type {
	p := new(Issue_Type)
	*p = x
	return p
}

func (x Issue_Type) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Issue_Type) Descriptor() protoreflect.EnumDescriptor {
	return file_v1_issue_service_proto_enumTypes[1].Descriptor()
}

func (Issue_Type) Type() protoreflect.EnumType {
	return &file_v1_issue_service_proto_enumTypes[1]
}

func (x Issue_Type) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Issue_Type.Descriptor instead.
func (Issue_Type) EnumDescriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{12, 0}
}

type Issue_RiskLevel int32

const (
	Issue_RISK_LEVEL_UNSPECIFIED Issue_RiskLevel = 0
	Issue_LOW                    Issue_RiskLevel = 1
	Issue_MODERATE               Issue_RiskLevel = 2
	Issue_HIGH                   Issue_RiskLevel = 3
)

// Enum value maps for Issue_RiskLevel.
var (
	Issue_RiskLevel_name = map[int32]string{
		0: "RISK_LEVEL_UNSPECIFIED",
		1: "LOW",
		2: "MODERATE",
		3: "HIGH",
	}
	Issue_RiskLevel_value = map[string]int32{
		"RISK_LEVEL_UNSPECIFIED": 0,
		"LOW":                    1,
		"MODERATE":               2,
		"HIGH":                   3,
	}
)

func (x Issue_RiskLevel) Enum() *Issue_RiskLevel {
	p := new(Issue_RiskLevel)
	*p = x
	return p
}

func (x Issue_RiskLevel) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Issue_RiskLevel) Descriptor() protoreflect.EnumDescriptor {
	return file_v1_issue_service_proto_enumTypes[2].Descriptor()
}

func (Issue_RiskLevel) Type() protoreflect.EnumType {
	return &file_v1_issue_service_proto_enumTypes[2]
}

func (x Issue_RiskLevel) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Issue_RiskLevel.Descriptor instead.
func (Issue_RiskLevel) EnumDescriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{12, 1}
}

type Issue_Approver_Status int32

const (
	Issue_Approver_STATUS_UNSPECIFIED Issue_Approver_Status = 0
	Issue_Approver_PENDING            Issue_Approver_Status = 1
	Issue_Approver_APPROVED           Issue_Approver_Status = 2
	Issue_Approver_REJECTED           Issue_Approver_Status = 3
)

// Enum value maps for Issue_Approver_Status.
var (
	Issue_Approver_Status_name = map[int32]string{
		0: "STATUS_UNSPECIFIED",
		1: "PENDING",
		2: "APPROVED",
		3: "REJECTED",
	}
	Issue_Approver_Status_value = map[string]int32{
		"STATUS_UNSPECIFIED": 0,
		"PENDING":            1,
		"APPROVED":           2,
		"REJECTED":           3,
	}
)

func (x Issue_Approver_Status) Enum() *Issue_Approver_Status {
	p := new(Issue_Approver_Status)
	*p = x
	return p
}

func (x Issue_Approver_Status) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Issue_Approver_Status) Descriptor() protoreflect.EnumDescriptor {
	return file_v1_issue_service_proto_enumTypes[3].Descriptor()
}

func (Issue_Approver_Status) Type() protoreflect.EnumType {
	return &file_v1_issue_service_proto_enumTypes[3]
}

func (x Issue_Approver_Status) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Issue_Approver_Status.Descriptor instead.
func (Issue_Approver_Status) EnumDescriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{12, 0, 0}
}

// Type of the ApprovalStep
// ALL means every node must be approved to proceed.
// ANY means approving any node will proceed.
type ApprovalStep_Type int32

const (
	ApprovalStep_TYPE_UNSPECIFIED ApprovalStep_Type = 0
	ApprovalStep_ALL              ApprovalStep_Type = 1
	ApprovalStep_ANY              ApprovalStep_Type = 2
)

// Enum value maps for ApprovalStep_Type.
var (
	ApprovalStep_Type_name = map[int32]string{
		0: "TYPE_UNSPECIFIED",
		1: "ALL",
		2: "ANY",
	}
	ApprovalStep_Type_value = map[string]int32{
		"TYPE_UNSPECIFIED": 0,
		"ALL":              1,
		"ANY":              2,
	}
)

func (x ApprovalStep_Type) Enum() *ApprovalStep_Type {
	p := new(ApprovalStep_Type)
	*p = x
	return p
}

func (x ApprovalStep_Type) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ApprovalStep_Type) Descriptor() protoreflect.EnumDescriptor {
	return file_v1_issue_service_proto_enumTypes[4].Descriptor()
}

func (ApprovalStep_Type) Type() protoreflect.EnumType {
	return &file_v1_issue_service_proto_enumTypes[4]
}

func (x ApprovalStep_Type) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ApprovalStep_Type.Descriptor instead.
func (ApprovalStep_Type) EnumDescriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{16, 0}
}

// Type of the ApprovalNode.
// type determines who should approve this node.
// ANY_IN_GROUP means the ApprovalNode can be approved by an user from our predefined user group.
// See GroupValue below for the predefined user groups.
type ApprovalNode_Type int32

const (
	ApprovalNode_TYPE_UNSPECIFIED ApprovalNode_Type = 0
	ApprovalNode_ANY_IN_GROUP     ApprovalNode_Type = 1
)

// Enum value maps for ApprovalNode_Type.
var (
	ApprovalNode_Type_name = map[int32]string{
		0: "TYPE_UNSPECIFIED",
		1: "ANY_IN_GROUP",
	}
	ApprovalNode_Type_value = map[string]int32{
		"TYPE_UNSPECIFIED": 0,
		"ANY_IN_GROUP":     1,
	}
)

func (x ApprovalNode_Type) Enum() *ApprovalNode_Type {
	p := new(ApprovalNode_Type)
	*p = x
	return p
}

func (x ApprovalNode_Type) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ApprovalNode_Type) Descriptor() protoreflect.EnumDescriptor {
	return file_v1_issue_service_proto_enumTypes[5].Descriptor()
}

func (ApprovalNode_Type) Type() protoreflect.EnumType {
	return &file_v1_issue_service_proto_enumTypes[5]
}

func (x ApprovalNode_Type) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ApprovalNode_Type.Descriptor instead.
func (ApprovalNode_Type) EnumDescriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{17, 0}
}

type IssueComment_Approval_Status int32

const (
	IssueComment_Approval_STATUS_UNSPECIFIED IssueComment_Approval_Status = 0
	IssueComment_Approval_PENDING            IssueComment_Approval_Status = 1
	IssueComment_Approval_APPROVED           IssueComment_Approval_Status = 2
	IssueComment_Approval_REJECTED           IssueComment_Approval_Status = 3
)

// Enum value maps for IssueComment_Approval_Status.
var (
	IssueComment_Approval_Status_name = map[int32]string{
		0: "STATUS_UNSPECIFIED",
		1: "PENDING",
		2: "APPROVED",
		3: "REJECTED",
	}
	IssueComment_Approval_Status_value = map[string]int32{
		"STATUS_UNSPECIFIED": 0,
		"PENDING":            1,
		"APPROVED":           2,
		"REJECTED":           3,
	}
)

func (x IssueComment_Approval_Status) Enum() *IssueComment_Approval_Status {
	p := new(IssueComment_Approval_Status)
	*p = x
	return p
}

func (x IssueComment_Approval_Status) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (IssueComment_Approval_Status) Descriptor() protoreflect.EnumDescriptor {
	return file_v1_issue_service_proto_enumTypes[6].Descriptor()
}

func (IssueComment_Approval_Status) Type() protoreflect.EnumType {
	return &file_v1_issue_service_proto_enumTypes[6]
}

func (x IssueComment_Approval_Status) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use IssueComment_Approval_Status.Descriptor instead.
func (IssueComment_Approval_Status) EnumDescriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{22, 0, 0}
}

type IssueComment_TaskUpdate_Status int32

const (
	IssueComment_TaskUpdate_STATUS_UNSPECIFIED IssueComment_TaskUpdate_Status = 0
	IssueComment_TaskUpdate_PENDING            IssueComment_TaskUpdate_Status = 1
	IssueComment_TaskUpdate_RUNNING            IssueComment_TaskUpdate_Status = 2
	IssueComment_TaskUpdate_DONE               IssueComment_TaskUpdate_Status = 3
	IssueComment_TaskUpdate_FAILED             IssueComment_TaskUpdate_Status = 4
	IssueComment_TaskUpdate_SKIPPED            IssueComment_TaskUpdate_Status = 5
	IssueComment_TaskUpdate_CANCELED           IssueComment_TaskUpdate_Status = 6
)

// Enum value maps for IssueComment_TaskUpdate_Status.
var (
	IssueComment_TaskUpdate_Status_name = map[int32]string{
		0: "STATUS_UNSPECIFIED",
		1: "PENDING",
		2: "RUNNING",
		3: "DONE",
		4: "FAILED",
		5: "SKIPPED",
		6: "CANCELED",
	}
	IssueComment_TaskUpdate_Status_value = map[string]int32{
		"STATUS_UNSPECIFIED": 0,
		"PENDING":            1,
		"RUNNING":            2,
		"DONE":               3,
		"FAILED":             4,
		"SKIPPED":            5,
		"CANCELED":           6,
	}
)

func (x IssueComment_TaskUpdate_Status) Enum() *IssueComment_TaskUpdate_Status {
	p := new(IssueComment_TaskUpdate_Status)
	*p = x
	return p
}

func (x IssueComment_TaskUpdate_Status) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (IssueComment_TaskUpdate_Status) Descriptor() protoreflect.EnumDescriptor {
	return file_v1_issue_service_proto_enumTypes[7].Descriptor()
}

func (IssueComment_TaskUpdate_Status) Type() protoreflect.EnumType {
	return &file_v1_issue_service_proto_enumTypes[7]
}

func (x IssueComment_TaskUpdate_Status) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use IssueComment_TaskUpdate_Status.Descriptor instead.
func (IssueComment_TaskUpdate_Status) EnumDescriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{22, 3, 0}
}

type GetIssueRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The name of the issue to retrieve.
	// Format: projects/{project}/issues/{issue}
	Name          string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Force         bool   `protobuf:"varint,2,opt,name=force,proto3" json:"force,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetIssueRequest) Reset() {
	*x = GetIssueRequest{}
	mi := &file_v1_issue_service_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetIssueRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetIssueRequest) ProtoMessage() {}

func (x *GetIssueRequest) ProtoReflect() protoreflect.Message {
	mi := &file_v1_issue_service_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetIssueRequest.ProtoReflect.Descriptor instead.
func (*GetIssueRequest) Descriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{0}
}

func (x *GetIssueRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *GetIssueRequest) GetForce() bool {
	if x != nil {
		return x.Force
	}
	return false
}

type CreateIssueRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The parent, which owns this collection of issues.
	// Format: projects/{project}
	Parent string `protobuf:"bytes,1,opt,name=parent,proto3" json:"parent,omitempty"`
	// The issue to create.
	Issue         *Issue `protobuf:"bytes,2,opt,name=issue,proto3" json:"issue,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateIssueRequest) Reset() {
	*x = CreateIssueRequest{}
	mi := &file_v1_issue_service_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateIssueRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateIssueRequest) ProtoMessage() {}

func (x *CreateIssueRequest) ProtoReflect() protoreflect.Message {
	mi := &file_v1_issue_service_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateIssueRequest.ProtoReflect.Descriptor instead.
func (*CreateIssueRequest) Descriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{1}
}

func (x *CreateIssueRequest) GetParent() string {
	if x != nil {
		return x.Parent
	}
	return ""
}

func (x *CreateIssueRequest) GetIssue() *Issue {
	if x != nil {
		return x.Issue
	}
	return nil
}

type ListIssuesRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The parent, which owns this collection of issues.
	// Format: projects/{project}
	Parent string `protobuf:"bytes,1,opt,name=parent,proto3" json:"parent,omitempty"`
	// The maximum number of issues to return. The service may return fewer than
	// this value.
	// If unspecified, at most 10 issues will be returned.
	// The maximum value is 1000; values above 1000 will be coerced to 1000.
	PageSize int32 `protobuf:"varint,2,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	// A page token, received from a previous `ListIssues` call.
	// Provide this to retrieve the subsequent page.
	//
	// When paginating, all other parameters provided to `ListIssues` must match
	// the call that provided the page token.
	PageToken string `protobuf:"bytes,3,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
	// Filter is used to filter issues returned in the list.
	// The syntax and semantics of CEL are documented at https://github.com/google/cel-spec
	//
	// Supported filters:
	// - creator: issue creator full name in "users/{email or id}" format, support "==" operator.
	// - status: the issue status, support "==" and "in" operator, check the IssueStatus enum for the values.
	// - create_time: issue create time in "2006-01-02T15:04:05Z07:00" format, support ">=" or "<=" operator.
	// - type: the issue type, support "==" and "in" operator, check the Type enum in the Issue message for the values.
	// - task_type: support "==" operator, the value can be "DDL", "DML" or "DATA_EXPORT"
	// - instance: the instance full name in the "instances/{id}" format, support "==" operator.
	// - database: the database full name in the "instances/{id}/databases/{name}" format, support "==" operator.
	// - labels: the issue labels, support "==" and "in" operator.
	// - has_pipeline: the issue has pipeline or not, support "==" operator, the value should be "true" or "false".
	//
	// For example:
	// creator == "users/ed@bytebase.com" && status in ["OPEN", "DONE"]
	// status == "CANCELED" && type == "DATABASE_CHANGE"
	// instance == "instances/sample" && labels in ["label1", "label2"]
	// has_pipeline == true && create_time >= "2025-01-02T15:04:05Z07:00"
	Filter string `protobuf:"bytes,4,opt,name=filter,proto3" json:"filter,omitempty"`
	// Query is the query statement.
	Query         string `protobuf:"bytes,5,opt,name=query,proto3" json:"query,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListIssuesRequest) Reset() {
	*x = ListIssuesRequest{}
	mi := &file_v1_issue_service_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListIssuesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListIssuesRequest) ProtoMessage() {}

func (x *ListIssuesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_v1_issue_service_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListIssuesRequest.ProtoReflect.Descriptor instead.
func (*ListIssuesRequest) Descriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{2}
}

func (x *ListIssuesRequest) GetParent() string {
	if x != nil {
		return x.Parent
	}
	return ""
}

func (x *ListIssuesRequest) GetPageSize() int32 {
	if x != nil {
		return x.PageSize
	}
	return 0
}

func (x *ListIssuesRequest) GetPageToken() string {
	if x != nil {
		return x.PageToken
	}
	return ""
}

func (x *ListIssuesRequest) GetFilter() string {
	if x != nil {
		return x.Filter
	}
	return ""
}

func (x *ListIssuesRequest) GetQuery() string {
	if x != nil {
		return x.Query
	}
	return ""
}

type ListIssuesResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The issues from the specified request.
	Issues []*Issue `protobuf:"bytes,1,rep,name=issues,proto3" json:"issues,omitempty"`
	// A token, which can be sent as `page_token` to retrieve the next page.
	// If this field is omitted, there are no subsequent pages.
	NextPageToken string `protobuf:"bytes,2,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListIssuesResponse) Reset() {
	*x = ListIssuesResponse{}
	mi := &file_v1_issue_service_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListIssuesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListIssuesResponse) ProtoMessage() {}

func (x *ListIssuesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_v1_issue_service_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListIssuesResponse.ProtoReflect.Descriptor instead.
func (*ListIssuesResponse) Descriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{3}
}

func (x *ListIssuesResponse) GetIssues() []*Issue {
	if x != nil {
		return x.Issues
	}
	return nil
}

func (x *ListIssuesResponse) GetNextPageToken() string {
	if x != nil {
		return x.NextPageToken
	}
	return ""
}

type SearchIssuesRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The parent, which owns this collection of issues.
	// Format: projects/{project}
	// Use "projects/-" to list all issues from all projects.
	Parent string `protobuf:"bytes,1,opt,name=parent,proto3" json:"parent,omitempty"`
	// The maximum number of issues to return. The service may return fewer than
	// this value.
	// If unspecified, at most 10 issues will be returned.
	// The maximum value is 1000; values above 1000 will be coerced to 1000.
	PageSize int32 `protobuf:"varint,2,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	// A page token, received from a previous `SearchIssues` call.
	// Provide this to retrieve the subsequent page.
	//
	// When paginating, all other parameters provided to `SearchIssues` must match
	// the call that provided the page token.
	PageToken string `protobuf:"bytes,3,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
	// Filter is used to filter issues returned in the list.
	// Check the filter field in the ListIssuesRequest message.
	Filter string `protobuf:"bytes,4,opt,name=filter,proto3" json:"filter,omitempty"`
	// Query is the query statement.
	Query         string `protobuf:"bytes,5,opt,name=query,proto3" json:"query,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SearchIssuesRequest) Reset() {
	*x = SearchIssuesRequest{}
	mi := &file_v1_issue_service_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SearchIssuesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SearchIssuesRequest) ProtoMessage() {}

func (x *SearchIssuesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_v1_issue_service_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SearchIssuesRequest.ProtoReflect.Descriptor instead.
func (*SearchIssuesRequest) Descriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{4}
}

func (x *SearchIssuesRequest) GetParent() string {
	if x != nil {
		return x.Parent
	}
	return ""
}

func (x *SearchIssuesRequest) GetPageSize() int32 {
	if x != nil {
		return x.PageSize
	}
	return 0
}

func (x *SearchIssuesRequest) GetPageToken() string {
	if x != nil {
		return x.PageToken
	}
	return ""
}

func (x *SearchIssuesRequest) GetFilter() string {
	if x != nil {
		return x.Filter
	}
	return ""
}

func (x *SearchIssuesRequest) GetQuery() string {
	if x != nil {
		return x.Query
	}
	return ""
}

type SearchIssuesResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The issues from the specified request.
	Issues []*Issue `protobuf:"bytes,1,rep,name=issues,proto3" json:"issues,omitempty"`
	// A token, which can be sent as `page_token` to retrieve the next page.
	// If this field is omitted, there are no subsequent pages.
	NextPageToken string `protobuf:"bytes,2,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SearchIssuesResponse) Reset() {
	*x = SearchIssuesResponse{}
	mi := &file_v1_issue_service_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SearchIssuesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SearchIssuesResponse) ProtoMessage() {}

func (x *SearchIssuesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_v1_issue_service_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SearchIssuesResponse.ProtoReflect.Descriptor instead.
func (*SearchIssuesResponse) Descriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{5}
}

func (x *SearchIssuesResponse) GetIssues() []*Issue {
	if x != nil {
		return x.Issues
	}
	return nil
}

func (x *SearchIssuesResponse) GetNextPageToken() string {
	if x != nil {
		return x.NextPageToken
	}
	return ""
}

type UpdateIssueRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The issue to update.
	//
	// The issue's `name` field is used to identify the issue to update.
	// Format: projects/{project}/issues/{issue}
	Issue *Issue `protobuf:"bytes,1,opt,name=issue,proto3" json:"issue,omitempty"`
	// The list of fields to update.
	UpdateMask    *fieldmaskpb.FieldMask `protobuf:"bytes,2,opt,name=update_mask,json=updateMask,proto3" json:"update_mask,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateIssueRequest) Reset() {
	*x = UpdateIssueRequest{}
	mi := &file_v1_issue_service_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateIssueRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateIssueRequest) ProtoMessage() {}

func (x *UpdateIssueRequest) ProtoReflect() protoreflect.Message {
	mi := &file_v1_issue_service_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateIssueRequest.ProtoReflect.Descriptor instead.
func (*UpdateIssueRequest) Descriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{6}
}

func (x *UpdateIssueRequest) GetIssue() *Issue {
	if x != nil {
		return x.Issue
	}
	return nil
}

func (x *UpdateIssueRequest) GetUpdateMask() *fieldmaskpb.FieldMask {
	if x != nil {
		return x.UpdateMask
	}
	return nil
}

type BatchUpdateIssuesStatusRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The parent resource shared by all issues being updated.
	// Format: projects/{project}
	// If the operation spans parents, a dash (-) may be accepted as a wildcard.
	// We only support updating the status of databases for now.
	Parent string `protobuf:"bytes,1,opt,name=parent,proto3" json:"parent,omitempty"`
	// The list of issues to update.
	// Format: projects/{project}/issues/{issue}
	Issues []string `protobuf:"bytes,2,rep,name=issues,proto3" json:"issues,omitempty"`
	// The new status.
	Status        IssueStatus `protobuf:"varint,3,opt,name=status,proto3,enum=bytebase.v1.IssueStatus" json:"status,omitempty"`
	Reason        string      `protobuf:"bytes,4,opt,name=reason,proto3" json:"reason,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BatchUpdateIssuesStatusRequest) Reset() {
	*x = BatchUpdateIssuesStatusRequest{}
	mi := &file_v1_issue_service_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BatchUpdateIssuesStatusRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BatchUpdateIssuesStatusRequest) ProtoMessage() {}

func (x *BatchUpdateIssuesStatusRequest) ProtoReflect() protoreflect.Message {
	mi := &file_v1_issue_service_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BatchUpdateIssuesStatusRequest.ProtoReflect.Descriptor instead.
func (*BatchUpdateIssuesStatusRequest) Descriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{7}
}

func (x *BatchUpdateIssuesStatusRequest) GetParent() string {
	if x != nil {
		return x.Parent
	}
	return ""
}

func (x *BatchUpdateIssuesStatusRequest) GetIssues() []string {
	if x != nil {
		return x.Issues
	}
	return nil
}

func (x *BatchUpdateIssuesStatusRequest) GetStatus() IssueStatus {
	if x != nil {
		return x.Status
	}
	return IssueStatus_ISSUE_STATUS_UNSPECIFIED
}

func (x *BatchUpdateIssuesStatusRequest) GetReason() string {
	if x != nil {
		return x.Reason
	}
	return ""
}

type BatchUpdateIssuesStatusResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BatchUpdateIssuesStatusResponse) Reset() {
	*x = BatchUpdateIssuesStatusResponse{}
	mi := &file_v1_issue_service_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BatchUpdateIssuesStatusResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BatchUpdateIssuesStatusResponse) ProtoMessage() {}

func (x *BatchUpdateIssuesStatusResponse) ProtoReflect() protoreflect.Message {
	mi := &file_v1_issue_service_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BatchUpdateIssuesStatusResponse.ProtoReflect.Descriptor instead.
func (*BatchUpdateIssuesStatusResponse) Descriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{8}
}

type ApproveIssueRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The name of the issue to add an approver.
	// Format: projects/{project}/issues/{issue}
	Name          string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Comment       string `protobuf:"bytes,2,opt,name=comment,proto3" json:"comment,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ApproveIssueRequest) Reset() {
	*x = ApproveIssueRequest{}
	mi := &file_v1_issue_service_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ApproveIssueRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ApproveIssueRequest) ProtoMessage() {}

func (x *ApproveIssueRequest) ProtoReflect() protoreflect.Message {
	mi := &file_v1_issue_service_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ApproveIssueRequest.ProtoReflect.Descriptor instead.
func (*ApproveIssueRequest) Descriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{9}
}

func (x *ApproveIssueRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *ApproveIssueRequest) GetComment() string {
	if x != nil {
		return x.Comment
	}
	return ""
}

type RejectIssueRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The name of the issue to add an rejection.
	// Format: projects/{project}/issues/{issue}
	Name          string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Comment       string `protobuf:"bytes,2,opt,name=comment,proto3" json:"comment,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RejectIssueRequest) Reset() {
	*x = RejectIssueRequest{}
	mi := &file_v1_issue_service_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RejectIssueRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RejectIssueRequest) ProtoMessage() {}

func (x *RejectIssueRequest) ProtoReflect() protoreflect.Message {
	mi := &file_v1_issue_service_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RejectIssueRequest.ProtoReflect.Descriptor instead.
func (*RejectIssueRequest) Descriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{10}
}

func (x *RejectIssueRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *RejectIssueRequest) GetComment() string {
	if x != nil {
		return x.Comment
	}
	return ""
}

type RequestIssueRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The name of the issue to request a issue.
	// Format: projects/{project}/issues/{issue}
	Name          string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Comment       string `protobuf:"bytes,2,opt,name=comment,proto3" json:"comment,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RequestIssueRequest) Reset() {
	*x = RequestIssueRequest{}
	mi := &file_v1_issue_service_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RequestIssueRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RequestIssueRequest) ProtoMessage() {}

func (x *RequestIssueRequest) ProtoReflect() protoreflect.Message {
	mi := &file_v1_issue_service_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RequestIssueRequest.ProtoReflect.Descriptor instead.
func (*RequestIssueRequest) Descriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{11}
}

func (x *RequestIssueRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *RequestIssueRequest) GetComment() string {
	if x != nil {
		return x.Comment
	}
	return ""
}

type Issue struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The name of the issue.
	// Format: projects/{project}/issues/{issue}
	Name              string              `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Title             string              `protobuf:"bytes,3,opt,name=title,proto3" json:"title,omitempty"`
	Description       string              `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	Type              Issue_Type          `protobuf:"varint,5,opt,name=type,proto3,enum=bytebase.v1.Issue_Type" json:"type,omitempty"`
	Status            IssueStatus         `protobuf:"varint,6,opt,name=status,proto3,enum=bytebase.v1.IssueStatus" json:"status,omitempty"`
	Approvers         []*Issue_Approver   `protobuf:"bytes,9,rep,name=approvers,proto3" json:"approvers,omitempty"`
	ApprovalTemplates []*ApprovalTemplate `protobuf:"bytes,10,rep,name=approval_templates,json=approvalTemplates,proto3" json:"approval_templates,omitempty"`
	// If the value is `false`, it means that the backend is still finding matching approval templates.
	// If `true`, approval_templates & approvers & approval_finding_error are available.
	ApprovalFindingDone  bool   `protobuf:"varint,11,opt,name=approval_finding_done,json=approvalFindingDone,proto3" json:"approval_finding_done,omitempty"`
	ApprovalFindingError string `protobuf:"bytes,12,opt,name=approval_finding_error,json=approvalFindingError,proto3" json:"approval_finding_error,omitempty"`
	// Format: users/hello@world.com
	Creator    string                 `protobuf:"bytes,14,opt,name=creator,proto3" json:"creator,omitempty"`
	CreateTime *timestamppb.Timestamp `protobuf:"bytes,15,opt,name=create_time,json=createTime,proto3" json:"create_time,omitempty"`
	UpdateTime *timestamppb.Timestamp `protobuf:"bytes,16,opt,name=update_time,json=updateTime,proto3" json:"update_time,omitempty"`
	// The plan associated with the issue.
	// Can be empty.
	// Format: projects/{project}/plans/{plan}
	Plan string `protobuf:"bytes,17,opt,name=plan,proto3" json:"plan,omitempty"`
	// The rollout associated with the issue.
	// Can be empty.
	// Format: projects/{project}/rollouts/{rollout}
	Rollout string `protobuf:"bytes,18,opt,name=rollout,proto3" json:"rollout,omitempty"`
	// Used if the issue type is GRANT_REQUEST.
	GrantRequest *GrantRequest `protobuf:"bytes,19,opt,name=grant_request,json=grantRequest,proto3" json:"grant_request,omitempty"`
	// The releasers of the pending stage of the issue rollout, judging
	// from the rollout policy.
	// Format:
	// - roles/workspaceOwner
	// - roles/workspaceDBA
	// - roles/projectOwner
	// - roles/projectReleaser
	// - users/{email}
	Releasers []string        `protobuf:"bytes,20,rep,name=releasers,proto3" json:"releasers,omitempty"`
	RiskLevel Issue_RiskLevel `protobuf:"varint,21,opt,name=risk_level,json=riskLevel,proto3,enum=bytebase.v1.Issue_RiskLevel" json:"risk_level,omitempty"`
	// The status count of the issue.
	// Keys are the following:
	// - NOT_STARTED
	// - SKIPPED
	// - PENDING
	// - RUNNING
	// - DONE
	// - FAILED
	// - CANCELED
	TaskStatusCount map[string]int32 `protobuf:"bytes,22,rep,name=task_status_count,json=taskStatusCount,proto3" json:"task_status_count,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	Labels          []string         `protobuf:"bytes,23,rep,name=labels,proto3" json:"labels,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *Issue) Reset() {
	*x = Issue{}
	mi := &file_v1_issue_service_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Issue) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Issue) ProtoMessage() {}

func (x *Issue) ProtoReflect() protoreflect.Message {
	mi := &file_v1_issue_service_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Issue.ProtoReflect.Descriptor instead.
func (*Issue) Descriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{12}
}

func (x *Issue) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Issue) GetTitle() string {
	if x != nil {
		return x.Title
	}
	return ""
}

func (x *Issue) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *Issue) GetType() Issue_Type {
	if x != nil {
		return x.Type
	}
	return Issue_TYPE_UNSPECIFIED
}

func (x *Issue) GetStatus() IssueStatus {
	if x != nil {
		return x.Status
	}
	return IssueStatus_ISSUE_STATUS_UNSPECIFIED
}

func (x *Issue) GetApprovers() []*Issue_Approver {
	if x != nil {
		return x.Approvers
	}
	return nil
}

func (x *Issue) GetApprovalTemplates() []*ApprovalTemplate {
	if x != nil {
		return x.ApprovalTemplates
	}
	return nil
}

func (x *Issue) GetApprovalFindingDone() bool {
	if x != nil {
		return x.ApprovalFindingDone
	}
	return false
}

func (x *Issue) GetApprovalFindingError() string {
	if x != nil {
		return x.ApprovalFindingError
	}
	return ""
}

func (x *Issue) GetCreator() string {
	if x != nil {
		return x.Creator
	}
	return ""
}

func (x *Issue) GetCreateTime() *timestamppb.Timestamp {
	if x != nil {
		return x.CreateTime
	}
	return nil
}

func (x *Issue) GetUpdateTime() *timestamppb.Timestamp {
	if x != nil {
		return x.UpdateTime
	}
	return nil
}

func (x *Issue) GetPlan() string {
	if x != nil {
		return x.Plan
	}
	return ""
}

func (x *Issue) GetRollout() string {
	if x != nil {
		return x.Rollout
	}
	return ""
}

func (x *Issue) GetGrantRequest() *GrantRequest {
	if x != nil {
		return x.GrantRequest
	}
	return nil
}

func (x *Issue) GetReleasers() []string {
	if x != nil {
		return x.Releasers
	}
	return nil
}

func (x *Issue) GetRiskLevel() Issue_RiskLevel {
	if x != nil {
		return x.RiskLevel
	}
	return Issue_RISK_LEVEL_UNSPECIFIED
}

func (x *Issue) GetTaskStatusCount() map[string]int32 {
	if x != nil {
		return x.TaskStatusCount
	}
	return nil
}

func (x *Issue) GetLabels() []string {
	if x != nil {
		return x.Labels
	}
	return nil
}

type GrantRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The requested role.
	// Format: roles/EXPORTER.
	Role string `protobuf:"bytes,1,opt,name=role,proto3" json:"role,omitempty"`
	// The user to be granted.
	// Format: users/{email}.
	User string `protobuf:"bytes,2,opt,name=user,proto3" json:"user,omitempty"`
	// The condition for the role. Same as the condtion in IAM Binding message.
	Condition     *expr.Expr           `protobuf:"bytes,3,opt,name=condition,proto3" json:"condition,omitempty"`
	Expiration    *durationpb.Duration `protobuf:"bytes,4,opt,name=expiration,proto3" json:"expiration,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GrantRequest) Reset() {
	*x = GrantRequest{}
	mi := &file_v1_issue_service_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GrantRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GrantRequest) ProtoMessage() {}

func (x *GrantRequest) ProtoReflect() protoreflect.Message {
	mi := &file_v1_issue_service_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GrantRequest.ProtoReflect.Descriptor instead.
func (*GrantRequest) Descriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{13}
}

func (x *GrantRequest) GetRole() string {
	if x != nil {
		return x.Role
	}
	return ""
}

func (x *GrantRequest) GetUser() string {
	if x != nil {
		return x.User
	}
	return ""
}

func (x *GrantRequest) GetCondition() *expr.Expr {
	if x != nil {
		return x.Condition
	}
	return nil
}

func (x *GrantRequest) GetExpiration() *durationpb.Duration {
	if x != nil {
		return x.Expiration
	}
	return nil
}

type ApprovalTemplate struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Flow          *ApprovalFlow          `protobuf:"bytes,1,opt,name=flow,proto3" json:"flow,omitempty"`
	Title         string                 `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
	Description   string                 `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ApprovalTemplate) Reset() {
	*x = ApprovalTemplate{}
	mi := &file_v1_issue_service_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ApprovalTemplate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ApprovalTemplate) ProtoMessage() {}

func (x *ApprovalTemplate) ProtoReflect() protoreflect.Message {
	mi := &file_v1_issue_service_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ApprovalTemplate.ProtoReflect.Descriptor instead.
func (*ApprovalTemplate) Descriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{14}
}

func (x *ApprovalTemplate) GetFlow() *ApprovalFlow {
	if x != nil {
		return x.Flow
	}
	return nil
}

func (x *ApprovalTemplate) GetTitle() string {
	if x != nil {
		return x.Title
	}
	return ""
}

func (x *ApprovalTemplate) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

type ApprovalFlow struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Steps         []*ApprovalStep        `protobuf:"bytes,1,rep,name=steps,proto3" json:"steps,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ApprovalFlow) Reset() {
	*x = ApprovalFlow{}
	mi := &file_v1_issue_service_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ApprovalFlow) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ApprovalFlow) ProtoMessage() {}

func (x *ApprovalFlow) ProtoReflect() protoreflect.Message {
	mi := &file_v1_issue_service_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ApprovalFlow.ProtoReflect.Descriptor instead.
func (*ApprovalFlow) Descriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{15}
}

func (x *ApprovalFlow) GetSteps() []*ApprovalStep {
	if x != nil {
		return x.Steps
	}
	return nil
}

type ApprovalStep struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Type          ApprovalStep_Type      `protobuf:"varint,1,opt,name=type,proto3,enum=bytebase.v1.ApprovalStep_Type" json:"type,omitempty"`
	Nodes         []*ApprovalNode        `protobuf:"bytes,2,rep,name=nodes,proto3" json:"nodes,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ApprovalStep) Reset() {
	*x = ApprovalStep{}
	mi := &file_v1_issue_service_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ApprovalStep) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ApprovalStep) ProtoMessage() {}

func (x *ApprovalStep) ProtoReflect() protoreflect.Message {
	mi := &file_v1_issue_service_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ApprovalStep.ProtoReflect.Descriptor instead.
func (*ApprovalStep) Descriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{16}
}

func (x *ApprovalStep) GetType() ApprovalStep_Type {
	if x != nil {
		return x.Type
	}
	return ApprovalStep_TYPE_UNSPECIFIED
}

func (x *ApprovalStep) GetNodes() []*ApprovalNode {
	if x != nil {
		return x.Nodes
	}
	return nil
}

type ApprovalNode struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Type          ApprovalNode_Type      `protobuf:"varint,1,opt,name=type,proto3,enum=bytebase.v1.ApprovalNode_Type" json:"type,omitempty"`
	Role          string                 `protobuf:"bytes,2,opt,name=role,proto3" json:"role,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ApprovalNode) Reset() {
	*x = ApprovalNode{}
	mi := &file_v1_issue_service_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ApprovalNode) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ApprovalNode) ProtoMessage() {}

func (x *ApprovalNode) ProtoReflect() protoreflect.Message {
	mi := &file_v1_issue_service_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ApprovalNode.ProtoReflect.Descriptor instead.
func (*ApprovalNode) Descriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{17}
}

func (x *ApprovalNode) GetType() ApprovalNode_Type {
	if x != nil {
		return x.Type
	}
	return ApprovalNode_TYPE_UNSPECIFIED
}

func (x *ApprovalNode) GetRole() string {
	if x != nil {
		return x.Role
	}
	return ""
}

type ListIssueCommentsRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Format: projects/{projects}/issues/{issue}
	Parent string `protobuf:"bytes,1,opt,name=parent,proto3" json:"parent,omitempty"`
	// The maximum number of issue comments to return. The service may return fewer than
	// this value.
	// If unspecified, at most 10 issue comments will be returned.
	// The maximum value is 1000; values above 1000 will be coerced to 1000.
	PageSize int32 `protobuf:"varint,2,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	// A page token, received from a previous `ListIssueComments` call.
	// Provide this to retrieve the subsequent page.
	//
	// When paginating, all other parameters provided to `ListIssueComments` must match
	// the call that provided the page token.
	PageToken     string `protobuf:"bytes,3,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListIssueCommentsRequest) Reset() {
	*x = ListIssueCommentsRequest{}
	mi := &file_v1_issue_service_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListIssueCommentsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListIssueCommentsRequest) ProtoMessage() {}

func (x *ListIssueCommentsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_v1_issue_service_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListIssueCommentsRequest.ProtoReflect.Descriptor instead.
func (*ListIssueCommentsRequest) Descriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{18}
}

func (x *ListIssueCommentsRequest) GetParent() string {
	if x != nil {
		return x.Parent
	}
	return ""
}

func (x *ListIssueCommentsRequest) GetPageSize() int32 {
	if x != nil {
		return x.PageSize
	}
	return 0
}

func (x *ListIssueCommentsRequest) GetPageToken() string {
	if x != nil {
		return x.PageToken
	}
	return ""
}

type ListIssueCommentsResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	IssueComments []*IssueComment        `protobuf:"bytes,1,rep,name=issue_comments,json=issueComments,proto3" json:"issue_comments,omitempty"`
	// A token, which can be sent as `page_token` to retrieve the next page.
	// If this field is omitted, there are no subsequent pages.
	NextPageToken string `protobuf:"bytes,2,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListIssueCommentsResponse) Reset() {
	*x = ListIssueCommentsResponse{}
	mi := &file_v1_issue_service_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListIssueCommentsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListIssueCommentsResponse) ProtoMessage() {}

func (x *ListIssueCommentsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_v1_issue_service_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListIssueCommentsResponse.ProtoReflect.Descriptor instead.
func (*ListIssueCommentsResponse) Descriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{19}
}

func (x *ListIssueCommentsResponse) GetIssueComments() []*IssueComment {
	if x != nil {
		return x.IssueComments
	}
	return nil
}

func (x *ListIssueCommentsResponse) GetNextPageToken() string {
	if x != nil {
		return x.NextPageToken
	}
	return ""
}

type CreateIssueCommentRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The issue name
	// Format: projects/{project}/issues/{issue}
	Parent        string        `protobuf:"bytes,1,opt,name=parent,proto3" json:"parent,omitempty"`
	IssueComment  *IssueComment `protobuf:"bytes,2,opt,name=issue_comment,json=issueComment,proto3" json:"issue_comment,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateIssueCommentRequest) Reset() {
	*x = CreateIssueCommentRequest{}
	mi := &file_v1_issue_service_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateIssueCommentRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateIssueCommentRequest) ProtoMessage() {}

func (x *CreateIssueCommentRequest) ProtoReflect() protoreflect.Message {
	mi := &file_v1_issue_service_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateIssueCommentRequest.ProtoReflect.Descriptor instead.
func (*CreateIssueCommentRequest) Descriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{20}
}

func (x *CreateIssueCommentRequest) GetParent() string {
	if x != nil {
		return x.Parent
	}
	return ""
}

func (x *CreateIssueCommentRequest) GetIssueComment() *IssueComment {
	if x != nil {
		return x.IssueComment
	}
	return nil
}

type UpdateIssueCommentRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The issue name
	// Format: projects/{project}/issues/{issue}
	Parent       string        `protobuf:"bytes,1,opt,name=parent,proto3" json:"parent,omitempty"`
	IssueComment *IssueComment `protobuf:"bytes,2,opt,name=issue_comment,json=issueComment,proto3" json:"issue_comment,omitempty"`
	// The list of fields to update.
	UpdateMask    *fieldmaskpb.FieldMask `protobuf:"bytes,3,opt,name=update_mask,json=updateMask,proto3" json:"update_mask,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateIssueCommentRequest) Reset() {
	*x = UpdateIssueCommentRequest{}
	mi := &file_v1_issue_service_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateIssueCommentRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateIssueCommentRequest) ProtoMessage() {}

func (x *UpdateIssueCommentRequest) ProtoReflect() protoreflect.Message {
	mi := &file_v1_issue_service_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateIssueCommentRequest.ProtoReflect.Descriptor instead.
func (*UpdateIssueCommentRequest) Descriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{21}
}

func (x *UpdateIssueCommentRequest) GetParent() string {
	if x != nil {
		return x.Parent
	}
	return ""
}

func (x *UpdateIssueCommentRequest) GetIssueComment() *IssueComment {
	if x != nil {
		return x.IssueComment
	}
	return nil
}

func (x *UpdateIssueCommentRequest) GetUpdateMask() *fieldmaskpb.FieldMask {
	if x != nil {
		return x.UpdateMask
	}
	return nil
}

type IssueComment struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Format: projects/{project}/issues/{issue}/issueComments/{issueComment-uid}
	Name    string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Comment string `protobuf:"bytes,2,opt,name=comment,proto3" json:"comment,omitempty"`
	// TODO: use struct message instead.
	Payload    string                 `protobuf:"bytes,3,opt,name=payload,proto3" json:"payload,omitempty"`
	CreateTime *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=create_time,json=createTime,proto3" json:"create_time,omitempty"`
	UpdateTime *timestamppb.Timestamp `protobuf:"bytes,5,opt,name=update_time,json=updateTime,proto3" json:"update_time,omitempty"`
	// Format: users/{email}
	Creator string `protobuf:"bytes,7,opt,name=creator,proto3" json:"creator,omitempty"`
	// Types that are valid to be assigned to Event:
	//
	//	*IssueComment_Approval_
	//	*IssueComment_IssueUpdate_
	//	*IssueComment_StageEnd_
	//	*IssueComment_TaskUpdate_
	//	*IssueComment_TaskPriorBackup_
	Event         isIssueComment_Event `protobuf_oneof:"event"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IssueComment) Reset() {
	*x = IssueComment{}
	mi := &file_v1_issue_service_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IssueComment) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IssueComment) ProtoMessage() {}

func (x *IssueComment) ProtoReflect() protoreflect.Message {
	mi := &file_v1_issue_service_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IssueComment.ProtoReflect.Descriptor instead.
func (*IssueComment) Descriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{22}
}

func (x *IssueComment) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *IssueComment) GetComment() string {
	if x != nil {
		return x.Comment
	}
	return ""
}

func (x *IssueComment) GetPayload() string {
	if x != nil {
		return x.Payload
	}
	return ""
}

func (x *IssueComment) GetCreateTime() *timestamppb.Timestamp {
	if x != nil {
		return x.CreateTime
	}
	return nil
}

func (x *IssueComment) GetUpdateTime() *timestamppb.Timestamp {
	if x != nil {
		return x.UpdateTime
	}
	return nil
}

func (x *IssueComment) GetCreator() string {
	if x != nil {
		return x.Creator
	}
	return ""
}

func (x *IssueComment) GetEvent() isIssueComment_Event {
	if x != nil {
		return x.Event
	}
	return nil
}

func (x *IssueComment) GetApproval() *IssueComment_Approval {
	if x != nil {
		if x, ok := x.Event.(*IssueComment_Approval_); ok {
			return x.Approval
		}
	}
	return nil
}

func (x *IssueComment) GetIssueUpdate() *IssueComment_IssueUpdate {
	if x != nil {
		if x, ok := x.Event.(*IssueComment_IssueUpdate_); ok {
			return x.IssueUpdate
		}
	}
	return nil
}

func (x *IssueComment) GetStageEnd() *IssueComment_StageEnd {
	if x != nil {
		if x, ok := x.Event.(*IssueComment_StageEnd_); ok {
			return x.StageEnd
		}
	}
	return nil
}

func (x *IssueComment) GetTaskUpdate() *IssueComment_TaskUpdate {
	if x != nil {
		if x, ok := x.Event.(*IssueComment_TaskUpdate_); ok {
			return x.TaskUpdate
		}
	}
	return nil
}

func (x *IssueComment) GetTaskPriorBackup() *IssueComment_TaskPriorBackup {
	if x != nil {
		if x, ok := x.Event.(*IssueComment_TaskPriorBackup_); ok {
			return x.TaskPriorBackup
		}
	}
	return nil
}

type isIssueComment_Event interface {
	isIssueComment_Event()
}

type IssueComment_Approval_ struct {
	Approval *IssueComment_Approval `protobuf:"bytes,8,opt,name=approval,proto3,oneof"`
}

type IssueComment_IssueUpdate_ struct {
	IssueUpdate *IssueComment_IssueUpdate `protobuf:"bytes,9,opt,name=issue_update,json=issueUpdate,proto3,oneof"`
}

type IssueComment_StageEnd_ struct {
	StageEnd *IssueComment_StageEnd `protobuf:"bytes,10,opt,name=stage_end,json=stageEnd,proto3,oneof"`
}

type IssueComment_TaskUpdate_ struct {
	TaskUpdate *IssueComment_TaskUpdate `protobuf:"bytes,11,opt,name=task_update,json=taskUpdate,proto3,oneof"`
}

type IssueComment_TaskPriorBackup_ struct {
	TaskPriorBackup *IssueComment_TaskPriorBackup `protobuf:"bytes,12,opt,name=task_prior_backup,json=taskPriorBackup,proto3,oneof"`
}

func (*IssueComment_Approval_) isIssueComment_Event() {}

func (*IssueComment_IssueUpdate_) isIssueComment_Event() {}

func (*IssueComment_StageEnd_) isIssueComment_Event() {}

func (*IssueComment_TaskUpdate_) isIssueComment_Event() {}

func (*IssueComment_TaskPriorBackup_) isIssueComment_Event() {}

type Issue_Approver struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The new status.
	Status Issue_Approver_Status `protobuf:"varint,1,opt,name=status,proto3,enum=bytebase.v1.Issue_Approver_Status" json:"status,omitempty"`
	// Format: users/hello@world.com
	Principal     string `protobuf:"bytes,2,opt,name=principal,proto3" json:"principal,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Issue_Approver) Reset() {
	*x = Issue_Approver{}
	mi := &file_v1_issue_service_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Issue_Approver) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Issue_Approver) ProtoMessage() {}

func (x *Issue_Approver) ProtoReflect() protoreflect.Message {
	mi := &file_v1_issue_service_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Issue_Approver.ProtoReflect.Descriptor instead.
func (*Issue_Approver) Descriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{12, 0}
}

func (x *Issue_Approver) GetStatus() Issue_Approver_Status {
	if x != nil {
		return x.Status
	}
	return Issue_Approver_STATUS_UNSPECIFIED
}

func (x *Issue_Approver) GetPrincipal() string {
	if x != nil {
		return x.Principal
	}
	return ""
}

type IssueComment_Approval struct {
	state         protoimpl.MessageState       `protogen:"open.v1"`
	Status        IssueComment_Approval_Status `protobuf:"varint,1,opt,name=status,proto3,enum=bytebase.v1.IssueComment_Approval_Status" json:"status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IssueComment_Approval) Reset() {
	*x = IssueComment_Approval{}
	mi := &file_v1_issue_service_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IssueComment_Approval) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IssueComment_Approval) ProtoMessage() {}

func (x *IssueComment_Approval) ProtoReflect() protoreflect.Message {
	mi := &file_v1_issue_service_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IssueComment_Approval.ProtoReflect.Descriptor instead.
func (*IssueComment_Approval) Descriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{22, 0}
}

func (x *IssueComment_Approval) GetStatus() IssueComment_Approval_Status {
	if x != nil {
		return x.Status
	}
	return IssueComment_Approval_STATUS_UNSPECIFIED
}

type IssueComment_IssueUpdate struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	FromTitle       *string                `protobuf:"bytes,1,opt,name=from_title,json=fromTitle,proto3,oneof" json:"from_title,omitempty"`
	ToTitle         *string                `protobuf:"bytes,2,opt,name=to_title,json=toTitle,proto3,oneof" json:"to_title,omitempty"`
	FromDescription *string                `protobuf:"bytes,3,opt,name=from_description,json=fromDescription,proto3,oneof" json:"from_description,omitempty"`
	ToDescription   *string                `protobuf:"bytes,4,opt,name=to_description,json=toDescription,proto3,oneof" json:"to_description,omitempty"`
	FromStatus      *IssueStatus           `protobuf:"varint,5,opt,name=from_status,json=fromStatus,proto3,enum=bytebase.v1.IssueStatus,oneof" json:"from_status,omitempty"`
	ToStatus        *IssueStatus           `protobuf:"varint,6,opt,name=to_status,json=toStatus,proto3,enum=bytebase.v1.IssueStatus,oneof" json:"to_status,omitempty"`
	FromLabels      []string               `protobuf:"bytes,9,rep,name=from_labels,json=fromLabels,proto3" json:"from_labels,omitempty"`
	ToLabels        []string               `protobuf:"bytes,10,rep,name=to_labels,json=toLabels,proto3" json:"to_labels,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *IssueComment_IssueUpdate) Reset() {
	*x = IssueComment_IssueUpdate{}
	mi := &file_v1_issue_service_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IssueComment_IssueUpdate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IssueComment_IssueUpdate) ProtoMessage() {}

func (x *IssueComment_IssueUpdate) ProtoReflect() protoreflect.Message {
	mi := &file_v1_issue_service_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IssueComment_IssueUpdate.ProtoReflect.Descriptor instead.
func (*IssueComment_IssueUpdate) Descriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{22, 1}
}

func (x *IssueComment_IssueUpdate) GetFromTitle() string {
	if x != nil && x.FromTitle != nil {
		return *x.FromTitle
	}
	return ""
}

func (x *IssueComment_IssueUpdate) GetToTitle() string {
	if x != nil && x.ToTitle != nil {
		return *x.ToTitle
	}
	return ""
}

func (x *IssueComment_IssueUpdate) GetFromDescription() string {
	if x != nil && x.FromDescription != nil {
		return *x.FromDescription
	}
	return ""
}

func (x *IssueComment_IssueUpdate) GetToDescription() string {
	if x != nil && x.ToDescription != nil {
		return *x.ToDescription
	}
	return ""
}

func (x *IssueComment_IssueUpdate) GetFromStatus() IssueStatus {
	if x != nil && x.FromStatus != nil {
		return *x.FromStatus
	}
	return IssueStatus_ISSUE_STATUS_UNSPECIFIED
}

func (x *IssueComment_IssueUpdate) GetToStatus() IssueStatus {
	if x != nil && x.ToStatus != nil {
		return *x.ToStatus
	}
	return IssueStatus_ISSUE_STATUS_UNSPECIFIED
}

func (x *IssueComment_IssueUpdate) GetFromLabels() []string {
	if x != nil {
		return x.FromLabels
	}
	return nil
}

func (x *IssueComment_IssueUpdate) GetToLabels() []string {
	if x != nil {
		return x.ToLabels
	}
	return nil
}

type IssueComment_StageEnd struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Stage         string                 `protobuf:"bytes,1,opt,name=stage,proto3" json:"stage,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IssueComment_StageEnd) Reset() {
	*x = IssueComment_StageEnd{}
	mi := &file_v1_issue_service_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IssueComment_StageEnd) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IssueComment_StageEnd) ProtoMessage() {}

func (x *IssueComment_StageEnd) ProtoReflect() protoreflect.Message {
	mi := &file_v1_issue_service_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IssueComment_StageEnd.ProtoReflect.Descriptor instead.
func (*IssueComment_StageEnd) Descriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{22, 2}
}

func (x *IssueComment_StageEnd) GetStage() string {
	if x != nil {
		return x.Stage
	}
	return ""
}

type IssueComment_TaskUpdate struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Tasks []string               `protobuf:"bytes,1,rep,name=tasks,proto3" json:"tasks,omitempty"`
	// Format: projects/{project}/sheets/{sheet}
	FromSheet *string `protobuf:"bytes,2,opt,name=from_sheet,json=fromSheet,proto3,oneof" json:"from_sheet,omitempty"`
	// Format: projects/{project}/sheets/{sheet}
	ToSheet       *string                         `protobuf:"bytes,3,opt,name=to_sheet,json=toSheet,proto3,oneof" json:"to_sheet,omitempty"`
	ToStatus      *IssueComment_TaskUpdate_Status `protobuf:"varint,6,opt,name=to_status,json=toStatus,proto3,enum=bytebase.v1.IssueComment_TaskUpdate_Status,oneof" json:"to_status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IssueComment_TaskUpdate) Reset() {
	*x = IssueComment_TaskUpdate{}
	mi := &file_v1_issue_service_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IssueComment_TaskUpdate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IssueComment_TaskUpdate) ProtoMessage() {}

func (x *IssueComment_TaskUpdate) ProtoReflect() protoreflect.Message {
	mi := &file_v1_issue_service_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IssueComment_TaskUpdate.ProtoReflect.Descriptor instead.
func (*IssueComment_TaskUpdate) Descriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{22, 3}
}

func (x *IssueComment_TaskUpdate) GetTasks() []string {
	if x != nil {
		return x.Tasks
	}
	return nil
}

func (x *IssueComment_TaskUpdate) GetFromSheet() string {
	if x != nil && x.FromSheet != nil {
		return *x.FromSheet
	}
	return ""
}

func (x *IssueComment_TaskUpdate) GetToSheet() string {
	if x != nil && x.ToSheet != nil {
		return *x.ToSheet
	}
	return ""
}

func (x *IssueComment_TaskUpdate) GetToStatus() IssueComment_TaskUpdate_Status {
	if x != nil && x.ToStatus != nil {
		return *x.ToStatus
	}
	return IssueComment_TaskUpdate_STATUS_UNSPECIFIED
}

type IssueComment_TaskPriorBackup struct {
	state         protoimpl.MessageState                `protogen:"open.v1"`
	Task          string                                `protobuf:"bytes,1,opt,name=task,proto3" json:"task,omitempty"`
	Tables        []*IssueComment_TaskPriorBackup_Table `protobuf:"bytes,2,rep,name=tables,proto3" json:"tables,omitempty"`
	OriginalLine  *int32                                `protobuf:"varint,3,opt,name=original_line,json=originalLine,proto3,oneof" json:"original_line,omitempty"`
	Database      string                                `protobuf:"bytes,4,opt,name=database,proto3" json:"database,omitempty"`
	Error         string                                `protobuf:"bytes,5,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IssueComment_TaskPriorBackup) Reset() {
	*x = IssueComment_TaskPriorBackup{}
	mi := &file_v1_issue_service_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IssueComment_TaskPriorBackup) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IssueComment_TaskPriorBackup) ProtoMessage() {}

func (x *IssueComment_TaskPriorBackup) ProtoReflect() protoreflect.Message {
	mi := &file_v1_issue_service_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IssueComment_TaskPriorBackup.ProtoReflect.Descriptor instead.
func (*IssueComment_TaskPriorBackup) Descriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{22, 4}
}

func (x *IssueComment_TaskPriorBackup) GetTask() string {
	if x != nil {
		return x.Task
	}
	return ""
}

func (x *IssueComment_TaskPriorBackup) GetTables() []*IssueComment_TaskPriorBackup_Table {
	if x != nil {
		return x.Tables
	}
	return nil
}

func (x *IssueComment_TaskPriorBackup) GetOriginalLine() int32 {
	if x != nil && x.OriginalLine != nil {
		return *x.OriginalLine
	}
	return 0
}

func (x *IssueComment_TaskPriorBackup) GetDatabase() string {
	if x != nil {
		return x.Database
	}
	return ""
}

func (x *IssueComment_TaskPriorBackup) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

type IssueComment_TaskPriorBackup_Table struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Schema        string                 `protobuf:"bytes,1,opt,name=schema,proto3" json:"schema,omitempty"`
	Table         string                 `protobuf:"bytes,2,opt,name=table,proto3" json:"table,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IssueComment_TaskPriorBackup_Table) Reset() {
	*x = IssueComment_TaskPriorBackup_Table{}
	mi := &file_v1_issue_service_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IssueComment_TaskPriorBackup_Table) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IssueComment_TaskPriorBackup_Table) ProtoMessage() {}

func (x *IssueComment_TaskPriorBackup_Table) ProtoReflect() protoreflect.Message {
	mi := &file_v1_issue_service_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IssueComment_TaskPriorBackup_Table.ProtoReflect.Descriptor instead.
func (*IssueComment_TaskPriorBackup_Table) Descriptor() ([]byte, []int) {
	return file_v1_issue_service_proto_rawDescGZIP(), []int{22, 4, 0}
}

func (x *IssueComment_TaskPriorBackup_Table) GetSchema() string {
	if x != nil {
		return x.Schema
	}
	return ""
}

func (x *IssueComment_TaskPriorBackup_Table) GetTable() string {
	if x != nil {
		return x.Table
	}
	return ""
}

var File_v1_issue_service_proto protoreflect.FileDescriptor

const file_v1_issue_service_proto_rawDesc = "" +
	"\n" +
	"\x16v1/issue_service.proto\x12\vbytebase.v1\x1a\x1cgoogle/api/annotations.proto\x1a\x17google/api/client.proto\x1a\x1fgoogle/api/field_behavior.proto\x1a\x19google/api/resource.proto\x1a\x1egoogle/protobuf/duration.proto\x1a google/protobuf/field_mask.proto\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x16google/type/expr.proto\x1a\x13v1/annotation.proto\"W\n" +
	"\x0fGetIssueRequest\x12.\n" +
	"\x04name\x18\x01 \x01(\tB\x1a\xe0A\x02\xfaA\x14\n" +
	"\x12bytebase.com/IssueR\x04name\x12\x14\n" +
	"\x05force\x18\x02 \x01(\bR\x05force\"y\n" +
	"\x12CreateIssueRequest\x124\n" +
	"\x06parent\x18\x01 \x01(\tB\x1c\xe0A\x02\xfaA\x16\n" +
	"\x14bytebase.com/ProjectR\x06parent\x12-\n" +
	"\x05issue\x18\x02 \x01(\v2\x12.bytebase.v1.IssueB\x03\xe0A\x02R\x05issue\"\xb3\x01\n" +
	"\x11ListIssuesRequest\x124\n" +
	"\x06parent\x18\x01 \x01(\tB\x1c\xe0A\x02\xfaA\x16\n" +
	"\x14bytebase.com/ProjectR\x06parent\x12\x1b\n" +
	"\tpage_size\x18\x02 \x01(\x05R\bpageSize\x12\x1d\n" +
	"\n" +
	"page_token\x18\x03 \x01(\tR\tpageToken\x12\x16\n" +
	"\x06filter\x18\x04 \x01(\tR\x06filter\x12\x14\n" +
	"\x05query\x18\x05 \x01(\tR\x05query\"h\n" +
	"\x12ListIssuesResponse\x12*\n" +
	"\x06issues\x18\x01 \x03(\v2\x12.bytebase.v1.IssueR\x06issues\x12&\n" +
	"\x0fnext_page_token\x18\x02 \x01(\tR\rnextPageToken\"\x9c\x01\n" +
	"\x13SearchIssuesRequest\x12\x1b\n" +
	"\x06parent\x18\x01 \x01(\tB\x03\xe0A\x02R\x06parent\x12\x1b\n" +
	"\tpage_size\x18\x02 \x01(\x05R\bpageSize\x12\x1d\n" +
	"\n" +
	"page_token\x18\x03 \x01(\tR\tpageToken\x12\x16\n" +
	"\x06filter\x18\x04 \x01(\tR\x06filter\x12\x14\n" +
	"\x05query\x18\x05 \x01(\tR\x05query\"j\n" +
	"\x14SearchIssuesResponse\x12*\n" +
	"\x06issues\x18\x01 \x03(\v2\x12.bytebase.v1.IssueR\x06issues\x12&\n" +
	"\x0fnext_page_token\x18\x02 \x01(\tR\rnextPageToken\"\x9c\x01\n" +
	"\x12UpdateIssueRequest\x12D\n" +
	"\x05issue\x18\x01 \x01(\v2\x12.bytebase.v1.IssueB\x1a\xe0A\x02\xfaA\x14\n" +
	"\x12bytebase.com/IssueR\x05issue\x12@\n" +
	"\vupdate_mask\x18\x02 \x01(\v2\x1a.google.protobuf.FieldMaskB\x03\xe0A\x02R\n" +
	"updateMask\"\xb8\x01\n" +
	"\x1eBatchUpdateIssuesStatusRequest\x124\n" +
	"\x06parent\x18\x01 \x01(\tB\x1c\xe0A\x02\xfaA\x16\n" +
	"\x14bytebase.com/ProjectR\x06parent\x12\x16\n" +
	"\x06issues\x18\x02 \x03(\tR\x06issues\x120\n" +
	"\x06status\x18\x03 \x01(\x0e2\x18.bytebase.v1.IssueStatusR\x06status\x12\x16\n" +
	"\x06reason\x18\x04 \x01(\tR\x06reason\"!\n" +
	"\x1fBatchUpdateIssuesStatusResponse\"_\n" +
	"\x13ApproveIssueRequest\x12.\n" +
	"\x04name\x18\x01 \x01(\tB\x1a\xe0A\x02\xfaA\x14\n" +
	"\x12bytebase.com/IssueR\x04name\x12\x18\n" +
	"\acomment\x18\x02 \x01(\tR\acomment\"^\n" +
	"\x12RejectIssueRequest\x12.\n" +
	"\x04name\x18\x01 \x01(\tB\x1a\xe0A\x02\xfaA\x14\n" +
	"\x12bytebase.com/IssueR\x04name\x12\x18\n" +
	"\acomment\x18\x02 \x01(\tR\acomment\"_\n" +
	"\x13RequestIssueRequest\x12.\n" +
	"\x04name\x18\x01 \x01(\tB\x1a\xe0A\x02\xfaA\x14\n" +
	"\x12bytebase.com/IssueR\x04name\x12\x18\n" +
	"\acomment\x18\x02 \x01(\tR\acomment\"\xe7\n" +
	"\n" +
	"\x05Issue\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x14\n" +
	"\x05title\x18\x03 \x01(\tR\x05title\x12 \n" +
	"\vdescription\x18\x04 \x01(\tR\vdescription\x12+\n" +
	"\x04type\x18\x05 \x01(\x0e2\x17.bytebase.v1.Issue.TypeR\x04type\x120\n" +
	"\x06status\x18\x06 \x01(\x0e2\x18.bytebase.v1.IssueStatusR\x06status\x129\n" +
	"\tapprovers\x18\t \x03(\v2\x1b.bytebase.v1.Issue.ApproverR\tapprovers\x12L\n" +
	"\x12approval_templates\x18\n" +
	" \x03(\v2\x1d.bytebase.v1.ApprovalTemplateR\x11approvalTemplates\x122\n" +
	"\x15approval_finding_done\x18\v \x01(\bR\x13approvalFindingDone\x124\n" +
	"\x16approval_finding_error\x18\f \x01(\tR\x14approvalFindingError\x12\x1d\n" +
	"\acreator\x18\x0e \x01(\tB\x03\xe0A\x03R\acreator\x12@\n" +
	"\vcreate_time\x18\x0f \x01(\v2\x1a.google.protobuf.TimestampB\x03\xe0A\x03R\n" +
	"createTime\x12@\n" +
	"\vupdate_time\x18\x10 \x01(\v2\x1a.google.protobuf.TimestampB\x03\xe0A\x03R\n" +
	"updateTime\x12\x12\n" +
	"\x04plan\x18\x11 \x01(\tR\x04plan\x12\x18\n" +
	"\arollout\x18\x12 \x01(\tR\arollout\x12>\n" +
	"\rgrant_request\x18\x13 \x01(\v2\x19.bytebase.v1.GrantRequestR\fgrantRequest\x12\x1c\n" +
	"\treleasers\x18\x14 \x03(\tR\treleasers\x12;\n" +
	"\n" +
	"risk_level\x18\x15 \x01(\x0e2\x1c.bytebase.v1.Issue.RiskLevelR\triskLevel\x12S\n" +
	"\x11task_status_count\x18\x16 \x03(\v2'.bytebase.v1.Issue.TaskStatusCountEntryR\x0ftaskStatusCount\x12\x16\n" +
	"\x06labels\x18\x17 \x03(\tR\x06labels\x1a\xaf\x01\n" +
	"\bApprover\x12:\n" +
	"\x06status\x18\x01 \x01(\x0e2\".bytebase.v1.Issue.Approver.StatusR\x06status\x12\x1c\n" +
	"\tprincipal\x18\x02 \x01(\tR\tprincipal\"I\n" +
	"\x06Status\x12\x16\n" +
	"\x12STATUS_UNSPECIFIED\x10\x00\x12\v\n" +
	"\aPENDING\x10\x01\x12\f\n" +
	"\bAPPROVED\x10\x02\x12\f\n" +
	"\bREJECTED\x10\x03\x1aB\n" +
	"\x14TaskStatusCountEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\x05R\x05value:\x028\x01\"Y\n" +
	"\x04Type\x12\x14\n" +
	"\x10TYPE_UNSPECIFIED\x10\x00\x12\x13\n" +
	"\x0fDATABASE_CHANGE\x10\x01\x12\x11\n" +
	"\rGRANT_REQUEST\x10\x02\x12\x13\n" +
	"\x0fDATABASE_EXPORT\x10\x03\"H\n" +
	"\tRiskLevel\x12\x1a\n" +
	"\x16RISK_LEVEL_UNSPECIFIED\x10\x00\x12\a\n" +
	"\x03LOW\x10\x01\x12\f\n" +
	"\bMODERATE\x10\x02\x12\b\n" +
	"\x04HIGH\x10\x03::\xeaA7\n" +
	"\x12bytebase.com/Issue\x12!projects/{project}/issues/{issue}J\x04\b\x02\x10\x03J\x04\b\a\x10\bJ\x04\b\b\x10\t\"\xa2\x01\n" +
	"\fGrantRequest\x12\x12\n" +
	"\x04role\x18\x01 \x01(\tR\x04role\x12\x12\n" +
	"\x04user\x18\x02 \x01(\tR\x04user\x12/\n" +
	"\tcondition\x18\x03 \x01(\v2\x11.google.type.ExprR\tcondition\x129\n" +
	"\n" +
	"expiration\x18\x04 \x01(\v2\x19.google.protobuf.DurationR\n" +
	"expiration\"y\n" +
	"\x10ApprovalTemplate\x12-\n" +
	"\x04flow\x18\x01 \x01(\v2\x19.bytebase.v1.ApprovalFlowR\x04flow\x12\x14\n" +
	"\x05title\x18\x02 \x01(\tR\x05title\x12 \n" +
	"\vdescription\x18\x03 \x01(\tR\vdescription\"?\n" +
	"\fApprovalFlow\x12/\n" +
	"\x05steps\x18\x01 \x03(\v2\x19.bytebase.v1.ApprovalStepR\x05steps\"\xa3\x01\n" +
	"\fApprovalStep\x122\n" +
	"\x04type\x18\x01 \x01(\x0e2\x1e.bytebase.v1.ApprovalStep.TypeR\x04type\x12/\n" +
	"\x05nodes\x18\x02 \x03(\v2\x19.bytebase.v1.ApprovalNodeR\x05nodes\".\n" +
	"\x04Type\x12\x14\n" +
	"\x10TYPE_UNSPECIFIED\x10\x00\x12\a\n" +
	"\x03ALL\x10\x01\x12\a\n" +
	"\x03ANY\x10\x02\"\x86\x01\n" +
	"\fApprovalNode\x122\n" +
	"\x04type\x18\x01 \x01(\x0e2\x1e.bytebase.v1.ApprovalNode.TypeR\x04type\x12\x12\n" +
	"\x04role\x18\x02 \x01(\tR\x04role\".\n" +
	"\x04Type\x12\x14\n" +
	"\x10TYPE_UNSPECIFIED\x10\x00\x12\x10\n" +
	"\fANY_IN_GROUP\x10\x01\"\x8a\x01\n" +
	"\x18ListIssueCommentsRequest\x122\n" +
	"\x06parent\x18\x01 \x01(\tB\x1a\xe0A\x02\xfaA\x14\n" +
	"\x12bytebase.com/IssueR\x06parent\x12\x1b\n" +
	"\tpage_size\x18\x02 \x01(\x05R\bpageSize\x12\x1d\n" +
	"\n" +
	"page_token\x18\x03 \x01(\tR\tpageToken\"\x85\x01\n" +
	"\x19ListIssueCommentsResponse\x12@\n" +
	"\x0eissue_comments\x18\x01 \x03(\v2\x19.bytebase.v1.IssueCommentR\rissueComments\x12&\n" +
	"\x0fnext_page_token\x18\x02 \x01(\tR\rnextPageToken\"\x8f\x01\n" +
	"\x19CreateIssueCommentRequest\x122\n" +
	"\x06parent\x18\x01 \x01(\tB\x1a\xe0A\x02\xfaA\x14\n" +
	"\x12bytebase.com/IssueR\x06parent\x12>\n" +
	"\rissue_comment\x18\x02 \x01(\v2\x19.bytebase.v1.IssueCommentR\fissueComment\"\xd1\x01\n" +
	"\x19UpdateIssueCommentRequest\x122\n" +
	"\x06parent\x18\x01 \x01(\tB\x1a\xe0A\x02\xfaA\x14\n" +
	"\x12bytebase.com/IssueR\x06parent\x12>\n" +
	"\rissue_comment\x18\x02 \x01(\v2\x19.bytebase.v1.IssueCommentR\fissueComment\x12@\n" +
	"\vupdate_mask\x18\x03 \x01(\v2\x1a.google.protobuf.FieldMaskB\x03\xe0A\x02R\n" +
	"updateMask\"\xf5\x0e\n" +
	"\fIssueComment\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x18\n" +
	"\acomment\x18\x02 \x01(\tR\acomment\x12\x18\n" +
	"\apayload\x18\x03 \x01(\tR\apayload\x12@\n" +
	"\vcreate_time\x18\x04 \x01(\v2\x1a.google.protobuf.TimestampB\x03\xe0A\x03R\n" +
	"createTime\x12@\n" +
	"\vupdate_time\x18\x05 \x01(\v2\x1a.google.protobuf.TimestampB\x03\xe0A\x03R\n" +
	"updateTime\x12\x1d\n" +
	"\acreator\x18\a \x01(\tB\x03\xe0A\x03R\acreator\x12@\n" +
	"\bapproval\x18\b \x01(\v2\".bytebase.v1.IssueComment.ApprovalH\x00R\bapproval\x12J\n" +
	"\fissue_update\x18\t \x01(\v2%.bytebase.v1.IssueComment.IssueUpdateH\x00R\vissueUpdate\x12A\n" +
	"\tstage_end\x18\n" +
	" \x01(\v2\".bytebase.v1.IssueComment.StageEndH\x00R\bstageEnd\x12G\n" +
	"\vtask_update\x18\v \x01(\v2$.bytebase.v1.IssueComment.TaskUpdateH\x00R\n" +
	"taskUpdate\x12W\n" +
	"\x11task_prior_backup\x18\f \x01(\v2).bytebase.v1.IssueComment.TaskPriorBackupH\x00R\x0ftaskPriorBackup\x1a\x98\x01\n" +
	"\bApproval\x12A\n" +
	"\x06status\x18\x01 \x01(\x0e2).bytebase.v1.IssueComment.Approval.StatusR\x06status\"I\n" +
	"\x06Status\x12\x16\n" +
	"\x12STATUS_UNSPECIFIED\x10\x00\x12\v\n" +
	"\aPENDING\x10\x01\x12\f\n" +
	"\bAPPROVED\x10\x02\x12\f\n" +
	"\bREJECTED\x10\x03\x1a\xd5\x03\n" +
	"\vIssueUpdate\x12\"\n" +
	"\n" +
	"from_title\x18\x01 \x01(\tH\x00R\tfromTitle\x88\x01\x01\x12\x1e\n" +
	"\bto_title\x18\x02 \x01(\tH\x01R\atoTitle\x88\x01\x01\x12.\n" +
	"\x10from_description\x18\x03 \x01(\tH\x02R\x0ffromDescription\x88\x01\x01\x12*\n" +
	"\x0eto_description\x18\x04 \x01(\tH\x03R\rtoDescription\x88\x01\x01\x12>\n" +
	"\vfrom_status\x18\x05 \x01(\x0e2\x18.bytebase.v1.IssueStatusH\x04R\n" +
	"fromStatus\x88\x01\x01\x12:\n" +
	"\tto_status\x18\x06 \x01(\x0e2\x18.bytebase.v1.IssueStatusH\x05R\btoStatus\x88\x01\x01\x12\x1f\n" +
	"\vfrom_labels\x18\t \x03(\tR\n" +
	"fromLabels\x12\x1b\n" +
	"\tto_labels\x18\n" +
	" \x03(\tR\btoLabelsB\r\n" +
	"\v_from_titleB\v\n" +
	"\t_to_titleB\x13\n" +
	"\x11_from_descriptionB\x11\n" +
	"\x0f_to_descriptionB\x0e\n" +
	"\f_from_statusB\f\n" +
	"\n" +
	"_to_statusJ\x04\b\a\x10\bJ\x04\b\b\x10\t\x1a \n" +
	"\bStageEnd\x12\x14\n" +
	"\x05stage\x18\x01 \x01(\tR\x05stage\x1a\xcc\x02\n" +
	"\n" +
	"TaskUpdate\x12\x14\n" +
	"\x05tasks\x18\x01 \x03(\tR\x05tasks\x12\"\n" +
	"\n" +
	"from_sheet\x18\x02 \x01(\tH\x00R\tfromSheet\x88\x01\x01\x12\x1e\n" +
	"\bto_sheet\x18\x03 \x01(\tH\x01R\atoSheet\x88\x01\x01\x12M\n" +
	"\tto_status\x18\x06 \x01(\x0e2+.bytebase.v1.IssueComment.TaskUpdate.StatusH\x02R\btoStatus\x88\x01\x01\"k\n" +
	"\x06Status\x12\x16\n" +
	"\x12STATUS_UNSPECIFIED\x10\x00\x12\v\n" +
	"\aPENDING\x10\x01\x12\v\n" +
	"\aRUNNING\x10\x02\x12\b\n" +
	"\x04DONE\x10\x03\x12\n" +
	"\n" +
	"\x06FAILED\x10\x04\x12\v\n" +
	"\aSKIPPED\x10\x05\x12\f\n" +
	"\bCANCELED\x10\x06B\r\n" +
	"\v_from_sheetB\v\n" +
	"\t_to_sheetB\f\n" +
	"\n" +
	"_to_status\x1a\x93\x02\n" +
	"\x0fTaskPriorBackup\x12\x12\n" +
	"\x04task\x18\x01 \x01(\tR\x04task\x12G\n" +
	"\x06tables\x18\x02 \x03(\v2/.bytebase.v1.IssueComment.TaskPriorBackup.TableR\x06tables\x12(\n" +
	"\roriginal_line\x18\x03 \x01(\x05H\x00R\foriginalLine\x88\x01\x01\x12\x1a\n" +
	"\bdatabase\x18\x04 \x01(\tR\bdatabase\x12\x14\n" +
	"\x05error\x18\x05 \x01(\tR\x05error\x1a5\n" +
	"\x05Table\x12\x16\n" +
	"\x06schema\x18\x01 \x01(\tR\x06schema\x12\x14\n" +
	"\x05table\x18\x02 \x01(\tR\x05tableB\x10\n" +
	"\x0e_original_lineB\a\n" +
	"\x05eventJ\x04\b\x06\x10\a*M\n" +
	"\vIssueStatus\x12\x1c\n" +
	"\x18ISSUE_STATUS_UNSPECIFIED\x10\x00\x12\b\n" +
	"\x04OPEN\x10\x01\x12\b\n" +
	"\x04DONE\x10\x02\x12\f\n" +
	"\bCANCELED\x10\x032\xd8\x0f\n" +
	"\fIssueService\x12\x80\x01\n" +
	"\bGetIssue\x12\x1c.bytebase.v1.GetIssueRequest\x1a\x12.bytebase.v1.Issue\"B\xdaA\x04name\x8a\xea0\rbb.issues.get\x90\xea0\x01\x82\xd3\xe4\x93\x02 \x12\x1e/v1/{name=projects/*/issues/*}\x12\x9c\x01\n" +
	"\vCreateIssue\x12\x1f.bytebase.v1.CreateIssueRequest\x1a\x12.bytebase.v1.Issue\"X\xdaA\fparent,issue\x8a\xea0\x10bb.issues.create\x90\xea0\x01\x98\xea0\x01\x82\xd3\xe4\x93\x02':\x05issue\"\x1e/v1/{parent=projects/*}/issues\x12\x94\x01\n" +
	"\n" +
	"ListIssues\x12\x1e.bytebase.v1.ListIssuesRequest\x1a\x1f.bytebase.v1.ListIssuesResponse\"E\xdaA\x06parent\x8a\xea0\x0ebb.issues.list\x90\xea0\x01\x82\xd3\xe4\x93\x02 \x12\x1e/v1/{parent=projects/*}/issues\x12\x9a\x01\n" +
	"\fSearchIssues\x12 .bytebase.v1.SearchIssuesRequest\x1a!.bytebase.v1.SearchIssuesResponse\"E\x8a\xea0\rbb.issues.get\x90\xea0\x02\x82\xd3\xe4\x93\x02*:\x01*\"%/v1/{parent=projects/*}/issues:search\x12\xa7\x01\n" +
	"\vUpdateIssue\x12\x1f.bytebase.v1.UpdateIssueRequest\x1a\x12.bytebase.v1.Issue\"c\xdaA\x11issue,update_mask\x8a\xea0\x10bb.issues.update\x90\xea0\x01\x98\xea0\x01\x82\xd3\xe4\x93\x02-:\x05issue2$/v1/{issue.name=projects/*/issues/*}\x12\xc0\x01\n" +
	"\x11ListIssueComments\x12%.bytebase.v1.ListIssueCommentsRequest\x1a&.bytebase.v1.ListIssueCommentsResponse\"\\\xdaA\x06parent\x8a\xea0\x15bb.issueComments.list\x90\xea0\x01\x82\xd3\xe4\x93\x020\x12./v1/{parent=projects/*/issues/*}/issueComments\x12\xd2\x01\n" +
	"\x12CreateIssueComment\x12&.bytebase.v1.CreateIssueCommentRequest\x1a\x19.bytebase.v1.IssueComment\"y\xdaA\x14parent,issue_comment\x8a\xea0\x17bb.issueComments.create\x90\xea0\x01\x98\xea0\x01\x82\xd3\xe4\x93\x029:\rissue_comment\"(/v1/{parent=projects/*/issues/*}:comment\x12\xdf\x01\n" +
	"\x12UpdateIssueComment\x12&.bytebase.v1.UpdateIssueCommentRequest\x1a\x19.bytebase.v1.IssueComment\"\x85\x01\xdaA parent,issue_comment,update_mask\x8a\xea0\x17bb.issueComments.update\x90\xea0\x01\x98\xea0\x01\x82\xd3\xe4\x93\x029:\rissue_comment2(/v1/{parent=projects/*/issues/*}:comment\x12\xcd\x01\n" +
	"\x17BatchUpdateIssuesStatus\x12+.bytebase.v1.BatchUpdateIssuesStatusRequest\x1a,.bytebase.v1.BatchUpdateIssuesStatusResponse\"W\x8a\xea0\x10bb.issues.update\x90\xea0\x01\x98\xea0\x01\x82\xd3\xe4\x93\x025:\x01*\"0/v1/{parent=projects/*}/issues:batchUpdateStatus\x12\x7f\n" +
	"\fApproveIssue\x12 .bytebase.v1.ApproveIssueRequest\x1a\x12.bytebase.v1.Issue\"9\x90\xea0\x02\x98\xea0\x01\x82\xd3\xe4\x93\x02+:\x01*\"&/v1/{name=projects/*/issues/*}:approve\x12|\n" +
	"\vRejectIssue\x12\x1f.bytebase.v1.RejectIssueRequest\x1a\x12.bytebase.v1.Issue\"8\x90\xea0\x02\x98\xea0\x01\x82\xd3\xe4\x93\x02*:\x01*\"%/v1/{name=projects/*/issues/*}:reject\x12\x7f\n" +
	"\fRequestIssue\x12 .bytebase.v1.RequestIssueRequest\x1a\x12.bytebase.v1.Issue\"9\x90\xea0\x02\x98\xea0\x01\x82\xd3\xe4\x93\x02+:\x01*\"&/v1/{name=projects/*/issues/*}:requestB6Z4github.com/bytebase/bytebase/backend/generated-go/v1b\x06proto3"

var (
	file_v1_issue_service_proto_rawDescOnce sync.Once
	file_v1_issue_service_proto_rawDescData []byte
)

func file_v1_issue_service_proto_rawDescGZIP() []byte {
	file_v1_issue_service_proto_rawDescOnce.Do(func() {
		file_v1_issue_service_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_v1_issue_service_proto_rawDesc), len(file_v1_issue_service_proto_rawDesc)))
	})
	return file_v1_issue_service_proto_rawDescData
}

var file_v1_issue_service_proto_enumTypes = make([]protoimpl.EnumInfo, 8)
var file_v1_issue_service_proto_msgTypes = make([]protoimpl.MessageInfo, 31)
var file_v1_issue_service_proto_goTypes = []any{
	(IssueStatus)(0),                           // 0: bytebase.v1.IssueStatus
	(Issue_Type)(0),                            // 1: bytebase.v1.Issue.Type
	(Issue_RiskLevel)(0),                       // 2: bytebase.v1.Issue.RiskLevel
	(Issue_Approver_Status)(0),                 // 3: bytebase.v1.Issue.Approver.Status
	(ApprovalStep_Type)(0),                     // 4: bytebase.v1.ApprovalStep.Type
	(ApprovalNode_Type)(0),                     // 5: bytebase.v1.ApprovalNode.Type
	(IssueComment_Approval_Status)(0),          // 6: bytebase.v1.IssueComment.Approval.Status
	(IssueComment_TaskUpdate_Status)(0),        // 7: bytebase.v1.IssueComment.TaskUpdate.Status
	(*GetIssueRequest)(nil),                    // 8: bytebase.v1.GetIssueRequest
	(*CreateIssueRequest)(nil),                 // 9: bytebase.v1.CreateIssueRequest
	(*ListIssuesRequest)(nil),                  // 10: bytebase.v1.ListIssuesRequest
	(*ListIssuesResponse)(nil),                 // 11: bytebase.v1.ListIssuesResponse
	(*SearchIssuesRequest)(nil),                // 12: bytebase.v1.SearchIssuesRequest
	(*SearchIssuesResponse)(nil),               // 13: bytebase.v1.SearchIssuesResponse
	(*UpdateIssueRequest)(nil),                 // 14: bytebase.v1.UpdateIssueRequest
	(*BatchUpdateIssuesStatusRequest)(nil),     // 15: bytebase.v1.BatchUpdateIssuesStatusRequest
	(*BatchUpdateIssuesStatusResponse)(nil),    // 16: bytebase.v1.BatchUpdateIssuesStatusResponse
	(*ApproveIssueRequest)(nil),                // 17: bytebase.v1.ApproveIssueRequest
	(*RejectIssueRequest)(nil),                 // 18: bytebase.v1.RejectIssueRequest
	(*RequestIssueRequest)(nil),                // 19: bytebase.v1.RequestIssueRequest
	(*Issue)(nil),                              // 20: bytebase.v1.Issue
	(*GrantRequest)(nil),                       // 21: bytebase.v1.GrantRequest
	(*ApprovalTemplate)(nil),                   // 22: bytebase.v1.ApprovalTemplate
	(*ApprovalFlow)(nil),                       // 23: bytebase.v1.ApprovalFlow
	(*ApprovalStep)(nil),                       // 24: bytebase.v1.ApprovalStep
	(*ApprovalNode)(nil),                       // 25: bytebase.v1.ApprovalNode
	(*ListIssueCommentsRequest)(nil),           // 26: bytebase.v1.ListIssueCommentsRequest
	(*ListIssueCommentsResponse)(nil),          // 27: bytebase.v1.ListIssueCommentsResponse
	(*CreateIssueCommentRequest)(nil),          // 28: bytebase.v1.CreateIssueCommentRequest
	(*UpdateIssueCommentRequest)(nil),          // 29: bytebase.v1.UpdateIssueCommentRequest
	(*IssueComment)(nil),                       // 30: bytebase.v1.IssueComment
	(*Issue_Approver)(nil),                     // 31: bytebase.v1.Issue.Approver
	nil,                                        // 32: bytebase.v1.Issue.TaskStatusCountEntry
	(*IssueComment_Approval)(nil),              // 33: bytebase.v1.IssueComment.Approval
	(*IssueComment_IssueUpdate)(nil),           // 34: bytebase.v1.IssueComment.IssueUpdate
	(*IssueComment_StageEnd)(nil),              // 35: bytebase.v1.IssueComment.StageEnd
	(*IssueComment_TaskUpdate)(nil),            // 36: bytebase.v1.IssueComment.TaskUpdate
	(*IssueComment_TaskPriorBackup)(nil),       // 37: bytebase.v1.IssueComment.TaskPriorBackup
	(*IssueComment_TaskPriorBackup_Table)(nil), // 38: bytebase.v1.IssueComment.TaskPriorBackup.Table
	(*fieldmaskpb.FieldMask)(nil),              // 39: google.protobuf.FieldMask
	(*timestamppb.Timestamp)(nil),              // 40: google.protobuf.Timestamp
	(*expr.Expr)(nil),                          // 41: google.type.Expr
	(*durationpb.Duration)(nil),                // 42: google.protobuf.Duration
}
var file_v1_issue_service_proto_depIdxs = []int32{
	20, // 0: bytebase.v1.CreateIssueRequest.issue:type_name -> bytebase.v1.Issue
	20, // 1: bytebase.v1.ListIssuesResponse.issues:type_name -> bytebase.v1.Issue
	20, // 2: bytebase.v1.SearchIssuesResponse.issues:type_name -> bytebase.v1.Issue
	20, // 3: bytebase.v1.UpdateIssueRequest.issue:type_name -> bytebase.v1.Issue
	39, // 4: bytebase.v1.UpdateIssueRequest.update_mask:type_name -> google.protobuf.FieldMask
	0,  // 5: bytebase.v1.BatchUpdateIssuesStatusRequest.status:type_name -> bytebase.v1.IssueStatus
	1,  // 6: bytebase.v1.Issue.type:type_name -> bytebase.v1.Issue.Type
	0,  // 7: bytebase.v1.Issue.status:type_name -> bytebase.v1.IssueStatus
	31, // 8: bytebase.v1.Issue.approvers:type_name -> bytebase.v1.Issue.Approver
	22, // 9: bytebase.v1.Issue.approval_templates:type_name -> bytebase.v1.ApprovalTemplate
	40, // 10: bytebase.v1.Issue.create_time:type_name -> google.protobuf.Timestamp
	40, // 11: bytebase.v1.Issue.update_time:type_name -> google.protobuf.Timestamp
	21, // 12: bytebase.v1.Issue.grant_request:type_name -> bytebase.v1.GrantRequest
	2,  // 13: bytebase.v1.Issue.risk_level:type_name -> bytebase.v1.Issue.RiskLevel
	32, // 14: bytebase.v1.Issue.task_status_count:type_name -> bytebase.v1.Issue.TaskStatusCountEntry
	41, // 15: bytebase.v1.GrantRequest.condition:type_name -> google.type.Expr
	42, // 16: bytebase.v1.GrantRequest.expiration:type_name -> google.protobuf.Duration
	23, // 17: bytebase.v1.ApprovalTemplate.flow:type_name -> bytebase.v1.ApprovalFlow
	24, // 18: bytebase.v1.ApprovalFlow.steps:type_name -> bytebase.v1.ApprovalStep
	4,  // 19: bytebase.v1.ApprovalStep.type:type_name -> bytebase.v1.ApprovalStep.Type
	25, // 20: bytebase.v1.ApprovalStep.nodes:type_name -> bytebase.v1.ApprovalNode
	5,  // 21: bytebase.v1.ApprovalNode.type:type_name -> bytebase.v1.ApprovalNode.Type
	30, // 22: bytebase.v1.ListIssueCommentsResponse.issue_comments:type_name -> bytebase.v1.IssueComment
	30, // 23: bytebase.v1.CreateIssueCommentRequest.issue_comment:type_name -> bytebase.v1.IssueComment
	30, // 24: bytebase.v1.UpdateIssueCommentRequest.issue_comment:type_name -> bytebase.v1.IssueComment
	39, // 25: bytebase.v1.UpdateIssueCommentRequest.update_mask:type_name -> google.protobuf.FieldMask
	40, // 26: bytebase.v1.IssueComment.create_time:type_name -> google.protobuf.Timestamp
	40, // 27: bytebase.v1.IssueComment.update_time:type_name -> google.protobuf.Timestamp
	33, // 28: bytebase.v1.IssueComment.approval:type_name -> bytebase.v1.IssueComment.Approval
	34, // 29: bytebase.v1.IssueComment.issue_update:type_name -> bytebase.v1.IssueComment.IssueUpdate
	35, // 30: bytebase.v1.IssueComment.stage_end:type_name -> bytebase.v1.IssueComment.StageEnd
	36, // 31: bytebase.v1.IssueComment.task_update:type_name -> bytebase.v1.IssueComment.TaskUpdate
	37, // 32: bytebase.v1.IssueComment.task_prior_backup:type_name -> bytebase.v1.IssueComment.TaskPriorBackup
	3,  // 33: bytebase.v1.Issue.Approver.status:type_name -> bytebase.v1.Issue.Approver.Status
	6,  // 34: bytebase.v1.IssueComment.Approval.status:type_name -> bytebase.v1.IssueComment.Approval.Status
	0,  // 35: bytebase.v1.IssueComment.IssueUpdate.from_status:type_name -> bytebase.v1.IssueStatus
	0,  // 36: bytebase.v1.IssueComment.IssueUpdate.to_status:type_name -> bytebase.v1.IssueStatus
	7,  // 37: bytebase.v1.IssueComment.TaskUpdate.to_status:type_name -> bytebase.v1.IssueComment.TaskUpdate.Status
	38, // 38: bytebase.v1.IssueComment.TaskPriorBackup.tables:type_name -> bytebase.v1.IssueComment.TaskPriorBackup.Table
	8,  // 39: bytebase.v1.IssueService.GetIssue:input_type -> bytebase.v1.GetIssueRequest
	9,  // 40: bytebase.v1.IssueService.CreateIssue:input_type -> bytebase.v1.CreateIssueRequest
	10, // 41: bytebase.v1.IssueService.ListIssues:input_type -> bytebase.v1.ListIssuesRequest
	12, // 42: bytebase.v1.IssueService.SearchIssues:input_type -> bytebase.v1.SearchIssuesRequest
	14, // 43: bytebase.v1.IssueService.UpdateIssue:input_type -> bytebase.v1.UpdateIssueRequest
	26, // 44: bytebase.v1.IssueService.ListIssueComments:input_type -> bytebase.v1.ListIssueCommentsRequest
	28, // 45: bytebase.v1.IssueService.CreateIssueComment:input_type -> bytebase.v1.CreateIssueCommentRequest
	29, // 46: bytebase.v1.IssueService.UpdateIssueComment:input_type -> bytebase.v1.UpdateIssueCommentRequest
	15, // 47: bytebase.v1.IssueService.BatchUpdateIssuesStatus:input_type -> bytebase.v1.BatchUpdateIssuesStatusRequest
	17, // 48: bytebase.v1.IssueService.ApproveIssue:input_type -> bytebase.v1.ApproveIssueRequest
	18, // 49: bytebase.v1.IssueService.RejectIssue:input_type -> bytebase.v1.RejectIssueRequest
	19, // 50: bytebase.v1.IssueService.RequestIssue:input_type -> bytebase.v1.RequestIssueRequest
	20, // 51: bytebase.v1.IssueService.GetIssue:output_type -> bytebase.v1.Issue
	20, // 52: bytebase.v1.IssueService.CreateIssue:output_type -> bytebase.v1.Issue
	11, // 53: bytebase.v1.IssueService.ListIssues:output_type -> bytebase.v1.ListIssuesResponse
	13, // 54: bytebase.v1.IssueService.SearchIssues:output_type -> bytebase.v1.SearchIssuesResponse
	20, // 55: bytebase.v1.IssueService.UpdateIssue:output_type -> bytebase.v1.Issue
	27, // 56: bytebase.v1.IssueService.ListIssueComments:output_type -> bytebase.v1.ListIssueCommentsResponse
	30, // 57: bytebase.v1.IssueService.CreateIssueComment:output_type -> bytebase.v1.IssueComment
	30, // 58: bytebase.v1.IssueService.UpdateIssueComment:output_type -> bytebase.v1.IssueComment
	16, // 59: bytebase.v1.IssueService.BatchUpdateIssuesStatus:output_type -> bytebase.v1.BatchUpdateIssuesStatusResponse
	20, // 60: bytebase.v1.IssueService.ApproveIssue:output_type -> bytebase.v1.Issue
	20, // 61: bytebase.v1.IssueService.RejectIssue:output_type -> bytebase.v1.Issue
	20, // 62: bytebase.v1.IssueService.RequestIssue:output_type -> bytebase.v1.Issue
	51, // [51:63] is the sub-list for method output_type
	39, // [39:51] is the sub-list for method input_type
	39, // [39:39] is the sub-list for extension type_name
	39, // [39:39] is the sub-list for extension extendee
	0,  // [0:39] is the sub-list for field type_name
}

func init() { file_v1_issue_service_proto_init() }
func file_v1_issue_service_proto_init() {
	if File_v1_issue_service_proto != nil {
		return
	}
	file_v1_annotation_proto_init()
	file_v1_issue_service_proto_msgTypes[22].OneofWrappers = []any{
		(*IssueComment_Approval_)(nil),
		(*IssueComment_IssueUpdate_)(nil),
		(*IssueComment_StageEnd_)(nil),
		(*IssueComment_TaskUpdate_)(nil),
		(*IssueComment_TaskPriorBackup_)(nil),
	}
	file_v1_issue_service_proto_msgTypes[26].OneofWrappers = []any{}
	file_v1_issue_service_proto_msgTypes[28].OneofWrappers = []any{}
	file_v1_issue_service_proto_msgTypes[29].OneofWrappers = []any{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_v1_issue_service_proto_rawDesc), len(file_v1_issue_service_proto_rawDesc)),
			NumEnums:      8,
			NumMessages:   31,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_v1_issue_service_proto_goTypes,
		DependencyIndexes: file_v1_issue_service_proto_depIdxs,
		EnumInfos:         file_v1_issue_service_proto_enumTypes,
		MessageInfos:      file_v1_issue_service_proto_msgTypes,
	}.Build()
	File_v1_issue_service_proto = out.File
	file_v1_issue_service_proto_goTypes = nil
	file_v1_issue_service_proto_depIdxs = nil
}
