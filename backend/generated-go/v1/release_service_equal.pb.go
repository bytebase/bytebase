// Code generated by protoc-gen-equal-go. DO NOT EDIT.
// source: v1/release_service.proto

package v1

import (
	proto "google.golang.org/protobuf/proto"
	fieldmaskpb "google.golang.org/protobuf/types/known/fieldmaskpb"
)

func (x *GetReleaseRequest) Equal(y *GetReleaseRequest) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	return true
}

func (x *ListReleasesRequest) Equal(y *ListReleasesRequest) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Parent != y.Parent {
		return false
	}
	if x.PageSize != y.PageSize {
		return false
	}
	if x.PageToken != y.PageToken {
		return false
	}
	if x.ShowDeleted != y.ShowDeleted {
		return false
	}
	return true
}

func (x *ListReleasesResponse) Equal(y *ListReleasesResponse) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if len(x.Releases) != len(y.Releases) {
		return false
	}
	for i := 0; i < len(x.Releases); i++ {
		if !x.Releases[i].Equal(y.Releases[i]) {
			return false
		}
	}
	if x.NextPageToken != y.NextPageToken {
		return false
	}
	return true
}

func (x *SearchReleasesRequest) Equal(y *SearchReleasesRequest) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Parent != y.Parent {
		return false
	}
	if x.PageSize != y.PageSize {
		return false
	}
	if x.PageToken != y.PageToken {
		return false
	}
	if p, q := x.Digest, y.Digest; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	return true
}

func (x *SearchReleasesResponse) Equal(y *SearchReleasesResponse) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if len(x.Releases) != len(y.Releases) {
		return false
	}
	for i := 0; i < len(x.Releases); i++ {
		if !x.Releases[i].Equal(y.Releases[i]) {
			return false
		}
	}
	if x.NextPageToken != y.NextPageToken {
		return false
	}
	return true
}

func (x *CreateReleaseRequest) Equal(y *CreateReleaseRequest) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Parent != y.Parent {
		return false
	}
	if !x.Release.Equal(y.Release) {
		return false
	}
	return true
}

func (x *UpdateReleaseRequest) Equal(y *UpdateReleaseRequest) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if !x.Release.Equal(y.Release) {
		return false
	}
	if equal, ok := interface{}(x.UpdateMask).(interface {
		Equal(*fieldmaskpb.FieldMask) bool
	}); !ok || !equal.Equal(y.UpdateMask) {
		return false
	} else if !proto.Equal(x.UpdateMask, y.UpdateMask) {
		return false
	}
	if x.AllowMissing != y.AllowMissing {
		return false
	}
	return true
}

func (x *DeleteReleaseRequest) Equal(y *DeleteReleaseRequest) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	return true
}

func (x *UndeleteReleaseRequest) Equal(y *UndeleteReleaseRequest) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	return true
}

func (x *CheckReleaseRequest) Equal(y *CheckReleaseRequest) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Parent != y.Parent {
		return false
	}
	if !x.Release.Equal(y.Release) {
		return false
	}
	if len(x.Targets) != len(y.Targets) {
		return false
	}
	for i := 0; i < len(x.Targets); i++ {
		if x.Targets[i] != y.Targets[i] {
			return false
		}
	}
	return true
}

func (x *CheckReleaseResponse_CheckResult) Equal(y *CheckReleaseResponse_CheckResult) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.File != y.File {
		return false
	}
	if x.Target != y.Target {
		return false
	}
	if len(x.Advices) != len(y.Advices) {
		return false
	}
	for i := 0; i < len(x.Advices); i++ {
		if !x.Advices[i].Equal(y.Advices[i]) {
			return false
		}
	}
	if x.AffectedRows != y.AffectedRows {
		return false
	}
	if x.RiskLevel != y.RiskLevel {
		return false
	}
	return true
}

func (x *CheckReleaseResponse) Equal(y *CheckReleaseResponse) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if len(x.Results) != len(y.Results) {
		return false
	}
	for i := 0; i < len(x.Results); i++ {
		if !x.Results[i].Equal(y.Results[i]) {
			return false
		}
	}
	if x.AffectedRows != y.AffectedRows {
		return false
	}
	if x.RiskLevel != y.RiskLevel {
		return false
	}
	return true
}

func (x *Release_File) Equal(y *Release_File) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Id != y.Id {
		return false
	}
	if x.Path != y.Path {
		return false
	}
	if x.Type != y.Type {
		return false
	}
	if x.Version != y.Version {
		return false
	}
	if x.MigrationType != y.MigrationType {
		return false
	}
	if x.Sheet != y.Sheet {
		return false
	}
	if string(x.Statement) != string(y.Statement) {
		return false
	}
	if x.SheetSha256 != y.SheetSha256 {
		return false
	}
	if x.StatementSize != y.StatementSize {
		return false
	}
	return true
}

func (x *Release_VCSSource) Equal(y *Release_VCSSource) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.VcsType != y.VcsType {
		return false
	}
	if x.Url != y.Url {
		return false
	}
	return true
}

func (x *Release) Equal(y *Release) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if x.Title != y.Title {
		return false
	}
	if len(x.Files) != len(y.Files) {
		return false
	}
	for i := 0; i < len(x.Files); i++ {
		if !x.Files[i].Equal(y.Files[i]) {
			return false
		}
	}
	if !x.VcsSource.Equal(y.VcsSource) {
		return false
	}
	if x.Creator != y.Creator {
		return false
	}
	if p, q := x.CreateTime, y.CreateTime; (p == nil && q != nil) || (p != nil && (q == nil || p.Seconds != q.Seconds || p.Nanos != q.Nanos)) {
		return false
	}
	if x.State != y.State {
		return false
	}
	if x.Digest != y.Digest {
		return false
	}
	return true
}
