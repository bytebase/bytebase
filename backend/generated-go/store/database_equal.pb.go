// Code generated by protoc-gen-equal-go. DO NOT EDIT.
// source: store/database.proto

package store

import (
	math "math"
)

func (x *DatabaseMetadata) Equal(y *DatabaseMetadata) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if len(x.Labels) != len(y.Labels) {
		return false
	}
	for k := range x.Labels {
		_, ok := y.Labels[k]
		if !ok {
			return false
		}
		if x.Labels[k] != y.Labels[k] {
			return false
		}
	}
	if p, q := x.LastSyncTime, y.LastSyncTime; (p == nil && q != nil) || (p != nil && (q == nil || p.Seconds != q.Seconds || p.Nanos != q.Nanos)) {
		return false
	}
	if x.BackupAvailable != y.BackupAvailable {
		return false
	}
	if x.Datashare != y.Datashare {
		return false
	}
	if x.Drifted != y.Drifted {
		return false
	}
	if x.Version != y.Version {
		return false
	}
	return true
}

func (x *DatabaseSchemaMetadata) Equal(y *DatabaseSchemaMetadata) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if len(x.Schemas) != len(y.Schemas) {
		return false
	}
	for i := 0; i < len(x.Schemas); i++ {
		if !x.Schemas[i].Equal(y.Schemas[i]) {
			return false
		}
	}
	if x.CharacterSet != y.CharacterSet {
		return false
	}
	if x.Collation != y.Collation {
		return false
	}
	if len(x.Extensions) != len(y.Extensions) {
		return false
	}
	for i := 0; i < len(x.Extensions); i++ {
		if !x.Extensions[i].Equal(y.Extensions[i]) {
			return false
		}
	}
	if x.Datashare != y.Datashare {
		return false
	}
	if x.ServiceName != y.ServiceName {
		return false
	}
	if len(x.LinkedDatabases) != len(y.LinkedDatabases) {
		return false
	}
	for i := 0; i < len(x.LinkedDatabases); i++ {
		if !x.LinkedDatabases[i].Equal(y.LinkedDatabases[i]) {
			return false
		}
	}
	if x.Owner != y.Owner {
		return false
	}
	if x.SearchPath != y.SearchPath {
		return false
	}
	return true
}

func (x *LinkedDatabaseMetadata) Equal(y *LinkedDatabaseMetadata) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if x.Username != y.Username {
		return false
	}
	if x.Host != y.Host {
		return false
	}
	return true
}

func (x *SchemaMetadata) Equal(y *SchemaMetadata) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if len(x.Tables) != len(y.Tables) {
		return false
	}
	for i := 0; i < len(x.Tables); i++ {
		if !x.Tables[i].Equal(y.Tables[i]) {
			return false
		}
	}
	if len(x.ExternalTables) != len(y.ExternalTables) {
		return false
	}
	for i := 0; i < len(x.ExternalTables); i++ {
		if !x.ExternalTables[i].Equal(y.ExternalTables[i]) {
			return false
		}
	}
	if len(x.Views) != len(y.Views) {
		return false
	}
	for i := 0; i < len(x.Views); i++ {
		if !x.Views[i].Equal(y.Views[i]) {
			return false
		}
	}
	if len(x.Functions) != len(y.Functions) {
		return false
	}
	for i := 0; i < len(x.Functions); i++ {
		if !x.Functions[i].Equal(y.Functions[i]) {
			return false
		}
	}
	if len(x.Procedures) != len(y.Procedures) {
		return false
	}
	for i := 0; i < len(x.Procedures); i++ {
		if !x.Procedures[i].Equal(y.Procedures[i]) {
			return false
		}
	}
	if len(x.Streams) != len(y.Streams) {
		return false
	}
	for i := 0; i < len(x.Streams); i++ {
		if !x.Streams[i].Equal(y.Streams[i]) {
			return false
		}
	}
	if len(x.Tasks) != len(y.Tasks) {
		return false
	}
	for i := 0; i < len(x.Tasks); i++ {
		if !x.Tasks[i].Equal(y.Tasks[i]) {
			return false
		}
	}
	if len(x.MaterializedViews) != len(y.MaterializedViews) {
		return false
	}
	for i := 0; i < len(x.MaterializedViews); i++ {
		if !x.MaterializedViews[i].Equal(y.MaterializedViews[i]) {
			return false
		}
	}
	if len(x.Sequences) != len(y.Sequences) {
		return false
	}
	for i := 0; i < len(x.Sequences); i++ {
		if !x.Sequences[i].Equal(y.Sequences[i]) {
			return false
		}
	}
	if len(x.Packages) != len(y.Packages) {
		return false
	}
	for i := 0; i < len(x.Packages); i++ {
		if !x.Packages[i].Equal(y.Packages[i]) {
			return false
		}
	}
	if x.Owner != y.Owner {
		return false
	}
	if x.Comment != y.Comment {
		return false
	}
	if len(x.Events) != len(y.Events) {
		return false
	}
	for i := 0; i < len(x.Events); i++ {
		if !x.Events[i].Equal(y.Events[i]) {
			return false
		}
	}
	if len(x.EnumTypes) != len(y.EnumTypes) {
		return false
	}
	for i := 0; i < len(x.EnumTypes); i++ {
		if !x.EnumTypes[i].Equal(y.EnumTypes[i]) {
			return false
		}
	}
	if x.SkipDump != y.SkipDump {
		return false
	}
	return true
}

func (x *EnumTypeMetadata) Equal(y *EnumTypeMetadata) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if len(x.Values) != len(y.Values) {
		return false
	}
	for i := 0; i < len(x.Values); i++ {
		if x.Values[i] != y.Values[i] {
			return false
		}
	}
	if x.Comment != y.Comment {
		return false
	}
	if x.SkipDump != y.SkipDump {
		return false
	}
	return true
}

func (x *EventMetadata) Equal(y *EventMetadata) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if x.Definition != y.Definition {
		return false
	}
	if x.TimeZone != y.TimeZone {
		return false
	}
	if x.SqlMode != y.SqlMode {
		return false
	}
	if x.CharacterSetClient != y.CharacterSetClient {
		return false
	}
	if x.CollationConnection != y.CollationConnection {
		return false
	}
	if x.Comment != y.Comment {
		return false
	}
	return true
}

func (x *SequenceMetadata) Equal(y *SequenceMetadata) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if x.DataType != y.DataType {
		return false
	}
	if x.Start != y.Start {
		return false
	}
	if x.MinValue != y.MinValue {
		return false
	}
	if x.MaxValue != y.MaxValue {
		return false
	}
	if x.Increment != y.Increment {
		return false
	}
	if x.Cycle != y.Cycle {
		return false
	}
	if x.CacheSize != y.CacheSize {
		return false
	}
	if x.LastValue != y.LastValue {
		return false
	}
	if x.OwnerTable != y.OwnerTable {
		return false
	}
	if x.OwnerColumn != y.OwnerColumn {
		return false
	}
	if x.Comment != y.Comment {
		return false
	}
	if x.SkipDump != y.SkipDump {
		return false
	}
	return true
}

func (x *TriggerMetadata) Equal(y *TriggerMetadata) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if x.Event != y.Event {
		return false
	}
	if x.Timing != y.Timing {
		return false
	}
	if x.Body != y.Body {
		return false
	}
	if x.SqlMode != y.SqlMode {
		return false
	}
	if x.CharacterSetClient != y.CharacterSetClient {
		return false
	}
	if x.CollationConnection != y.CollationConnection {
		return false
	}
	if x.Comment != y.Comment {
		return false
	}
	if x.SkipDump != y.SkipDump {
		return false
	}
	return true
}

func (x *RuleMetadata) Equal(y *RuleMetadata) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if x.Event != y.Event {
		return false
	}
	if x.Condition != y.Condition {
		return false
	}
	if x.Action != y.Action {
		return false
	}
	if x.IsInstead != y.IsInstead {
		return false
	}
	if x.IsEnabled != y.IsEnabled {
		return false
	}
	if x.Definition != y.Definition {
		return false
	}
	return true
}

func (x *TaskMetadata) Equal(y *TaskMetadata) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if x.Id != y.Id {
		return false
	}
	if x.Owner != y.Owner {
		return false
	}
	if x.Comment != y.Comment {
		return false
	}
	if x.Warehouse != y.Warehouse {
		return false
	}
	if x.Schedule != y.Schedule {
		return false
	}
	if len(x.Predecessors) != len(y.Predecessors) {
		return false
	}
	for i := 0; i < len(x.Predecessors); i++ {
		if x.Predecessors[i] != y.Predecessors[i] {
			return false
		}
	}
	if x.State != y.State {
		return false
	}
	if x.Condition != y.Condition {
		return false
	}
	if x.Definition != y.Definition {
		return false
	}
	return true
}

func (x *StreamMetadata) Equal(y *StreamMetadata) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if x.TableName != y.TableName {
		return false
	}
	if x.Owner != y.Owner {
		return false
	}
	if x.Comment != y.Comment {
		return false
	}
	if x.Type != y.Type {
		return false
	}
	if x.Stale != y.Stale {
		return false
	}
	if x.Mode != y.Mode {
		return false
	}
	if x.Definition != y.Definition {
		return false
	}
	return true
}

func (x *TableMetadata) Equal(y *TableMetadata) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if len(x.Columns) != len(y.Columns) {
		return false
	}
	for i := 0; i < len(x.Columns); i++ {
		if !x.Columns[i].Equal(y.Columns[i]) {
			return false
		}
	}
	if len(x.Indexes) != len(y.Indexes) {
		return false
	}
	for i := 0; i < len(x.Indexes); i++ {
		if !x.Indexes[i].Equal(y.Indexes[i]) {
			return false
		}
	}
	if x.Engine != y.Engine {
		return false
	}
	if x.Collation != y.Collation {
		return false
	}
	if x.Charset != y.Charset {
		return false
	}
	if x.RowCount != y.RowCount {
		return false
	}
	if x.DataSize != y.DataSize {
		return false
	}
	if x.IndexSize != y.IndexSize {
		return false
	}
	if x.DataFree != y.DataFree {
		return false
	}
	if x.CreateOptions != y.CreateOptions {
		return false
	}
	if x.Comment != y.Comment {
		return false
	}
	if x.UserComment != y.UserComment {
		return false
	}
	if len(x.ForeignKeys) != len(y.ForeignKeys) {
		return false
	}
	for i := 0; i < len(x.ForeignKeys); i++ {
		if !x.ForeignKeys[i].Equal(y.ForeignKeys[i]) {
			return false
		}
	}
	if len(x.Partitions) != len(y.Partitions) {
		return false
	}
	for i := 0; i < len(x.Partitions); i++ {
		if !x.Partitions[i].Equal(y.Partitions[i]) {
			return false
		}
	}
	if len(x.CheckConstraints) != len(y.CheckConstraints) {
		return false
	}
	for i := 0; i < len(x.CheckConstraints); i++ {
		if !x.CheckConstraints[i].Equal(y.CheckConstraints[i]) {
			return false
		}
	}
	if x.Owner != y.Owner {
		return false
	}
	if len(x.SortingKeys) != len(y.SortingKeys) {
		return false
	}
	for i := 0; i < len(x.SortingKeys); i++ {
		if x.SortingKeys[i] != y.SortingKeys[i] {
			return false
		}
	}
	if len(x.Triggers) != len(y.Triggers) {
		return false
	}
	for i := 0; i < len(x.Triggers); i++ {
		if !x.Triggers[i].Equal(y.Triggers[i]) {
			return false
		}
	}
	if x.SkipDump != y.SkipDump {
		return false
	}
	if len(x.Rules) != len(y.Rules) {
		return false
	}
	for i := 0; i < len(x.Rules); i++ {
		if !x.Rules[i].Equal(y.Rules[i]) {
			return false
		}
	}
	if x.ShardingInfo != y.ShardingInfo {
		return false
	}
	if x.PrimaryKeyType != y.PrimaryKeyType {
		return false
	}
	return true
}

func (x *CheckConstraintMetadata) Equal(y *CheckConstraintMetadata) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if x.Expression != y.Expression {
		return false
	}
	return true
}

func (x *ExternalTableMetadata) Equal(y *ExternalTableMetadata) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if x.ExternalServerName != y.ExternalServerName {
		return false
	}
	if x.ExternalDatabaseName != y.ExternalDatabaseName {
		return false
	}
	if len(x.Columns) != len(y.Columns) {
		return false
	}
	for i := 0; i < len(x.Columns); i++ {
		if !x.Columns[i].Equal(y.Columns[i]) {
			return false
		}
	}
	return true
}

func (x *TablePartitionMetadata) Equal(y *TablePartitionMetadata) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if x.Type != y.Type {
		return false
	}
	if x.Expression != y.Expression {
		return false
	}
	if x.Value != y.Value {
		return false
	}
	if x.UseDefault != y.UseDefault {
		return false
	}
	if len(x.Subpartitions) != len(y.Subpartitions) {
		return false
	}
	for i := 0; i < len(x.Subpartitions); i++ {
		if !x.Subpartitions[i].Equal(y.Subpartitions[i]) {
			return false
		}
	}
	if len(x.Indexes) != len(y.Indexes) {
		return false
	}
	for i := 0; i < len(x.Indexes); i++ {
		if !x.Indexes[i].Equal(y.Indexes[i]) {
			return false
		}
	}
	if len(x.CheckConstraints) != len(y.CheckConstraints) {
		return false
	}
	for i := 0; i < len(x.CheckConstraints); i++ {
		if !x.CheckConstraints[i].Equal(y.CheckConstraints[i]) {
			return false
		}
	}
	return true
}

func (x *ColumnMetadata) Equal(y *ColumnMetadata) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if x.Position != y.Position {
		return false
	}
	if x.Default != y.Default {
		return false
	}
	if x.DefaultNull != y.DefaultNull {
		return false
	}
	if x.DefaultExpression != y.DefaultExpression {
		return false
	}
	if x.DefaultOnNull != y.DefaultOnNull {
		return false
	}
	if x.OnUpdate != y.OnUpdate {
		return false
	}
	if x.Nullable != y.Nullable {
		return false
	}
	if x.Type != y.Type {
		return false
	}
	if x.CharacterSet != y.CharacterSet {
		return false
	}
	if x.Collation != y.Collation {
		return false
	}
	if x.Comment != y.Comment {
		return false
	}
	if x.UserComment != y.UserComment {
		return false
	}
	if !x.Generation.Equal(y.Generation) {
		return false
	}
	if x.IsIdentity != y.IsIdentity {
		return false
	}
	if x.IdentityGeneration != y.IdentityGeneration {
		return false
	}
	if x.IdentitySeed != y.IdentitySeed {
		return false
	}
	if x.IdentityIncrement != y.IdentityIncrement {
		return false
	}
	if x.DefaultConstraintName != y.DefaultConstraintName {
		return false
	}
	return true
}

func (x *GenerationMetadata) Equal(y *GenerationMetadata) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Type != y.Type {
		return false
	}
	if x.Expression != y.Expression {
		return false
	}
	return true
}

func (x *ViewMetadata) Equal(y *ViewMetadata) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if x.Definition != y.Definition {
		return false
	}
	if x.Comment != y.Comment {
		return false
	}
	if len(x.DependencyColumns) != len(y.DependencyColumns) {
		return false
	}
	for i := 0; i < len(x.DependencyColumns); i++ {
		if !x.DependencyColumns[i].Equal(y.DependencyColumns[i]) {
			return false
		}
	}
	if len(x.Columns) != len(y.Columns) {
		return false
	}
	for i := 0; i < len(x.Columns); i++ {
		if !x.Columns[i].Equal(y.Columns[i]) {
			return false
		}
	}
	if len(x.Triggers) != len(y.Triggers) {
		return false
	}
	for i := 0; i < len(x.Triggers); i++ {
		if !x.Triggers[i].Equal(y.Triggers[i]) {
			return false
		}
	}
	if x.SkipDump != y.SkipDump {
		return false
	}
	if len(x.Rules) != len(y.Rules) {
		return false
	}
	for i := 0; i < len(x.Rules); i++ {
		if !x.Rules[i].Equal(y.Rules[i]) {
			return false
		}
	}
	return true
}

func (x *DependencyColumn) Equal(y *DependencyColumn) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Schema != y.Schema {
		return false
	}
	if x.Table != y.Table {
		return false
	}
	if x.Column != y.Column {
		return false
	}
	return true
}

func (x *MaterializedViewMetadata) Equal(y *MaterializedViewMetadata) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if x.Definition != y.Definition {
		return false
	}
	if x.Comment != y.Comment {
		return false
	}
	if len(x.DependencyColumns) != len(y.DependencyColumns) {
		return false
	}
	for i := 0; i < len(x.DependencyColumns); i++ {
		if !x.DependencyColumns[i].Equal(y.DependencyColumns[i]) {
			return false
		}
	}
	if len(x.Triggers) != len(y.Triggers) {
		return false
	}
	for i := 0; i < len(x.Triggers); i++ {
		if !x.Triggers[i].Equal(y.Triggers[i]) {
			return false
		}
	}
	if len(x.Indexes) != len(y.Indexes) {
		return false
	}
	for i := 0; i < len(x.Indexes); i++ {
		if !x.Indexes[i].Equal(y.Indexes[i]) {
			return false
		}
	}
	if x.SkipDump != y.SkipDump {
		return false
	}
	return true
}

func (x *DependencyTable) Equal(y *DependencyTable) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Schema != y.Schema {
		return false
	}
	if x.Table != y.Table {
		return false
	}
	return true
}

func (x *FunctionMetadata) Equal(y *FunctionMetadata) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if x.Definition != y.Definition {
		return false
	}
	if x.Signature != y.Signature {
		return false
	}
	if x.CharacterSetClient != y.CharacterSetClient {
		return false
	}
	if x.CollationConnection != y.CollationConnection {
		return false
	}
	if x.DatabaseCollation != y.DatabaseCollation {
		return false
	}
	if x.SqlMode != y.SqlMode {
		return false
	}
	if x.Comment != y.Comment {
		return false
	}
	if len(x.DependencyTables) != len(y.DependencyTables) {
		return false
	}
	for i := 0; i < len(x.DependencyTables); i++ {
		if !x.DependencyTables[i].Equal(y.DependencyTables[i]) {
			return false
		}
	}
	if x.SkipDump != y.SkipDump {
		return false
	}
	return true
}

func (x *ProcedureMetadata) Equal(y *ProcedureMetadata) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if x.Definition != y.Definition {
		return false
	}
	if x.Signature != y.Signature {
		return false
	}
	if x.CharacterSetClient != y.CharacterSetClient {
		return false
	}
	if x.CollationConnection != y.CollationConnection {
		return false
	}
	if x.DatabaseCollation != y.DatabaseCollation {
		return false
	}
	if x.SqlMode != y.SqlMode {
		return false
	}
	if x.Comment != y.Comment {
		return false
	}
	if x.SkipDump != y.SkipDump {
		return false
	}
	return true
}

func (x *PackageMetadata) Equal(y *PackageMetadata) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if x.Definition != y.Definition {
		return false
	}
	return true
}

func (x *IndexMetadata) Equal(y *IndexMetadata) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if len(x.Expressions) != len(y.Expressions) {
		return false
	}
	for i := 0; i < len(x.Expressions); i++ {
		if x.Expressions[i] != y.Expressions[i] {
			return false
		}
	}
	if len(x.KeyLength) != len(y.KeyLength) {
		return false
	}
	for i := 0; i < len(x.KeyLength); i++ {
		if x.KeyLength[i] != y.KeyLength[i] {
			return false
		}
	}
	if len(x.Descending) != len(y.Descending) {
		return false
	}
	for i := 0; i < len(x.Descending); i++ {
		if x.Descending[i] != y.Descending[i] {
			return false
		}
	}
	if x.Type != y.Type {
		return false
	}
	if x.Unique != y.Unique {
		return false
	}
	if x.Primary != y.Primary {
		return false
	}
	if x.Visible != y.Visible {
		return false
	}
	if x.Comment != y.Comment {
		return false
	}
	if x.Definition != y.Definition {
		return false
	}
	if x.ParentIndexSchema != y.ParentIndexSchema {
		return false
	}
	if x.ParentIndexName != y.ParentIndexName {
		return false
	}
	if x.Granularity != y.Granularity {
		return false
	}
	if x.IsConstraint != y.IsConstraint {
		return false
	}
	if !x.SpatialConfig.Equal(y.SpatialConfig) {
		return false
	}
	if len(x.OpclassNames) != len(y.OpclassNames) {
		return false
	}
	for i := 0; i < len(x.OpclassNames); i++ {
		if x.OpclassNames[i] != y.OpclassNames[i] {
			return false
		}
	}
	if len(x.OpclassDefaults) != len(y.OpclassDefaults) {
		return false
	}
	for i := 0; i < len(x.OpclassDefaults); i++ {
		if x.OpclassDefaults[i] != y.OpclassDefaults[i] {
			return false
		}
	}
	return true
}

func (x *SpatialIndexConfig) Equal(y *SpatialIndexConfig) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Method != y.Method {
		return false
	}
	if !x.Tessellation.Equal(y.Tessellation) {
		return false
	}
	if !x.Storage.Equal(y.Storage) {
		return false
	}
	if !x.Dimensional.Equal(y.Dimensional) {
		return false
	}
	if len(x.EngineSpecific) != len(y.EngineSpecific) {
		return false
	}
	for k := range x.EngineSpecific {
		_, ok := y.EngineSpecific[k]
		if !ok {
			return false
		}
		if x.EngineSpecific[k] != y.EngineSpecific[k] {
			return false
		}
	}
	return true
}

func (x *TessellationConfig) Equal(y *TessellationConfig) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Scheme != y.Scheme {
		return false
	}
	if !x.BoundingBox.Equal(y.BoundingBox) {
		return false
	}
	if len(x.GridLevels) != len(y.GridLevels) {
		return false
	}
	for i := 0; i < len(x.GridLevels); i++ {
		if !x.GridLevels[i].Equal(y.GridLevels[i]) {
			return false
		}
	}
	if x.CellsPerObject != y.CellsPerObject {
		return false
	}
	return true
}

func (x *BoundingBox) Equal(y *BoundingBox) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if (math.IsNaN(float64(x.Xmin)) && !math.IsNaN(float64(y.Xmin)) || !math.IsNaN(float64(x.Xmin)) && math.IsNaN(float64(y.Xmin))) || (!math.IsNaN(float64(x.Xmin)) && !math.IsNaN(float64(y.Xmin)) && x.Xmin != y.Xmin) {
		return false
	}
	if (math.IsNaN(float64(x.Ymin)) && !math.IsNaN(float64(y.Ymin)) || !math.IsNaN(float64(x.Ymin)) && math.IsNaN(float64(y.Ymin))) || (!math.IsNaN(float64(x.Ymin)) && !math.IsNaN(float64(y.Ymin)) && x.Ymin != y.Ymin) {
		return false
	}
	if (math.IsNaN(float64(x.Xmax)) && !math.IsNaN(float64(y.Xmax)) || !math.IsNaN(float64(x.Xmax)) && math.IsNaN(float64(y.Xmax))) || (!math.IsNaN(float64(x.Xmax)) && !math.IsNaN(float64(y.Xmax)) && x.Xmax != y.Xmax) {
		return false
	}
	if (math.IsNaN(float64(x.Ymax)) && !math.IsNaN(float64(y.Ymax)) || !math.IsNaN(float64(x.Ymax)) && math.IsNaN(float64(y.Ymax))) || (!math.IsNaN(float64(x.Ymax)) && !math.IsNaN(float64(y.Ymax)) && x.Ymax != y.Ymax) {
		return false
	}
	return true
}

func (x *GridLevel) Equal(y *GridLevel) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Level != y.Level {
		return false
	}
	if x.Density != y.Density {
		return false
	}
	return true
}

func (x *StorageConfig) Equal(y *StorageConfig) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Fillfactor != y.Fillfactor {
		return false
	}
	if x.Buffering != y.Buffering {
		return false
	}
	if x.Tablespace != y.Tablespace {
		return false
	}
	if x.WorkTablespace != y.WorkTablespace {
		return false
	}
	if x.SdoLevel != y.SdoLevel {
		return false
	}
	if x.CommitInterval != y.CommitInterval {
		return false
	}
	if x.PadIndex != y.PadIndex {
		return false
	}
	if x.SortInTempdb != y.SortInTempdb {
		return false
	}
	if x.DropExisting != y.DropExisting {
		return false
	}
	if x.Online != y.Online {
		return false
	}
	if x.AllowRowLocks != y.AllowRowLocks {
		return false
	}
	if x.AllowPageLocks != y.AllowPageLocks {
		return false
	}
	if x.Maxdop != y.Maxdop {
		return false
	}
	if x.DataCompression != y.DataCompression {
		return false
	}
	return true
}

func (x *DimensionalConfig) Equal(y *DimensionalConfig) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Dimensions != y.Dimensions {
		return false
	}
	if x.DataType != y.DataType {
		return false
	}
	if x.OperatorClass != y.OperatorClass {
		return false
	}
	if x.LayerGtype != y.LayerGtype {
		return false
	}
	if x.ParallelBuild != y.ParallelBuild {
		return false
	}
	return true
}

func (x *ExtensionMetadata) Equal(y *ExtensionMetadata) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if x.Schema != y.Schema {
		return false
	}
	if x.Version != y.Version {
		return false
	}
	if x.Description != y.Description {
		return false
	}
	return true
}

func (x *ForeignKeyMetadata) Equal(y *ForeignKeyMetadata) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if len(x.Columns) != len(y.Columns) {
		return false
	}
	for i := 0; i < len(x.Columns); i++ {
		if x.Columns[i] != y.Columns[i] {
			return false
		}
	}
	if x.ReferencedSchema != y.ReferencedSchema {
		return false
	}
	if x.ReferencedTable != y.ReferencedTable {
		return false
	}
	if len(x.ReferencedColumns) != len(y.ReferencedColumns) {
		return false
	}
	for i := 0; i < len(x.ReferencedColumns); i++ {
		if x.ReferencedColumns[i] != y.ReferencedColumns[i] {
			return false
		}
	}
	if x.OnDelete != y.OnDelete {
		return false
	}
	if x.OnUpdate != y.OnUpdate {
		return false
	}
	if x.MatchType != y.MatchType {
		return false
	}
	return true
}

func (x *InstanceRoleMetadata) Equal(y *InstanceRoleMetadata) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if x.Grant != y.Grant {
		return false
	}
	return true
}

func (x *DatabaseConfig) Equal(y *DatabaseConfig) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if len(x.Schemas) != len(y.Schemas) {
		return false
	}
	for i := 0; i < len(x.Schemas); i++ {
		if !x.Schemas[i].Equal(y.Schemas[i]) {
			return false
		}
	}
	return true
}

func (x *SchemaCatalog) Equal(y *SchemaCatalog) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if len(x.Tables) != len(y.Tables) {
		return false
	}
	for i := 0; i < len(x.Tables); i++ {
		if !x.Tables[i].Equal(y.Tables[i]) {
			return false
		}
	}
	return true
}

func (x *TableCatalog) Equal(y *TableCatalog) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if len(x.Columns) != len(y.Columns) {
		return false
	}
	for i := 0; i < len(x.Columns); i++ {
		if !x.Columns[i].Equal(y.Columns[i]) {
			return false
		}
	}
	if !x.ObjectSchema.Equal(y.ObjectSchema) {
		return false
	}
	if x.Classification != y.Classification {
		return false
	}
	return true
}

func (x *ColumnCatalog) Equal(y *ColumnCatalog) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Name != y.Name {
		return false
	}
	if x.SemanticType != y.SemanticType {
		return false
	}
	if len(x.Labels) != len(y.Labels) {
		return false
	}
	for k := range x.Labels {
		_, ok := y.Labels[k]
		if !ok {
			return false
		}
		if x.Labels[k] != y.Labels[k] {
			return false
		}
	}
	if x.Classification != y.Classification {
		return false
	}
	if !x.ObjectSchema.Equal(y.ObjectSchema) {
		return false
	}
	if x.MaskingLevel != y.MaskingLevel {
		return false
	}
	if x.FullMaskingAlgorithmId != y.FullMaskingAlgorithmId {
		return false
	}
	if x.PartialMaskingAlgorithmId != y.PartialMaskingAlgorithmId {
		return false
	}
	return true
}

func (x *ObjectSchema_StructKind) Equal(y *ObjectSchema_StructKind) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if len(x.Properties) != len(y.Properties) {
		return false
	}
	for k := range x.Properties {
		_, ok := y.Properties[k]
		if !ok {
			return false
		}
		if !x.Properties[k].Equal(y.Properties[k]) {
			return false
		}
	}
	return true
}

func (x *ObjectSchema_ArrayKind) Equal(y *ObjectSchema_ArrayKind) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if !x.Kind.Equal(y.Kind) {
		return false
	}
	return true
}

func (x *ObjectSchema) Equal(y *ObjectSchema) bool {
	if x == y {
		return true
	}
	if x == nil || y == nil {
		return x == nil && y == nil
	}
	if x.Type != y.Type {
		return false
	}
	if !x.GetStructKind().Equal(y.GetStructKind()) {
		return false
	}
	if !x.GetArrayKind().Equal(y.GetArrayKind()) {
		return false
	}
	if x.SemanticType != y.SemanticType {
		return false
	}
	return true
}
