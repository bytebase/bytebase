// Package mssql is the advisor for MSSQL database.
package mssql

import (
	"fmt"
	"strings"

	"github.com/antlr4-go/antlr/v4"
	parser "github.com/bytebase/tsql-parser"
	"github.com/pkg/errors"

	"github.com/bytebase/bytebase/backend/plugin/advisor"
	tsqlparser "github.com/bytebase/bytebase/backend/plugin/parser/tsql"
	storepb "github.com/bytebase/bytebase/proto/generated-go/store"
)

var (
	_ advisor.Advisor = (*MigrationCompatibilityAdvisor)(nil)
)

func init() {
	advisor.Register(storepb.Engine_MSSQL, advisor.MSSQLMigrationCompatibility, &MigrationCompatibilityAdvisor{})
}

// MigrationCompatibilityAdvisor is the advisor checking for migration compatibility..
type MigrationCompatibilityAdvisor struct {
}

// Check checks for migration compatibility..
func (*MigrationCompatibilityAdvisor) Check(ctx advisor.Context, _ string) ([]advisor.Advice, error) {
	tree, ok := ctx.AST.(antlr.Tree)
	if !ok {
		return nil, errors.Errorf("failed to convert to Tree")
	}

	level, err := advisor.NewStatusBySQLReviewRuleLevel(ctx.Rule.Level)
	if err != nil {
		return nil, err
	}

	listener := &migrationCompatibilityChecker{
		level:                              level,
		title:                              string(ctx.Rule.Type),
		currentDatabase:                    ctx.CurrentDatabase,
		normalizedNewCreateTableNameMap:    make(map[string]any),
		normalizedNewCreateSchemaNameMap:   make(map[string]any),
		normalizedNewCreateDatabaseNameMap: make(map[string]any),
	}

	antlr.ParseTreeWalkerDefault.Walk(listener, tree)

	return listener.generateAdvice()
}

// migrationCompatibilityChecker is the listener for migration compatibility.
type migrationCompatibilityChecker struct {
	*parser.BaseTSqlParserListener

	level advisor.Status
	title string

	// normalizedLastCreateTableNameMap contain the last created table name in normalized format.
	normalizedNewCreateTableNameMap map[string]any
	// normalizedLastCreateSchemaNameMap contain the last created schema name in normalized format.
	normalizedNewCreateSchemaNameMap map[string]any
	// normalizedNewCreateDatabaseNameMap contain the new created database name in normalized format.
	normalizedNewCreateDatabaseNameMap map[string]any

	// currentDatabase is the current database name.
	currentDatabase string

	adviceList []advisor.Advice
}

// generateAdvice returns the advices generated by the listener, the advices must not be empty.
func (l *migrationCompatibilityChecker) generateAdvice() ([]advisor.Advice, error) {
	if len(l.adviceList) == 0 {
		l.adviceList = append(l.adviceList, advisor.Advice{
			Status:  advisor.Success,
			Code:    advisor.Ok,
			Title:   "OK",
			Content: "",
		})
	}
	return l.adviceList, nil
}

func (l *migrationCompatibilityChecker) EnterCreate_table(ctx *parser.Create_tableContext) {
	tableName := ctx.Table_name()
	if tableName == nil || tableName.GetTable() == nil {
		return
	}
	normalizedTableName := tsqlparser.NormalizeTSQLTableName(tableName, l.currentDatabase, "dbo", false)
	l.normalizedNewCreateTableNameMap[normalizedTableName] = any(nil)
}

func (l *migrationCompatibilityChecker) EnterCreate_schema(ctx *parser.Create_schemaContext) {
	var schemaName string
	if v := ctx.GetSchema_name(); v != nil {
		schemaName = tsqlparser.NormalizeTSQLIdentifier(v)
	} else {
		schemaName = tsqlparser.NormalizeTSQLIdentifier(ctx.GetOwner_name())
	}

	normalizedDatabaseSchemaName := fmt.Sprintf("%s.%s", l.currentDatabase, schemaName)
	l.normalizedNewCreateSchemaNameMap[normalizedDatabaseSchemaName] = any(nil)
}

func (l *migrationCompatibilityChecker) EnterCreate_database(ctx *parser.Create_databaseContext) {
	databaseName := tsqlparser.NormalizeTSQLIdentifier(ctx.GetDatabase())
	l.normalizedNewCreateDatabaseNameMap[databaseName] = any(nil)
}

func (l *migrationCompatibilityChecker) EnterDrop_table(ctx *parser.Drop_tableContext) {
	allTableNames := ctx.AllTable_name()
	for _, tableName := range allTableNames {
		if tableName == nil || tableName.GetTable() == nil {
			continue
		}
		normalizedTableName := tsqlparser.NormalizeTSQLTableName(tableName, l.currentDatabase, "dbo", false)
		if _, ok := l.normalizedNewCreateTableNameMap[normalizedTableName]; !ok {
			l.adviceList = append(l.adviceList, advisor.Advice{
				Status:  l.level,
				Code:    advisor.CompatibilityDropSchema,
				Title:   l.title,
				Content: fmt.Sprintf("Drop table %s may cause incompatibility with the existing data and code", normalizedTableName),
				Line:    ctx.GetStart().GetLine(),
			})
		}
		delete(l.normalizedNewCreateTableNameMap, normalizedTableName)
	}
}

func (l *migrationCompatibilityChecker) EnterDrop_schema(ctx *parser.Drop_schemaContext) {
	schemaName := ctx.GetSchema_name()
	normalizedSchemaName := fmt.Sprintf("%s.%s", l.currentDatabase, tsqlparser.NormalizeTSQLIdentifier(schemaName))
	if _, ok := l.normalizedNewCreateSchemaNameMap[normalizedSchemaName]; !ok {
		l.adviceList = append(l.adviceList, advisor.Advice{
			Status:  l.level,
			Code:    advisor.CompatibilityDropSchema,
			Title:   l.title,
			Content: fmt.Sprintf("Drop schema %s may cause incompatibility with the existing data and code", normalizedSchemaName),
			Line:    ctx.GetStart().GetLine(),
		})
	}
	delete(l.normalizedNewCreateSchemaNameMap, normalizedSchemaName)
}

func (l *migrationCompatibilityChecker) EnterDrop_database(ctx *parser.Drop_databaseContext) {
	databaseName := ctx.GetDatabase_name_or_database_snapshot_name()
	normalizedDatabaseName := tsqlparser.NormalizeTSQLIdentifier(databaseName)
	if _, ok := l.normalizedNewCreateDatabaseNameMap[normalizedDatabaseName]; !ok {
		l.adviceList = append(l.adviceList, advisor.Advice{
			Status:  l.level,
			Code:    advisor.CompatibilityDropSchema,
			Title:   l.title,
			Content: fmt.Sprintf("Drop database %s may cause incompatibility with the existing data and code", normalizedDatabaseName),
			Line:    ctx.GetStart().GetLine(),
		})
	}
	delete(l.normalizedNewCreateDatabaseNameMap, normalizedDatabaseName)
}

func (l *migrationCompatibilityChecker) EnterAlter_table(ctx *parser.Alter_tableContext) {
	handleTableName := ctx.Table_name(0)
	normalizedHandleTableName := tsqlparser.NormalizeTSQLTableName(handleTableName, l.currentDatabase, "dbo", false)
	if _, ok := l.normalizedNewCreateTableNameMap[normalizedHandleTableName]; ok {
		return
	}

	if ctx.DROP() != nil && ctx.COLUMN() != nil {
		allDropColumns := ctx.AllId_()
		var allNormalizedDropColumnNames []string
		for _, dropColumn := range allDropColumns {
			normalizedDropColumnName := tsqlparser.NormalizeTSQLIdentifier(dropColumn)
			allNormalizedDropColumnNames = append(allNormalizedDropColumnNames, normalizedDropColumnName)
		}
		placeholder := strings.Join(allNormalizedDropColumnNames, ", ")
		l.adviceList = append(l.adviceList, advisor.Advice{
			Status:  l.level,
			Code:    advisor.CompatibilityDropSchema,
			Title:   l.title,
			Content: fmt.Sprintf("Drop column %s may cause incompatibility with the existing data and code", placeholder),
			Line:    ctx.COLUMN().GetSymbol().GetLine(),
		})
		return
	}
	if len(ctx.AllALTER()) == 2 && ctx.COLUMN() != nil {
		normalizedColumnName := ""
		if ctx.Column_definition() != nil {
			normalizedColumnName = tsqlparser.NormalizeTSQLIdentifier(ctx.Column_definition().Id_())
		} else if ctx.Column_modifier() != nil {
			normalizedColumnName = tsqlparser.NormalizeTSQLIdentifier(ctx.Column_modifier().Id_())
		}

		l.adviceList = append(l.adviceList, advisor.Advice{
			Status:  l.level,
			Code:    advisor.CompatibilityAlterColumn,
			Title:   l.title,
			Content: fmt.Sprintf("Alter COLUMN %s may cause incompatibility with the existing data and code", normalizedColumnName),
			Line:    ctx.COLUMN().GetSymbol().GetLine(),
		})
		return
	}
	if v := ctx.Column_def_table_constraints(); v != nil {
		allColumnDefTableConstraints := v.AllColumn_def_table_constraint()
		for _, columnDefTableConstraint := range allColumnDefTableConstraints {
			code := advisor.Ok
			operation := ""
			tableConstraint := columnDefTableConstraint.Table_constraint()
			if tableConstraint == nil {
				continue
			}
			if tableConstraint.PRIMARY() != nil {
				code = advisor.CompatibilityAddPrimaryKey
				operation = "Add PRIMARY KEY"
			}
			if tableConstraint.UNIQUE() != nil {
				code = advisor.CompatibilityAddUniqueKey
				operation = "Add UNIQUE KEY"
			}
			if tableConstraint.Check_constraint() != nil {
				code = advisor.CompatibilityAddCheck
				operation = "Add CHECK"
			}
			l.adviceList = append(l.adviceList, advisor.Advice{
				Status:  l.level,
				Code:    code,
				Title:   l.title,
				Content: fmt.Sprintf("%s may cause incompatibility with the existing data and code", operation),
				Line:    ctx.GetStart().GetLine(),
			})
		}
		return
	}
	if ctx.WITH() != nil && ctx.NOCHECK() != nil {
		if ctx.FOREIGN() != nil {
			l.adviceList = append(l.adviceList, advisor.Advice{
				Status:  l.level,
				Code:    advisor.CompatibilityAddForeignKey,
				Title:   l.title,
				Content: "Add FOREIGN KEY WITH NO CHECK may cause incompatibility with the existing data and code",
				Line:    ctx.FOREIGN().GetSymbol().GetLine(),
			})
			return
		}
		if len(ctx.AllCHECK()) == 1 {
			l.adviceList = append(l.adviceList, advisor.Advice{
				Status:  l.level,
				Code:    advisor.CompatibilityAddForeignKey,
				Title:   l.title,
				Content: "Add CHECK WITH NO CHECK may cause incompatibility with the existing data and code",
				Line:    ctx.CHECK(0).GetSymbol().GetLine(),
			})
			return
		}
	}
}

// EnterExecute_body is called when production execute_body is entered.
func (l *migrationCompatibilityChecker) EnterExecute_body(ctx *parser.Execute_bodyContext) {
	if ctx.Func_proc_name_server_database_schema() == nil {
		return
	}
	if ctx.Func_proc_name_server_database_schema().Func_proc_name_database_schema() == nil {
		return
	}
	if ctx.Func_proc_name_server_database_schema().Func_proc_name_database_schema().Func_proc_name_schema() == nil {
		return
	}
	if ctx.Func_proc_name_server_database_schema().Func_proc_name_database_schema().Func_proc_name_schema().GetSchema() != nil {
		return
	}

	v := ctx.Func_proc_name_server_database_schema().Func_proc_name_database_schema().Func_proc_name_schema().GetProcedure()
	normalizedProcedureName := tsqlparser.NormalizeTSQLIdentifier(v)
	if normalizedProcedureName != "sp_rename" {
		return
	}

	unnamedArguments := tsqlparser.FlattenExecuteStatementArgExecuteStatementArgUnnamed(ctx.Execute_statement_arg())

	firstArgument := unnamedArguments[0]
	if firstArgument == nil {
		return
	}
	if firstArgument.Execute_parameter() == nil {
		return
	}
	if firstArgument.Execute_parameter().Constant() == nil {
		return
	}
	if firstArgument.Execute_parameter().Constant().STRING() == nil {
		return
	}
	if len(unnamedArguments) == 2 {
		secondArgument := unnamedArguments[1]
		if secondArgument == nil {
			return
		}
		if secondArgument.Execute_parameter() == nil {
			return
		}
		if secondArgument.Execute_parameter().Constant() == nil {
			return
		}
		if secondArgument.Execute_parameter().Constant().STRING() == nil {
			return
		}
		l.adviceList = append(l.adviceList, advisor.Advice{
			Status:  l.level,
			Code:    advisor.CompatibilityRenameTable,
			Title:   l.title,
			Content: fmt.Sprintf("Rename Table %s WITH may cause incompatibility with the existing data and code", firstArgument.GetText()),
			Line:    ctx.GetStart().GetLine(),
		})
	} else if len(unnamedArguments) == 3 {
		thirdArgument := unnamedArguments[2]
		if thirdArgument == nil {
			return
		}
		if thirdArgument.Execute_parameter() == nil {
			return
		}
		if thirdArgument.Execute_parameter().Constant() == nil {
			return
		}
		if thirdArgument.Execute_parameter().Constant().STRING() == nil {
			return
		}
		if thirdArgument.GetText() != "'COLUMN'" {
			return
		}

		l.adviceList = append(l.adviceList, advisor.Advice{
			Status:  l.level,
			Code:    advisor.CompatibilityRenameColumn,
			Title:   l.title,
			Content: fmt.Sprintf("Rename COLUMN %s may cause incompatibility with the existing data and code", firstArgument.GetText()),
			Line:    ctx.GetStart().GetLine(),
		})
	}
}
