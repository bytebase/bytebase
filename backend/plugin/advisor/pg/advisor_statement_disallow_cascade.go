package pg

// Framework code is generated by the generator.

import (
	"encoding/json"
	"fmt"

	pgquery "github.com/pganalyze/pg_query_go/v4"
	"github.com/pkg/errors"

	"github.com/bytebase/bytebase/backend/plugin/advisor"
	"github.com/bytebase/bytebase/backend/plugin/parser/sql/ast"
	storepb "github.com/bytebase/bytebase/proto/generated-go/store"
)

var (
	_ advisor.Advisor = (*StatementDmlDryRunAdvisor)(nil)
	_ ast.Visitor     = (*statementDmlDryRunChecker)(nil)
)

func init() {
	advisor.Register(storepb.Engine_POSTGRES, advisor.PostgreSQLStatementDisallowCascade, &StatementDisallowCascadeAdvisor{})
}

// StatementDisallowCascadeAdvisor is the advisor checking the disallow cascade.
type StatementDisallowCascadeAdvisor struct {
}

// Check checks for DML dry run.
func (*StatementDisallowCascadeAdvisor) Check(ctx advisor.Context, _ string) ([]advisor.Advice, error) {
	stmt := ctx.Statements
	if stmt == "" {
		return []advisor.Advice{
			{
				Status:  advisor.Success,
				Code:    advisor.Ok,
				Title:   "OK",
				Content: "",
			},
		}, nil
	}

	level, err := advisor.NewStatusBySQLReviewRuleLevel(ctx.Rule.Level)
	if err != nil {
		return nil, err
	}

	jsonText, err := pgquery.ParseToJSON(stmt)
	if err != nil {
		return nil, errors.Wrapf(err, "failed to parse statement to JSON")
	}

	var jsonData map[string]any
	if err := json.Unmarshal([]byte(jsonText), &jsonData); err != nil {
		return nil, errors.Wrapf(err, "failed to unmarshal JSON")
	}

	cascadeNum := cascadeNumRecursive(jsonData)
	if cascadeNum > 0 {
		return []advisor.Advice{
			{
				Status:  level,
				Code:    advisor.StatementDisallowCascade,
				Title:   string(ctx.Rule.Type),
				Content: fmt.Sprintf("CASCADE is not allowed, but detect %d CASCADE", cascadeNum),
			},
		}, nil
	}

	return []advisor.Advice{
		{
			Status:  advisor.Success,
			Code:    advisor.Ok,
			Title:   "OK",
			Content: "",
		},
	}, nil
}

func cascadeNumRecursive(jsonData map[string]any) int {
	cnt := 0
	if jsonData["behavior"] == "DROP_CASCADE" {
		cnt++
	}
	if jsonData["fk_del_action"] == "c" {
		cnt++
	}

	for _, value := range jsonData {
		switch value := value.(type) {
		case map[string]any:
			cnt += cascadeNumRecursive(value)
		case []any:
			for _, v := range value {
				mv, ok := v.(map[string]any)
				if !ok {
					continue
				}
				cnt += cascadeNumRecursive(mv)
			}
		}
	}

	return cnt
}
