package oracle

import (
	"context"
	"database/sql"
	"strconv"
	"strings"
	"testing"

	"github.com/google/go-cmp/cmp"
	"github.com/stretchr/testify/require"
	"google.golang.org/protobuf/testing/protocmp"

	"github.com/bytebase/bytebase/backend/common/testcontainer"
	"github.com/bytebase/bytebase/backend/plugin/schema"
	storepb "github.com/bytebase/bytebase/proto/generated-go/store"
)

// TestGetDatabaseDefinitionWithTestcontainer tests the GetDatabaseDefinition function
// by creating a schema, getting its definition, recreating it in a new database,
// and comparing the results.
func TestGetDatabaseDefinitionWithTestcontainer(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping Oracle testcontainer test in short mode")
	}

	ctx := context.Background()

	// Get Oracle container from testcontainer utility
	container := testcontainer.GetTestOracleContainer(ctx, t)
	defer container.Close(ctx)

	// Test cases with various schema configurations
	testCases := []struct {
		name          string
		initialSchema string
		description   string
	}{
		{
			name: "basic_tables_and_constraints",
			initialSchema: `
CREATE TABLE DEPARTMENTS (
    ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    NAME VARCHAR2(100) NOT NULL,
    BUDGET NUMBER(12, 2) DEFAULT 0
);

CREATE TABLE EMPLOYEES (
    ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    NAME VARCHAR2(100) NOT NULL,
    EMAIL VARCHAR2(100) UNIQUE,
    DEPARTMENT_ID NUMBER,
    SALARY NUMBER(10, 2),
    HIRE_DATE DATE DEFAULT SYSDATE,
    IS_ACTIVE NUMBER(1) DEFAULT 1 CHECK (IS_ACTIVE IN (0, 1)),
    CONSTRAINT FK_DEPT FOREIGN KEY (DEPARTMENT_ID) REFERENCES DEPARTMENTS(ID)
);

CREATE INDEX IDX_EMP_DEPT ON EMPLOYEES(DEPARTMENT_ID);
CREATE INDEX IDX_EMP_NAME ON EMPLOYEES(NAME);
`,
			description: "Basic tables with primary keys, foreign keys, unique constraints, check constraints, and indexes",
		},
		{
			name: "complex_data_types",
			initialSchema: `
CREATE TABLE DATA_TYPES_TEST (
    ID NUMBER PRIMARY KEY,
    -- Numeric types
    NUM_INTEGER NUMBER(10),
    NUM_DECIMAL NUMBER(15, 3),
    NUM_FLOAT FLOAT(126),
    -- Character types
    CHAR_FIXED CHAR(10),
    VARCHAR_VAR VARCHAR2(200),
    NVARCHAR_VAR NVARCHAR2(100),
    -- Date/Time types
    DATE_FIELD DATE,
    TIMESTAMP_FIELD TIMESTAMP,
    TIMESTAMP_TZ TIMESTAMP WITH TIME ZONE,
    TIMESTAMP_LTZ TIMESTAMP WITH LOCAL TIME ZONE,
    -- Large objects
    CLOB_FIELD CLOB,
    BLOB_FIELD BLOB,
    -- Other types
    RAW_FIELD RAW(100),
    LONG_RAW_FIELD LONG RAW
);

CREATE TABLE JSON_TEST (
    ID NUMBER PRIMARY KEY,
    JSON_DATA CLOB CHECK (JSON_DATA IS JSON)
);
`,
			description: "Various Oracle data types including numeric, character, date/time, LOB, and JSON",
		},
		{
			name: "sequences_and_identity",
			initialSchema: `
CREATE SEQUENCE ORDER_SEQ START WITH 1000 INCREMENT BY 1;
CREATE SEQUENCE INVOICE_SEQ START WITH 5000 INCREMENT BY 10 MAXVALUE 999999 CYCLE;

CREATE TABLE ORDERS (
    ID NUMBER DEFAULT ORDER_SEQ.NEXTVAL PRIMARY KEY,
    ORDER_DATE DATE DEFAULT SYSDATE NOT NULL,
    STATUS VARCHAR2(20) DEFAULT 'PENDING'
);

CREATE TABLE INVOICES (
    ID NUMBER DEFAULT INVOICE_SEQ.NEXTVAL PRIMARY KEY,
    ORDER_ID NUMBER NOT NULL,
    AMOUNT NUMBER(10, 2) NOT NULL,
    CONSTRAINT FK_INVOICE_ORDER FOREIGN KEY (ORDER_ID) REFERENCES ORDERS(ID)
);

CREATE TABLE PRODUCTS (
    ID NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    NAME VARCHAR2(100) NOT NULL,
    PRICE NUMBER(10, 2) NOT NULL
);

CREATE TABLE PRODUCT_VERSIONS (
    ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    PRODUCT_ID NUMBER NOT NULL,
    VERSION VARCHAR2(20) NOT NULL,
    CONSTRAINT FK_PROD_VERSION FOREIGN KEY (PRODUCT_ID) REFERENCES PRODUCTS(ID)
);
`,
			description: "Sequences with various options and identity columns",
		},
		{
			name: "views_and_materialized_views",
			initialSchema: `
CREATE TABLE SALES (
    ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    PRODUCT_NAME VARCHAR2(100) NOT NULL,
    QUANTITY NUMBER NOT NULL,
    PRICE NUMBER(10, 2) NOT NULL,
    SALE_DATE DATE DEFAULT SYSDATE
);

CREATE VIEW SALES_SUMMARY AS
SELECT 
    PRODUCT_NAME,
    COUNT(*) AS TOTAL_SALES,
    SUM(QUANTITY) AS TOTAL_QUANTITY,
    SUM(QUANTITY * PRICE) AS TOTAL_REVENUE
FROM SALES
GROUP BY PRODUCT_NAME;

CREATE MATERIALIZED VIEW DAILY_SALES_MV
BUILD IMMEDIATE
REFRESH COMPLETE ON DEMAND
AS
SELECT 
    TRUNC(SALE_DATE) AS SALE_DAY,
    COUNT(*) AS TRANSACTION_COUNT,
    SUM(QUANTITY * PRICE) AS DAILY_REVENUE
FROM SALES
GROUP BY TRUNC(SALE_DATE);

CREATE INDEX IDX_DAILY_SALES_MV ON DAILY_SALES_MV(SALE_DAY);
`,
			description: "Views and materialized views with indexes",
		},
		{
			name: "functions_and_procedures",
			initialSchema: `
CREATE TABLE ACCOUNTS (
    ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    ACCOUNT_NAME VARCHAR2(100) NOT NULL,
    BALANCE NUMBER(12, 2) DEFAULT 0
);

CREATE OR REPLACE FUNCTION GET_ACCOUNT_BALANCE(P_ACCOUNT_ID NUMBER)
RETURN NUMBER
IS
    V_BALANCE NUMBER(12, 2);
BEGIN
    SELECT BALANCE INTO V_BALANCE
    FROM ACCOUNTS
    WHERE ID = P_ACCOUNT_ID;
    
    RETURN V_BALANCE;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RETURN 0;
END;
/

CREATE OR REPLACE PROCEDURE TRANSFER_FUNDS(
    P_FROM_ACCOUNT NUMBER,
    P_TO_ACCOUNT NUMBER,
    P_AMOUNT NUMBER
)
IS
    V_FROM_BALANCE NUMBER(12, 2);
BEGIN
    -- Check balance
    SELECT BALANCE INTO V_FROM_BALANCE
    FROM ACCOUNTS
    WHERE ID = P_FROM_ACCOUNT
    FOR UPDATE;
    
    IF V_FROM_BALANCE < P_AMOUNT THEN
        RAISE_APPLICATION_ERROR(-20001, 'Insufficient funds');
    END IF;
    
    -- Transfer
    UPDATE ACCOUNTS SET BALANCE = BALANCE - P_AMOUNT WHERE ID = P_FROM_ACCOUNT;
    UPDATE ACCOUNTS SET BALANCE = BALANCE + P_AMOUNT WHERE ID = P_TO_ACCOUNT;
    
    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;
/
`,
			description: "Functions and stored procedures",
		},
		{
			name: "complex_constraints",
			initialSchema: `
CREATE TABLE PROJECTS (
    ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    NAME VARCHAR2(100) NOT NULL,
    START_DATE DATE NOT NULL,
    END_DATE DATE,
    BUDGET NUMBER(12, 2),
    STATUS VARCHAR2(20) DEFAULT 'PLANNING',
    CONSTRAINT CHK_DATES CHECK (END_DATE IS NULL OR END_DATE > START_DATE),
    CONSTRAINT CHK_BUDGET CHECK (BUDGET > 0),
    CONSTRAINT CHK_STATUS CHECK (STATUS IN ('PLANNING', 'ACTIVE', 'COMPLETED', 'CANCELLED'))
);

CREATE TABLE TASKS (
    ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    PROJECT_ID NUMBER NOT NULL,
    TASK_NAME VARCHAR2(200) NOT NULL,
    ASSIGNED_TO VARCHAR2(100),
    PRIORITY NUMBER(1) DEFAULT 3,
    ESTIMATED_HOURS NUMBER(6, 2),
    ACTUAL_HOURS NUMBER(6, 2),
    CONSTRAINT FK_PROJECT FOREIGN KEY (PROJECT_ID) REFERENCES PROJECTS(ID) ON DELETE CASCADE,
    CONSTRAINT CHK_PRIORITY CHECK (PRIORITY BETWEEN 1 AND 5),
    CONSTRAINT CHK_HOURS CHECK (ESTIMATED_HOURS > 0 AND (ACTUAL_HOURS IS NULL OR ACTUAL_HOURS >= 0)),
    CONSTRAINT UK_PROJECT_TASK UNIQUE (PROJECT_ID, TASK_NAME)
);

CREATE INDEX IDX_TASKS_PROJECT ON TASKS(PROJECT_ID);
CREATE INDEX IDX_TASKS_ASSIGNED ON TASKS(ASSIGNED_TO);
CREATE INDEX IDX_TASKS_PRIORITY ON TASKS(PRIORITY, PROJECT_ID);
`,
			description: "Complex check constraints, unique constraints, and composite indexes",
		},
		{
			name: "partitioned_tables",
			initialSchema: `
CREATE TABLE SALES_PARTITIONED (
    ID NUMBER GENERATED BY DEFAULT AS IDENTITY,
    SALE_DATE DATE NOT NULL,
    PRODUCT_ID NUMBER NOT NULL,
    QUANTITY NUMBER NOT NULL,
    AMOUNT NUMBER(10, 2) NOT NULL,
    REGION VARCHAR2(50) NOT NULL
)
PARTITION BY RANGE (SALE_DATE)
(
    PARTITION P_2023 VALUES LESS THAN (TO_DATE('2024-01-01', 'YYYY-MM-DD')),
    PARTITION P_2024 VALUES LESS THAN (TO_DATE('2025-01-01', 'YYYY-MM-DD')),
    PARTITION P_FUTURE VALUES LESS THAN (MAXVALUE)
);

CREATE INDEX IDX_SALES_PART_DATE ON SALES_PARTITIONED(SALE_DATE) LOCAL;
CREATE INDEX IDX_SALES_PART_PRODUCT ON SALES_PARTITIONED(PRODUCT_ID) LOCAL;
`,
			description: "Partitioned tables with local indexes",
		},
		{
			name: "synonyms_and_dblinks",
			initialSchema: `
CREATE TABLE MASTER_DATA (
    ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    CODE VARCHAR2(50) UNIQUE NOT NULL,
    DESCRIPTION VARCHAR2(200),
    IS_ACTIVE NUMBER(1) DEFAULT 1
);

CREATE OR REPLACE SYNONYM MD FOR MASTER_DATA;

CREATE TABLE TRANSACTIONS (
    ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    MASTER_ID NUMBER NOT NULL,
    TRANSACTION_DATE DATE DEFAULT SYSDATE,
    AMOUNT NUMBER(10, 2) NOT NULL,
    CONSTRAINT FK_MASTER FOREIGN KEY (MASTER_ID) REFERENCES MD(ID)
);
`,
			description: "Tables with synonyms",
		},
		{
			name: "triggers",
			initialSchema: `
CREATE TABLE AUDIT_LOG (
    ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    TABLE_NAME VARCHAR2(100) NOT NULL,
    OPERATION VARCHAR2(10) NOT NULL,
    USER_NAME VARCHAR2(100) DEFAULT USER,
    OPERATION_TIME TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE INVENTORY (
    ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    PRODUCT_NAME VARCHAR2(100) NOT NULL,
    QUANTITY NUMBER DEFAULT 0,
    LAST_UPDATED TIMESTAMP
);

CREATE OR REPLACE TRIGGER TRG_INVENTORY_AUDIT
AFTER INSERT OR UPDATE OR DELETE ON INVENTORY
FOR EACH ROW
BEGIN
    IF INSERTING THEN
        INSERT INTO AUDIT_LOG(TABLE_NAME, OPERATION) VALUES ('INVENTORY', 'INSERT');
    ELSIF UPDATING THEN
        INSERT INTO AUDIT_LOG(TABLE_NAME, OPERATION) VALUES ('INVENTORY', 'UPDATE');
    ELSIF DELETING THEN
        INSERT INTO AUDIT_LOG(TABLE_NAME, OPERATION) VALUES ('INVENTORY', 'DELETE');
    END IF;
END;
/

CREATE OR REPLACE TRIGGER TRG_INVENTORY_TIMESTAMP
BEFORE UPDATE ON INVENTORY
FOR EACH ROW
BEGIN
    :NEW.LAST_UPDATED := CURRENT_TIMESTAMP;
END;
/
`,
			description: "Tables with triggers",
		},
		{
			name: "complex_foreign_keys",
			initialSchema: `
CREATE TABLE ORGANIZATIONS (
    ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    NAME VARCHAR2(100) NOT NULL,
    PARENT_ID NUMBER,
    CONSTRAINT FK_PARENT_ORG FOREIGN KEY (PARENT_ID) REFERENCES ORGANIZATIONS(ID)
);

CREATE TABLE USERS (
    ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    USERNAME VARCHAR2(50) UNIQUE NOT NULL,
    ORG_ID NUMBER NOT NULL,
    MANAGER_ID NUMBER,
    CONSTRAINT FK_USER_ORG FOREIGN KEY (ORG_ID) REFERENCES ORGANIZATIONS(ID),
    CONSTRAINT FK_USER_MANAGER FOREIGN KEY (MANAGER_ID) REFERENCES USERS(ID)
);

CREATE TABLE PROJECTS (
    ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    NAME VARCHAR2(100) NOT NULL,
    ORG_ID NUMBER NOT NULL,
    OWNER_ID NUMBER NOT NULL,
    CONSTRAINT FK_PROJECT_ORG FOREIGN KEY (ORG_ID) REFERENCES ORGANIZATIONS(ID) ON DELETE CASCADE,
    CONSTRAINT FK_PROJECT_OWNER FOREIGN KEY (OWNER_ID) REFERENCES USERS(ID)
);

CREATE TABLE PROJECT_MEMBERS (
    PROJECT_ID NUMBER NOT NULL,
    USER_ID NUMBER NOT NULL,
    ROLE VARCHAR2(50) NOT NULL,
    JOINED_DATE DATE DEFAULT SYSDATE,
    CONSTRAINT PK_PROJECT_MEMBERS PRIMARY KEY (PROJECT_ID, USER_ID),
    CONSTRAINT FK_PM_PROJECT FOREIGN KEY (PROJECT_ID) REFERENCES PROJECTS(ID) ON DELETE CASCADE,
    CONSTRAINT FK_PM_USER FOREIGN KEY (USER_ID) REFERENCES USERS(ID) ON DELETE CASCADE
);
`,
			description: "Complex foreign key relationships including self-referencing and cascading deletes",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Get the database connection from the container
			testDB := container.GetDB()

			// Set current schema to TESTUSER
			_, err := testDB.Exec("ALTER SESSION SET CURRENT_SCHEMA = TESTUSER")
			require.NoError(t, err)

			// Clean up any existing objects
			cleanupSchema(t, testDB)

			// Step 1: Initialize the database schema and use SyncDBSchema to get metadata A
			err = executeStatements(testDB, tc.initialSchema)
			require.NoError(t, err, "Failed to execute initial schema")

			portInt, err := strconv.Atoi(container.GetPort())
			require.NoError(t, err)
			metadataA, err := getSyncMetadataForGenerateMigration(ctx, container.GetHost(), portInt, "testuser", "testpass", "FREEPDB1")
			require.NoError(t, err, "Failed to get initial metadata")

			// Step 2: Call GetDatabaseDefinition to generate the database definition X
			definition, err := GetDatabaseDefinition(schema.GetDefinitionContext{}, metadataA)
			require.NoError(t, err, "Failed to generate database definition")
			require.NotEmpty(t, definition, "Generated definition should not be empty")

			// Log the generated definition for debugging
			t.Logf("Generated definition:\n%s", definition)

			// Step 3: Create a new database schema and run the database definition X
			// First, clean up the schema
			cleanupSchema(t, testDB)

			// Execute the generated definition
			err = executeStatements(testDB, definition)
			require.NoError(t, err, "Failed to execute generated definition")

			// Get metadata B after recreating from definition
			metadataB, err := getSyncMetadataForGenerateMigration(ctx, container.GetHost(), portInt, "testuser", "testpass", "FREEPDB1")
			require.NoError(t, err, "Failed to get metadata after recreation")

			// Step 4: Compare the database metadata A and B, should be the same
			normalizeMetadataForComparison(metadataA)
			normalizeMetadataForComparison(metadataB)

			// Normalize column positions to 0 before comparison
			normalizeColumnPositions(metadataA)
			normalizeColumnPositions(metadataB)

			// Additional normalization for Oracle-specific issues
			normalizeOracleMetadata(metadataA)
			normalizeOracleMetadata(metadataB)

			// Use cmp with protocmp for proto message comparison
			if diff := cmp.Diff(metadataA, metadataB, protocmp.Transform()); diff != "" {
				t.Errorf("Schema mismatch after recreation (-original +recreated):\n%s", diff)
			}
		})
	}
}

// cleanupSchema drops all user objects in the schema
func cleanupSchema(t *testing.T, db *sql.DB) {
	// Set current schema to TESTUSER before cleanup
	_, err := db.Exec("ALTER SESSION SET CURRENT_SCHEMA = TESTUSER")
	require.NoError(t, err)

	// Drop all user objects in dependency order
	dropStatements := []string{
		// Drop triggers first
		"BEGIN FOR c IN (SELECT trigger_name FROM user_triggers) LOOP EXECUTE IMMEDIATE 'DROP TRIGGER ' || c.trigger_name; END LOOP; END;",
		// Drop materialized views
		"BEGIN FOR c IN (SELECT mview_name FROM user_mviews) LOOP EXECUTE IMMEDIATE 'DROP MATERIALIZED VIEW ' || c.mview_name; END LOOP; END;",
		// Drop views
		"BEGIN FOR c IN (SELECT view_name FROM user_views) LOOP EXECUTE IMMEDIATE 'DROP VIEW ' || c.view_name || ' CASCADE CONSTRAINTS'; END LOOP; END;",
		// Drop synonyms
		"BEGIN FOR c IN (SELECT synonym_name FROM user_synonyms) LOOP EXECUTE IMMEDIATE 'DROP SYNONYM ' || c.synonym_name; END LOOP; END;",
		// Drop procedures
		"BEGIN FOR c IN (SELECT object_name FROM user_objects WHERE object_type = 'PROCEDURE') LOOP EXECUTE IMMEDIATE 'DROP PROCEDURE ' || c.object_name; END LOOP; END;",
		// Drop functions
		"BEGIN FOR c IN (SELECT object_name FROM user_objects WHERE object_type = 'FUNCTION') LOOP EXECUTE IMMEDIATE 'DROP FUNCTION ' || c.object_name; END LOOP; END;",
		// Drop tables with cascade constraints
		"BEGIN FOR c IN (SELECT table_name FROM user_tables) LOOP EXECUTE IMMEDIATE 'DROP TABLE ' || c.table_name || ' CASCADE CONSTRAINTS'; END LOOP; END;",
		// Drop non-system sequences (system sequences cannot be dropped)
		"BEGIN FOR c IN (SELECT sequence_name FROM user_sequences WHERE sequence_name NOT LIKE 'ISEQ$$_%') LOOP EXECUTE IMMEDIATE 'DROP SEQUENCE ' || c.sequence_name; END LOOP; END;",
	}

	for _, stmt := range dropStatements {
		_, err := db.Exec(stmt)
		if err != nil {
			t.Logf("Warning during cleanup: %v", err)
		}
	}
}

// normalizeOracleMetadata handles Oracle-specific normalization for metadata comparison
func normalizeOracleMetadata(metadata *storepb.DatabaseSchemaMetadata) {
	for _, schema := range metadata.Schemas {
		for _, table := range schema.Tables {
			for _, column := range table.Columns {
				// Normalize system-generated sequence references in default expressions
				if column.DefaultValue != nil {
					defaultExpr := column.GetDefaultExpression()
					// If it's a system-generated sequence, remove the default expression
					// since these sequences can't be manually recreated with the same name
					if strings.Contains(defaultExpr, "ISEQ$$_") {
						column.DefaultValue = nil
					}
				}

				// Clear collation information as we skip it in DDL generation
				column.Collation = ""

				// Normalize NVARCHAR2 type size differences
				// Oracle stores NVARCHAR2 sizes in max bytes, but DDL defines in characters
				if strings.HasPrefix(column.Type, "NVARCHAR2") {
					// Extract the size and convert to character count
					if strings.Contains(column.Type, "(") && strings.Contains(column.Type, ")") {
						// For simplicity, we'll normalize all NVARCHAR2 types to just NVARCHAR2
						// This avoids issues with byte vs character counting
						column.Type = "NVARCHAR2"
					}
				}
			}
		}
	}
}
