package oracle

import (
	"context"
	"fmt"
	"strings"
	"testing"

	"github.com/google/go-cmp/cmp"
	"github.com/google/uuid"
	"github.com/stretchr/testify/require"
	"google.golang.org/protobuf/testing/protocmp"

	"github.com/bytebase/bytebase/backend/common/testcontainer"
	storepb "github.com/bytebase/bytebase/backend/generated-go/store"
	"github.com/bytebase/bytebase/backend/plugin/db"
	"github.com/bytebase/bytebase/backend/plugin/schema"
)

// TestGetDatabaseDefinitionWithTestcontainer tests the GetDatabaseDefinition function
// by creating a schema, getting its definition, recreating it in a new database,
// and comparing the results.
//
//nolint:tparallel
func TestGetDatabaseDefinitionWithTestcontainer(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping Oracle testcontainer test in short mode")
	}

	ctx := context.Background()

	// Get Oracle container from testcontainer utility
	container := testcontainer.GetTestOracleContainer(ctx, t)
	t.Cleanup(func() { container.Close(ctx) })

	// Create shared SYSTEM database connection for user management
	systemDB, err := openSystemDatabase(container.GetHost(), container.GetPort())
	require.NoError(t, err)
	t.Cleanup(func() { systemDB.Close() })

	// Test cases with various schema configurations
	testCases := []struct {
		name          string
		initialSchema string
		description   string
	}{
		{
			name: "basic_tables_and_constraints",
			initialSchema: `
CREATE TABLE DEPARTMENTS (
    ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    NAME VARCHAR2(100) NOT NULL,
    BUDGET NUMBER(12, 2) DEFAULT 0
);

CREATE TABLE EMPLOYEES (
    ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    NAME VARCHAR2(100) NOT NULL,
    EMAIL VARCHAR2(100) UNIQUE,
    DEPARTMENT_ID NUMBER,
    SALARY NUMBER(10, 2),
    HIRE_DATE DATE DEFAULT SYSDATE,
    IS_ACTIVE NUMBER(1) DEFAULT 1 CHECK (IS_ACTIVE IN (0, 1)),
    CONSTRAINT FK_DEPT FOREIGN KEY (DEPARTMENT_ID) REFERENCES DEPARTMENTS(ID)
);

CREATE INDEX IDX_EMP_DEPT ON EMPLOYEES(DEPARTMENT_ID);
CREATE INDEX IDX_EMP_NAME ON EMPLOYEES(NAME);
`,
			description: "Basic tables with primary keys, foreign keys, unique constraints, check constraints, and indexes",
		},
	}

	for _, tc := range testCases {
		tc := tc // Capture range variable
		t.Run(tc.name, func(t *testing.T) {
			t.Parallel()

			// Create unique Oracle user for this test (Oracle users are schemas)
			// Use UUID to ensure uniqueness and avoid name collisions
			testUser := fmt.Sprintf("U_%s", strings.ReplaceAll(uuid.New().String(), "-", "_"))

			// Create user using shared SYSTEM connection
			require.NoError(t, createOracleUser(systemDB, testUser))

			// Connect as the test user
			driver, err := createOracleDriver(ctx, container.GetHost(), container.GetPort(), testUser)
			require.NoError(t, err)
			defer driver.Close(ctx)

			// Step 1: Initialize the database schema and use SyncDBSchema to get metadata A
			err = executeStatements(ctx, driver, tc.initialSchema)
			require.NoError(t, err, "Failed to execute initial schema")

			// Get schema metadata A
			metadataA, err := driver.SyncDBSchema(ctx)
			require.NoError(t, err, "Failed to get initial metadata")

			// Step 2: Call GetDatabaseDefinition to generate the database definition X
			definition, err := GetDatabaseDefinition(schema.GetDefinitionContext{}, metadataA)
			require.NoError(t, err, "Failed to generate database definition")
			require.NotEmpty(t, definition, "Generated definition should not be empty")

			// Log the generated definition for debugging
			t.Logf("Generated definition:\n%s", definition)

			// Step 3: Drop all objects and recreate using the generated definition in the same schema
			// Get list of all objects to drop
			dropStatements, err := generateDropStatements(ctx, driver)
			require.NoError(t, err, "Failed to generate drop statements")

			// Drop all objects
			err = executeStatements(ctx, driver, dropStatements)
			require.NoError(t, err, "Failed to drop objects")

			// Execute the generated definition in the same schema
			err = executeStatements(ctx, driver, definition)
			require.NoError(t, err, "Failed to execute generated definition")

			// Get metadata B after recreating from definition
			metadataB, err := driver.SyncDBSchema(ctx)
			require.NoError(t, err, "Failed to get metadata after recreation")

			// Step 4: Compare the database metadata A and B, should be the same
			normalizeMetadataForComparison(metadataA)
			normalizeMetadataForComparison(metadataB)

			// Normalize column positions to 0 before comparison
			normalizeColumnPositions(metadataA)
			normalizeColumnPositions(metadataB)

			// Additional normalization for Oracle-specific issues
			normalizeOracleMetadata(metadataA)
			normalizeOracleMetadata(metadataB)

			// Use cmp with protocmp for proto message comparison
			if diff := cmp.Diff(metadataA, metadataB, protocmp.Transform()); diff != "" {
				t.Errorf("Schema mismatch after recreation (-original +recreated):\n%s", diff)
			}
		})
	}
}

// normalizeOracleMetadata handles Oracle-specific normalization for metadata comparison
func normalizeOracleMetadata(metadata *storepb.DatabaseSchemaMetadata) {
	for _, schema := range metadata.Schemas {
		for _, table := range schema.Tables {
			for _, column := range table.Columns {
				// Normalize system-generated sequence references in default expressions
				if column.Default != "" {
					// If it's a system-generated sequence, remove the default expression
					// since these sequences can't be manually recreated with the same name
					if strings.Contains(column.Default, "ISEQ$$_") {
						column.Default = ""
					}
				}

				// Clear collation information as we skip it in DDL generation
				column.Collation = ""

				// Normalize NVARCHAR2 type size differences
				// Oracle stores NVARCHAR2 sizes in max bytes, but DDL defines in characters
				if strings.HasPrefix(column.Type, "NVARCHAR2") {
					// Extract the size and convert to character count
					if strings.Contains(column.Type, "(") && strings.Contains(column.Type, ")") {
						// For simplicity, we'll normalize all NVARCHAR2 types to just NVARCHAR2
						// This avoids issues with byte vs character counting
						column.Type = "NVARCHAR2"
					}
				}
			}
		}
	}
}

// generateDropStatements generates DROP statements for all objects in the schema
func generateDropStatements(ctx context.Context, driver db.Driver) (string, error) {
	metadata, err := driver.SyncDBSchema(ctx)
	if err != nil {
		return "", err
	}

	var drops []string

	// Drop in reverse dependency order
	for _, schema := range metadata.Schemas {
		// Drop materialized views
		for _, mv := range schema.MaterializedViews {
			drops = append(drops, fmt.Sprintf("DROP MATERIALIZED VIEW \"%s\"", mv.Name))
		}

		// Drop views
		for _, view := range schema.Views {
			drops = append(drops, fmt.Sprintf("DROP VIEW \"%s\"", view.Name))
		}

		// Drop tables (cascade constraints to handle foreign keys)
		for _, table := range schema.Tables {
			drops = append(drops, fmt.Sprintf("DROP TABLE \"%s\" CASCADE CONSTRAINTS", table.Name))
		}

		// Drop sequences
		for _, seq := range schema.Sequences {
			drops = append(drops, fmt.Sprintf("DROP SEQUENCE \"%s\"", seq.Name))
		}

		// Drop functions
		for _, fn := range schema.Functions {
			drops = append(drops, fmt.Sprintf("DROP FUNCTION \"%s\"", fn.Name))
		}

		// Drop procedures
		for _, proc := range schema.Procedures {
			drops = append(drops, fmt.Sprintf("DROP PROCEDURE \"%s\"", proc.Name))
		}
	}

	return strings.Join(drops, ";\n") + ";\n", nil
}
