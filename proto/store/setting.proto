syntax = "proto3";

package bytebase.store;

import "google/api/expr/v1alpha1/syntax.proto";
import "google/protobuf/duration.proto";
import "google/type/expr.proto";
import "store/approval.proto";
import "store/common.proto";
import "store/database.proto";

option go_package = "generated-go/store";

message WorkspaceProfileSetting {
  // The URL user visits Bytebase.
  //
  // The external URL is used for:
  // 1. Constructing the correct callback URL when configuring the VCS provider.
  // The callback URL points to the frontend.
  // 2. Creating the correct webhook endpoint when configuring the project
  // GitOps workflow. The webhook endpoint points to the backend.
  string external_url = 1;

  // Disallow self-service signup, users can only be invited by the owner.
  bool disallow_signup = 2;

  // Require 2FA for all users.
  bool require_2fa = 3;

  // outbound_ip_list is the outbound IP for Bytebase instance in SaaS mode.
  repeated string outbound_ip_list = 4;

  // The webhook URL for the GitOps workflow.
  string gitops_webhook_url = 5;

  // The duration for token.
  google.protobuf.Duration token_duration = 6;

  // The setting of custom announcement
  Announcement announcement = 7;
}

message Announcement {
  // We support three levels of AlertLevel: INFO, WARNING, and ERROR.
  enum AlertLevel {
    ALERT_LEVEL_UNSPECIFIED = 0;
    ALERT_LEVEL_INFO = 1;
    ALERT_LEVEL_WARNING = 2;
    ALERT_LEVEL_CRITICAL = 3;
  }

  // The alert level of announcemnt
  AlertLevel level = 1;

  // The text of announcemnt
  string text = 2;

  // The optional link, user can follow the link to check extra details
  string link = 3;
}

message AgentPluginSetting {
  // The URL for the agent API.
  string url = 1;

  // The token for the agent.
  string token = 2;
}

message WorkspaceApprovalSetting {
  message Rule {
    google.api.expr.v1alpha1.ParsedExpr expression = 1;
    ApprovalTemplate template = 2;
    google.type.Expr condition = 3;
  }
  repeated Rule rules = 1;
}

message ExternalApprovalSetting {
  message Node {
    // A unique identifier for a node in UUID format.
    // We will also include the id in the message sending to the external relay
    // service to identify the node.
    string id = 1;
    // The title of the node.
    string title = 2;
    // The external endpoint for the relay service, e.g. "http://hello:1234".
    string endpoint = 3;
  }
  repeated Node nodes = 1;
}

message SMTPMailDeliverySetting {
  // The SMTP server address.
  string server = 1;

  // The SMTP server port.
  int32 port = 2;

  // We support three types of SMTP encryption: NONE, STARTTLS, and SSL/TLS.
  enum Encryption {
    ENCRYPTION_UNSPECIFIED = 0;
    ENCRYPTION_NONE = 1;
    ENCRYPTION_STARTTLS = 2;
    ENCRYPTION_SSL_TLS = 3;
  }

  // The SMTP server encryption.
  Encryption encryption = 3;

  // The CA, KEY, and CERT for the SMTP server.
  string ca = 4;
  string key = 5;
  string cert = 6;

  // We support four types of SMTP authentication: NONE, PLAIN, LOGIN, and
  // CRAM-MD5.
  enum Authentication {
    AUTHENTICATION_UNSPECIFIED = 0;
    AUTHENTICATION_NONE = 1;
    AUTHENTICATION_PLAIN = 2;
    AUTHENTICATION_LOGIN = 3;
    AUTHENTICATION_CRAM_MD5 = 4;
  }
  Authentication authentication = 7;
  string username = 8;
  string password = 9;

  // The sender email address.
  string from = 10;
}

message SchemaTemplateSetting {
  message FieldTemplate {
    string id = 1;

    Engine engine = 2;

    string category = 3;

    ColumnMetadata column = 4;

    ColumnConfig config = 5;
  }

  repeated FieldTemplate field_templates = 1;

  message ColumnType {
    Engine engine = 1;

    bool enabled = 2;

    repeated string types = 3;
  }

  repeated ColumnType column_types = 2;

  message TableTemplate {
    string id = 1;

    Engine engine = 2;

    string category = 3;

    TableMetadata table = 4;

    TableConfig config = 5;
  }

  repeated TableTemplate table_templates = 3;
}

message DataClassificationSetting {
  message DataClassificationConfig {
    // id is the uuid for classification. Each project can chose one
    // classification config.
    string id = 1;
    string title = 2;

    message Level {
      string id = 1;
      string title = 2;
      string description = 3;
    }

    // levels is user defined level list for classification.
    // The order for the level decides its priority.
    repeated Level levels = 3;

    message DataClassification {
      // id is the classification id in [0-9]+-[0-9]+-[0-9]+ format.
      string id = 1;
      string title = 2;
      string description = 3;
      optional string level_id = 4;
    }

    // classification is the id - DataClassification map.
    // The id should in [0-9]+-[0-9]+-[0-9]+ format.
    map<string, DataClassification> classification = 4;
  }
  repeated DataClassificationConfig configs = 1;
}

message SemanticTypeSetting {
  message SemanticType {
    // id is the uuid for semantic type.
    string id = 1;
    // the title of the semantic type, it should not be empty.
    string title = 2;
    // the description of the semantic type, it can be empty.
    string description = 3;
    // the partial mask algorithm id for the semantic type, if it is empty,
    // should use the default partial mask algorithm.
    string partial_mask_algorithm_id = 4;
    // the full mask algorithm id for the semantic type, if it is empty, should
    // use the default full mask algorithm.
    string full_mask_algorithm_id = 5;
  }

  repeated SemanticType types = 1;
}

message MaskingAlgorithmSetting {
  message Algorithm {
    // id is the uuid for masking algorithm.
    string id = 1;
    // title is the title for masking algorithm.
    string title = 2;
    // description is the description for masking algorithm.
    string description = 3;

    // Category is the category for masking algorithm. Currently, it accepts 2 categories only: MASKING and HASHING.
    // The range of accepted Payload is decided by the category.
    // Mask: FullMask, RangeMask
    // Hash: MD5Mask
    string category = 4;

    message FullMask {
      // substitution is the string used to replace the original value, the
      // max length of the string is 16 bytes.
      string substitution = 1;
    }

    message RangeMask {
      message Slice {
        // start is the start index of the original value, start from 0 and should be less than stop.
        int32 start = 1;
        // stop is the stop index of the original value, should be less than the length of the original value.
        int32 end = 2;
        // OriginalValue[start:end) would be replaced with replace_with.
        string substitution = 3;
      }
      // We store it as a repeated field to face the fact that the original value may have multiple parts should be masked.
      // But frontend can be started with a single rule easily.
      repeated Slice slices = 1;
    }

    message MD5Mask {
      // salt is the salt value to generate a different hash that with the word alone.
      string salt = 1;
    }

    oneof mask {
      FullMask full_mask = 5;
      RangeMask range_mask = 6;
      MD5Mask md5_mask = 7;
    }
  }

  // algorithms is the list of masking algorithms.
  repeated Algorithm algorithms = 1;
}
