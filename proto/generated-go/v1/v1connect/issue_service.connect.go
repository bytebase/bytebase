// Code generated by protoc-gen-connect-go. DO NOT EDIT.
//
// Source: v1/issue_service.proto

package v1connect

import (
	connect "connectrpc.com/connect"
	context "context"
	errors "errors"
	v1 "github.com/bytebase/bytebase/proto/generated-go/v1"
	http "net/http"
	strings "strings"
)

// This is a compile-time assertion to ensure that this generated file and the connect package are
// compatible. If you get a compiler error that this constant is not defined, this code was
// generated with a version of connect newer than the one compiled into your binary. You can fix the
// problem by either regenerating this code with an older version of connect or updating the connect
// version compiled into your binary.
const _ = connect.IsAtLeastVersion1_13_0

const (
	// IssueServiceName is the fully-qualified name of the IssueService service.
	IssueServiceName = "bytebase.v1.IssueService"
)

// These constants are the fully-qualified names of the RPCs defined in this package. They're
// exposed at runtime as Spec.Procedure and as the final two segments of the HTTP route.
//
// Note that these are different from the fully-qualified method names used by
// google.golang.org/protobuf/reflect/protoreflect. To convert from these constants to
// reflection-formatted method names, remove the leading slash and convert the remaining slash to a
// period.
const (
	// IssueServiceGetIssueProcedure is the fully-qualified name of the IssueService's GetIssue RPC.
	IssueServiceGetIssueProcedure = "/bytebase.v1.IssueService/GetIssue"
	// IssueServiceCreateIssueProcedure is the fully-qualified name of the IssueService's CreateIssue
	// RPC.
	IssueServiceCreateIssueProcedure = "/bytebase.v1.IssueService/CreateIssue"
	// IssueServiceListIssuesProcedure is the fully-qualified name of the IssueService's ListIssues RPC.
	IssueServiceListIssuesProcedure = "/bytebase.v1.IssueService/ListIssues"
	// IssueServiceSearchIssuesProcedure is the fully-qualified name of the IssueService's SearchIssues
	// RPC.
	IssueServiceSearchIssuesProcedure = "/bytebase.v1.IssueService/SearchIssues"
	// IssueServiceUpdateIssueProcedure is the fully-qualified name of the IssueService's UpdateIssue
	// RPC.
	IssueServiceUpdateIssueProcedure = "/bytebase.v1.IssueService/UpdateIssue"
	// IssueServiceListIssueCommentsProcedure is the fully-qualified name of the IssueService's
	// ListIssueComments RPC.
	IssueServiceListIssueCommentsProcedure = "/bytebase.v1.IssueService/ListIssueComments"
	// IssueServiceCreateIssueCommentProcedure is the fully-qualified name of the IssueService's
	// CreateIssueComment RPC.
	IssueServiceCreateIssueCommentProcedure = "/bytebase.v1.IssueService/CreateIssueComment"
	// IssueServiceUpdateIssueCommentProcedure is the fully-qualified name of the IssueService's
	// UpdateIssueComment RPC.
	IssueServiceUpdateIssueCommentProcedure = "/bytebase.v1.IssueService/UpdateIssueComment"
	// IssueServiceBatchUpdateIssuesStatusProcedure is the fully-qualified name of the IssueService's
	// BatchUpdateIssuesStatus RPC.
	IssueServiceBatchUpdateIssuesStatusProcedure = "/bytebase.v1.IssueService/BatchUpdateIssuesStatus"
	// IssueServiceApproveIssueProcedure is the fully-qualified name of the IssueService's ApproveIssue
	// RPC.
	IssueServiceApproveIssueProcedure = "/bytebase.v1.IssueService/ApproveIssue"
	// IssueServiceRejectIssueProcedure is the fully-qualified name of the IssueService's RejectIssue
	// RPC.
	IssueServiceRejectIssueProcedure = "/bytebase.v1.IssueService/RejectIssue"
	// IssueServiceRequestIssueProcedure is the fully-qualified name of the IssueService's RequestIssue
	// RPC.
	IssueServiceRequestIssueProcedure = "/bytebase.v1.IssueService/RequestIssue"
)

// IssueServiceClient is a client for the bytebase.v1.IssueService service.
type IssueServiceClient interface {
	GetIssue(context.Context, *connect.Request[v1.GetIssueRequest]) (*connect.Response[v1.Issue], error)
	CreateIssue(context.Context, *connect.Request[v1.CreateIssueRequest]) (*connect.Response[v1.Issue], error)
	ListIssues(context.Context, *connect.Request[v1.ListIssuesRequest]) (*connect.Response[v1.ListIssuesResponse], error)
	// Search for issues that the caller has the bb.issues.get permission on and also satisfy the specified filter & query.
	SearchIssues(context.Context, *connect.Request[v1.SearchIssuesRequest]) (*connect.Response[v1.SearchIssuesResponse], error)
	UpdateIssue(context.Context, *connect.Request[v1.UpdateIssueRequest]) (*connect.Response[v1.Issue], error)
	ListIssueComments(context.Context, *connect.Request[v1.ListIssueCommentsRequest]) (*connect.Response[v1.ListIssueCommentsResponse], error)
	CreateIssueComment(context.Context, *connect.Request[v1.CreateIssueCommentRequest]) (*connect.Response[v1.IssueComment], error)
	UpdateIssueComment(context.Context, *connect.Request[v1.UpdateIssueCommentRequest]) (*connect.Response[v1.IssueComment], error)
	BatchUpdateIssuesStatus(context.Context, *connect.Request[v1.BatchUpdateIssuesStatusRequest]) (*connect.Response[v1.BatchUpdateIssuesStatusResponse], error)
	// ApproveIssue approves the issue.
	// The access is based on approval flow.
	ApproveIssue(context.Context, *connect.Request[v1.ApproveIssueRequest]) (*connect.Response[v1.Issue], error)
	// RejectIssue rejects the issue.
	// The access is based on approval flow.
	RejectIssue(context.Context, *connect.Request[v1.RejectIssueRequest]) (*connect.Response[v1.Issue], error)
	// RequestIssue requests the issue.
	// The access is based on approval flow.
	RequestIssue(context.Context, *connect.Request[v1.RequestIssueRequest]) (*connect.Response[v1.Issue], error)
}

// NewIssueServiceClient constructs a client for the bytebase.v1.IssueService service. By default,
// it uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses, and
// sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the connect.WithGRPC()
// or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewIssueServiceClient(httpClient connect.HTTPClient, baseURL string, opts ...connect.ClientOption) IssueServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	issueServiceMethods := v1.File_v1_issue_service_proto.Services().ByName("IssueService").Methods()
	return &issueServiceClient{
		getIssue: connect.NewClient[v1.GetIssueRequest, v1.Issue](
			httpClient,
			baseURL+IssueServiceGetIssueProcedure,
			connect.WithSchema(issueServiceMethods.ByName("GetIssue")),
			connect.WithClientOptions(opts...),
		),
		createIssue: connect.NewClient[v1.CreateIssueRequest, v1.Issue](
			httpClient,
			baseURL+IssueServiceCreateIssueProcedure,
			connect.WithSchema(issueServiceMethods.ByName("CreateIssue")),
			connect.WithClientOptions(opts...),
		),
		listIssues: connect.NewClient[v1.ListIssuesRequest, v1.ListIssuesResponse](
			httpClient,
			baseURL+IssueServiceListIssuesProcedure,
			connect.WithSchema(issueServiceMethods.ByName("ListIssues")),
			connect.WithClientOptions(opts...),
		),
		searchIssues: connect.NewClient[v1.SearchIssuesRequest, v1.SearchIssuesResponse](
			httpClient,
			baseURL+IssueServiceSearchIssuesProcedure,
			connect.WithSchema(issueServiceMethods.ByName("SearchIssues")),
			connect.WithClientOptions(opts...),
		),
		updateIssue: connect.NewClient[v1.UpdateIssueRequest, v1.Issue](
			httpClient,
			baseURL+IssueServiceUpdateIssueProcedure,
			connect.WithSchema(issueServiceMethods.ByName("UpdateIssue")),
			connect.WithClientOptions(opts...),
		),
		listIssueComments: connect.NewClient[v1.ListIssueCommentsRequest, v1.ListIssueCommentsResponse](
			httpClient,
			baseURL+IssueServiceListIssueCommentsProcedure,
			connect.WithSchema(issueServiceMethods.ByName("ListIssueComments")),
			connect.WithClientOptions(opts...),
		),
		createIssueComment: connect.NewClient[v1.CreateIssueCommentRequest, v1.IssueComment](
			httpClient,
			baseURL+IssueServiceCreateIssueCommentProcedure,
			connect.WithSchema(issueServiceMethods.ByName("CreateIssueComment")),
			connect.WithClientOptions(opts...),
		),
		updateIssueComment: connect.NewClient[v1.UpdateIssueCommentRequest, v1.IssueComment](
			httpClient,
			baseURL+IssueServiceUpdateIssueCommentProcedure,
			connect.WithSchema(issueServiceMethods.ByName("UpdateIssueComment")),
			connect.WithClientOptions(opts...),
		),
		batchUpdateIssuesStatus: connect.NewClient[v1.BatchUpdateIssuesStatusRequest, v1.BatchUpdateIssuesStatusResponse](
			httpClient,
			baseURL+IssueServiceBatchUpdateIssuesStatusProcedure,
			connect.WithSchema(issueServiceMethods.ByName("BatchUpdateIssuesStatus")),
			connect.WithClientOptions(opts...),
		),
		approveIssue: connect.NewClient[v1.ApproveIssueRequest, v1.Issue](
			httpClient,
			baseURL+IssueServiceApproveIssueProcedure,
			connect.WithSchema(issueServiceMethods.ByName("ApproveIssue")),
			connect.WithClientOptions(opts...),
		),
		rejectIssue: connect.NewClient[v1.RejectIssueRequest, v1.Issue](
			httpClient,
			baseURL+IssueServiceRejectIssueProcedure,
			connect.WithSchema(issueServiceMethods.ByName("RejectIssue")),
			connect.WithClientOptions(opts...),
		),
		requestIssue: connect.NewClient[v1.RequestIssueRequest, v1.Issue](
			httpClient,
			baseURL+IssueServiceRequestIssueProcedure,
			connect.WithSchema(issueServiceMethods.ByName("RequestIssue")),
			connect.WithClientOptions(opts...),
		),
	}
}

// issueServiceClient implements IssueServiceClient.
type issueServiceClient struct {
	getIssue                *connect.Client[v1.GetIssueRequest, v1.Issue]
	createIssue             *connect.Client[v1.CreateIssueRequest, v1.Issue]
	listIssues              *connect.Client[v1.ListIssuesRequest, v1.ListIssuesResponse]
	searchIssues            *connect.Client[v1.SearchIssuesRequest, v1.SearchIssuesResponse]
	updateIssue             *connect.Client[v1.UpdateIssueRequest, v1.Issue]
	listIssueComments       *connect.Client[v1.ListIssueCommentsRequest, v1.ListIssueCommentsResponse]
	createIssueComment      *connect.Client[v1.CreateIssueCommentRequest, v1.IssueComment]
	updateIssueComment      *connect.Client[v1.UpdateIssueCommentRequest, v1.IssueComment]
	batchUpdateIssuesStatus *connect.Client[v1.BatchUpdateIssuesStatusRequest, v1.BatchUpdateIssuesStatusResponse]
	approveIssue            *connect.Client[v1.ApproveIssueRequest, v1.Issue]
	rejectIssue             *connect.Client[v1.RejectIssueRequest, v1.Issue]
	requestIssue            *connect.Client[v1.RequestIssueRequest, v1.Issue]
}

// GetIssue calls bytebase.v1.IssueService.GetIssue.
func (c *issueServiceClient) GetIssue(ctx context.Context, req *connect.Request[v1.GetIssueRequest]) (*connect.Response[v1.Issue], error) {
	return c.getIssue.CallUnary(ctx, req)
}

// CreateIssue calls bytebase.v1.IssueService.CreateIssue.
func (c *issueServiceClient) CreateIssue(ctx context.Context, req *connect.Request[v1.CreateIssueRequest]) (*connect.Response[v1.Issue], error) {
	return c.createIssue.CallUnary(ctx, req)
}

// ListIssues calls bytebase.v1.IssueService.ListIssues.
func (c *issueServiceClient) ListIssues(ctx context.Context, req *connect.Request[v1.ListIssuesRequest]) (*connect.Response[v1.ListIssuesResponse], error) {
	return c.listIssues.CallUnary(ctx, req)
}

// SearchIssues calls bytebase.v1.IssueService.SearchIssues.
func (c *issueServiceClient) SearchIssues(ctx context.Context, req *connect.Request[v1.SearchIssuesRequest]) (*connect.Response[v1.SearchIssuesResponse], error) {
	return c.searchIssues.CallUnary(ctx, req)
}

// UpdateIssue calls bytebase.v1.IssueService.UpdateIssue.
func (c *issueServiceClient) UpdateIssue(ctx context.Context, req *connect.Request[v1.UpdateIssueRequest]) (*connect.Response[v1.Issue], error) {
	return c.updateIssue.CallUnary(ctx, req)
}

// ListIssueComments calls bytebase.v1.IssueService.ListIssueComments.
func (c *issueServiceClient) ListIssueComments(ctx context.Context, req *connect.Request[v1.ListIssueCommentsRequest]) (*connect.Response[v1.ListIssueCommentsResponse], error) {
	return c.listIssueComments.CallUnary(ctx, req)
}

// CreateIssueComment calls bytebase.v1.IssueService.CreateIssueComment.
func (c *issueServiceClient) CreateIssueComment(ctx context.Context, req *connect.Request[v1.CreateIssueCommentRequest]) (*connect.Response[v1.IssueComment], error) {
	return c.createIssueComment.CallUnary(ctx, req)
}

// UpdateIssueComment calls bytebase.v1.IssueService.UpdateIssueComment.
func (c *issueServiceClient) UpdateIssueComment(ctx context.Context, req *connect.Request[v1.UpdateIssueCommentRequest]) (*connect.Response[v1.IssueComment], error) {
	return c.updateIssueComment.CallUnary(ctx, req)
}

// BatchUpdateIssuesStatus calls bytebase.v1.IssueService.BatchUpdateIssuesStatus.
func (c *issueServiceClient) BatchUpdateIssuesStatus(ctx context.Context, req *connect.Request[v1.BatchUpdateIssuesStatusRequest]) (*connect.Response[v1.BatchUpdateIssuesStatusResponse], error) {
	return c.batchUpdateIssuesStatus.CallUnary(ctx, req)
}

// ApproveIssue calls bytebase.v1.IssueService.ApproveIssue.
func (c *issueServiceClient) ApproveIssue(ctx context.Context, req *connect.Request[v1.ApproveIssueRequest]) (*connect.Response[v1.Issue], error) {
	return c.approveIssue.CallUnary(ctx, req)
}

// RejectIssue calls bytebase.v1.IssueService.RejectIssue.
func (c *issueServiceClient) RejectIssue(ctx context.Context, req *connect.Request[v1.RejectIssueRequest]) (*connect.Response[v1.Issue], error) {
	return c.rejectIssue.CallUnary(ctx, req)
}

// RequestIssue calls bytebase.v1.IssueService.RequestIssue.
func (c *issueServiceClient) RequestIssue(ctx context.Context, req *connect.Request[v1.RequestIssueRequest]) (*connect.Response[v1.Issue], error) {
	return c.requestIssue.CallUnary(ctx, req)
}

// IssueServiceHandler is an implementation of the bytebase.v1.IssueService service.
type IssueServiceHandler interface {
	GetIssue(context.Context, *connect.Request[v1.GetIssueRequest]) (*connect.Response[v1.Issue], error)
	CreateIssue(context.Context, *connect.Request[v1.CreateIssueRequest]) (*connect.Response[v1.Issue], error)
	ListIssues(context.Context, *connect.Request[v1.ListIssuesRequest]) (*connect.Response[v1.ListIssuesResponse], error)
	// Search for issues that the caller has the bb.issues.get permission on and also satisfy the specified filter & query.
	SearchIssues(context.Context, *connect.Request[v1.SearchIssuesRequest]) (*connect.Response[v1.SearchIssuesResponse], error)
	UpdateIssue(context.Context, *connect.Request[v1.UpdateIssueRequest]) (*connect.Response[v1.Issue], error)
	ListIssueComments(context.Context, *connect.Request[v1.ListIssueCommentsRequest]) (*connect.Response[v1.ListIssueCommentsResponse], error)
	CreateIssueComment(context.Context, *connect.Request[v1.CreateIssueCommentRequest]) (*connect.Response[v1.IssueComment], error)
	UpdateIssueComment(context.Context, *connect.Request[v1.UpdateIssueCommentRequest]) (*connect.Response[v1.IssueComment], error)
	BatchUpdateIssuesStatus(context.Context, *connect.Request[v1.BatchUpdateIssuesStatusRequest]) (*connect.Response[v1.BatchUpdateIssuesStatusResponse], error)
	// ApproveIssue approves the issue.
	// The access is based on approval flow.
	ApproveIssue(context.Context, *connect.Request[v1.ApproveIssueRequest]) (*connect.Response[v1.Issue], error)
	// RejectIssue rejects the issue.
	// The access is based on approval flow.
	RejectIssue(context.Context, *connect.Request[v1.RejectIssueRequest]) (*connect.Response[v1.Issue], error)
	// RequestIssue requests the issue.
	// The access is based on approval flow.
	RequestIssue(context.Context, *connect.Request[v1.RequestIssueRequest]) (*connect.Response[v1.Issue], error)
}

// NewIssueServiceHandler builds an HTTP handler from the service implementation. It returns the
// path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewIssueServiceHandler(svc IssueServiceHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	issueServiceMethods := v1.File_v1_issue_service_proto.Services().ByName("IssueService").Methods()
	issueServiceGetIssueHandler := connect.NewUnaryHandler(
		IssueServiceGetIssueProcedure,
		svc.GetIssue,
		connect.WithSchema(issueServiceMethods.ByName("GetIssue")),
		connect.WithHandlerOptions(opts...),
	)
	issueServiceCreateIssueHandler := connect.NewUnaryHandler(
		IssueServiceCreateIssueProcedure,
		svc.CreateIssue,
		connect.WithSchema(issueServiceMethods.ByName("CreateIssue")),
		connect.WithHandlerOptions(opts...),
	)
	issueServiceListIssuesHandler := connect.NewUnaryHandler(
		IssueServiceListIssuesProcedure,
		svc.ListIssues,
		connect.WithSchema(issueServiceMethods.ByName("ListIssues")),
		connect.WithHandlerOptions(opts...),
	)
	issueServiceSearchIssuesHandler := connect.NewUnaryHandler(
		IssueServiceSearchIssuesProcedure,
		svc.SearchIssues,
		connect.WithSchema(issueServiceMethods.ByName("SearchIssues")),
		connect.WithHandlerOptions(opts...),
	)
	issueServiceUpdateIssueHandler := connect.NewUnaryHandler(
		IssueServiceUpdateIssueProcedure,
		svc.UpdateIssue,
		connect.WithSchema(issueServiceMethods.ByName("UpdateIssue")),
		connect.WithHandlerOptions(opts...),
	)
	issueServiceListIssueCommentsHandler := connect.NewUnaryHandler(
		IssueServiceListIssueCommentsProcedure,
		svc.ListIssueComments,
		connect.WithSchema(issueServiceMethods.ByName("ListIssueComments")),
		connect.WithHandlerOptions(opts...),
	)
	issueServiceCreateIssueCommentHandler := connect.NewUnaryHandler(
		IssueServiceCreateIssueCommentProcedure,
		svc.CreateIssueComment,
		connect.WithSchema(issueServiceMethods.ByName("CreateIssueComment")),
		connect.WithHandlerOptions(opts...),
	)
	issueServiceUpdateIssueCommentHandler := connect.NewUnaryHandler(
		IssueServiceUpdateIssueCommentProcedure,
		svc.UpdateIssueComment,
		connect.WithSchema(issueServiceMethods.ByName("UpdateIssueComment")),
		connect.WithHandlerOptions(opts...),
	)
	issueServiceBatchUpdateIssuesStatusHandler := connect.NewUnaryHandler(
		IssueServiceBatchUpdateIssuesStatusProcedure,
		svc.BatchUpdateIssuesStatus,
		connect.WithSchema(issueServiceMethods.ByName("BatchUpdateIssuesStatus")),
		connect.WithHandlerOptions(opts...),
	)
	issueServiceApproveIssueHandler := connect.NewUnaryHandler(
		IssueServiceApproveIssueProcedure,
		svc.ApproveIssue,
		connect.WithSchema(issueServiceMethods.ByName("ApproveIssue")),
		connect.WithHandlerOptions(opts...),
	)
	issueServiceRejectIssueHandler := connect.NewUnaryHandler(
		IssueServiceRejectIssueProcedure,
		svc.RejectIssue,
		connect.WithSchema(issueServiceMethods.ByName("RejectIssue")),
		connect.WithHandlerOptions(opts...),
	)
	issueServiceRequestIssueHandler := connect.NewUnaryHandler(
		IssueServiceRequestIssueProcedure,
		svc.RequestIssue,
		connect.WithSchema(issueServiceMethods.ByName("RequestIssue")),
		connect.WithHandlerOptions(opts...),
	)
	return "/bytebase.v1.IssueService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case IssueServiceGetIssueProcedure:
			issueServiceGetIssueHandler.ServeHTTP(w, r)
		case IssueServiceCreateIssueProcedure:
			issueServiceCreateIssueHandler.ServeHTTP(w, r)
		case IssueServiceListIssuesProcedure:
			issueServiceListIssuesHandler.ServeHTTP(w, r)
		case IssueServiceSearchIssuesProcedure:
			issueServiceSearchIssuesHandler.ServeHTTP(w, r)
		case IssueServiceUpdateIssueProcedure:
			issueServiceUpdateIssueHandler.ServeHTTP(w, r)
		case IssueServiceListIssueCommentsProcedure:
			issueServiceListIssueCommentsHandler.ServeHTTP(w, r)
		case IssueServiceCreateIssueCommentProcedure:
			issueServiceCreateIssueCommentHandler.ServeHTTP(w, r)
		case IssueServiceUpdateIssueCommentProcedure:
			issueServiceUpdateIssueCommentHandler.ServeHTTP(w, r)
		case IssueServiceBatchUpdateIssuesStatusProcedure:
			issueServiceBatchUpdateIssuesStatusHandler.ServeHTTP(w, r)
		case IssueServiceApproveIssueProcedure:
			issueServiceApproveIssueHandler.ServeHTTP(w, r)
		case IssueServiceRejectIssueProcedure:
			issueServiceRejectIssueHandler.ServeHTTP(w, r)
		case IssueServiceRequestIssueProcedure:
			issueServiceRequestIssueHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedIssueServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedIssueServiceHandler struct{}

func (UnimplementedIssueServiceHandler) GetIssue(context.Context, *connect.Request[v1.GetIssueRequest]) (*connect.Response[v1.Issue], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("bytebase.v1.IssueService.GetIssue is not implemented"))
}

func (UnimplementedIssueServiceHandler) CreateIssue(context.Context, *connect.Request[v1.CreateIssueRequest]) (*connect.Response[v1.Issue], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("bytebase.v1.IssueService.CreateIssue is not implemented"))
}

func (UnimplementedIssueServiceHandler) ListIssues(context.Context, *connect.Request[v1.ListIssuesRequest]) (*connect.Response[v1.ListIssuesResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("bytebase.v1.IssueService.ListIssues is not implemented"))
}

func (UnimplementedIssueServiceHandler) SearchIssues(context.Context, *connect.Request[v1.SearchIssuesRequest]) (*connect.Response[v1.SearchIssuesResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("bytebase.v1.IssueService.SearchIssues is not implemented"))
}

func (UnimplementedIssueServiceHandler) UpdateIssue(context.Context, *connect.Request[v1.UpdateIssueRequest]) (*connect.Response[v1.Issue], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("bytebase.v1.IssueService.UpdateIssue is not implemented"))
}

func (UnimplementedIssueServiceHandler) ListIssueComments(context.Context, *connect.Request[v1.ListIssueCommentsRequest]) (*connect.Response[v1.ListIssueCommentsResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("bytebase.v1.IssueService.ListIssueComments is not implemented"))
}

func (UnimplementedIssueServiceHandler) CreateIssueComment(context.Context, *connect.Request[v1.CreateIssueCommentRequest]) (*connect.Response[v1.IssueComment], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("bytebase.v1.IssueService.CreateIssueComment is not implemented"))
}

func (UnimplementedIssueServiceHandler) UpdateIssueComment(context.Context, *connect.Request[v1.UpdateIssueCommentRequest]) (*connect.Response[v1.IssueComment], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("bytebase.v1.IssueService.UpdateIssueComment is not implemented"))
}

func (UnimplementedIssueServiceHandler) BatchUpdateIssuesStatus(context.Context, *connect.Request[v1.BatchUpdateIssuesStatusRequest]) (*connect.Response[v1.BatchUpdateIssuesStatusResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("bytebase.v1.IssueService.BatchUpdateIssuesStatus is not implemented"))
}

func (UnimplementedIssueServiceHandler) ApproveIssue(context.Context, *connect.Request[v1.ApproveIssueRequest]) (*connect.Response[v1.Issue], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("bytebase.v1.IssueService.ApproveIssue is not implemented"))
}

func (UnimplementedIssueServiceHandler) RejectIssue(context.Context, *connect.Request[v1.RejectIssueRequest]) (*connect.Response[v1.Issue], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("bytebase.v1.IssueService.RejectIssue is not implemented"))
}

func (UnimplementedIssueServiceHandler) RequestIssue(context.Context, *connect.Request[v1.RequestIssueRequest]) (*connect.Response[v1.Issue], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("bytebase.v1.IssueService.RequestIssue is not implemented"))
}
