{
  "$id": "google.api.expr.v1alpha1.Expr.Comprehension.jsonschema.strict.json",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "additionalProperties": false,
  "description": "Comprehensions are not part of the core syntax, but enabled with macros.\n A macro matches a specific call signature within a parsed AST and replaces\n the call with an alternate AST block. Macro expansion happens at parse\n time.\n\n The following macros are supported within CEL:\n\n Aggregate type macros may be applied to all elements in a list or all keys\n in a map:\n\n *  `all`, `exists`, `exists_one` -  test a predicate expression against\n    the inputs and return `true` if the predicate is satisfied for all,\n    any, or only one value `list.all(x, x \u003c 10)`.\n *  `filter` - test a predicate expression against the inputs and return\n    the subset of elements which satisfy the predicate:\n    `payments.filter(p, p \u003e 1000)`.\n *  `map` - apply an expression to all elements in the input and return the\n    output aggregate type: `[1, 2, 3].map(i, i * i)`.\n\n The `has(m.x)` macro tests whether the property `x` is present in struct\n `m`. The semantics of this macro depend on the type of `m`. For proto2\n messages `has(m.x)` is defined as 'defined, but not set`. For proto3, the\n macro tests whether the property is set to its default. For map and struct\n types, the macro tests whether the property `x` is defined on `m`.\n\n Comprehensions for the standard environment macros evaluation can be best\n visualized as the following pseudocode:\n\n ```\n let `accu_var` = `accu_init`\n for (let `iter_var` in `iter_range`) {\n   if (!`loop_condition`) {\n     break\n   }\n   `accu_var` = `loop_step`\n }\n return `result`\n ```\n\n Comprehensions for the optional V2 macros which support map-to-map\n translation differ slightly from the standard environment macros in that\n they expose both the key or index in addition to the value for each list\n or map entry:\n\n ```\n let `accu_var` = `accu_init`\n for (let `iter_var`, `iter_var2` in `iter_range`) {\n   if (!`loop_condition`) {\n     break\n   }\n   `accu_var` = `loop_step`\n }\n return `result`\n ```",
  "properties": {
    "accuInit": {
      "$ref": "google.api.expr.v1alpha1.Expr.jsonschema.strict.json",
      "description": "The initial value of the accumulator."
    },
    "accuVar": {
      "description": "The name of the variable used for accumulation of the result.",
      "type": "string"
    },
    "iterRange": {
      "$ref": "google.api.expr.v1alpha1.Expr.jsonschema.strict.json",
      "description": "The range over which the comprehension iterates."
    },
    "iterVar": {
      "description": "The name of the first iteration variable.\n When the iter_range is a list, this variable is the list element.\n When the iter_range is a map, this variable is the map entry key.",
      "type": "string"
    },
    "iterVar2": {
      "description": "The name of the second iteration variable, empty if not set.\n When the iter_range is a list, this variable is the integer index.\n When the iter_range is a map, this variable is the map entry value.\n This field is only set for comprehension v2 macros.",
      "type": "string"
    },
    "loopCondition": {
      "$ref": "google.api.expr.v1alpha1.Expr.jsonschema.strict.json",
      "description": "Returns false when the result has been computed and may be used as\n a hint to short-circuit the remainder of the comprehension.",
      "title": "An expression which can contain iter_var, iter_var2, and accu_var."
    },
    "loopStep": {
      "$ref": "google.api.expr.v1alpha1.Expr.jsonschema.strict.json",
      "description": "Computes the next value of accu_var.",
      "title": "An expression which can contain iter_var, iter_var2, and accu_var."
    },
    "result": {
      "$ref": "google.api.expr.v1alpha1.Expr.jsonschema.strict.json",
      "description": "Computes the result.",
      "title": "An expression which can contain accu_var."
    }
  },
  "required": [
    "iterVar",
    "iterVar2",
    "accuVar"
  ],
  "title": "A comprehension expression applied to a list or map.",
  "type": "object"
}
